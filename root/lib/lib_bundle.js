(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":30,"util/":5}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],5:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":4,"_process":33,"inherits":3}],6:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],8:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],9:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":7,"buffer":9,"ieee754":24}],10:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],11:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":12,"get-intrinsic":18}],12:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":17,"get-intrinsic":18}],13:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":18}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],15:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;

},{"is-callable":27}],16:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],17:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":16}],18:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":17,"has":22,"has-symbols":19}],19:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":20}],20:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],21:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":20}],22:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":17}],23:[function(require,module,exports){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":39,"url":59}],24:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],25:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],26:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":11,"has-tostringtag/shams":21}],27:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]';
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalized DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					// IE 6-8 uses `objectClass`
					return (str === ddaClass || str === objectClass) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass || tryFunctionObject(value);
	};

},{}],28:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":21}],29:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":6,"call-bind/callBound":11,"es-abstract/helpers/getOwnPropertyDescriptor":13,"for-each":15,"has-tostringtag/shams":21}],30:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],31:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],32:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":33}],33:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],34:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],37:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":35,"./encode":36}],38:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":9}],39:[function(require,module,exports){
(function (global){(function (){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":41,"./lib/response":42,"builtin-status-codes":10,"url":59,"xtend":66}],40:[function(require,module,exports){
(function (global){(function (){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],41:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null
	self._socketTimeout = null
	self._socketTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	if ('timeout' in opts && opts.timeout !== 0) {
		self.setTimeout(opts.timeout)
	}

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._resetTimers(false)
			self._connect()
		}, function (reason) {
			self._resetTimers(true)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self._resetTimers(true)
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	self._resetTimers(false)

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress(self._resetTimers.bind(self))
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype._resetTimers = function (done) {
	var self = this

	global.clearTimeout(self._socketTimer)
	self._socketTimer = null

	if (done) {
		global.clearTimeout(self._fetchTimer)
		self._fetchTimer = null
	} else if (self._socketTimeout) {
		self._socketTimer = global.setTimeout(function () {
			self.emit('timeout')
		}, self._socketTimeout)
	}
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
	var self = this
	self._destroyed = true
	self._resetTimers(true)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()

	if (err)
		self.emit('error', err)
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.setTimeout = function (timeout, cb) {
	var self = this

	if (cb)
		self.once('timeout', cb)

	self._socketTimeout = timeout
	self._resetTimers(false)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":40,"./response":42,"_process":33,"buffer":9,"inherits":25,"readable-stream":57}],42:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					resetTimers(false)
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					resetTimers(true)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				resetTimers(result.done)
				if (result.done) {
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				resetTimers(true)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				resetTimers(true)
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		resetTimers(true)
		self.push(null)
	}
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":40,"_process":33,"buffer":9,"inherits":25,"readable-stream":57}],43:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],44:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":46,"./_stream_writable":48,"_process":33,"inherits":25}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":47,"inherits":25}],46:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":43,"./_stream_duplex":44,"./internal/streams/async_iterator":49,"./internal/streams/buffer_list":50,"./internal/streams/destroy":51,"./internal/streams/from":53,"./internal/streams/state":55,"./internal/streams/stream":56,"_process":33,"buffer":9,"events":14,"inherits":25,"string_decoder/":58,"util":8}],47:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":43,"./_stream_duplex":44,"inherits":25}],48:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":43,"./_stream_duplex":44,"./internal/streams/destroy":51,"./internal/streams/state":55,"./internal/streams/stream":56,"_process":33,"buffer":9,"inherits":25,"util-deprecate":61}],49:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":52,"_process":33}],50:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":9,"util":8}],51:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":33}],52:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":43}],53:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],54:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":43,"./end-of-stream":52}],55:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":43}],56:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":14}],57:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":44,"./lib/_stream_passthrough.js":45,"./lib/_stream_readable.js":46,"./lib/_stream_transform.js":47,"./lib/_stream_writable.js":48,"./lib/internal/streams/end-of-stream.js":52,"./lib/internal/streams/pipeline.js":54}],58:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":38}],59:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":60,"punycode":34,"querystring":37}],60:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],61:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],62:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],63:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":26,"is-generator-function":28,"is-typed-array":29,"which-typed-array":65}],64:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))
},{"./support/isBuffer":62,"./support/types":63,"_process":33,"inherits":25}],65:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":6,"call-bind/callBound":11,"es-abstract/helpers/getOwnPropertyDescriptor":13,"for-each":15,"has-tostringtag/shams":21,"is-typed-array":29}],66:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],67:[function(require,module,exports){
const fs = require('fs')
const Builder = require('opal-compiler').Builder
// Opal object will be available on the global scope

const builder = Builder.create()
builder.appendPaths('lib') 

const result = builder.build('cross-document-references-macro.rb') 
fs.writeFileSync('cross-document-references-macro.js', result.toString(), 'utf8') 

const result_2 = builder.build('git-macro.rb') 
fs.writeFileSync('git-macro.js', result.toString(), 'utf8')

const result_3 = builder.build('inter-document-references-macro.rb') 
fs.writeFileSync('inter-document-references-macro.js', result.toString(), 'utf8')

const result_4 = builder.build('man-macro.rb') 
fs.writeFileSync('man-macro.js', result.toString(), 'utf8')

const result_5 = builder.build('packages-macro.rb') 
fs.writeFileSync('packages-macro.js', result.toString(), 'utf8')

const result_6 = builder.build('sectnumoffset-treeprocessor.rb') 
fs.writeFileSync('sectnumoffset-treeprocessor.js', result.toString(), 'utf8')
},{"fs":1,"opal-compiler":84}],68:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});


},{}],69:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["GitReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,[],to_i');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'GitReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("gitref");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var hash = nil, repository = nil, length = nil, url = nil;

      
      hash = target;
      repository = ($truthy((repository = attrs['$[]']("repository"))) ? ("" + (repository)) : ("src"));
      length = ($truthy((length = attrs['$[]']("length"))) ? (length.$to_i()) : (12));
      url = "https://cgit.freebsd.org/" + (repository) + "/commit/?id=" + (hash);
      return "<a href=\"" + (url) + "\">" + (hash['$[]'](0, length)) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("GitReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('GitReferencesMacro'))}, {$$arity: 0, $$s: self});
});

},{}],70:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["GitReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,[],to_i');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'GitReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("gitref");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var hash = nil, repository = nil, length = nil, url = nil;

      
      hash = target;
      repository = ($truthy((repository = attrs['$[]']("repository"))) ? ("" + (repository)) : ("src"));
      length = ($truthy((length = attrs['$[]']("length"))) ? (length.$to_i()) : (12));
      url = "https://cgit.freebsd.org/" + (repository) + "/commit/?id=" + (hash);
      return "<a href=\"" + (url) + "\">" + (hash['$[]'](0, length)) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("GitReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('GitReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["InterDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'InterDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("crossref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, anchor = nil, text = nil, doc = nil;

      
      destination = target;
      anchor = attrs['$[]'](1);
      text = attrs['$[]'](2);
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("book"), "True")) {
        if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./#" + (anchor)})).$render()
        } else {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./index.html#" + (anchor)})).$render()
        }
      } else if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/#" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html#" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("InterDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('InterDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

},{}],71:[function(require,module,exports){
require('./cross-document-references-macro.js')
require('./git-macro.js')
require('./inter-document-references-macro.js')
require('./man-macro.js')
require('./packages-macro.js')
require('./sectnumoffset-treeprocessor.js')
require('./compile.js')
},{"./compile.js":67,"./cross-document-references-macro.js":68,"./git-macro.js":69,"./inter-document-references-macro.js":70,"./man-macro.js":72,"./packages-macro.js":73,"./sectnumoffset-treeprocessor.js":74}],72:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["GitReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,[],to_i');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'GitReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("gitref");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var hash = nil, repository = nil, length = nil, url = nil;

      
      hash = target;
      repository = ($truthy((repository = attrs['$[]']("repository"))) ? ("" + (repository)) : ("src"));
      length = ($truthy((length = attrs['$[]']("length"))) ? (length.$to_i()) : (12));
      url = "https://cgit.freebsd.org/" + (repository) + "/commit/?id=" + (hash);
      return "<a href=\"" + (url) + "\">" + (hash['$[]'](0, length)) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("GitReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('GitReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["InterDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'InterDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("crossref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, anchor = nil, text = nil, doc = nil;

      
      destination = target;
      anchor = attrs['$[]'](1);
      text = attrs['$[]'](2);
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("book"), "True")) {
        if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./#" + (anchor)})).$render()
        } else {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./index.html#" + (anchor)})).$render()
        }
      } else if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/#" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html#" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("InterDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('InterDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["ManPageMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[]');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'ManPageMacro');

    
    
    self.$use_dsl();
    self.$named("man");
    self.$name_positional_attributes("section");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var manname = nil, section = nil, url = nil;

      
      manname = target;
      section = ($truthy((section = attrs['$[]']("section"))) ? ("" + (section)) : (""));
      url = "https://www.freebsd.org/cgi/man.cgi?query=" + (manname) + "&sektion=" + (section) + "&format=html";
      return "<a href=\"" + (url) + "\">" + (manname) + "(" + (section) + ")</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("ManPageMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('ManPageMacro'))}, {$$arity: 0, $$s: self});
});

},{}],73:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["GitReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,[],to_i');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'GitReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("gitref");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var hash = nil, repository = nil, length = nil, url = nil;

      
      hash = target;
      repository = ($truthy((repository = attrs['$[]']("repository"))) ? ("" + (repository)) : ("src"));
      length = ($truthy((length = attrs['$[]']("length"))) ? (length.$to_i()) : (12));
      url = "https://cgit.freebsd.org/" + (repository) + "/commit/?id=" + (hash);
      return "<a href=\"" + (url) + "\">" + (hash['$[]'](0, length)) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("GitReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('GitReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["InterDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'InterDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("crossref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, anchor = nil, text = nil, doc = nil;

      
      destination = target;
      anchor = attrs['$[]'](1);
      text = attrs['$[]'](2);
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("book"), "True")) {
        if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./#" + (anchor)})).$render()
        } else {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./index.html#" + (anchor)})).$render()
        }
      } else if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/#" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html#" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("InterDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('InterDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["ManPageMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[]');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'ManPageMacro');

    
    
    self.$use_dsl();
    self.$named("man");
    self.$name_positional_attributes("section");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var manname = nil, section = nil, url = nil;

      
      manname = target;
      section = ($truthy((section = attrs['$[]']("section"))) ? ("" + (section)) : (""));
      url = "https://www.freebsd.org/cgi/man.cgi?query=" + (manname) + "&sektion=" + (section) + "&format=html";
      return "<a href=\"" + (url) + "\">" + (manname) + "(" + (section) + ")</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("ManPageMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('ManPageMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["PackagesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,register,document');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'PackagesMacro');

    
    
    self.$use_dsl();
    self.$named("package");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var packagename = nil;

      
      packagename = target;
      target = "https://cgit.freebsd.org/ports/tree/" + (target) + "/pkg-descr";
      parent.$document().$register("links", target);
      return "<a class=\"package\" href=\"" + (target) + "\">" + (packagename) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("PackagesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('PackagesMacro'))}, {$$arity: 0, $$s: self});
});

},{}],74:[function(require,module,exports){
Opal.modules["CrossDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],nil?,+,document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'CrossDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("extref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, text = nil, anchor = nil, doc = nil;

      
      destination = target;
      text = attrs['$[]'](1);
      anchor = "";
      if (!$truthy(attrs['$[]'](2)['$nil?']())) {
        anchor = $rb_plus("#", attrs['$[]'](2))
      };
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("isonline"), "1")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + (anchor)})).$render()
      } else if ($eqeq(doc.$attributes()['$[]']("doctype"), "book")) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "" + (destination) + "/index.html" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("CrossDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('CrossDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["GitReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,[],to_i');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'GitReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("gitref");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var hash = nil, repository = nil, length = nil, url = nil;

      
      hash = target;
      repository = ($truthy((repository = attrs['$[]']("repository"))) ? ("" + (repository)) : ("src"));
      length = ($truthy((length = attrs['$[]']("length"))) ? (length.$to_i()) : (12));
      url = "https://cgit.freebsd.org/" + (repository) + "/commit/?id=" + (hash);
      return "<a href=\"" + (url) + "\">" + (hash['$[]'](0, length)) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("GitReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('GitReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["InterDocumentReferencesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[],document,==,attributes,render,create_anchor');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'InterDocumentReferencesMacro');

    
    
    self.$use_dsl();
    self.$named("crossref");
    self.$name_positional_attributes("attributes");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var self = this, destination = nil, anchor = nil, text = nil, doc = nil;

      
      destination = target;
      anchor = attrs['$[]'](1);
      text = attrs['$[]'](2);
      doc = parent.$document();
      if ($eqeq(doc.$attributes()['$[]']("book"), "True")) {
        if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./#" + (anchor)})).$render()
        } else {
          return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "./index.html#" + (anchor)})).$render()
        }
      } else if ($eqeq(doc.$attributes()['$[]']("isonline"), 1)) {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/#" + (anchor)})).$render()
      } else {
        return self.$create_anchor(parent, text, $hash2(["type", "target"], {"type": "link", "target": "../" + (destination) + "/index.html#" + (anchor)})).$render()
      };
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("InterDocumentReferencesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('InterDocumentReferencesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["ManPageMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,name_positional_attributes,[]');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'ManPageMacro');

    
    
    self.$use_dsl();
    self.$named("man");
    self.$name_positional_attributes("section");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var manname = nil, section = nil, url = nil;

      
      manname = target;
      section = ($truthy((section = attrs['$[]']("section"))) ? ("" + (section)) : (""));
      url = "https://www.freebsd.org/cgi/man.cgi?query=" + (manname) + "&sektion=" + (section) + "&format=html";
      return "<a href=\"" + (url) + "\">" + (manname) + "(" + (section) + ")</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("ManPageMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('ManPageMacro'))}, {$$arity: 0, $$s: self});
});

Opal.modules["PackagesMacro/extension"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('include,use_dsl,named,register,document');
  
  nil;
  self.$include($$$('Asciidoctor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'PackagesMacro');

    
    
    self.$use_dsl();
    self.$named("package");
    return $def(self, '$process', function $$process(parent, target, attrs) {
      var packagename = nil;

      
      packagename = target;
      target = "https://cgit.freebsd.org/ports/tree/" + (target) + "/pkg-descr";
      parent.$document().$register("links", target);
      return "<a class=\"package\" href=\"" + (target) + "\">" + (packagename) + "</a>";
    }, 3);
  })($nesting[0], $$$($$$($$('Asciidoctor'), 'Extensions'), 'InlineMacroProcessor'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $send = Opal.send;

  Opal.add_stubs('require,register,inline_macro');
  
  
  self.$require("PackagesMacro/extension");;
  return $send($$$($$('Asciidoctor'), 'Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return self.$inline_macro($$('PackagesMacro'))}, {$$arity: 0, $$s: self});
});

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $send = Opal.send, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('include,register,treeprocessor,process,==,attr,attr?,to_s,each,find_by,level,numeral=,+,numeral');
  
  nil;
  self.$include($$('Asciidoctor'));
  return $send($$('Extensions'), 'register', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

    return $send(self, 'treeprocessor', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

      return $send(self, 'process', [], function $$3(document){var book = nil, sectnumoffset = nil;

        
        
        if (document == null) document = nil;;
        if (($truthy(document['$attr?']("sectnumoffset")) && ($eqeq((book = document.$attr("book", false)), false)))) {
          
          sectnumoffset = document.$attr("sectnumoffset", "0").$to_s();
          return $send($send(document, 'find_by', [$hash2(["context"], {"context": "section"})], function $$4(sect){
            
            
            if (sect == null) sect = nil;;
            return sect.$level()['$=='](1);}, 1), 'each', [], function $$5(sect){var $a;

            
            
            if (sect == null) sect = nil;;
            return ($a = [$rb_plus($rb_plus(sectnumoffset.$to_s(), "."), sect.$numeral().$to_s())], $send(sect, 'numeral=', $a), $a[$a.length - 1]);}, 1);
        } else {
          return nil
        };}, 1)}, {$$arity: 0, $$s: self})}, {$$arity: 0, $$s: self});
});

},{}],75:[function(require,module,exports){
'use strict';
module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

},{}],76:[function(require,module,exports){
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},{"balanced-match":75,"concat-map":77}],77:[function(require,module,exports){
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],78:[function(require,module,exports){
(function (process){(function (){
module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = require('fs')
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = require('./old.js')

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}

}).call(this)}).call(this,require('_process'))
},{"./old.js":79,"_process":33,"fs":1}],79:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = require('path');
var isWindows = process.platform === 'win32';
var fs = require('fs');

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

}).call(this)}).call(this,require('_process'))
},{"_process":33,"fs":1,"path":32}],80:[function(require,module,exports){
(function (process){(function (){
var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}

}).call(this)}).call(this,require('_process'))
},{"_process":33,"once":83,"wrappy":99}],81:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],82:[function(require,module,exports){
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return require('path') } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

},{"brace-expansion":76,"path":32}],83:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":99}],84:[function(require,module,exports){
const Opal = require('opal-runtime').Opal
require('./opal-builder.js')
require('./opal-source-maps.js')

Opal.require('nodejs')
Opal.require('opal-builder')
Opal.require('opal-source-maps')

/**
 * Convert a JSON to an (Opal) Hash.
 * @private
 */
const toHash = function (object) {
  if (object && !object.smap) {
    return Opal.hash(object)
  }
  return object
}

const Builder = Opal.const_get_qualified(Opal.const_get_relative([], 'Opal'), 'Builder')
const ERB = Opal.const_get_qualified(Opal.const_get_relative([], 'Opal'), 'ERB')

// Public API

Builder.$$class.prototype.create = function () {
  return this.$new()
}

Builder.prototype.appendPaths = function (paths) {
  this.$append_paths(paths)
}

Builder.prototype.setCompilerOptions = function (options) {
  this.compiler_options = toHash(options)
}

Builder.prototype.build = function (path, options) {
  return this.$build(path, toHash(options))
}

Builder.prototype.buildString = function (str, path = '.', options = {}) {
  return this.$build_str(str, path, toHash(options))
}

Builder.prototype.toString = function () {
  return this.$to_s()
}

Builder.prototype.getSourceMap = function () {
  return this.$source_map()
}

ERB.$$class.prototype.compile = function (source, fileName) {
  return this.$compile(source, fileName)
}

module.exports.Builder = Builder
module.exports.ERB = ERB

},{"./opal-builder.js":85,"./opal-source-maps.js":86,"opal-runtime":92}],85:[function(require,module,exports){
Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $const_set = Opal.const_set;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) max = nil;;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["pathname"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $defs = Opal.defs, $to_ary = Opal.to_ary, $send = Opal.send, $to_a = Opal.to_a, $return_ivar = Opal.return_ivar, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $not = Opal.not, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs('require,include,quote,===,to_s,path,respond_to?,to_path,is_a?,nil?,raise,class,==,new,pwd,attr_reader,!,relative?,chop_basename,basename,=~,source,[],rindex,sub,absolute?,expand_path,plus,unshift,length,!=,empty?,first,shift,+,join,dirname,pop,reverse_each,directory?,extname,<=>,nonzero?,proc,casecmp,cleanpath,inspect,include?,fill,map,entries');
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.path = nil;
    
    self.$include($$('Comparable'));
    $const_set($nesting[0], 'SEPARATOR_PAT', $regexp([$$('Regexp').$quote($$$($$('File'), 'SEPARATOR'))]));
    
    $def(self, '$initialize', function $$initialize(path) {
      var self = this;

      
      if ($eqeqeq($$('Pathname'), path)) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$('String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$('TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$('TypeError'), "no implicit conversion of " + (path.$class()) + " into String")
      };
      if ($eqeq(self.path, "\u0000")) {
        return self.$raise($$('ArgumentError'))
      } else {
        return nil
      };
    }, 1);
    $defs(self, '$pwd', function $$pwd() {
      var self = this;

      return self.$new($$('Dir').$pwd())
    }, 0);
    self.$attr_reader("path");
    
    $def(self, '$==', function $Pathname_$eq_eq$1(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, 1);
    
    $def(self, '$absolute?', function $Pathname_absolute$ques$2() {
      var self = this;

      return self['$relative?']()['$!']()
    }, 0);
    
    $def(self, '$relative?', function $Pathname_relative$ques$3() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = $to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, 0);
    
    $def(self, '$chop_basename', function $$chop_basename(path) {
      var base = nil;

      
      base = $$('File').$basename(path);
      if ($truthy($$('Regexp').$new("^" + ($$$($$('Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, 1);
    
    $def(self, '$root?', function $Pathname_root$ques$4() {
      var self = this;

      return self.path['$==']("/")
    }, 0);
    
    $def(self, '$parent', function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if ($eqeq(new_path, "")) {
        new_path = ($truthy(self['$absolute?']()) ? ("/") : ("."))
      };
      return $$('Pathname').$new(new_path);
    }, 0);
    
    $def(self, '$sub', function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $$('Pathname').$new($send(self.path, 'sub', $to_a(args)));
    }, -1);
    
    $def(self, '$cleanpath', function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, 0);
    
    $def(self, '$to_path', $return_ivar("path"), 0);
    
    $def(self, '$hash', $return_ivar("path"), 0);
    
    $def(self, '$expand_path', function $$expand_path() {
      var self = this;

      return $$('Pathname').$new($$('File').$expand_path(self.path))
    }, 0);
    
    $def(self, '$+', function $Pathname_$plus$5(other) {
      var self = this;

      
      if (!$eqeqeq($$('Pathname'), other)) {
        other = $$('Pathname').$new(other)
      };
      return $$('Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, 1);
    
    $def(self, '$plus', function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, $ret_or_1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = $to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($neqeq(prefix2, "")) {
        return path2
      };
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$=='](".")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if (!$truthy((r1 = self.$chop_basename(prefix1)))) {
          break;
        };
        $c = r1, $b = $to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if ($eqeq(basename1, ".")) {
          continue;
        };
        if ((($eqeq(basename1, "..") || ($truthy(basename_list2['$empty?']()))) || ($neqeq(basename_list2.$first(), "..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;
        };
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if (($not(r1) && ($truthy($regexp([$$('SEPARATOR_PAT')])['$=~']($$('File').$basename(prefix1)))))) {
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$==']("..")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }
      };
      if ($not(basename_list2['$empty?']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$('File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$('File').$dirname(prefix1)
      };
    }, 2);
    
    $def(self, '$join', function $$join($a) {try {

      var $post_args, args, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self
      };
      result = args.$pop();
      if (!$eqeqeq($$('Pathname'), result)) {
        result = $$('Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result
      };
      $send(args, 'reverse_each', [], function $$6(arg){
        
        
        if (arg == null) arg = nil;;
        if (!$eqeqeq($$('Pathname'), arg)) {
          arg = $$('Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, 1);
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$split', function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, 0);
    
    $def(self, '$dirname', function $$dirname() {
      var self = this;

      return $$('Pathname').$new($$('File').$dirname(self.path))
    }, 0);
    
    $def(self, '$basename', function $$basename() {
      var self = this;

      return $$('Pathname').$new($$('File').$basename(self.path))
    }, 0);
    
    $def(self, '$directory?', function $Pathname_directory$ques$7() {
      var self = this;

      return $$('File')['$directory?'](self.path)
    }, 0);
    
    $def(self, '$extname', function $$extname() {
      var self = this;

      return $$('File').$extname(self.path)
    }, 0);
    
    $def(self, '$<=>', function $Pathname_$lt_eq_gt$8(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, 1);
    $const_set($nesting[0], 'SAME_PATHS', ($truthy($$$($$('File'), 'FNM_SYSCASE')['$nonzero?']()) ? ($send(self, 'proc', [], function $Pathname$9(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a.$casecmp(b)['$=='](0);}, 2)) : ($send(self, 'proc', [], function $Pathname$10(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a['$=='](b);}, 2))));
    
    $def(self, '$relative_path_from', function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, $ret_or_1 = nil, $ret_or_2 = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = $to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          dest_names.$unshift(basename)
        };
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = $to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          base_names.$unshift(basename)
        };
      };
      if (!$truthy($$('SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
        self.$raise($$('ArgumentError'), "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = dest_names['$empty?']()['$!']())) ? (base_names['$empty?']()['$!']()) : ($ret_or_2)))) ? ($$('SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first())) : ($ret_or_1)))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$('ArgumentError'), "base_directory has ..: " + (base_directory.$inspect()))
      };
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$('Pathname').$new(".")
      } else {
        return $$('Pathname').$new($send($$('File'), 'join', $to_a(relpath_names)))
      };
    }, 1);
    
    $def(self, '$entries', function $$entries() {
      var self = this;

      return $send($$('Dir').$entries(self.path), 'map', [], function $$11(f){var self = $$11.$$s == null ? this : $$11.$$s;

        
        
        if (f == null) f = nil;;
        return self.$class().$new(f);}, {$$arity: 1, $$s: self})
    }, 0);
    $alias(self, "===", "==");
    $alias(self, "eql?", "==");
    $alias(self, "to_s", "to_path");
    return $alias(self, "to_str", "to_path");
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Pathname', function $$Pathname(path) {
      
      return $$('Pathname').$new(path)
    }, 1)
  })($nesting[0], $nesting);
};

Opal.modules["opal/hike"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $def = Opal.def, $return_self = Opal.return_self, $truthy = Opal.truthy, $to_ary = Opal.to_ary, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a;

  Opal.add_stubs('require,attr_reader,freeze,dup,map,new,to_s,sub,=~,find_in_base_path,find_in_paths,[],[]=,directory?,sort,reject,entries,key?,exist?,stat,protected,is_a?,last,pop,split,each,match,join,to_proc,paths_contain?,pattern_for,select,sort_matches,file?,any?,paths,==,length,build_pattern_for,extensions,escape,sort_by,scan,inject,index,+,expand_path,concat,normalize_path,normalize_extension,find,root,private,start_with?,relative?');
  
  self.$require("pathname");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Hike');

      var $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Index');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.root = $proto.entries = $proto.stats = $proto.pathnames = $proto.patterns = nil;
        
        self.$attr_reader("paths");
        self.$attr_reader("extensions");
        
        $def(self, '$initialize', function $$initialize(root, paths, extensions) {
          var self = this;

          
          self.root = root;
          self.paths = paths.$dup().$freeze();
          self.extensions = extensions.$dup().$freeze();
          self.pathnames = $send(paths, 'map', [], function $$1(path){
            
            
            if (path == null) path = nil;;
            return $$('Pathname').$new(path);}, 1);
          self.stats = $hash2([], {});
          self.entries = $hash2([], {});
          return (self.patterns = $hash2([], {}));
        }, 3);
        
        $def(self, '$root', function $$root() {
          var self = this;

          return self.root.$to_s()
        }, 0);
        
        $def(self, '$index', $return_self, 0);
        
        $def(self, '$find', function $$find(logical_path) {try {

          var self = this, base_path = nil;

          
          base_path = $$('Pathname').$new(self.root);
          logical_path = $$('Pathname').$new(logical_path.$sub(/^\//, ""));
          if ($truthy(logical_path.$to_s()['$=~'](/^\.\.?\//))) {
            $send(self, 'find_in_base_path', [logical_path, base_path], function $$2(path){
              
              
              if (path == null) path = nil;;
              Opal.ret(path);}, 1)
          } else {
            $send(self, 'find_in_paths', [logical_path], function $$3(path){
              
              
              if (path == null) path = nil;;
              Opal.ret(path);}, 1)
          };
          return nil;
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, 1);
        
        $def(self, '$entries', function $$entries(path) {
          var $a, self = this, $ret_or_1 = nil, pathname = nil;

          if ($truthy(($ret_or_1 = self.entries['$[]'](path.$to_s())))) {
            return $ret_or_1
          } else {
            return ($a = [path.$to_s(), ((pathname = $$('Pathname').$new(path)), ($truthy(pathname['$directory?']()) ? ($send(pathname.$entries(), 'reject', [], function $$4(entry){
              
              
              if (entry == null) entry = nil;;
              return entry.$to_s()['$=~'](/^\.|~$|^\#.*\#$/);}, 1).$sort()) : ([])))], $send(self.entries, '[]=', $a), $a[$a.length - 1])
          }
        }, 1);
        
        $def(self, '$stat', function $$stat(path) {
          var $a, self = this, key = nil;

          
          key = path.$to_s();
          if ($truthy(self.stats['$key?'](key))) {
            return self.stats['$[]'](key)
          } else if ($truthy($$('File')['$exist?'](path))) {
            return ($a = [key, $$('File').$stat(path)], $send(self.stats, '[]=', $a), $a[$a.length - 1])
          } else {
            return ($a = [key, nil], $send(self.stats, '[]=', $a), $a[$a.length - 1])
          };
        }, 1);
        self.$protected();
        
        $def(self, '$extract_options!', function $Index_extract_options$excl$5(arguments$) {
          
          if ($truthy(arguments$.$last()['$is_a?']($$('Hash')))) {
            return arguments$.$pop().$dup()
          } else {
            return $hash2([], {})
          }
        }, 1);
        
        $def(self, '$find_in_paths', function $$find_in_paths(logical_path) {
          var block = $$find_in_paths.$$p || nil, $a, $b, self = this, dirname = nil, basename = nil;

          delete $$find_in_paths.$$p;
          
          ;
          $b = logical_path.$split(), $a = $to_ary($b), (dirname = ($a[0] == null ? nil : $a[0])), (basename = ($a[1] == null ? nil : $a[1])), $b;
          return $send(self.pathnames, 'each', [], function $$6(base_path){var self = $$6.$$s == null ? this : $$6.$$s;

            
            
            if (base_path == null) base_path = nil;;
            return $send(self, 'match', [base_path.$join(dirname), basename], block.$to_proc());}, {$$arity: 1, $$s: self});
        }, 1);
        
        $def(self, '$find_in_base_path', function $$find_in_base_path(logical_path, base_path) {
          var block = $$find_in_base_path.$$p || nil, $a, $b, self = this, candidate = nil, dirname = nil, basename = nil;

          delete $$find_in_base_path.$$p;
          
          ;
          candidate = base_path.$join(logical_path);
          $b = candidate.$split(), $a = $to_ary($b), (dirname = ($a[0] == null ? nil : $a[0])), (basename = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy(self['$paths_contain?'](dirname))) {
            return $send(self, 'match', [dirname, basename], block.$to_proc())
          } else {
            return nil
          };
        }, 2);
        
        $def(self, '$match', function $$match(dirname, basename) {
          var $yield = $$match.$$p || nil, self = this, matches = nil, pattern = nil;

          delete $$match.$$p;
          
          matches = self.$entries(dirname);
          pattern = self.$pattern_for(basename);
          matches = $send(matches, 'select', [], function $$7(m){
            
            
            if (m == null) m = nil;;
            return m.$to_s()['$=~'](pattern);}, 1);
          return $send(self.$sort_matches(matches, basename), 'each', [], function $$8(path){var self = $$8.$$s == null ? this : $$8.$$s, pathname = nil, stat = nil;

            
            
            if (path == null) path = nil;;
            pathname = dirname.$join(path);
            stat = self.$stat(pathname);
            if (($truthy(stat) && ($truthy(stat['$file?']())))) {
              return Opal.yield1($yield, pathname.$to_s());
            } else {
              return nil
            };}, {$$arity: 1, $$s: self});
        }, 2);
        
        $def(self, '$paths_contain?', function $Index_paths_contain$ques$9(dirname) {
          var self = this;

          return $send(self.$paths(), 'any?', [], function $$10(path){
            
            
            if (path == null) path = nil;;
            return dirname.$to_s()['$[]'](0, path.$length())['$=='](path);}, 1)
        }, 1);
        
        $def(self, '$pattern_for', function $$pattern_for(basename) {
          var $a, self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.patterns['$[]'](basename)))) {
            return $ret_or_1
          } else {
            return ($a = [basename, self.$build_pattern_for(basename)], $send(self.patterns, '[]=', $a), $a[$a.length - 1])
          }
        }, 1);
        
        $def(self, '$build_pattern_for', function $$build_pattern_for(basename) {
          var self = this, extension_pattern = nil;

          
          extension_pattern = $send(self.$extensions(), 'map', [], function $$11(e){
            
            
            if (e == null) e = nil;;
            return $$('Regexp').$escape(e);}, 1).$join("|");
          return $regexp(["^", basename, "(?:", extension_pattern, ")*$"]);
        }, 1);
        return $def(self, '$sort_matches', function $$sort_matches(matches, basename) {
          var self = this;

          return $send(matches, 'sort_by', [], function $$12(match){var self = $$12.$$s == null ? this : $$12.$$s, extnames = nil;

            
            
            if (match == null) match = nil;;
            extnames = match.$sub(basename.$to_s(), "").$to_s().$scan(/\.[^.]+/);
            return $send(extnames, 'inject', [0], function $$13(sum, ext){var self = $$13.$$s == null ? this : $$13.$$s, index = nil;

              
              
              if (sum == null) sum = nil;;
              
              if (ext == null) ext = nil;;
              index = self.$extensions().$index(ext);
              if ($truthy(index)) {
                return $rb_plus($rb_plus(sum, index), 1)
              } else {
                return sum
              };}, {$$arity: 2, $$s: self});}, {$$arity: 1, $$s: self})
        }, 2);
      })($nesting[0], null, $nesting);
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Trail');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.root = $proto.paths = $proto.extensions = nil;
        
        self.$attr_reader("paths");
        self.$attr_reader("extensions");
        
        $def(self, '$initialize', function $$initialize(root) {
          var self = this;

          
          
          if (root == null) root = ".";;
          self.root = $$('Pathname').$new(root).$expand_path();
          self.paths = [];
          return (self.extensions = []);
        }, -1);
        
        $def(self, '$root', function $$root() {
          var self = this;

          return self.root.$to_s()
        }, 0);
        
        $def(self, '$append_paths', function $$append_paths($a) {
          var $post_args, paths, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          paths = $post_args;;
          return self.paths.$concat($send(paths, 'map', [], function $$14(p){var self = $$14.$$s == null ? this : $$14.$$s;

            
            
            if (p == null) p = nil;;
            return self.$normalize_path(p);}, {$$arity: 1, $$s: self}));
        }, -1);
        
        $def(self, '$append_extensions', function $$append_extensions($a) {
          var $post_args, extensions, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          extensions = $post_args;;
          return self.extensions.$concat($send(extensions, 'map', [], function $$15(e){var self = $$15.$$s == null ? this : $$15.$$s;

            
            
            if (e == null) e = nil;;
            return self.$normalize_extension(e);}, {$$arity: 1, $$s: self}));
        }, -1);
        
        $def(self, '$find', function $$find($a) {
          var block = $$find.$$p || nil, $post_args, args, self = this;

          delete $$find.$$p;
          
          ;
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          return $send(self.$index(), 'find', $to_a(args), block.$to_proc());
        }, -1);
        
        $def(self, '$index', function $$index() {
          var self = this;

          return $$('Index').$new(self.$root(), self.$paths(), self.$extensions())
        }, 0);
        
        $def(self, '$entries', function $$entries(path) {
          var pathname = nil;

          
          pathname = $$('Pathname').$new(path);
          if ($truthy(pathname['$directory?']())) {
            return $send(pathname.$entries(), 'reject', [], function $$16(entry){
              
              
              if (entry == null) entry = nil;;
              return entry.$to_s()['$=~'](/^\.|~$|^\#.*\#$/);}, 1).$sort()
          } else {
            return []
          };
        }, 1);
        
        $def(self, '$stat', function $$stat(path) {
          
          if ($truthy($$('File')['$exist?'](path))) {
            return $$('File').$stat(path.$to_s())
          } else {
            return nil
          }
        }, 1);
        self.$private();
        
        $def(self, '$normalize_extension', function $$normalize_extension(ext) {
          
          if ($truthy(ext['$start_with?']("."))) {
            return ext
          } else {
            return "." + (ext)
          }
        }, 1);
        return $def(self, '$normalize_path', function $$normalize_path(path) {
          var self = this;

          
          path = $$('Pathname').$new(path);
          if ($truthy(path['$relative?']())) {
            path = self.root.$join(path)
          };
          return path.$expand_path().$to_s();
        }, 1);
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/path_reader"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy;

  Opal.add_stubs('require,freeze,quote,paths,new,append_paths,append_extensions,expand,nil?,exist?,open,to_proc,=~,absolute?,find_path,file_finder,extensions,private,Pathname,find,attr_reader');
  
  self.$require("opal/regexp_anchors");
  self.$require("opal/hike");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'PathReader');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.file_finder = nil;
      
      $const_set($nesting[0], 'RELATIVE_PATH_REGEXP', $regexp([$$$($$('Opal'), 'REGEXP_START'), "\\.?\\.", $$('Regexp').$quote($$$($$('File'), 'SEPARATOR'))]).$freeze());
      $const_set($nesting[0], 'DEFAULT_EXTENSIONS', [".js", ".js.rb", ".rb", ".opalerb"].$freeze());
      
      $def(self, '$initialize', function $$initialize(paths, extensions) {
        var self = this;

        
        
        if (paths == null) paths = $$('Opal').$paths();;
        
        if (extensions == null) extensions = $$('DEFAULT_EXTENSIONS');;
        self.file_finder = $$$($$('Hike'), 'Trail').$new();
        $send(self.file_finder, 'append_paths', $to_a(paths));
        return $send(self.file_finder, 'append_extensions', $to_a(extensions));
      }, -1);
      
      $def(self, '$read', function $$read(path) {
        var self = this, full_path = nil;

        
        full_path = self.$expand(path);
        if ($truthy(full_path['$nil?']())) {
          return nil
        };
        if ($truthy($$('File')['$exist?'](full_path))) {
          return $send($$('File'), 'open', [full_path, "rb:UTF-8"], "read".$to_proc())
        } else {
          return nil
        };
      }, 1);
      
      $def(self, '$expand', function $$expand(path) {
        var self = this;

        if (($truthy($$('Pathname').$new(path)['$absolute?']()) || ($truthy(path['$=~']($$('RELATIVE_PATH_REGEXP')))))) {
          return path
        } else {
          return self.$find_path(path)
        }
      }, 1);
      
      $def(self, '$paths', function $$paths() {
        var self = this;

        return self.$file_finder().$paths()
      }, 0);
      
      $def(self, '$extensions', function $$extensions() {
        var self = this;

        return self.$file_finder().$extensions()
      }, 0);
      
      $def(self, '$append_paths', function $$append_paths($a) {
        var $post_args, paths, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        paths = $post_args;;
        return $send(self.$file_finder(), 'append_paths', $to_a(paths));
      }, -1);
      self.$private();
      
      $def(self, '$find_path', function $$find_path(path) {
        var self = this, pathname = nil;

        
        pathname = self.$Pathname(path);
        if (($truthy(pathname['$absolute?']()) && ($truthy(pathname['$exist?']())))) {
          return path
        };
        return self.$file_finder().$find(path);
      }, 1);
      return self.$attr_reader("file_finder");
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/paths"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('expand_path,append_paths,concat,require_paths_for_gem,private,find_by_name,raise,each,runtime_dependencies,+,name,gem_dir,map,require_paths,<<,join,extend,freeze,core_dir,std_dir,reset_paths!');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$gem_dir', function $$gem_dir() {
      
      return $$('File').$expand_path("../..", "opal/paths.rb")
    }, 0);
    $defs(self, '$core_dir', function $$core_dir() {
      
      return $$('File').$expand_path("../../../opal", "opal/paths.rb")
    }, 0);
    $defs(self, '$std_dir', function $$std_dir() {
      
      return $$('File').$expand_path("../../../stdlib", "opal/paths.rb")
    }, 0);
    $defs(self, '$append_path', function $$append_path(path) {
      var self = this;

      return self.$append_paths(path)
    }, 1);
    $defs(self, '$append_paths', function $$append_paths($a) {
      var $post_args, paths, self = this;
      if (self.paths == null) self.paths = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      paths = $post_args;;
      self.paths.$concat(paths);
      return nil;
    }, -1);
    (function($base, $parent_nesting) {
      var self = $module($base, 'UseGem');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$use_gem', function $$use_gem(gem_name, include_dependencies) {
        var self = this;

        
        
        if (include_dependencies == null) include_dependencies = true;;
        return $send(self, 'append_paths', $to_a(self.$require_paths_for_gem(gem_name, include_dependencies)));
      }, -2);
      self.$private();
      return $def(self, '$require_paths_for_gem', function $$require_paths_for_gem(gem_name, include_dependencies) {
        var self = this, paths = nil, spec = nil, gem_dir = nil;

        
        paths = [];
        spec = $$$($$('Gem'), 'Specification').$find_by_name(gem_name);
        if (!$truthy(spec)) {
          self.$raise($$('GemNotFound'), gem_name)
        };
        if ($truthy(include_dependencies)) {
          $send(spec.$runtime_dependencies(), 'each', [], function $$1(dependency){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (dependency == null) dependency = nil;;
            return (paths = $rb_plus(paths, self.$require_paths_for_gem(dependency.$name(), include_dependencies)));}, {$$arity: 1, $$s: self})
        };
        gem_dir = spec.$gem_dir();
        $send(spec.$require_paths(), 'map', [], function $$2(path){
          
          
          if (path == null) path = nil;;
          return paths['$<<']($$('File').$join(gem_dir, path));}, 1);
        return paths;
      }, 2);
    })($nesting[0], $nesting);
    self.$extend($$('UseGem'));
    $defs(self, '$paths', function $$paths() {
      var self = this;
      if (self.paths == null) self.paths = nil;

      return self.paths.$freeze()
    }, 0);
    $defs(self, '$reset_paths!', function $Opal_reset_paths$excl$3() {
      var self = this;

      
      self.paths = [self.$core_dir(), self.$std_dir(), self.$gem_dir()];
      nil;
      return nil;
    }, 0);
    return self['$reset_paths!']();
  })($nesting[0], $nesting)
};

Opal.modules["set"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $alias = Opal.alias, $module = Opal.module, $to_a = Opal.to_a;

  Opal.add_stubs('include,new,nil?,===,raise,each,add,merge,class,respond_to?,subtract,dup,join,to_a,equal?,instance_of?,==,instance_variable_get,size,is_a?,all?,include?,[]=,enum_for,[],<<,replace,delete,select,reject,delete_if,to_proc,keep_if,each_key,empty?,eql?,instance_eval,clear,<,<=,any?,!,intersect?,keys,|,proper_subset?,subset?,proper_superset?,superset?,-,select!,collect!');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Set');

    var $ret_or_1 = nil, $proto = self.$$prototype;

    $proto.hash = nil;
    
    self.$include($$$('Enumerable'));
    $defs(self, '$[]', function $Set_$$$1($a) {
      var $post_args, ary, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      ary = $post_args;;
      return self.$new(ary);
    }, -1);
    
    $def(self, '$initialize', function $$initialize(enum$) {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      
      if (enum$ == null) enum$ = nil;;
      self.hash = $hash2([], {});
      if ($truthy(enum$['$nil?']())) {
        return nil
      };
      if (!$eqeqeq($$$('Enumerable'), enum$)) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], function $$2(item){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (item == null) item = nil;;
          return self.$add(Opal.yield1(block, item));}, {$$arity: 1, $$s: self})
      } else {
        return self.$merge(enum$)
      };
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    }, 0);
    
    $def(self, '$-', function $Set_$minus$3(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    }, 0);
    
    $def(self, '$==', function $Set_$eq_eq$4(other) {
      var self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if (($truthy(other['$is_a?']($$$('Set'))) && ($eqeq(self.$size(), other.$size())))) {
        return $send(other, 'all?', [], function $$5(o){var self = $$5.$$s == null ? this : $$5.$$s;
          if (self.hash == null) self.hash = nil;

          
          
          if (o == null) o = nil;;
          return self.hash['$include?'](o);}, {$$arity: 1, $$s: self})
      } else {
        return false
      }
    }, 1);
    
    $def(self, '$add', function $$add(o) {
      var self = this;

      
      self.hash['$[]='](o, true);
      return self;
    }, 1);
    
    $def(self, '$classify', function $$classify() {
      var block = $$classify.$$p || nil, self = this, result = nil;

      delete $$classify.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("classify")
      };
      result = $send($$$('Hash'), 'new', [], function $$6(h, k){var $a, self = $$6.$$s == null ? this : $$6.$$s;

        
        
        if (h == null) h = nil;;
        
        if (k == null) k = nil;;
        return ($a = [k, self.$class().$new()], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
      $send(self, 'each', [], function $$7(item){
        
        
        if (item == null) item = nil;;
        return result['$[]'](Opal.yield1(block, item)).$add(item);}, 1);
      return result;
    }, 0);
    
    $def(self, '$collect!', function $Set_collect$excl$8() {
      var block = $Set_collect$excl$8.$$p || nil, self = this, result = nil;

      delete $Set_collect$excl$8.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], function $$9(item){
        
        
        if (item == null) item = nil;;
        return result['$<<'](Opal.yield1(block, item));}, 1);
      return self.$replace(result);
    }, 0);
    
    $def(self, '$delete', function $Set_delete$10(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    }, 1);
    
    $def(self, '$delete?', function $Set_delete$ques$11(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var $yield = $$delete_if.$$p || nil, self = this;

      delete $$delete_if.$$p;
      
      if (!($yield !== nil)) {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], function $$12(o){
        
        
        if (o == null) o = nil;;
        return Opal.yield1($yield, o);;}, 1), 'each', [], function $$13(o){var self = $$13.$$s == null ? this : $$13.$$s;
        if (self.hash == null) self.hash = nil;

        
        
        if (o == null) o = nil;;
        return self.hash.$delete(o);}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$keep_if', function $$keep_if() {
      var $yield = $$keep_if.$$p || nil, self = this;

      delete $$keep_if.$$p;
      
      if (!($yield !== nil)) {
        return self.$enum_for("keep_if")
      };
      $send($send(self, 'reject', [], function $$14(o){
        
        
        if (o == null) o = nil;;
        return Opal.yield1($yield, o);;}, 1), 'each', [], function $$15(o){var self = $$15.$$s == null ? this : $$15.$$s;
        if (self.hash == null) self.hash = nil;

        
        
        if (o == null) o = nil;;
        return self.hash.$delete(o);}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$reject!', function $Set_reject$excl$16() {
      var block = $Set_reject$excl$16.$$p || nil, self = this, before = nil;

      delete $Set_reject$excl$16.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("reject!")
      };
      before = self.$size();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$select!', function $Set_select$excl$17() {
      var block = $Set_select$excl$17.$$p || nil, self = this, before = nil;

      delete $Set_select$excl$17.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("select!")
      };
      before = self.$size();
      $send(self, 'keep_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$add?', function $Set_add$ques$18(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    }, 1);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$empty?', function $Set_empty$ques$19() {
      var self = this;

      return self.hash['$empty?']()
    }, 0);
    
    $def(self, '$eql?', function $Set_eql$ques$20(other) {
      var self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;
        if (self.hash == null) self.hash = nil;

        return self.hash}, {$$arity: 0, $$s: self}))
    }, 1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    }, 0);
    
    $def(self, '$include?', function $Set_include$ques$22(o) {
      var self = this;

      return self.hash['$include?'](o)
    }, 1);
    
    $def(self, '$merge', function $$merge(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$23(item){var self = $$23.$$s == null ? this : $$23.$$s;

        
        
        if (item == null) item = nil;;
        return self.$add(item);}, {$$arity: 1, $$s: self});
      return self;
    }, 1);
    
    $def(self, '$replace', function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    }, 1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      return self.hash.$size()
    }, 0);
    
    $def(self, '$subtract', function $$subtract(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$24(item){var self = $$24.$$s == null ? this : $$24.$$s;

        
        
        if (item == null) item = nil;;
        return self.$delete(item);}, {$$arity: 1, $$s: self});
      return self;
    }, 1);
    
    $def(self, '$|', function $Set_$$25(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    }, 1);
    
    function is_set(set) {
      ($truthy(($ret_or_1 = (set)['$is_a?']($$$('Set')))) ? ($ret_or_1) : ($Kernel.$raise($$$('ArgumentError'), "value must be a set")))
    }
  ;
    
    $def(self, '$superset?', function $Set_superset$ques$26(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$27(o){var self = $$27.$$s == null ? this : $$27.$$s;

        
        
        if (o == null) o = nil;;
        return self['$include?'](o);}, {$$arity: 1, $$s: self});
    }, 1);
    
    $def(self, '$proper_superset?', function $Set_proper_superset$ques$28(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$29(o){var self = $$29.$$s == null ? this : $$29.$$s;

        
        
        if (o == null) o = nil;;
        return self['$include?'](o);}, {$$arity: 1, $$s: self});
    }, 1);
    
    $def(self, '$subset?', function $Set_subset$ques$30(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$31(o){
        
        
        if (o == null) o = nil;;
        return set['$include?'](o);}, 1);
    }, 1);
    
    $def(self, '$proper_subset?', function $Set_proper_subset$ques$32(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$33(o){
        
        
        if (o == null) o = nil;;
        return set['$include?'](o);}, 1);
    }, 1);
    
    $def(self, '$intersect?', function $Set_intersect$ques$34(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return $send(self, 'any?', [], function $$35(o){
          
          
          if (o == null) o = nil;;
          return set['$include?'](o);}, 1)
      } else {
        return $send(set, 'any?', [], function $$36(o){var self = $$36.$$s == null ? this : $$36.$$s;

          
          
          if (o == null) o = nil;;
          return self['$include?'](o);}, {$$arity: 1, $$s: self})
      };
    }, 1);
    
    $def(self, '$disjoint?', function $Set_disjoint$ques$37(set) {
      var self = this;

      return self['$intersect?'](set)['$!']()
    }, 1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.hash.$keys()
    }, 0);
    $alias(self, "+", "|");
    $alias(self, "<", "proper_subset?");
    $alias(self, "<<", "add");
    $alias(self, "<=", "subset?");
    $alias(self, ">", "proper_superset?");
    $alias(self, ">=", "superset?");
    $alias(self, "difference", "-");
    $alias(self, "filter!", "select!");
    $alias(self, "length", "size");
    $alias(self, "map!", "collect!");
    $alias(self, "member?", "include?");
    return $alias(self, "union", "|");
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_set', function $$to_set($a, $b) {
      var block = $$to_set.$$p || nil, $post_args, klass, args, self = this;

      delete $$to_set.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      if ($post_args.length > 0) klass = $post_args.shift();
      if (klass == null) klass = $$('Set');;
      
      args = $post_args;;
      return $send(klass, 'new', [self].concat($to_a(args)), block.$to_proc());
    }, -1)
  })('::', $nesting);
};

Opal.modules["opal/config"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $truthy = Opal.truthy, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $assign_ivar_val = Opal.assign_ivar_val, $lambda = Opal.lambda;

  Opal.add_stubs('require,extend,private,fetch,[]=,config_options,define_singleton_method,config,any?,===,raise,inspect,public,each,call,default_config,config_option,new');
  
  self.$require("set");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Config');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$extend(self);
      self.$private();
      
      $def(self, '$config_options', function $$config_options() {
        var self = this, $ret_or_1 = nil;
        if (self.config_options == null) self.config_options = nil;

        return (self.config_options = ($truthy(($ret_or_1 = self.config_options)) ? ($ret_or_1) : ($hash2([], {}))))
      }, 0);
      
      $def(self, '$config_option', function $$config_option(name, default_value, options) {
        var self = this, compiler = nil, valid_values = nil;

        
        
        if (options == null) options = $hash2([], {});;
        compiler = options.$fetch("compiler_option", nil);
        valid_values = options.$fetch("valid_values", [true, false]);
        self.$config_options()['$[]='](name, $hash2(["default", "compiler"], {"default": default_value, "compiler": compiler}));
        $send(self, 'define_singleton_method', [name], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          return self.$config().$fetch(name, default_value)}, {$$arity: 0, $$s: self});
        return $send(self, 'define_singleton_method', ["" + (name) + "="], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (value == null) value = nil;;
          if (!$truthy($send(valid_values, 'any?', [], function $$3(valid_value){
            
            
            if (valid_value == null) valid_value = nil;;
            return valid_value['$==='](value);}, 1))) {
            self.$raise($$('ArgumentError'), "" + ("Not a valid value for option " + (self) + "." + (name) + ", provided " + (value.$inspect()) + ". ") + ("Must be " + (valid_values.$inspect()) + " === " + (value.$inspect())))
          };
          return ($a = [name, value], $send(self.$config(), '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
      }, -3);
      self.$public();
      
      $def(self, '$default_config', function $$default_config() {
        var self = this, default_config = nil;

        
        default_config = $hash2([], {});
        $send(self.$config_options(), 'each', [], function $$4(name, options){var $a, default_value = nil;

          
          
          if (name == null) name = nil;;
          
          if (options == null) options = nil;;
          default_value = options.$fetch("default");
          default_value = ($eqeqeq($$('Proc'), default_value) ? (default_value.$call()) : (default_value));
          return ($a = [name, default_value], $send(default_config, '[]=', $a), $a[$a.length - 1]);}, 2);
        return default_config;
      }, 0);
      
      $def(self, '$compiler_options', function $$compiler_options() {
        var self = this, compiler_options = nil;

        
        compiler_options = $hash2([], {});
        $send(self.$config_options(), 'each', [], function $$5(name, options){var $a, self = $$5.$$s == null ? this : $$5.$$s, compiler_option_name = nil;

          
          
          if (name == null) name = nil;;
          
          if (options == null) options = nil;;
          compiler_option_name = options.$fetch("compiler");
          return ($a = [compiler_option_name, self.$config().$fetch(name)], $send(compiler_options, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
        return compiler_options;
      }, 0);
      
      $def(self, '$config', function $$config() {
        var self = this, $ret_or_1 = nil;
        if (self.config == null) self.config = nil;

        return (self.config = ($truthy(($ret_or_1 = self.config)) ? ($ret_or_1) : (self.$default_config())))
      }, 0);
      
      $def(self, '$reset!', $assign_ivar_val("config", nil), 0);
      self.$config_option("method_missing_enabled", true, $hash2(["compiler_option"], {"compiler_option": "method_missing"}));
      self.$config_option("const_missing_enabled", true, $hash2(["compiler_option"], {"compiler_option": "const_missing"}));
      self.$config_option("arity_check_enabled", false, $hash2(["compiler_option"], {"compiler_option": "arity_check"}));
      self.$config_option("freezing_stubs_enabled", true, $hash2(["compiler_option"], {"compiler_option": "freezing"}));
      self.$config_option("esm", false, $hash2(["compiler_option"], {"compiler_option": "esm"}));
      self.$config_option("dynamic_require_severity", "warning", $hash2(["compiler_option", "valid_values"], {"compiler_option": "dynamic_require_severity", "valid_values": ["error", "warning", "ignore"]}));
      self.$config_option("missing_require_severity", "error", $hash2(["valid_values"], {"valid_values": ["error", "warning", "ignore"]}));
      self.$config_option("irb_enabled", false, $hash2(["compiler_option"], {"compiler_option": "irb"}));
      self.$config_option("inline_operators_enabled", true, $hash2(["compiler_option"], {"compiler_option": "inline_operators"}));
      self.$config_option("source_map_enabled", true);
      return self.$config_option("stubbed_files", $lambda(function $Config$6(){
        return $$('Set').$new()}, 0), $hash2(["valid_values"], {"valid_values": [$$('Set')]}));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/cache"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $not = Opal.not, $eqeq = Opal.eqeq, $defs = Opal.defs, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $rb_plus = Opal.rb_plus, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs('require,attr_writer,singleton_class,!,find_dir,[],==,new,module_function,respond_to?,fetch,to_proc,+,digest,join,runtime_key,get,dynamic_cache_result,set,expand_path,gem_dir,grep,map,sort,size,to_f,mtime,to_s,to_i,hexdigest');
  
  self.$require("opal/paths");
  nil;
  nil;
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$singleton_class().$attr_writer("cache");
    $defs(self, '$cache', function $$cache() {
      var self = this, $ret_or_1 = nil;
      if (self.cache == null) self.cache = nil;

      return (self.cache = ($truthy(($ret_or_1 = self.cache)) ? ($ret_or_1) : ((($eqeq($$('RUBY_ENGINE'), "opal") || ($truthy($$('ENV')['$[]']("OPAL_CACHE_DISABLE")))) || ($not($$$($$('Cache'), 'FileCache').$find_dir()))) ? ($$$($$('Cache'), 'NullCache').$new()) : ($$$($$('Cache'), 'FileCache').$new()))))
    }, 0);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Cache');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'NullCache');

        
        return $def(self, '$fetch', function $$fetch($a) {
          var $post_args, $rest_arg, $yield = $$fetch.$$p || nil;

          delete $$fetch.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          return Opal.yieldX($yield, []);;
        }, -1)
      })($nesting[0], null);
      self.$module_function();
      
      $def(self, '$fetch', function $$fetch(cache, key) {
        var block = $$fetch.$$p || nil, self = this, data = nil, $ret_or_1 = nil, compiler = nil;

        delete $$fetch.$$p;
        
        ;
        if ($truthy(cache['$respond_to?']("fetch"))) {
          return $send(cache, 'fetch', [key], block.$to_proc())
        };
        key = $rb_plus($rb_plus(self.$digest(key.$join("/")), "-"), self.$runtime_key());
        data = cache.$get(key);
        if ($truthy(($ret_or_1 = data))) {
          return $ret_or_1
        } else {
          
          compiler = Opal.yieldX(block, []);
          if (!$truthy(compiler.$dynamic_cache_result())) {
            cache.$set(key, compiler)
          };
          return compiler;
        };
      }, 2);
      
      $def(self, '$runtime_key', function $$runtime_key() {
        var self = this, $ret_or_1 = nil, opal_path = nil, files = nil;
        if (self.runtime_key == null) self.runtime_key = nil;
        if ($gvars.LOADED_FEATURES == null) $gvars.LOADED_FEATURES = nil;

        return (self.runtime_key = ($truthy(($ret_or_1 = self.runtime_key)) ? ($ret_or_1) : (((opal_path = $$('File').$expand_path("..", $$('Opal').$gem_dir())), (files = $$('Dir')['$[]']("" + (opal_path) + "/{Gemfile*,*.gemspec,lib/**/*}")), (files = $rb_plus(files, $gvars.LOADED_FEATURES.$grep(/lib\/(parser|ast)/))), self.$digest([$send(files.$sort(), 'map', [], function $$1(f){
          
          
          if (f == null) f = nil;;
          return "" + (f) + ":" + ($$('File').$size(f)) + ":" + ($$('File').$mtime(f).$to_f());}, 1), $$('RUBY_VERSION'), $$('RUBY_PATCHLEVEL')].$join("/"))))))
      }, 0);
      return $def(self, '$digest', function $$digest(string) {
        
        return $$$($$$('Digest'), 'SHA256').$hexdigest(string)['$[]']($range(-32, -1, false)).$to_i(16).$to_s(36)
      }, 1);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["opal/builder"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $send = Opal.send, $hash2 = Opal.hash2, $Opal = Opal.Opal, $def = Opal.def, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $not = Opal.not, $lambda = Opal.lambda;

  Opal.add_stubs('require,include?,processors,<<,each,extensions,each_pair,public_send,new,paths,flatten,map,compiler_options,missing_require_severity,cache,build,to_proc,build_str,source_for,read,nil?,expand_path,expand_ext,processor_for,+,preload,requires,tree_requires,process_require,autoloads,processed,raise,inspect,message,backtrace,dup,stubs,path_reader,prerequired,to_sym,join,append_paths,include,attr_reader,attr_accessor,private,empty?,to_s,pwd,dirname,Pathname,flat_map,required_trees,find,start_with?,glob,relative_path_from,match?,!,merge,[],warn,already_processed,stub?,process_requires,expand,basename');
  
  self.$require("opal/path_reader");
  self.$require("opal/paths");
  self.$require("opal/config");
  self.$require("opal/cache");
  self.$require("set");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Builder');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.stubs = $proto.preload = $proto.processors = $proto.path_reader = $proto.prerequired = $proto.compiler_options = $proto.missing_require_severity = $proto.cache = $proto.already_processed = nil;
      
      $defs(self, '$processors', function $$processors() {
        var self = this, $ret_or_1 = nil;
        if (self.processors == null) self.processors = nil;

        return (self.processors = ($truthy(($ret_or_1 = self.processors)) ? ($ret_or_1) : ([])))
      }, 0);
      $defs(self, '$extensions', function $$extensions() {
        var self = this, $ret_or_1 = nil;
        if (self.extensions == null) self.extensions = nil;

        return (self.extensions = ($truthy(($ret_or_1 = self.extensions)) ? ($ret_or_1) : ([])))
      }, 0);
      $defs(self, '$register_processor', function $$register_processor(processor, processor_extensions) {
        var self = this;

        
        if ($truthy(self.$processors()['$include?'](processor))) {
          return nil
        };
        self.$processors()['$<<'](processor);
        return $send(processor_extensions, 'each', [], function $$1(ext){var self = $$1.$$s == null ? this : $$1.$$s;

          
          
          if (ext == null) ext = nil;;
          return self.$extensions()['$<<'](ext);}, {$$arity: 1, $$s: self});
      }, 2);
      $klass($nesting[0], $$('LoadError'), 'MissingRequire');
      $klass($nesting[0], $$('LoadError'), 'ProcessorNotFound');
      
      $def(self, '$initialize', function $$initialize(options) {
        var self = this, $ret_or_1 = nil;

        
        
        if (options == null) options = nil;;
        $send(($truthy(($ret_or_1 = options)) ? ($ret_or_1) : ($hash2([], {}))), 'each_pair', [], function $$2(k, v){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (k == null) k = nil;;
          
          if (v == null) v = nil;;
          return self.$public_send("" + (k) + "=", v);}, {$$arity: 2, $$s: self});
        self.stubs = ($truthy(($ret_or_1 = self.stubs)) ? ($ret_or_1) : ([]));
        self.preload = ($truthy(($ret_or_1 = self.preload)) ? ($ret_or_1) : ([]));
        self.processors = ($truthy(($ret_or_1 = self.processors)) ? ($ret_or_1) : ($$$($Opal, 'Builder').$processors()));
        self.path_reader = ($truthy(($ret_or_1 = self.path_reader)) ? ($ret_or_1) : ($$('PathReader').$new($$('Opal').$paths(), $send(self.$extensions(), 'map', [], function $$3(e){
          
          
          if (e == null) e = nil;;
          return ["." + (e), ".js." + (e)];}, 1).$flatten())));
        self.prerequired = ($truthy(($ret_or_1 = self.prerequired)) ? ($ret_or_1) : ([]));
        self.compiler_options = ($truthy(($ret_or_1 = self.compiler_options)) ? ($ret_or_1) : ($$$($$('Opal'), 'Config').$compiler_options()));
        self.missing_require_severity = ($truthy(($ret_or_1 = self.missing_require_severity)) ? ($ret_or_1) : ($$$($$('Opal'), 'Config').$missing_require_severity()));
        self.cache = ($truthy(($ret_or_1 = self.cache)) ? ($ret_or_1) : ($$('Opal').$cache()));
        return (self.processed = []);
      }, -1);
      $defs(self, '$build', function $$build($a) {
        var block = $$build.$$p || nil, $post_args, args, self = this;

        delete $$build.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        return $send(self.$new(), 'build', $to_a(args), block.$to_proc());
      }, -1);
      
      $def(self, '$build', function $$build(path, options) {
        var self = this;

        
        
        if (options == null) options = $hash2([], {});;
        return self.$build_str(self.$source_for(path), path, options);
      }, -2);
      
      $def(self, '$source_for', function $$source_for(path) {
        var self = this;

        return self.$read(path, false)
      }, 1);
      
      $def(self, '$build_str', function $$build_str(source, rel_path, options) {
        var self = this, abs_path = nil, asset = nil, requires = nil, error = nil;

        
        
        if (options == null) options = $hash2([], {});;
        try {
          
          if ($truthy(source['$nil?']())) {
            return nil
          };
          abs_path = self.$expand_path(rel_path);
          rel_path = self.$expand_ext(rel_path);
          asset = self.$processor_for(source, rel_path, abs_path, false, options);
          requires = $rb_plus($rb_plus(self.$preload(), asset.$requires()), self.$tree_requires(asset, abs_path));
          $send(requires, 'map', [], function $$4(r){var self = $$4.$$s == null ? this : $$4.$$s;

            
            
            if (r == null) r = nil;;
            return self.$process_require(r, asset.$autoloads(), options);}, {$$arity: 1, $$s: self});
          self.$processed()['$<<'](asset);
          return self;
        } catch ($err) {
          if (Opal.rescue($err, [$$('MissingRequire')])) {(error = $err)
            try {
              return self.$raise(error, "A file required by " + (rel_path.$inspect()) + " wasn't found.\n" + (error.$message()), error.$backtrace())
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      }, -3);
      
      $def(self, '$build_require', function $$build_require(path, options) {
        var self = this;

        
        
        if (options == null) options = $hash2([], {});;
        return self.$process_require(path, [], options);
      }, -2);
      
      $def(self, '$initialize_copy', function $$initialize_copy(other) {
        var $yield = $$initialize_copy.$$p || nil, self = this;

        delete $$initialize_copy.$$p;
        
        $send2(self, $find_super(self, 'initialize_copy', $$initialize_copy, false, true), 'initialize_copy', [other], $yield);
        self.stubs = other.$stubs().$dup();
        self.preload = other.$preload().$dup();
        self.processors = other.$processors().$dup();
        self.path_reader = other.$path_reader().$dup();
        self.prerequired = other.$prerequired().$dup();
        self.compiler_options = other.$compiler_options().$dup();
        self.missing_require_severity = other.$missing_require_severity().$to_sym();
        return (self.processed = other.$processed().$dup());
      }, 1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return $send(self.$processed(), 'map', [], "to_s".$to_proc()).$join("\n")
      }, 0);
      
      $def(self, '$source_map', function $$source_map() {
        var self = this;

        return $$$($$$($Opal, 'SourceMap'), 'Index').$new($send(self.$processed(), 'map', [], "source_map".$to_proc()), $hash2(["join"], {"join": "\n"}))
      }, 0);
      
      $def(self, '$append_paths', function $$append_paths($a) {
        var $post_args, paths, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        paths = $post_args;;
        return $send(self.$path_reader(), 'append_paths', $to_a(paths));
      }, -1);
      self.$include($$('UseGem'));
      self.$attr_reader("processed");
      self.$attr_accessor("processors", "path_reader", "stubs", "prerequired", "preload", "compiler_options", "missing_require_severity", "cache");
      self.$private();
      
      $def(self, '$tree_requires', function $$tree_requires(asset, asset_path) {
        var self = this, dirname = nil, abs_base_paths = nil;

        
        dirname = ($truthy(asset_path.$to_s()['$empty?']()) ? ($$('Pathname').$pwd()) : (self.$Pathname(asset_path).$expand_path().$dirname()));
        abs_base_paths = $send(self.$path_reader().$paths(), 'map', [], function $$5(p){
          
          
          if (p == null) p = nil;;
          return $$('File').$expand_path(p);}, 1);
        return $send(asset.$required_trees(), 'flat_map', [], function $$6(tree){var self = $$6.$$s == null ? this : $$6.$$s, abs_tree_path = nil, abs_base_path = nil, entries_glob = nil;

          
          
          if (tree == null) tree = nil;;
          abs_tree_path = dirname.$join(tree).$expand_path().$to_s();
          abs_base_path = $send(abs_base_paths, 'find', [], function $$7(p){
            
            
            if (p == null) p = nil;;
            return abs_tree_path['$start_with?'](p);}, 1);
          if ($truthy(abs_base_path)) {
            
            abs_base_path = self.$Pathname(abs_base_path);
            entries_glob = self.$Pathname(abs_tree_path).$join("**", "*{.js,}.{" + (self.$extensions().$join(",")) + "}");
            return $send($$('Pathname').$glob(entries_glob), 'map', [], function $$8(file){
              
              
              if (file == null) file = nil;;
              return file.$relative_path_from(abs_base_path).$to_s();}, 1);
          } else {
            return []
          };}, {$$arity: 1, $$s: self});
      }, 2);
      
      $def(self, '$processor_for', function $$processor_for(source, rel_path, abs_path, autoload, options) {
        var self = this, processor = nil;

        
        processor = $send(self.$processors(), 'find', [], function $$9(p){
          
          
          if (p == null) p = nil;;
          return p['$match?'](abs_path);}, 1);
        if (($not(processor) && ($not(autoload)))) {
          self.$raise($$('ProcessorNotFound'), "can't find processor for rel_path: " + ("" + (rel_path.$inspect()) + ", ") + ("abs_path: " + (abs_path.$inspect()) + ", ") + ("source: " + (source.$inspect()) + ", ") + ("processors: " + (self.$processors().$inspect())))
        };
        options = options.$merge($hash2(["cache"], {"cache": self.$cache()}));
        return processor.$new(source, rel_path, self.compiler_options.$merge(options));
      }, 5);
      
      $def(self, '$read', function $$read(path, autoload) {
        var self = this, $ret_or_1 = nil, print_list = nil, message = nil;

        if ($truthy(($ret_or_1 = self.$path_reader().$read(path)))) {
          return $ret_or_1
        } else {
          
          print_list = $lambda(function $$10(list){
            
            
            if (list == null) list = nil;;
            return "- " + (list.$join("\n- ")) + "\n";}, 1);
          message = $rb_plus($rb_plus($rb_plus($rb_plus($rb_plus("can't find file: " + (path.$inspect()) + " in:\n", print_list['$[]'](self.$path_reader().$paths())), "\nWith the following extensions:\n"), print_list['$[]'](self.$path_reader().$extensions())), "\nAnd the following processors:\n"), print_list['$[]'](self.$processors()));
          if (!$truthy(autoload)) {
            
            switch (self.$missing_require_severity()) {
              case "error":
                self.$raise($$('MissingRequire'), message)
                break;
              case "warning":
                self.$warn(message)
                break;
              case "ignore":
                
                break;
              default:
                nil
            }
          };
          return nil;
        }
      }, 2);
      
      $def(self, '$process_require', function $$process_require(rel_path, autoloads, options) {
        var self = this, autoload = nil, source = nil, abs_path = nil, asset = nil;

        
        if ($truthy(self.$prerequired()['$include?'](rel_path))) {
          return nil
        };
        if ($truthy(self.$already_processed()['$include?'](rel_path))) {
          return nil
        };
        self.$already_processed()['$<<'](rel_path);
        autoload = autoloads['$include?'](rel_path);
        source = ($truthy(self['$stub?'](rel_path)) ? ("") : (self.$read(rel_path, autoload)));
        if ($truthy(source['$nil?']())) {
          return nil
        };
        abs_path = self.$expand_path(rel_path);
        rel_path = self.$expand_ext(rel_path);
        asset = self.$processor_for(source, rel_path, abs_path, autoload, options.$merge($hash2(["requirable"], {"requirable": true})));
        self.$process_requires(rel_path, $rb_plus(asset.$requires(), self.$tree_requires(asset, abs_path)), asset.$autoloads(), options);
        return self.$processed()['$<<'](asset);
      }, 3);
      
      $def(self, '$expand_ext', function $$expand_ext(path) {
        var self = this, abs_path = nil;

        
        abs_path = self.$path_reader().$expand(path);
        if ($truthy(abs_path)) {
          return $$('File').$join($$('File').$dirname(path), $$('File').$basename(abs_path))
        } else {
          return path
        };
      }, 1);
      
      $def(self, '$expand_path', function $$expand_path(path) {
        var self = this, $ret_or_1 = nil;

        
        if ($truthy(self['$stub?'](path))) {
          return nil
        };
        return ($truthy(($ret_or_1 = self.$path_reader().$expand(path))) ? ($ret_or_1) : ($$('File').$expand_path(path))).$to_s();
      }, 1);
      
      $def(self, '$process_requires', function $$process_requires(rel_path, requires, autoloads, options) {
        var self = this, error = nil;

        try {
          return $send(requires, 'map', [], function $$11(r){var self = $$11.$$s == null ? this : $$11.$$s;

            
            
            if (r == null) r = nil;;
            return self.$process_require(r, autoloads, options);}, {$$arity: 1, $$s: self})
        } catch ($err) {
          if (Opal.rescue($err, [$$('MissingRequire')])) {(error = $err)
            try {
              return self.$raise(error, "A file required by " + (rel_path.$inspect()) + " wasn't found.\n" + (error.$message()), error.$backtrace())
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      }, 4);
      
      $def(self, '$already_processed', function $$already_processed() {
        var self = this, $ret_or_1 = nil;

        return (self.already_processed = ($truthy(($ret_or_1 = self.already_processed)) ? ($ret_or_1) : ($$('Set').$new())))
      }, 0);
      
      $def(self, '$stub?', function $Builder_stub$ques$12(path) {
        var self = this;

        return self.$stubs()['$include?'](path)
      }, 1);
      return $def(self, '$extensions', function $$extensions() {
        
        return $$$($Opal, 'Builder').$extensions()
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["ast/node"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $alias = Opal.alias, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $return_self = Opal.return_self, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $to_a = Opal.to_a;

  Opal.add_stubs('attr_reader,children,to_sym,freeze,to_a,assign_properties,hash,class,eql?,type,each,instance_variable_set,protected,dup,private,nil?,==,original_dup,send,equal?,respond_to?,to_ast,updated,+,concat,append,*,fancy_type,is_a?,to_sexp,inspect,map,to_sexp_array,gsub,to_s');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'AST');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Node');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.type = $proto.children = nil;
      
      self.$attr_reader("type");
      self.$attr_reader("children");
      $alias(self, "to_a", "children");
      self.$attr_reader("hash");
      
      $def(self, '$initialize', function $$initialize(type, children, properties) {
        var $a, self = this;

        
        
        if (children == null) children = [];;
        
        if (properties == null) properties = $hash2([], {});;
        $a = [type.$to_sym(), children.$to_a().$freeze()], (self.type = $a[0]), (self.children = $a[1]), $a;
        self.$assign_properties(properties);
        self.hash = [self.type, self.children, self.$class()].$hash();
        return self.$freeze();
      }, -2);
      
      $def(self, '$eql?', function $Node_eql$ques$1(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$class()['$eql?'](other.$class()))) ? (self.type['$eql?'](other.$type())) : ($ret_or_2))))) {
          return self.children['$eql?'](other.$children())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$assign_properties', function $$assign_properties(properties) {
        var self = this;

        
        $send(properties, 'each', [], function $$2(name, value){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (name == null) name = nil;;
          
          if (value == null) value = nil;;
          return self.$instance_variable_set("@" + (name), value);}, {$$arity: 2, $$s: self});
        return nil;
      }, 1);
      self.$protected("assign_properties");
      $alias(self, "original_dup", "dup");
      self.$private("original_dup");
      
      $def(self, '$dup', $return_self, 0);
      $alias(self, "clone", "dup");
      
      $def(self, '$updated', function $$updated(type, children, properties) {
        var self = this, new_type = nil, $ret_or_1 = nil, new_children = nil, new_properties = nil, copy = nil;

        
        
        if (type == null) type = nil;;
        
        if (children == null) children = nil;;
        
        if (properties == null) properties = nil;;
        new_type = ($truthy(($ret_or_1 = type)) ? ($ret_or_1) : (self.type));
        new_children = ($truthy(($ret_or_1 = children)) ? ($ret_or_1) : (self.children));
        new_properties = ($truthy(($ret_or_1 = properties)) ? ($ret_or_1) : ($hash2([], {})));
        if ((($eqeq(self.type, new_type) && ($eqeq(self.children, new_children))) && ($truthy(properties['$nil?']())))) {
          return self
        } else {
          
          copy = self.$original_dup();
          copy.$send("initialize", new_type, new_children, new_properties);
          return copy;
        };
      }, -1);
      
      $def(self, '$==', function $Node_$eq_eq$3(other) {
        var self = this, $ret_or_1 = nil;

        if ($truthy(self['$equal?'](other))) {
          return true
        } else if ($truthy(other['$respond_to?']("to_ast"))) {
          
          other = other.$to_ast();
          if ($truthy(($ret_or_1 = other.$type()['$=='](self.$type())))) {
            return other.$children()['$=='](self.$children())
          } else {
            return $ret_or_1
          };
        } else {
          return false
        }
      }, 1);
      
      $def(self, '$concat', function $$concat(array) {
        var self = this;

        return self.$updated(nil, $rb_plus(self.children, array.$to_a()))
      }, 1);
      $alias(self, "+", "concat");
      
      $def(self, '$append', function $$append(element) {
        var self = this;

        return self.$updated(nil, $rb_plus(self.children, [element]))
      }, 1);
      $alias(self, "<<", "append");
      
      $def(self, '$to_sexp', function $$to_sexp(indent) {
        var self = this, indented = nil, sexp = nil;

        
        
        if (indent == null) indent = 0;;
        indented = $rb_times("  ", indent);
        sexp = "" + (indented) + "(" + (self.$fancy_type());
        $send(self.$children(), 'each', [], function $$4(child){
          
          
          if (child == null) child = nil;;
          if ($truthy(child['$is_a?']($$('Node')))) {
            return (sexp = $rb_plus(sexp, "\n" + (child.$to_sexp($rb_plus(indent, 1)))))
          } else {
            return (sexp = $rb_plus(sexp, " " + (child.$inspect())))
          };}, 1);
        sexp = $rb_plus(sexp, ")");
        return sexp;
      }, -1);
      $alias(self, "to_s", "to_sexp");
      
      $def(self, '$inspect', function $$inspect(indent) {
        var self = this, indented = nil, sexp = nil;

        
        
        if (indent == null) indent = 0;;
        indented = $rb_times("  ", indent);
        sexp = "" + (indented) + "s(:" + (self.type);
        $send(self.$children(), 'each', [], function $$5(child){
          
          
          if (child == null) child = nil;;
          if ($truthy(child['$is_a?']($$('Node')))) {
            return (sexp = $rb_plus(sexp, ",\n" + (child.$inspect($rb_plus(indent, 1)))))
          } else {
            return (sexp = $rb_plus(sexp, ", " + (child.$inspect())))
          };}, 1);
        sexp = $rb_plus(sexp, ")");
        return sexp;
      }, -1);
      
      $def(self, '$to_ast', $return_self, 0);
      
      $def(self, '$to_sexp_array', function $$to_sexp_array() {
        var self = this, children_sexp_arrs = nil;

        
        children_sexp_arrs = $send(self.$children(), 'map', [], function $$6(child){
          
          
          if (child == null) child = nil;;
          if ($truthy(child['$is_a?']($$('Node')))) {
            return child.$to_sexp_array()
          } else {
            return child
          };}, 1);
        return [self.$type()].concat($to_a(children_sexp_arrs));
      }, 0);
      
      $def(self, '$deconstruct', function $$deconstruct() {
        var self = this;

        return [self.$type()].concat($to_a(self.$children()))
      }, 0);
      self.$protected();
      return $def(self, '$fancy_type', function $$fancy_type() {
        var self = this;

        return self.type.$to_s().$gsub("_", "-")
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ast/processor/mixin"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $return_val = Opal.return_val;

  Opal.add_stubs('nil?,to_ast,type,respond_to?,send,handler_missing,map,to_a,process');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'AST');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Processor');

      var $nesting = [self].concat($parent_nesting);

      return (function($base) {
        var self = $module($base, 'Mixin');

        
        
        
        $def(self, '$process', function $$process(node) {
          var self = this, on_handler = nil, new_node = nil;

          
          if ($truthy(node['$nil?']())) {
            return nil
          };
          node = node.$to_ast();
          on_handler = "on_" + (node.$type());
          if ($truthy(self['$respond_to?'](on_handler))) {
            new_node = self.$send(on_handler, node)
          } else {
            new_node = self.$handler_missing(node)
          };
          if ($truthy(new_node)) {
            node = new_node
          };
          return node;
        }, 1);
        
        $def(self, '$process_all', function $$process_all(nodes) {
          var self = this;

          return $send(nodes.$to_a(), 'map', [], function $$1(node){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (node == null) node = nil;;
            return self.$process(node);}, {$$arity: 1, $$s: self})
        }, 1);
        return $def(self, '$handler_missing', $return_val(nil), 0);
      })($nesting[0])
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ast/processor"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs('require,include');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'AST');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Processor');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$require("ast/processor/mixin");
      return self.$include($$('Mixin'));
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ast/sexp"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $def = Opal.def;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'AST');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Sexp');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return $def(self, '$s', function $$s(type, $a) {
        var $post_args, children;

        
        
        $post_args = Opal.slice.call(arguments, 1);
        
        children = $post_args;;
        return $$('Node').$new(type, children);
      }, -2)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ast"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module;

  Opal.add_stubs('require');
  return (function($base) {
    var self = $module($base, 'AST');

    
    
    self.$require("ast/node");
    self.$require("ast/processor");
    return self.$require("ast/sexp");
  })($nesting[0])
};

Opal.modules["parser/ast/node"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $alias = Opal.alias, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('attr_reader,location,[],frozen?,dup,node=');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Node');

        
        
        self.$attr_reader("location");
        $alias(self, "loc", "location");
        return $def(self, '$assign_properties', function $$assign_properties(properties) {
          var self = this, location = nil;

          if ($truthy((location = properties['$[]']("location")))) {
            
            if ($truthy(location['$frozen?']())) {
              location = location.$dup()
            };
            location['$node='](self);
            return (self.location = location);
          } else {
            return nil
          }
        }, 1);
      })($nesting[0], $$$($$$('AST'), 'Node'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/ast/node"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('require,attr_reader,[],frozen?,dup,merge!,loc,line,column');
  
  self.$require("ast");
  self.$require("parser/ast/node");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Node');

        var $proto = self.$$prototype;

        $proto.meta = nil;
        
        self.$attr_reader("meta");
        
        $def(self, '$assign_properties', function $$assign_properties(properties) {
          var $yield = $$assign_properties.$$p || nil, self = this, meta = nil, $ret_or_1 = nil;

          delete $$assign_properties.$$p;
          
          if ($truthy((meta = properties['$[]']("meta")))) {
            
            if ($truthy(meta['$frozen?']())) {
              meta = meta.$dup()
            };
            self.meta['$merge!'](meta);
          } else {
            self.meta = ($truthy(($ret_or_1 = self.meta)) ? ($ret_or_1) : ($hash2([], {})))
          };
          return $send2(self, $find_super(self, 'assign_properties', $$assign_properties, false, true), 'assign_properties', [properties], $yield);
        }, 1);
        
        $def(self, '$line', function $$line() {
          var self = this;

          if ($truthy(self.$loc())) {
            return self.$loc().$line()
          } else {
            return nil
          }
        }, 0);
        return $def(self, '$column', function $$column() {
          var self = this;

          if ($truthy(self.$loc())) {
            return self.$loc().$column()
          } else {
            return nil
          }
        }, 0);
      })($nesting[0], $$$($$$($$$('Parser'), 'AST'), 'Node'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["racc/parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $const_set = Opal.const_set, $defs = Opal.defs, $gvars = Opal.gvars, $rb_lt = Opal.rb_lt, $def = Opal.def, $to_ary = Opal.to_ary, $send = Opal.send, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $rb_le = Opal.rb_le, $rb_times = Opal.rb_times, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('[],class,<,size,[]=,__send__,_racc_setup,raise,_racc_init_sysvars,catch,!=,next_token,racc_read_token,+,==,>=,_racc_evalact,!,>,-,push,racc_shift,-@,_racc_do_reduce,racc_accept,throw,on_error,<=,pop,racc_e_pop,inspect,racc_next_state,*,racc_reduce,sprintf,token_to_str,print,racc_token2str,puts,racc_print_stacks,empty?,each,racc_print_states,each_index');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Racc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return ($klass($nesting[0], $$('StandardError'), 'ParseError'), nil)
  })($nesting[0], $nesting);
  if (!$truthy((($a = $$$('::', 'ParseError', 'skip_raise')) ? 'constant' : nil))) {
    $const_set($nesting[0], 'ParseError', $$$($$('Racc'), 'ParseError'))
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Racc');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    if (!$truthy((($a = $$('Racc_No_Extensions', 'skip_raise')) ? 'constant' : nil))) {
      $const_set($nesting[0], 'Racc_No_Extensions', false)
    };
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.yydebug = $proto.racc_debug_out = $proto.racc_error_status = $proto.racc_t = $proto.racc_vstack = $proto.racc_val = $proto.racc_state = $proto.racc_tstack = nil;
      
      $const_set($nesting[0], 'Racc_Runtime_Version', "1.4.6");
      $const_set($nesting[0], 'Racc_Runtime_Revision', ["originalRevision:", "1.8"]['$[]'](1));
      $const_set($nesting[0], 'Racc_Runtime_Core_Version_R', "1.4.6");
      $const_set($nesting[0], 'Racc_Runtime_Core_Revision_R', ["originalRevision:", "1.8"]['$[]'](1));
      $const_set($nesting[0], 'Racc_Main_Parsing_Routine', "_racc_do_parse_rb");
      $const_set($nesting[0], 'Racc_YY_Parse_Method', "_racc_yyparse_rb");
      $const_set($nesting[0], 'Racc_Runtime_Core_Version', $$('Racc_Runtime_Core_Version_R'));
      $const_set($nesting[0], 'Racc_Runtime_Core_Revision', $$('Racc_Runtime_Core_Revision_R'));
      $const_set($nesting[0], 'Racc_Runtime_Type', "ruby");
      $defs($$('Parser'), '$racc_runtime_type', function $$racc_runtime_type() {
        
        return $$('Racc_Runtime_Type')
      }, 0);
      
      $def(self, '$_racc_setup', function $$_racc_setup() {
        var $a, $b, self = this, $ret_or_1 = nil, arg = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;

        
        if (!$truthy($$$(self.$class(), 'Racc_debug_parser'))) {
          self.yydebug = false
        };
        if (!$truthy((($a = self['yydebug'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          self.yydebug = false
        };
        if ($truthy(self.yydebug)) {
          
          if (!$truthy((($b = self['racc_debug_out'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            self.racc_debug_out = $gvars.stderr
          };
          self.racc_debug_out = ($truthy(($ret_or_1 = self.racc_debug_out)) ? ($ret_or_1) : ($gvars.stderr));
        };
        arg = $$$(self.$class(), 'Racc_arg');
        if ($truthy($rb_lt(arg.$size(), 14))) {
          arg['$[]='](13, true)
        };
        return arg;
      }, 0);
      
      $def(self, '$_racc_init_sysvars', function $$_racc_init_sysvars() {
        var self = this;

        
        self.racc_state = [0];
        self.racc_tstack = [];
        self.racc_vstack = [];
        self.racc_t = nil;
        self.racc_val = nil;
        self.racc_read_next = true;
        self.racc_user_yyerror = false;
        return (self.racc_error_status = 0);
      }, 0);
      
      $def(self, '$do_parse', function $$do_parse() {
        var self = this;

        return self.$__send__($$('Racc_Main_Parsing_Routine'), self.$_racc_setup(), false)
      }, 0);
      
      $def(self, '$next_token', function $$next_token() {
        var self = this;

        return self.$raise($$('NotImplementedError'), "" + (self.$class()) + "#next_token is not defined")
      }, 0);
      
      $def(self, '$_racc_do_parse_rb', function $$_racc_do_parse_rb(arg, in_debug) {
        var $a, $b, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, tok = nil, act = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;
        self.$_racc_init_sysvars();
        tok = (act = (i = nil));
        return $send(self, 'catch', ["racc_end_parse"], function $$1(){var $c, $d, $e, self = $$1.$$s == null ? this : $$1.$$s, $ret_or_1 = nil;
          if (self.racc_state == null) self.racc_state = nil;
          if (self.racc_read_next == null) self.racc_read_next = nil;
          if (self.racc_t == null) self.racc_t = nil;
          if (self.yydebug == null) self.yydebug = nil;
          if (self.racc_val == null) self.racc_val = nil;

          while ($truthy(true)) {
            
            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {
              
              if ($truthy(self.racc_read_next)) {
                if ($neqeq(self.racc_t, 0)) {
                  
                  $e = self.$next_token(), $d = $to_ary($e), (tok = ($d[0] == null ? nil : $d[0])), (self.racc_val = ($d[1] == null ? nil : $d[1])), $e;
                  if ($truthy(tok)) {
                    self.racc_t = ($truthy(($ret_or_1 = token_table['$[]'](tok))) ? ($ret_or_1) : (1))
                  } else {
                    self.racc_t = 0
                  };
                  if ($truthy(self.yydebug)) {
                    self.$racc_read_token(self.racc_t, tok, self.racc_val)
                  };
                  self.racc_read_next = false;
                }
              };
              i = $rb_plus(i, self.racc_t);
              if (!(($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                act = action_default['$[]'](self.racc_state['$[]'](-1))
              };
            } else {
              act = action_default['$[]'](self.racc_state['$[]'](-1))
            };
            while ($truthy((act = self.$_racc_evalact(act, arg)))) {
              
            };
          }}, {$$arity: 0, $$s: self});
      }, 2);
      
      $def(self, '$yyparse', function $$yyparse(recv, mid) {
        var self = this;

        return self.$__send__($$('Racc_YY_Parse_Method'), recv, mid, self.$_racc_setup(), true)
      }, 2);
      
      $def(self, '$_racc_yyparse_rb', function $$_racc_yyparse_rb(recv, mid, arg, c_debug) {
        var $a, $b, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, act = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;
        self.$_racc_init_sysvars();
        act = nil;
        i = nil;
        return $send(self, 'catch', ["racc_end_parse"], function $$2(){var $c, $d, self = $$2.$$s == null ? this : $$2.$$s;
          if (self.racc_state == null) self.racc_state = nil;

          
          while (!($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1)))))) {
            while ($truthy((act = self.$_racc_evalact(action_default['$[]'](self.racc_state['$[]'](-1)), arg)))) {
              
            }
          };
          return $send(recv, '__send__', [mid], function $$3(tok, val){var $e, $f, self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil, $ret_or_2 = nil;
            if (self.racc_t == null) self.racc_t = nil;
            if (self.racc_state == null) self.racc_state = nil;
            if (self.racc_read_next == null) self.racc_read_next = nil;

            
            
            if (tok == null) tok = nil;;
            
            if (val == null) val = nil;;
            if ($truthy(tok)) {
              self.racc_t = ($truthy(($ret_or_1 = token_table['$[]'](tok))) ? ($ret_or_1) : (1))
            } else {
              self.racc_t = 0
            };
            self.racc_val = val;
            self.racc_read_next = false;
            i = $rb_plus(i, self.racc_t);
            if (!(($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
              act = action_default['$[]'](self.racc_state['$[]'](-1))
            };
            while ($truthy((act = self.$_racc_evalact(act, arg)))) {
              
            };
            while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = (i = action_pointer['$[]'](self.racc_state['$[]'](-1)))['$!']())) ? ($ret_or_2) : (self.racc_read_next['$!']())))) ? ($ret_or_1) : (self.racc_t['$=='](0))))) {
              
              if (!(((($truthy(i) && ($truthy((i = $rb_plus(i, self.racc_t))))) && ($truthy($rb_ge(i, 0)))) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                act = action_default['$[]'](self.racc_state['$[]'](-1))
              };
              while ($truthy((act = self.$_racc_evalact(act, arg)))) {
                
              };
            };}, {$$arity: 2, $$s: self});}, {$$arity: 0, $$s: self});
      }, 4);
      
      $def(self, '$_racc_evalact', function $$_racc_evalact(act, arg) {
        var $a, $b, self = this, action_table = nil, action_check = nil, _ = nil, action_pointer = nil, shift_n = nil, reduce_n = nil, code = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (shift_n = ($a[11] == null ? nil : $a[11])), (reduce_n = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), (_ = ($a[14] == null ? nil : $a[14])), $b;
        if (($truthy($rb_gt(act, 0)) && ($truthy($rb_lt(act, shift_n))))) {
          
          if ($truthy($rb_gt(self.racc_error_status, 0))) {
            if (!$eqeq(self.racc_t, 1)) {
              self.racc_error_status = $rb_minus(self.racc_error_status, 1)
            }
          };
          self.racc_vstack.$push(self.racc_val);
          self.racc_state.$push(act);
          self.racc_read_next = true;
          if ($truthy(self.yydebug)) {
            
            self.racc_tstack.$push(self.racc_t);
            self.$racc_shift(self.racc_t, self.racc_tstack, self.racc_vstack);
          };
        } else if (($truthy($rb_lt(act, 0)) && ($truthy($rb_gt(act, reduce_n['$-@']()))))) {
          
          code = $send(self, 'catch', ["racc_jump"], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.racc_state == null) self.racc_state = nil;

            
            self.racc_state.$push(self.$_racc_do_reduce(arg, act));
            return false;}, {$$arity: 0, $$s: self});
          if ($truthy(code)) {
            
            switch (code) {
              case 1:
                
                self.racc_user_yyerror = true;
                return reduce_n['$-@']();
              case 2:
                return shift_n
              default:
                self.$raise("[Racc Bug] unknown jump code")
            }
          };
        } else if ($eqeq(act, shift_n)) {
          
          if ($truthy(self.yydebug)) {
            self.$racc_accept()
          };
          self.$throw("racc_end_parse", self.racc_vstack['$[]'](0));
        } else if ($eqeq(act, reduce_n['$-@']())) {
          
          
          switch (self.racc_error_status) {
            case 0:
              if (!$truthy(arg['$[]'](21))) {
                self.$on_error(self.racc_t, self.racc_val, self.racc_vstack)
              }
              break;
            case 3:
              
              if ($eqeq(self.racc_t, 0)) {
                self.$throw("racc_end_parse", nil)
              };
              self.racc_read_next = true;
              break;
            default:
              nil
          };
          self.racc_user_yyerror = false;
          self.racc_error_status = 3;
          while ($truthy(true)) {
            
            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {
              
              i = $rb_plus(i, 1);
              if ((($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                break;
              };
            };
            if ($truthy($rb_le(self.racc_state.$size(), 1))) {
              self.$throw("racc_end_parse", nil)
            };
            self.racc_state.$pop();
            self.racc_vstack.$pop();
            if ($truthy(self.yydebug)) {
              
              self.racc_tstack.$pop();
              self.$racc_e_pop(self.racc_state, self.racc_tstack, self.racc_vstack);
            };
          };
          return act;
        } else {
          self.$raise("[Racc Bug] unknown action " + (act.$inspect()))
        };
        if ($truthy(self.yydebug)) {
          self.$racc_next_state(self.racc_state['$[]'](-1), self.racc_state)
        };
        return nil;
      }, 2);
      
      $def(self, '$_racc_do_reduce', function $$_racc_do_reduce(arg, act) {
        var $a, $b, self = this, _ = nil, goto_table = nil, goto_check = nil, goto_default = nil, goto_pointer = nil, nt_base = nil, reduce_table = nil, use_result = nil, state = nil, vstack = nil, tstack = nil, i = nil, len = nil, reduce_to = nil, method_id = nil, void_array = nil, tmp_t = nil, tmp_v = nil, k1 = nil, curstate = nil;

        
        $b = arg, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), (goto_table = ($a[4] == null ? nil : $a[4])), (goto_check = ($a[5] == null ? nil : $a[5])), (goto_default = ($a[6] == null ? nil : $a[6])), (goto_pointer = ($a[7] == null ? nil : $a[7])), (nt_base = ($a[8] == null ? nil : $a[8])), (reduce_table = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (use_result = ($a[13] == null ? nil : $a[13])), $b;
        state = self.racc_state;
        vstack = self.racc_vstack;
        tstack = self.racc_tstack;
        i = $rb_times(act, -3);
        len = reduce_table['$[]'](i);
        reduce_to = reduce_table['$[]']($rb_plus(i, 1));
        method_id = reduce_table['$[]']($rb_plus(i, 2));
        void_array = [];
        if ($truthy(self.yydebug)) {
          tmp_t = tstack['$[]'](len['$-@'](), len)
        };
        tmp_v = vstack['$[]'](len['$-@'](), len);
        if ($truthy(self.yydebug)) {
          tstack['$[]='](len['$-@'](), len, void_array)
        };
        vstack['$[]='](len['$-@'](), len, void_array);
        state['$[]='](len['$-@'](), len, void_array);
        if ($truthy(use_result)) {
          vstack.$push(self.$__send__(method_id, tmp_v, vstack, tmp_v['$[]'](0)))
        } else {
          vstack.$push(self.$__send__(method_id, tmp_v, vstack))
        };
        tstack.$push(reduce_to);
        if ($truthy(self.yydebug)) {
          self.$racc_reduce(tmp_t, reduce_to, tstack, vstack)
        };
        k1 = $rb_minus(reduce_to, nt_base);
        if ($truthy((i = goto_pointer['$[]'](k1)))) {
          
          i = $rb_plus(i, state['$[]'](-1));
          if ((($truthy($rb_ge(i, 0)) && ($truthy((curstate = goto_table['$[]'](i))))) && ($eqeq(goto_check['$[]'](i), k1)))) {
            return curstate
          };
        };
        return goto_default['$[]'](k1);
      }, 2);
      
      $def(self, '$on_error', function $$on_error(t, val, vstack) {
        var self = this, $ret_or_1 = nil;

        return self.$raise($$('ParseError'), self.$sprintf("\nparse error on value %s (%s)", val.$inspect(), ($truthy(($ret_or_1 = self.$token_to_str(t))) ? ($ret_or_1) : ("?"))))
      }, 3);
      
      $def(self, '$yyerror', function $$yyerror() {
        var self = this;

        return self.$throw("racc_jump", 1)
      }, 0);
      
      $def(self, '$yyaccept', function $$yyaccept() {
        var self = this;

        return self.$throw("racc_jump", 2)
      }, 0);
      
      $def(self, '$yyerrok', $assign_ivar_val("racc_error_status", 0), 0);
      
      $def(self, '$racc_read_token', function $$racc_read_token(t, tok, val) {
        var self = this;

        
        self.racc_debug_out.$print("read    ");
        self.racc_debug_out.$print(tok.$inspect(), "(", self.$racc_token2str(t), ") ");
        self.racc_debug_out.$puts(val.$inspect());
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_shift', function $$racc_shift(tok, tstack, vstack) {
        var self = this;

        
        self.racc_debug_out.$puts("shift   " + (self.$racc_token2str(tok)));
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_reduce', function $$racc_reduce(toks, sim, tstack, vstack) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("reduce ");
        if ($truthy(toks['$empty?']())) {
          out.$print(" <none>")
        } else {
          $send(toks, 'each', [], function $$5(t){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (t == null) t = nil;;
            return out.$print(" ", self.$racc_token2str(t));}, {$$arity: 1, $$s: self})
        };
        out.$puts(" --> " + (self.$racc_token2str(sim)));
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 4);
      
      $def(self, '$racc_accept', function $$racc_accept() {
        var self = this;

        
        self.racc_debug_out.$puts("accept");
        return self.racc_debug_out.$puts();
      }, 0);
      
      $def(self, '$racc_e_pop', function $$racc_e_pop(state, tstack, vstack) {
        var self = this;

        
        self.racc_debug_out.$puts("error recovering mode: pop token");
        self.$racc_print_states(state);
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_next_state', function $$racc_next_state(curstate, state) {
        var self = this;

        
        self.racc_debug_out.$puts("goto    " + (curstate));
        self.$racc_print_states(state);
        return self.racc_debug_out.$puts();
      }, 2);
      
      $def(self, '$racc_print_stacks', function $$racc_print_stacks(t, v) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("        [");
        $send(t, 'each_index', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s;

          
          
          if (i == null) i = nil;;
          return out.$print(" (", self.$racc_token2str(t['$[]'](i)), " ", v['$[]'](i).$inspect(), ")");}, {$$arity: 1, $$s: self});
        return out.$puts(" ]");
      }, 2);
      
      $def(self, '$racc_print_states', function $$racc_print_states(s) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("        [");
        $send(s, 'each', [], function $$7(st){
          
          
          if (st == null) st = nil;;
          return out.$print(" ", st);}, 1);
        return out.$puts(" ]");
      }, 1);
      
      $def(self, '$racc_token2str', function $$racc_token2str(tok) {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$(self.$class(), 'Racc_token_to_s_table')['$[]'](tok)))) {
          return $ret_or_1
        } else {
          return self.$raise("[Racc Bug] can't convert token " + (tok) + " to string")
        }
      }, 1);
      return $def(self, '$token_to_str', function $$token_to_str(t) {
        var self = this;

        return $$$(self.$class(), 'Racc_token_to_s_table')['$[]'](t)
      }, 1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["parser/version"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "3.1.2.1")
  })($nesting[0], $nesting)
};

Opal.modules["racc/parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $const_set = Opal.const_set, $defs = Opal.defs, $gvars = Opal.gvars, $rb_lt = Opal.rb_lt, $def = Opal.def, $to_ary = Opal.to_ary, $send = Opal.send, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $rb_le = Opal.rb_le, $rb_times = Opal.rb_times, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('[],class,<,size,[]=,__send__,_racc_setup,raise,_racc_init_sysvars,catch,!=,next_token,racc_read_token,+,==,>=,_racc_evalact,!,>,-,push,racc_shift,-@,_racc_do_reduce,racc_accept,throw,on_error,<=,pop,racc_e_pop,inspect,racc_next_state,*,racc_reduce,sprintf,token_to_str,print,racc_token2str,puts,racc_print_stacks,empty?,each,racc_print_states,each_index');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Racc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return ($klass($nesting[0], $$('StandardError'), 'ParseError'), nil)
  })($nesting[0], $nesting);
  if (!$truthy((($a = $$$('::', 'ParseError', 'skip_raise')) ? 'constant' : nil))) {
    $const_set($nesting[0], 'ParseError', $$$($$('Racc'), 'ParseError'))
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Racc');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    if (!$truthy((($a = $$('Racc_No_Extensions', 'skip_raise')) ? 'constant' : nil))) {
      $const_set($nesting[0], 'Racc_No_Extensions', false)
    };
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.yydebug = $proto.racc_debug_out = $proto.racc_error_status = $proto.racc_t = $proto.racc_vstack = $proto.racc_val = $proto.racc_state = $proto.racc_tstack = nil;
      
      $const_set($nesting[0], 'Racc_Runtime_Version', "1.4.6");
      $const_set($nesting[0], 'Racc_Runtime_Revision', ["originalRevision:", "1.8"]['$[]'](1));
      $const_set($nesting[0], 'Racc_Runtime_Core_Version_R', "1.4.6");
      $const_set($nesting[0], 'Racc_Runtime_Core_Revision_R', ["originalRevision:", "1.8"]['$[]'](1));
      $const_set($nesting[0], 'Racc_Main_Parsing_Routine', "_racc_do_parse_rb");
      $const_set($nesting[0], 'Racc_YY_Parse_Method', "_racc_yyparse_rb");
      $const_set($nesting[0], 'Racc_Runtime_Core_Version', $$('Racc_Runtime_Core_Version_R'));
      $const_set($nesting[0], 'Racc_Runtime_Core_Revision', $$('Racc_Runtime_Core_Revision_R'));
      $const_set($nesting[0], 'Racc_Runtime_Type', "ruby");
      $defs($$('Parser'), '$racc_runtime_type', function $$racc_runtime_type() {
        
        return $$('Racc_Runtime_Type')
      }, 0);
      
      $def(self, '$_racc_setup', function $$_racc_setup() {
        var $a, $b, self = this, $ret_or_1 = nil, arg = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;

        
        if (!$truthy($$$(self.$class(), 'Racc_debug_parser'))) {
          self.yydebug = false
        };
        if (!$truthy((($a = self['yydebug'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          self.yydebug = false
        };
        if ($truthy(self.yydebug)) {
          
          if (!$truthy((($b = self['racc_debug_out'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            self.racc_debug_out = $gvars.stderr
          };
          self.racc_debug_out = ($truthy(($ret_or_1 = self.racc_debug_out)) ? ($ret_or_1) : ($gvars.stderr));
        };
        arg = $$$(self.$class(), 'Racc_arg');
        if ($truthy($rb_lt(arg.$size(), 14))) {
          arg['$[]='](13, true)
        };
        return arg;
      }, 0);
      
      $def(self, '$_racc_init_sysvars', function $$_racc_init_sysvars() {
        var self = this;

        
        self.racc_state = [0];
        self.racc_tstack = [];
        self.racc_vstack = [];
        self.racc_t = nil;
        self.racc_val = nil;
        self.racc_read_next = true;
        self.racc_user_yyerror = false;
        return (self.racc_error_status = 0);
      }, 0);
      
      $def(self, '$do_parse', function $$do_parse() {
        var self = this;

        return self.$__send__($$('Racc_Main_Parsing_Routine'), self.$_racc_setup(), false)
      }, 0);
      
      $def(self, '$next_token', function $$next_token() {
        var self = this;

        return self.$raise($$('NotImplementedError'), "" + (self.$class()) + "#next_token is not defined")
      }, 0);
      
      $def(self, '$_racc_do_parse_rb', function $$_racc_do_parse_rb(arg, in_debug) {
        var $a, $b, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, tok = nil, act = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;
        self.$_racc_init_sysvars();
        tok = (act = (i = nil));
        return $send(self, 'catch', ["racc_end_parse"], function $$1(){var $c, $d, $e, self = $$1.$$s == null ? this : $$1.$$s, $ret_or_1 = nil;
          if (self.racc_state == null) self.racc_state = nil;
          if (self.racc_read_next == null) self.racc_read_next = nil;
          if (self.racc_t == null) self.racc_t = nil;
          if (self.yydebug == null) self.yydebug = nil;
          if (self.racc_val == null) self.racc_val = nil;

          while ($truthy(true)) {
            
            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {
              
              if ($truthy(self.racc_read_next)) {
                if ($neqeq(self.racc_t, 0)) {
                  
                  $e = self.$next_token(), $d = $to_ary($e), (tok = ($d[0] == null ? nil : $d[0])), (self.racc_val = ($d[1] == null ? nil : $d[1])), $e;
                  if ($truthy(tok)) {
                    self.racc_t = ($truthy(($ret_or_1 = token_table['$[]'](tok))) ? ($ret_or_1) : (1))
                  } else {
                    self.racc_t = 0
                  };
                  if ($truthy(self.yydebug)) {
                    self.$racc_read_token(self.racc_t, tok, self.racc_val)
                  };
                  self.racc_read_next = false;
                }
              };
              i = $rb_plus(i, self.racc_t);
              if (!(($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                act = action_default['$[]'](self.racc_state['$[]'](-1))
              };
            } else {
              act = action_default['$[]'](self.racc_state['$[]'](-1))
            };
            while ($truthy((act = self.$_racc_evalact(act, arg)))) {
              
            };
          }}, {$$arity: 0, $$s: self});
      }, 2);
      
      $def(self, '$yyparse', function $$yyparse(recv, mid) {
        var self = this;

        return self.$__send__($$('Racc_YY_Parse_Method'), recv, mid, self.$_racc_setup(), true)
      }, 2);
      
      $def(self, '$_racc_yyparse_rb', function $$_racc_yyparse_rb(recv, mid, arg, c_debug) {
        var $a, $b, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, act = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;
        self.$_racc_init_sysvars();
        act = nil;
        i = nil;
        return $send(self, 'catch', ["racc_end_parse"], function $$2(){var $c, $d, self = $$2.$$s == null ? this : $$2.$$s;
          if (self.racc_state == null) self.racc_state = nil;

          
          while (!($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1)))))) {
            while ($truthy((act = self.$_racc_evalact(action_default['$[]'](self.racc_state['$[]'](-1)), arg)))) {
              
            }
          };
          return $send(recv, '__send__', [mid], function $$3(tok, val){var $e, $f, self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil, $ret_or_2 = nil;
            if (self.racc_t == null) self.racc_t = nil;
            if (self.racc_state == null) self.racc_state = nil;
            if (self.racc_read_next == null) self.racc_read_next = nil;

            
            
            if (tok == null) tok = nil;;
            
            if (val == null) val = nil;;
            if ($truthy(tok)) {
              self.racc_t = ($truthy(($ret_or_1 = token_table['$[]'](tok))) ? ($ret_or_1) : (1))
            } else {
              self.racc_t = 0
            };
            self.racc_val = val;
            self.racc_read_next = false;
            i = $rb_plus(i, self.racc_t);
            if (!(($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
              act = action_default['$[]'](self.racc_state['$[]'](-1))
            };
            while ($truthy((act = self.$_racc_evalact(act, arg)))) {
              
            };
            while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = (i = action_pointer['$[]'](self.racc_state['$[]'](-1)))['$!']())) ? ($ret_or_2) : (self.racc_read_next['$!']())))) ? ($ret_or_1) : (self.racc_t['$=='](0))))) {
              
              if (!(((($truthy(i) && ($truthy((i = $rb_plus(i, self.racc_t))))) && ($truthy($rb_ge(i, 0)))) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                act = action_default['$[]'](self.racc_state['$[]'](-1))
              };
              while ($truthy((act = self.$_racc_evalact(act, arg)))) {
                
              };
            };}, {$$arity: 2, $$s: self});}, {$$arity: 0, $$s: self});
      }, 4);
      
      $def(self, '$_racc_evalact', function $$_racc_evalact(act, arg) {
        var $a, $b, self = this, action_table = nil, action_check = nil, _ = nil, action_pointer = nil, shift_n = nil, reduce_n = nil, code = nil, i = nil;

        
        $b = arg, $a = $to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (shift_n = ($a[11] == null ? nil : $a[11])), (reduce_n = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), (_ = ($a[14] == null ? nil : $a[14])), $b;
        if (($truthy($rb_gt(act, 0)) && ($truthy($rb_lt(act, shift_n))))) {
          
          if ($truthy($rb_gt(self.racc_error_status, 0))) {
            if (!$eqeq(self.racc_t, 1)) {
              self.racc_error_status = $rb_minus(self.racc_error_status, 1)
            }
          };
          self.racc_vstack.$push(self.racc_val);
          self.racc_state.$push(act);
          self.racc_read_next = true;
          if ($truthy(self.yydebug)) {
            
            self.racc_tstack.$push(self.racc_t);
            self.$racc_shift(self.racc_t, self.racc_tstack, self.racc_vstack);
          };
        } else if (($truthy($rb_lt(act, 0)) && ($truthy($rb_gt(act, reduce_n['$-@']()))))) {
          
          code = $send(self, 'catch', ["racc_jump"], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.racc_state == null) self.racc_state = nil;

            
            self.racc_state.$push(self.$_racc_do_reduce(arg, act));
            return false;}, {$$arity: 0, $$s: self});
          if ($truthy(code)) {
            
            switch (code) {
              case 1:
                
                self.racc_user_yyerror = true;
                return reduce_n['$-@']();
              case 2:
                return shift_n
              default:
                self.$raise("[Racc Bug] unknown jump code")
            }
          };
        } else if ($eqeq(act, shift_n)) {
          
          if ($truthy(self.yydebug)) {
            self.$racc_accept()
          };
          self.$throw("racc_end_parse", self.racc_vstack['$[]'](0));
        } else if ($eqeq(act, reduce_n['$-@']())) {
          
          
          switch (self.racc_error_status) {
            case 0:
              if (!$truthy(arg['$[]'](21))) {
                self.$on_error(self.racc_t, self.racc_val, self.racc_vstack)
              }
              break;
            case 3:
              
              if ($eqeq(self.racc_t, 0)) {
                self.$throw("racc_end_parse", nil)
              };
              self.racc_read_next = true;
              break;
            default:
              nil
          };
          self.racc_user_yyerror = false;
          self.racc_error_status = 3;
          while ($truthy(true)) {
            
            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {
              
              i = $rb_plus(i, 1);
              if ((($truthy($rb_ge(i, 0)) && ($truthy((act = action_table['$[]'](i))))) && ($eqeq(action_check['$[]'](i), self.racc_state['$[]'](-1))))) {
                break;
              };
            };
            if ($truthy($rb_le(self.racc_state.$size(), 1))) {
              self.$throw("racc_end_parse", nil)
            };
            self.racc_state.$pop();
            self.racc_vstack.$pop();
            if ($truthy(self.yydebug)) {
              
              self.racc_tstack.$pop();
              self.$racc_e_pop(self.racc_state, self.racc_tstack, self.racc_vstack);
            };
          };
          return act;
        } else {
          self.$raise("[Racc Bug] unknown action " + (act.$inspect()))
        };
        if ($truthy(self.yydebug)) {
          self.$racc_next_state(self.racc_state['$[]'](-1), self.racc_state)
        };
        return nil;
      }, 2);
      
      $def(self, '$_racc_do_reduce', function $$_racc_do_reduce(arg, act) {
        var $a, $b, self = this, _ = nil, goto_table = nil, goto_check = nil, goto_default = nil, goto_pointer = nil, nt_base = nil, reduce_table = nil, use_result = nil, state = nil, vstack = nil, tstack = nil, i = nil, len = nil, reduce_to = nil, method_id = nil, void_array = nil, tmp_t = nil, tmp_v = nil, k1 = nil, curstate = nil;

        
        $b = arg, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), (goto_table = ($a[4] == null ? nil : $a[4])), (goto_check = ($a[5] == null ? nil : $a[5])), (goto_default = ($a[6] == null ? nil : $a[6])), (goto_pointer = ($a[7] == null ? nil : $a[7])), (nt_base = ($a[8] == null ? nil : $a[8])), (reduce_table = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (use_result = ($a[13] == null ? nil : $a[13])), $b;
        state = self.racc_state;
        vstack = self.racc_vstack;
        tstack = self.racc_tstack;
        i = $rb_times(act, -3);
        len = reduce_table['$[]'](i);
        reduce_to = reduce_table['$[]']($rb_plus(i, 1));
        method_id = reduce_table['$[]']($rb_plus(i, 2));
        void_array = [];
        if ($truthy(self.yydebug)) {
          tmp_t = tstack['$[]'](len['$-@'](), len)
        };
        tmp_v = vstack['$[]'](len['$-@'](), len);
        if ($truthy(self.yydebug)) {
          tstack['$[]='](len['$-@'](), len, void_array)
        };
        vstack['$[]='](len['$-@'](), len, void_array);
        state['$[]='](len['$-@'](), len, void_array);
        if ($truthy(use_result)) {
          vstack.$push(self.$__send__(method_id, tmp_v, vstack, tmp_v['$[]'](0)))
        } else {
          vstack.$push(self.$__send__(method_id, tmp_v, vstack))
        };
        tstack.$push(reduce_to);
        if ($truthy(self.yydebug)) {
          self.$racc_reduce(tmp_t, reduce_to, tstack, vstack)
        };
        k1 = $rb_minus(reduce_to, nt_base);
        if ($truthy((i = goto_pointer['$[]'](k1)))) {
          
          i = $rb_plus(i, state['$[]'](-1));
          if ((($truthy($rb_ge(i, 0)) && ($truthy((curstate = goto_table['$[]'](i))))) && ($eqeq(goto_check['$[]'](i), k1)))) {
            return curstate
          };
        };
        return goto_default['$[]'](k1);
      }, 2);
      
      $def(self, '$on_error', function $$on_error(t, val, vstack) {
        var self = this, $ret_or_1 = nil;

        return self.$raise($$('ParseError'), self.$sprintf("\nparse error on value %s (%s)", val.$inspect(), ($truthy(($ret_or_1 = self.$token_to_str(t))) ? ($ret_or_1) : ("?"))))
      }, 3);
      
      $def(self, '$yyerror', function $$yyerror() {
        var self = this;

        return self.$throw("racc_jump", 1)
      }, 0);
      
      $def(self, '$yyaccept', function $$yyaccept() {
        var self = this;

        return self.$throw("racc_jump", 2)
      }, 0);
      
      $def(self, '$yyerrok', $assign_ivar_val("racc_error_status", 0), 0);
      
      $def(self, '$racc_read_token', function $$racc_read_token(t, tok, val) {
        var self = this;

        
        self.racc_debug_out.$print("read    ");
        self.racc_debug_out.$print(tok.$inspect(), "(", self.$racc_token2str(t), ") ");
        self.racc_debug_out.$puts(val.$inspect());
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_shift', function $$racc_shift(tok, tstack, vstack) {
        var self = this;

        
        self.racc_debug_out.$puts("shift   " + (self.$racc_token2str(tok)));
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_reduce', function $$racc_reduce(toks, sim, tstack, vstack) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("reduce ");
        if ($truthy(toks['$empty?']())) {
          out.$print(" <none>")
        } else {
          $send(toks, 'each', [], function $$5(t){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (t == null) t = nil;;
            return out.$print(" ", self.$racc_token2str(t));}, {$$arity: 1, $$s: self})
        };
        out.$puts(" --> " + (self.$racc_token2str(sim)));
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 4);
      
      $def(self, '$racc_accept', function $$racc_accept() {
        var self = this;

        
        self.racc_debug_out.$puts("accept");
        return self.racc_debug_out.$puts();
      }, 0);
      
      $def(self, '$racc_e_pop', function $$racc_e_pop(state, tstack, vstack) {
        var self = this;

        
        self.racc_debug_out.$puts("error recovering mode: pop token");
        self.$racc_print_states(state);
        self.$racc_print_stacks(tstack, vstack);
        return self.racc_debug_out.$puts();
      }, 3);
      
      $def(self, '$racc_next_state', function $$racc_next_state(curstate, state) {
        var self = this;

        
        self.racc_debug_out.$puts("goto    " + (curstate));
        self.$racc_print_states(state);
        return self.racc_debug_out.$puts();
      }, 2);
      
      $def(self, '$racc_print_stacks', function $$racc_print_stacks(t, v) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("        [");
        $send(t, 'each_index', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s;

          
          
          if (i == null) i = nil;;
          return out.$print(" (", self.$racc_token2str(t['$[]'](i)), " ", v['$[]'](i).$inspect(), ")");}, {$$arity: 1, $$s: self});
        return out.$puts(" ]");
      }, 2);
      
      $def(self, '$racc_print_states', function $$racc_print_states(s) {
        var self = this, out = nil;

        
        out = self.racc_debug_out;
        out.$print("        [");
        $send(s, 'each', [], function $$7(st){
          
          
          if (st == null) st = nil;;
          return out.$print(" ", st);}, 1);
        return out.$puts(" ]");
      }, 1);
      
      $def(self, '$racc_token2str', function $$racc_token2str(tok) {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$(self.$class(), 'Racc_token_to_s_table')['$[]'](tok)))) {
          return $ret_or_1
        } else {
          return self.$raise("[Racc Bug] can't convert token " + (tok) + " to string")
        }
      }, 1);
      return $def(self, '$token_to_str', function $$token_to_str(t) {
        var self = this;

        return $$$(self.$class(), 'Racc_token_to_s_table')['$[]'](t)
      }, 1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["parser/messages"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $hash2 = Opal.hash2, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs;

  Opal.add_stubs('freeze,[],empty?,===,format');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    
    $const_set($nesting[0], 'MESSAGES', $hash2(["unicode_point_too_large", "invalid_escape", "incomplete_escape", "invalid_hex_escape", "invalid_unicode_escape", "unterminated_unicode", "escape_eof", "string_eof", "regexp_options", "cvar_name", "ivar_name", "trailing_in_number", "empty_numeric", "invalid_octal", "no_dot_digit_literal", "bare_backslash", "unexpected", "embedded_document", "heredoc_id_has_newline", "heredoc_id_ends_with_nl", "unterminated_heredoc_id", "invalid_escape_use", "ambiguous_literal", "ambiguous_regexp", "ambiguous_prefix", "triple_dot_at_eol", "nth_ref_alias", "begin_in_method", "backref_assignment", "invalid_assignment", "module_name_const", "unexpected_token", "argument_const", "argument_ivar", "argument_gvar", "argument_cvar", "duplicate_argument", "empty_symbol", "odd_hash", "singleton_literal", "dynamic_const", "const_reassignment", "module_in_def", "class_in_def", "unexpected_percent_str", "block_and_blockarg", "masgn_as_condition", "block_given_to_yield", "invalid_regexp", "invalid_return", "csend_in_lhs_of_masgn", "cant_assign_to_numparam", "reserved_for_numparam", "ordinary_param_defined", "numparam_used_in_outer_scope", "circular_argument_reference", "pm_interp_in_var_name", "lvar_name", "undefined_lvar", "duplicate_variable_name", "duplicate_pattern_key", "endless_setter", "invalid_id_to_get", "forward_arg_after_restarg", "no_anonymous_blockarg", "useless_else", "duplicate_hash_key", "invalid_encoding", "invalid_action", "clobbered", "different_replacements", "swallowed_insertions", "swallowed_insertions_conflict", "crossing_deletions", "crossing_deletions_conflict", "crossing_insertions", "crossing_insertions_conflict"], {"unicode_point_too_large": "invalid Unicode codepoint (too large)", "invalid_escape": "invalid escape character syntax", "incomplete_escape": "incomplete character syntax", "invalid_hex_escape": "invalid hex escape", "invalid_unicode_escape": "invalid Unicode escape", "unterminated_unicode": "unterminated Unicode escape", "escape_eof": "escape sequence meets end of file", "string_eof": "unterminated string meets end of file", "regexp_options": "unknown regexp options: %{options}", "cvar_name": "`%{name}' is not allowed as a class variable name", "ivar_name": "`%{name}' is not allowed as an instance variable name", "trailing_in_number": "trailing `%{character}' in number", "empty_numeric": "numeric literal without digits", "invalid_octal": "invalid octal digit", "no_dot_digit_literal": "no .<digit> floating literal anymore; put 0 before dot", "bare_backslash": "bare backslash only allowed before newline", "unexpected": "unexpected `%{character}'", "embedded_document": "embedded document meets end of file (and they embark on a romantic journey)", "heredoc_id_has_newline": "here document identifier across newlines, never match", "heredoc_id_ends_with_nl": "here document identifier ends with a newline", "unterminated_heredoc_id": "unterminated heredoc id", "invalid_escape_use": "invalid character syntax; use ?%{escape}", "ambiguous_literal": "ambiguous first argument; put parentheses or a space even after the operator", "ambiguous_regexp": "ambiguity between regexp and two divisions: wrap regexp in parentheses or add a space after `/' operator", "ambiguous_prefix": "`%{prefix}' interpreted as argument prefix", "triple_dot_at_eol": "... at EOL, should be parenthesized", "nth_ref_alias": "cannot define an alias for a back-reference variable", "begin_in_method": "BEGIN in method", "backref_assignment": "cannot assign to a back-reference variable", "invalid_assignment": "cannot assign to a keyword", "module_name_const": "class or module name must be a constant literal", "unexpected_token": "unexpected token %{token}", "argument_const": "formal argument cannot be a constant", "argument_ivar": "formal argument cannot be an instance variable", "argument_gvar": "formal argument cannot be a global variable", "argument_cvar": "formal argument cannot be a class variable", "duplicate_argument": "duplicate argument name", "empty_symbol": "empty symbol literal", "odd_hash": "odd number of entries for a hash", "singleton_literal": "cannot define a singleton method for a literal", "dynamic_const": "dynamic constant assignment", "const_reassignment": "constant re-assignment", "module_in_def": "module definition in method body", "class_in_def": "class definition in method body", "unexpected_percent_str": "%{type}: unknown type of percent-literal", "block_and_blockarg": "both block argument and literal block are passed", "masgn_as_condition": "multiple assignment in conditional context", "block_given_to_yield": "block given to yield", "invalid_regexp": "%{message}", "invalid_return": "Invalid return in class/module body", "csend_in_lhs_of_masgn": "&. inside multiple assignment destination", "cant_assign_to_numparam": "cannot assign to numbered parameter %{name}", "reserved_for_numparam": "%{name} is reserved for numbered parameter", "ordinary_param_defined": "ordinary parameter is defined", "numparam_used_in_outer_scope": "numbered parameter is already used in an outer scope", "circular_argument_reference": "circular argument reference %{var_name}", "pm_interp_in_var_name": "symbol literal with interpolation is not allowed", "lvar_name": "`%{name}' is not allowed as a local variable name", "undefined_lvar": "no such local variable: `%{name}'", "duplicate_variable_name": "duplicate variable name %{name}", "duplicate_pattern_key": "duplicate hash pattern key %{name}", "endless_setter": "setter method cannot be defined in an endless method definition", "invalid_id_to_get": "identifier %{identifier} is not valid to get", "forward_arg_after_restarg": "... after rest argument", "no_anonymous_blockarg": "no anonymous block parameter", "useless_else": "else without rescue is useless", "duplicate_hash_key": "key is duplicated and overwritten", "invalid_encoding": "literal contains escape sequences incompatible with UTF-8", "invalid_action": "cannot %{action}", "clobbered": "clobbered by: %{action}", "different_replacements": "different replacements: %{replacement} vs %{other_replacement}", "swallowed_insertions": "this replacement:", "swallowed_insertions_conflict": "swallows some inner rewriting actions:", "crossing_deletions": "the deletion of:", "crossing_deletions_conflict": "is crossing:", "crossing_insertions": "the rewriting action on:", "crossing_insertions_conflict": "is crossing that on:"}).$freeze());
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Messages');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return $defs(self, '$compile', function $$compile(reason, arguments$) {
        var self = this, template = nil;

        
        template = $$('MESSAGES')['$[]'](reason);
        if (($eqeqeq($$('Hash'), arguments$) && ($truthy(arguments$['$empty?']())))) {
          return template
        };
        return self.$format(template, arguments$);
      }, 2)
    })($nesting[0], $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["parser/deprecation"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('attr_writer,warn');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'Deprecation');

      
      
      self.$attr_writer("warned_of_deprecation");
      return $def(self, '$warn_of_deprecation', function $$warn_of_deprecation() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;
        if (self.warned_of_deprecation == null) self.warned_of_deprecation = nil;

        return (self.warned_of_deprecation = ($truthy(($ret_or_1 = self.warned_of_deprecation)) ? ($ret_or_1) : ($truthy(($ret_or_2 = self.$warn($$$(self, 'DEPRECATION_WARNING')))) ? ($ret_or_2) : (true))))
      }, 0);
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["parser/ast/processor"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $alias = Opal.alias, $to_a = Opal.to_a, $not = Opal.not, $truthy = Opal.truthy, $slice = Opal.slice;

  Opal.add_stubs('updated,process_all,process_regular_node,on_var,process_variable_node,!,nil?,process,on_vasgn,process_var_asgn_node,on_argument,process_argument_node,is_a?,[],children,on_send,warn');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Processor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$process_regular_node', function $$process_regular_node(node) {
          var self = this;

          return node.$updated(nil, self.$process_all(node))
        }, 1);
        $alias(self, "on_dstr", "process_regular_node");
        $alias(self, "on_dsym", "process_regular_node");
        $alias(self, "on_regexp", "process_regular_node");
        $alias(self, "on_xstr", "process_regular_node");
        $alias(self, "on_splat", "process_regular_node");
        $alias(self, "on_kwsplat", "process_regular_node");
        $alias(self, "on_array", "process_regular_node");
        $alias(self, "on_pair", "process_regular_node");
        $alias(self, "on_hash", "process_regular_node");
        $alias(self, "on_kwargs", "process_regular_node");
        $alias(self, "on_irange", "process_regular_node");
        $alias(self, "on_erange", "process_regular_node");
        
        $def(self, '$on_var', function $$on_var(node) {
          
          return node
        }, 1);
        
        $def(self, '$process_variable_node', function $$process_variable_node(node) {
          var self = this;

          return self.$on_var(node)
        }, 1);
        $alias(self, "on_lvar", "process_variable_node");
        $alias(self, "on_ivar", "process_variable_node");
        $alias(self, "on_gvar", "process_variable_node");
        $alias(self, "on_cvar", "process_variable_node");
        $alias(self, "on_back_ref", "process_variable_node");
        $alias(self, "on_nth_ref", "process_variable_node");
        
        $def(self, '$on_vasgn', function $$on_vasgn(node) {
          var $a, self = this, name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [name, self.$process(value_node)])
          } else {
            return node
          };
        }, 1);
        
        $def(self, '$process_var_asgn_node', function $$process_var_asgn_node(node) {
          var self = this;

          return self.$on_vasgn(node)
        }, 1);
        $alias(self, "on_lvasgn", "process_var_asgn_node");
        $alias(self, "on_ivasgn", "process_var_asgn_node");
        $alias(self, "on_gvasgn", "process_var_asgn_node");
        $alias(self, "on_cvasgn", "process_var_asgn_node");
        $alias(self, "on_and_asgn", "process_regular_node");
        $alias(self, "on_or_asgn", "process_regular_node");
        
        $def(self, '$on_op_asgn', function $$on_op_asgn(node) {
          var $a, self = this, var_node = nil, method_name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (var_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [self.$process(var_node), method_name, self.$process(value_node)]);
        }, 1);
        $alias(self, "on_mlhs", "process_regular_node");
        $alias(self, "on_masgn", "process_regular_node");
        
        $def(self, '$on_const', function $$on_const(node) {
          var $a, self = this, scope_node = nil, name = nil;

          
          $a = [].concat($to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $a;
          return node.$updated(nil, [self.$process(scope_node), name]);
        }, 1);
        
        $def(self, '$on_casgn', function $$on_casgn(node) {
          var $a, self = this, scope_node = nil, name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [self.$process(scope_node), name, self.$process(value_node)])
          } else {
            return node.$updated(nil, [self.$process(scope_node), name])
          };
        }, 1);
        $alias(self, "on_args", "process_regular_node");
        
        $def(self, '$on_argument', function $$on_argument(node) {
          var $a, self = this, arg_name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (arg_name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [arg_name, self.$process(value_node)])
          } else {
            return node
          };
        }, 1);
        
        $def(self, '$process_argument_node', function $$process_argument_node(node) {
          var self = this;

          return self.$on_argument(node)
        }, 1);
        $alias(self, "on_arg", "process_argument_node");
        $alias(self, "on_optarg", "process_argument_node");
        $alias(self, "on_restarg", "process_argument_node");
        $alias(self, "on_blockarg", "process_argument_node");
        $alias(self, "on_shadowarg", "process_argument_node");
        $alias(self, "on_kwarg", "process_argument_node");
        $alias(self, "on_kwoptarg", "process_argument_node");
        $alias(self, "on_kwrestarg", "process_argument_node");
        $alias(self, "on_forward_arg", "process_argument_node");
        
        $def(self, '$on_procarg0', function $$on_procarg0(node) {
          var self = this;

          if ($truthy(node.$children()['$[]'](0)['$is_a?']($$('Symbol')))) {
            return self.$on_argument(node)
          } else {
            return self.$process_regular_node(node)
          }
        }, 1);
        $alias(self, "on_arg_expr", "process_regular_node");
        $alias(self, "on_restarg_expr", "process_regular_node");
        $alias(self, "on_blockarg_expr", "process_regular_node");
        $alias(self, "on_block_pass", "process_regular_node");
        $alias(self, "on_module", "process_regular_node");
        $alias(self, "on_class", "process_regular_node");
        $alias(self, "on_sclass", "process_regular_node");
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, self = this, name = nil, args_node = nil, body_node = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (args_node = ($a[1] == null ? nil : $a[1])), (body_node = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [name, self.$process(args_node), self.$process(body_node)]);
        }, 1);
        
        $def(self, '$on_defs', function $$on_defs(node) {
          var $a, self = this, definee_node = nil, name = nil, args_node = nil, body_node = nil;

          
          $a = [].concat($to_a(node)), (definee_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (args_node = ($a[2] == null ? nil : $a[2])), (body_node = ($a[3] == null ? nil : $a[3])), $a;
          return node.$updated(nil, [self.$process(definee_node), name, self.$process(args_node), self.$process(body_node)]);
        }, 1);
        $alias(self, "on_undef", "process_regular_node");
        $alias(self, "on_alias", "process_regular_node");
        
        $def(self, '$on_send', function $$on_send(node) {
          var $a, self = this, receiver_node = nil, method_name = nil, arg_nodes = nil;

          
          $a = [].concat($to_a(node)), (receiver_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (arg_nodes = $slice.call($a, 2)), $a;
          if ($truthy(receiver_node)) {
            receiver_node = self.$process(receiver_node)
          };
          return node.$updated(nil, [receiver_node, method_name].concat($to_a(self.$process_all(arg_nodes))));
        }, 1);
        $alias(self, "on_csend", "on_send");
        $alias(self, "on_index", "process_regular_node");
        $alias(self, "on_indexasgn", "process_regular_node");
        $alias(self, "on_block", "process_regular_node");
        $alias(self, "on_lambda", "process_regular_node");
        
        $def(self, '$on_numblock', function $$on_numblock(node) {
          var $a, self = this, method_call = nil, max_numparam = nil, body = nil;

          
          $a = [].concat($to_a(node)), (method_call = ($a[0] == null ? nil : $a[0])), (max_numparam = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [self.$process(method_call), max_numparam, self.$process(body)]);
        }, 1);
        $alias(self, "on_while", "process_regular_node");
        $alias(self, "on_while_post", "process_regular_node");
        $alias(self, "on_until", "process_regular_node");
        $alias(self, "on_until_post", "process_regular_node");
        $alias(self, "on_for", "process_regular_node");
        $alias(self, "on_return", "process_regular_node");
        $alias(self, "on_break", "process_regular_node");
        $alias(self, "on_next", "process_regular_node");
        $alias(self, "on_redo", "process_regular_node");
        $alias(self, "on_retry", "process_regular_node");
        $alias(self, "on_super", "process_regular_node");
        $alias(self, "on_yield", "process_regular_node");
        $alias(self, "on_defined?", "process_regular_node");
        $alias(self, "on_not", "process_regular_node");
        $alias(self, "on_and", "process_regular_node");
        $alias(self, "on_or", "process_regular_node");
        $alias(self, "on_if", "process_regular_node");
        $alias(self, "on_when", "process_regular_node");
        $alias(self, "on_case", "process_regular_node");
        $alias(self, "on_iflipflop", "process_regular_node");
        $alias(self, "on_eflipflop", "process_regular_node");
        $alias(self, "on_match_current_line", "process_regular_node");
        $alias(self, "on_match_with_lvasgn", "process_regular_node");
        $alias(self, "on_resbody", "process_regular_node");
        $alias(self, "on_rescue", "process_regular_node");
        $alias(self, "on_ensure", "process_regular_node");
        $alias(self, "on_begin", "process_regular_node");
        $alias(self, "on_kwbegin", "process_regular_node");
        $alias(self, "on_preexe", "process_regular_node");
        $alias(self, "on_postexe", "process_regular_node");
        $alias(self, "on_case_match", "process_regular_node");
        $alias(self, "on_in_match", "process_regular_node");
        $alias(self, "on_match_pattern", "process_regular_node");
        $alias(self, "on_match_pattern_p", "process_regular_node");
        $alias(self, "on_in_pattern", "process_regular_node");
        $alias(self, "on_if_guard", "process_regular_node");
        $alias(self, "on_unless_guard", "process_regular_node");
        $alias(self, "on_match_var", "process_variable_node");
        $alias(self, "on_match_rest", "process_regular_node");
        $alias(self, "on_pin", "process_regular_node");
        $alias(self, "on_match_alt", "process_regular_node");
        $alias(self, "on_match_as", "process_regular_node");
        $alias(self, "on_array_pattern", "process_regular_node");
        $alias(self, "on_array_pattern_with_tail", "process_regular_node");
        $alias(self, "on_hash_pattern", "process_regular_node");
        $alias(self, "on_const_pattern", "process_regular_node");
        $alias(self, "on_find_pattern", "process_regular_node");
        
        $def(self, '$process_variable_node', function $$process_variable_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_variable_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_var instead.");
          return self.$on_var(node);
        }, 1);
        
        $def(self, '$process_var_asgn_node', function $$process_var_asgn_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_var_asgn_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_vasgn instead.");
          return self.$on_vasgn(node);
        }, 1);
        
        $def(self, '$process_argument_node', function $$process_argument_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_argument_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_argument instead.");
          return self.$on_argument(node);
        }, 1);
        return $def(self, '$on_empty_else', function $$on_empty_else(node) {
          
          return node
        }, 1);
      })($nesting[0], $$$($$$('AST'), 'Processor'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/meta"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set;

  Opal.add_stubs('freeze,to_set');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Meta');

      var $nesting = [self].concat($parent_nesting);

      return $const_set($nesting[0], 'NODE_TYPES', ["true", "false", "nil", "int", "float", "str", "dstr", "sym", "dsym", "xstr", "regopt", "regexp", "array", "splat", "pair", "kwsplat", "hash", "irange", "erange", "self", "lvar", "ivar", "cvar", "gvar", "const", "defined?", "lvasgn", "ivasgn", "cvasgn", "gvasgn", "casgn", "mlhs", "masgn", "op_asgn", "and_asgn", "ensure", "rescue", "arg_expr", "or_asgn", "back_ref", "nth_ref", "match_with_lvasgn", "match_current_line", "module", "class", "sclass", "def", "defs", "undef", "alias", "args", "cbase", "arg", "optarg", "restarg", "blockarg", "block_pass", "kwarg", "kwoptarg", "kwrestarg", "kwnilarg", "send", "csend", "super", "zsuper", "yield", "block", "and", "not", "or", "if", "when", "case", "while", "until", "while_post", "until_post", "for", "break", "next", "redo", "return", "resbody", "kwbegin", "begin", "retry", "preexe", "postexe", "iflipflop", "eflipflop", "shadowarg", "complex", "rational", "__FILE__", "__LINE__", "__ENCODING__", "ident", "lambda", "indexasgn", "index", "procarg0", "restarg_expr", "blockarg_expr", "objc_kwarg", "objc_restarg", "objc_varargs", "numargs", "numblock", "forward_args", "forwarded_args", "forward_arg", "case_match", "in_match", "in_pattern", "match_var", "pin", "match_alt", "match_as", "match_rest", "array_pattern", "match_with_trailing_comma", "array_pattern_with_tail", "hash_pattern", "const_pattern", "if_guard", "unless_guard", "match_nil_pattern", "empty_else", "find_pattern", "kwargs", "match_pattern_p", "match_pattern"].$to_set().$freeze())
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/buffer"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $enc = Opal.enc, $truthy = Opal.truthy, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $neqeq = Opal.neqeq, $defs = Opal.defs, $hash2 = Opal.hash2, $send = Opal.send, $def = Opal.def, $not = Opal.not, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs('attr_reader,empty?,=~,start_with?,freeze,==,[],!=,nil?,match,find,encoding,recognize_encoding,force_encoding,encode,to_s,source=,open,read,raise,frozen?,dup,reencode_string,class,valid_encoding?,name,raw_source=,gsub,!,ascii_only?,line_index_for_position,line_begins,+,-,to_a,lines,end_with?,<<,each,chomp!,fetch,source_lines,>=,size,<,new,source,source_range,private,index,bsearch,[]=,method_defined?,bsearch_index');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Buffer');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.name = $proto.source = $proto.slice_source = $proto.first_line = $proto.lines = $proto.source_range = $proto.line_begins = $proto.line_index_for_position = $proto.line_range = nil;
        
        self.$attr_reader("name", "first_line");
        $const_set($nesting[0], 'ENCODING_RE', $regexp([$enc("[\\s#](en)?coding\\s*[:=]\\s*", "ASCII-8BIT"), $enc("(", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("(utf8-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+?)(-unix|-dos|-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+)", "ASCII-8BIT"), $enc(")", "ASCII-8BIT"), $enc("", "ASCII-8BIT")]));
        $defs(self, '$recognize_encoding', function $$recognize_encoding(string) {
          var $a, $b, first_line = nil, second_line = nil, encoding_line = nil, result = nil, $ret_or_1 = nil, $ret_or_2 = nil;

          
          if ($truthy(string['$empty?']())) {
            return nil
          };
          string['$=~'](/^(.*)\n?(.*\n)?/);
          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (first_line = $a[0]), (second_line = $a[1]), $a;
          if ($truthy(first_line['$start_with?']($enc("\xEF\xBB\xBF", "ASCII-8BIT").$freeze()))) {
            return $$$($$('Encoding'), 'UTF_8')
          } else if ($eqeq(first_line['$[]'](0, 2), $enc("#!", "ASCII-8BIT").$freeze())) {
            encoding_line = second_line
          } else {
            encoding_line = first_line
          };
          if (($truthy(encoding_line['$nil?']()) || ($neqeq(encoding_line['$[]'](0), $enc("#", "ASCII-8BIT"))))) {
            return nil
          };
          if ($truthy((result = $$('ENCODING_RE').$match(encoding_line)))) {
            return $$('Encoding').$find(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = result['$[]'](3))) ? ($ret_or_2) : (result['$[]'](4))))) ? ($ret_or_1) : (result['$[]'](6))))
          } else {
            return nil
          };
        }, 1);
        $defs(self, '$reencode_string', function $$reencode_string(input) {
          var self = this, original_encoding = nil, detected_encoding = nil;

          
          original_encoding = input.$encoding();
          detected_encoding = self.$recognize_encoding(input.$force_encoding($$$($$('Encoding'), 'BINARY')));
          if ($truthy(detected_encoding['$nil?']())) {
            return input.$force_encoding(original_encoding)
          } else if ($eqeq(detected_encoding, $$$($$('Encoding'), 'BINARY'))) {
            return input
          } else {
            return input.$force_encoding(detected_encoding).$encode($$$($$('Encoding'), 'UTF_8'))
          };
        }, 1);
        
        $def(self, '$initialize', function $$initialize(name, $a, $b) {
          var $post_args, $kwargs, first_line, source, $c, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          $kwargs = Opal.extract_kwargs($post_args);
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          if ($post_args.length > 0) first_line = $post_args.shift();
          if (first_line == null) first_line = 1;;
          
          source = $kwargs.$$smap["source"];
          if (source == null) source = nil;
          self.name = name.$to_s();
          self.source = nil;
          self.first_line = first_line;
          self.lines = nil;
          self.line_begins = nil;
          self.slice_source = nil;
          self.line_index_for_position = $hash2([], {});
          if ($truthy(source)) {
            return ($c = [source], $send(self, 'source=', $c), $c[$c.length - 1])
          } else {
            return nil
          };
        }, -2);
        
        $def(self, '$read', function $$read() {
          var self = this;

          
          $send($$('File'), 'open', [self.name, $enc("rb", "ASCII-8BIT")], function $$1(io){var $a, self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (io == null) io = nil;;
            return ($a = [io.$read()], $send(self, 'source=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
          return self;
        }, 0);
        
        $def(self, '$source', function $$source() {
          var self = this;

          
          if ($truthy(self.source['$nil?']())) {
            self.$raise($$('RuntimeError'), $enc("Cannot extract source from uninitialized Source::Buffer", "ASCII-8BIT"))
          };
          return self.source;
        }, 0);
        
        $def(self, '$source=', function $Buffer_source$eq$2(input) {
          var $a, self = this;

          
          if ($truthy(input['$frozen?']())) {
            input = input.$dup()
          };
          input = self.$class().$reencode_string(input);
          if (!$truthy(input['$valid_encoding?']())) {
            self.$raise($$('EncodingError'), $enc("invalid byte sequence in ", "ASCII-8BIT") + (input.$encoding().$name()))
          };
          return ($a = [input], $send(self, 'raw_source=', $a), $a[$a.length - 1]);
        }, 1);
        
        $def(self, '$raw_source=', function $Buffer_raw_source$eq$3(input) {
          var self = this;

          
          if ($truthy(self.source)) {
            self.$raise($$('ArgumentError'), $enc("Source::Buffer is immutable", "ASCII-8BIT"))
          };
          self.source = input.$gsub($enc("\r\n", "ASCII-8BIT").$freeze(), $enc("\n", "ASCII-8BIT").$freeze()).$freeze();
          if ((($not(self.source['$ascii_only?']()) && ($neqeq(self.source.$encoding(), $$$($$('Encoding'), 'UTF_32LE')))) && ($neqeq(self.source.$encoding(), $$$($$('Encoding'), 'BINARY'))))) {
            return (self.slice_source = self.source.$encode($$$($$('Encoding'), 'UTF_32LE')))
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$slice', function $$slice(range) {
          var self = this;

          if ($truthy(self.slice_source['$nil?']())) {
            return self.source['$[]'](range)
          } else {
            return self.slice_source['$[]'](range).$encode(self.source.$encoding())
          }
        }, 1);
        
        $def(self, '$decompose_position', function $$decompose_position(position) {
          var self = this, line_index = nil, line_begin = nil;

          
          line_index = self.$line_index_for_position(position);
          line_begin = self.$line_begins()['$[]'](line_index);
          return [$rb_plus(self.first_line, line_index), $rb_minus(position, line_begin)];
        }, 1);
        
        $def(self, '$line_for_position', function $$line_for_position(position) {
          var self = this;

          return $rb_plus(self.$line_index_for_position(position), self.first_line)
        }, 1);
        
        $def(self, '$column_for_position', function $$column_for_position(position) {
          var self = this, line_index = nil;

          
          line_index = self.$line_index_for_position(position);
          return $rb_minus(position, self.$line_begins()['$[]'](line_index));
        }, 1);
        
        $def(self, '$source_lines', function $$source_lines() {
          var self = this, $ret_or_1 = nil, lines = nil;

          return (self.lines = ($truthy(($ret_or_1 = self.lines)) ? ($ret_or_1) : (((lines = self.source.$lines().$to_a()), ($truthy(self.source['$end_with?']($enc("\n", "ASCII-8BIT").$freeze())) ? (lines['$<<']($enc("", "ASCII-8BIT").$dup())) : nil), $send(lines, 'each', [], function $$4(line){
            
            
            if (line == null) line = nil;;
            line['$chomp!']($enc("\n", "ASCII-8BIT").$freeze());
            return line.$freeze();}, 1), lines.$freeze()))))
        }, 0);
        
        $def(self, '$source_line', function $$source_line(lineno) {
          var self = this;

          return self.$source_lines().$fetch($rb_minus(lineno, self.first_line)).$dup()
        }, 1);
        
        $def(self, '$line_range', function $$line_range(lineno) {
          var self = this, index = nil;

          
          index = $rb_minus(lineno, self.first_line);
          if (($truthy($rb_lt(index, 0)) || ($truthy($rb_ge($rb_plus(index, 1), self.$line_begins().$size()))))) {
            return self.$raise($$('IndexError'), $enc("Parser::Source::Buffer: range for line ", "ASCII-8BIT") + ("" + (lineno) + $enc(" requested, valid line numbers are ", "ASCII-8BIT") + (self.first_line) + $enc("..", "ASCII-8BIT")) + ("" + ($rb_minus($rb_plus(self.first_line, self.$line_begins().$size()), 2))))
          } else {
            return $$('Range').$new(self, self.$line_begins()['$[]'](index), $rb_minus(self.$line_begins()['$[]']($rb_plus(index, 1)), 1))
          };
        }, 1);
        
        $def(self, '$source_range', function $$source_range() {
          var self = this, $ret_or_1 = nil;

          return (self.source_range = ($truthy(($ret_or_1 = self.source_range)) ? ($ret_or_1) : ($$('Range').$new(self, 0, self.$source().$size()))))
        }, 0);
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return $rb_minus($rb_plus(self.$line_begins().$size(), self.first_line), 2)
        }, 0);
        
        $def(self, '$freeze', function $$freeze() {
          var $yield = $$freeze.$$p || nil, self = this;

          delete $$freeze.$$p;
          
          self.$source_lines();
          self.$line_begins();
          self.$source_range();
          return $send2(self, $find_super(self, 'freeze', $$freeze, false, true), 'freeze', [], $yield);
        }, 0);
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return $enc("#<", "ASCII-8BIT") + (self.$class()) + $enc(" ", "ASCII-8BIT") + (self.$name()) + $enc(">", "ASCII-8BIT")
        }, 0);
        self.$private();
        
        $def(self, '$line_begins', function $$line_begins() {
          var $a, self = this, $ret_or_1 = nil, begins = nil, index = nil;

          return (self.line_begins = ($truthy(($ret_or_1 = self.line_begins)) ? ($ret_or_1) : ((function() {
          (begins = [0]);
          (index = 0);
          (function() {while ($truthy((index = self.source.$index($enc("\n", "ASCII-8BIT").$freeze(), index)))) {
            
            index = $rb_plus(index, 1);
            begins['$<<'](index);
          }; return nil; })();
          begins['$<<']($rb_plus(self.source.$size(), 1));
          return begins;})())))
        }, 0);
        
        $def(self, '$line_index_for_position', function $$line_index_for_position(position) {
          var self = this, $ret_or_1 = nil, index = nil;

          if ($truthy(($ret_or_1 = self.line_index_for_position['$[]'](position)))) {
            return $ret_or_1
          } else {
            
            index = $rb_minus(self.$bsearch(self.$line_begins(), position), 1);
            if (!$truthy(self.line_index_for_position['$frozen?']())) {
              self.line_index_for_position['$[]='](position, index)
            };
            return index;
          }
        }, 1);
        if ($truthy($$('Array')['$method_defined?']("bsearch_index"))) {
          return $def(self, '$bsearch', function $$bsearch(line_begins, position) {
            var $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = $send(line_begins, 'bsearch_index', [], function $$5(line_begin){
              
              
              if (line_begin == null) line_begin = nil;;
              return $rb_lt(position, line_begin);}, 1)))) {
              return $ret_or_1
            } else {
              return $rb_minus(line_begins.$size(), 1)
            }
          }, 2)
        } else {
          return $def(self, '$bsearch', function $$bsearch(line_begins, position) {
            var self = this, $ret_or_1 = nil;

            
            self.line_range = ($truthy(($ret_or_1 = self.line_range)) ? ($ret_or_1) : (Opal.Range.$new(0,line_begins.$size(), true)));
            if ($truthy(($ret_or_1 = $send(self.line_range, 'bsearch', [], function $$6(i){
              
              
              if (i == null) i = nil;;
              return $rb_lt(position, line_begins['$[]'](i));}, 1)))) {
              return $ret_or_1
            } else {
              return $rb_minus(line_begins.$size(), 1)
            };
          }, 2)
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/range"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $def = Opal.def, $hash2 = Opal.hash2, $rb_minus = Opal.rb_minus, $alias = Opal.alias, $neqeq = Opal.neqeq, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $rb_ge = Opal.rb_ge, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq;

  Opal.add_stubs('include,attr_reader,<,raise,nil?,freeze,with,-,size,line_for_position,alias_method,column_for_position,!=,line,last_line,inspect,column,last_column,source_line,slice,begin_pos,end_pos,include?,source,to_a,decompose_position,join,name,+,new,min,max,disjoint?,empty?,>=,!,<=>,contains?,overlaps?,==,*,source_buffer,is_a?,nonzero?,hash');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Range');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.begin_pos = $proto.end_pos = $proto.source_buffer = nil;
        
        self.$include($$('Comparable'));
        self.$attr_reader("source_buffer");
        self.$attr_reader("begin_pos", "end_pos");
        
        $def(self, '$initialize', function $$initialize(source_buffer, begin_pos, end_pos) {
          var $a, self = this;

          
          if ($truthy($rb_lt(end_pos, begin_pos))) {
            self.$raise($$('ArgumentError'), "Parser::Source::Range: end_pos must not be less than begin_pos")
          };
          if ($truthy(source_buffer['$nil?']())) {
            self.$raise($$('ArgumentError'), "Parser::Source::Range: source_buffer must not be nil")
          };
          self.source_buffer = source_buffer;
          $a = [begin_pos, end_pos], (self.begin_pos = $a[0]), (self.end_pos = $a[1]), $a;
          return self.$freeze();
        }, 3);
        
        $def(self, '$begin', function $$begin() {
          var self = this;

          return self.$with($hash2(["end_pos"], {"end_pos": self.begin_pos}))
        }, 0);
        
        $def(self, '$end', function $$end() {
          var self = this;

          return self.$with($hash2(["begin_pos"], {"begin_pos": self.end_pos}))
        }, 0);
        
        $def(self, '$size', function $$size() {
          var self = this;

          return $rb_minus(self.end_pos, self.begin_pos)
        }, 0);
        $alias(self, "length", "size");
        
        $def(self, '$line', function $$line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.begin_pos)
        }, 0);
        self.$alias_method("first_line", "line");
        
        $def(self, '$column', function $$column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.begin_pos)
        }, 0);
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.end_pos)
        }, 0);
        
        $def(self, '$last_column', function $$last_column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.end_pos)
        }, 0);
        
        $def(self, '$column_range', function $$column_range() {
          var self = this;

          
          if ($neqeq(self.$line(), self.$last_line())) {
            self.$raise($$('RangeError'), "" + (self.$inspect()) + " spans more than one line")
          };
          return Opal.Range.$new(self.$column(),self.$last_column(), true);
        }, 0);
        
        $def(self, '$source_line', function $$source_line() {
          var self = this;

          return self.source_buffer.$source_line(self.$line())
        }, 0);
        
        $def(self, '$source', function $$source() {
          var self = this;

          return self.source_buffer.$slice(Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true))
        }, 0);
        
        $def(self, '$is?', function $Range_is$ques$1($a) {
          var $post_args, what, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          what = $post_args;;
          return what['$include?'](self.$source());
        }, -1);
        
        $def(self, '$to_a', function $$to_a() {
          var self = this;

          return Opal.Range.$new(self.begin_pos,self.end_pos, true).$to_a()
        }, 0);
        
        $def(self, '$to_range', function $$to_range() {
          var self = this;

          return Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true)
        }, 0);
        
        $def(self, '$to_s', function $$to_s() {
          var $a, $b, self = this, line = nil, column = nil;

          
          $b = self.source_buffer.$decompose_position(self.begin_pos), $a = $to_ary($b), (line = ($a[0] == null ? nil : $a[0])), (column = ($a[1] == null ? nil : $a[1])), $b;
          return [self.source_buffer.$name(), line, $rb_plus(column, 1)].$join(":");
        }, 0);
        
        $def(self, '$with', function $Range_with$2($kwargs) {
          var begin_pos, end_pos, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          begin_pos = $kwargs.$$smap["begin_pos"];
          if (begin_pos == null) begin_pos = self.begin_pos;
          
          end_pos = $kwargs.$$smap["end_pos"];
          if (end_pos == null) end_pos = self.end_pos;
          return $$('Range').$new(self.source_buffer, begin_pos, end_pos);
        }, -1);
        
        $def(self, '$adjust', function $$adjust($kwargs) {
          var begin_pos, end_pos, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          begin_pos = $kwargs.$$smap["begin_pos"];
          if (begin_pos == null) begin_pos = 0;
          
          end_pos = $kwargs.$$smap["end_pos"];
          if (end_pos == null) end_pos = 0;
          return $$('Range').$new(self.source_buffer, $rb_plus(self.begin_pos, begin_pos), $rb_plus(self.end_pos, end_pos));
        }, -1);
        
        $def(self, '$resize', function $$resize(new_size) {
          var self = this;

          return self.$with($hash2(["end_pos"], {"end_pos": $rb_plus(self.begin_pos, new_size)}))
        }, 1);
        
        $def(self, '$join', function $$join(other) {
          var self = this;

          return $$('Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$min(), [self.end_pos, other.$end_pos()].$max())
        }, 1);
        
        $def(self, '$intersect', function $$intersect(other) {
          var self = this;

          if ($truthy(self['$disjoint?'](other))) {
            return nil
          } else {
            return $$('Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$max(), [self.end_pos, other.$end_pos()].$min())
          }
        }, 1);
        
        $def(self, '$disjoint?', function $Range_disjoint$ques$3(other) {
          var self = this, $ret_or_1 = nil;

          if (($truthy(self['$empty?']()) && ($truthy(other['$empty?']())))) {
            return self.begin_pos['$!='](other.$begin_pos())
          } else if ($truthy(($ret_or_1 = $rb_ge(self.begin_pos, other.$end_pos())))) {
            return $ret_or_1
          } else {
            return $rb_ge(other.$begin_pos(), self.end_pos)
          }
        }, 1);
        
        $def(self, '$overlaps?', function $Range_overlaps$ques$4(other) {
          var self = this;

          return self['$disjoint?'](other)['$!']()
        }, 1);
        
        $def(self, '$contains?', function $Range_contains$ques$5(other) {
          var self = this;

          return $rb_ge($rb_plus(other.$begin_pos()['$<=>'](self.begin_pos), self.end_pos['$<=>'](other.$end_pos())), ($truthy(other['$empty?']()) ? (2) : (1)))
        }, 1);
        
        $def(self, '$contained?', function $Range_contained$ques$6(other) {
          var self = this;

          return other['$contains?'](self)
        }, 1);
        
        $def(self, '$crossing?', function $Range_crossing$ques$7(other) {
          var self = this;

          
          if (!$truthy(self['$overlaps?'](other))) {
            return false
          };
          return $rb_times(self.begin_pos['$<=>'](other.$begin_pos()), self.end_pos['$<=>'](other.$end_pos()))['$=='](1);
        }, 1);
        
        $def(self, '$empty?', function $Range_empty$ques$8() {
          var self = this;

          return self.begin_pos['$=='](self.end_pos)
        }, 0);
        
        $def(self, '$<=>', function $Range_$lt_eq_gt$9(other) {
          var self = this, $ret_or_1 = nil;

          
          if (!($truthy(other['$is_a?']($$$($$$($$$('Parser'), 'Source'), 'Range'))) && ($eqeq(self.source_buffer, other.$source_buffer())))) {
            return nil
          };
          if ($truthy(($ret_or_1 = self.begin_pos['$<=>'](other.$begin_pos())['$nonzero?']()))) {
            return $ret_or_1
          } else {
            
            return self.end_pos['$<=>'](other.$end_pos());
          };
        }, 1);
        self.$alias_method("eql?", "==");
        
        $def(self, '$hash', function $$hash() {
          var self = this;

          return [self.source_buffer, self.begin_pos, self.end_pos].$hash()
        }, 0);
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Parser::Source::Range " + (self.source_buffer.$name()) + " " + (self.begin_pos) + "..." + (self.end_pos) + ">"
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/comment"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy;

  Opal.add_stubs('attr_reader,alias_method,new,associate,associate_locations,associate_by_identity,freeze,source,start_with?,text,==,type,is_a?,location,to_s,expression,inspect');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Comment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.location = nil;
        
        self.$attr_reader("text");
        self.$attr_reader("location");
        self.$alias_method("loc", "location");
        $defs(self, '$associate', function $$associate(ast, comments) {
          var associator = nil;

          
          associator = $$('Associator').$new(ast, comments);
          return associator.$associate();
        }, 2);
        $defs(self, '$associate_locations', function $$associate_locations(ast, comments) {
          var associator = nil;

          
          associator = $$('Associator').$new(ast, comments);
          return associator.$associate_locations();
        }, 2);
        $defs(self, '$associate_by_identity', function $$associate_by_identity(ast, comments) {
          var associator = nil;

          
          associator = $$('Associator').$new(ast, comments);
          return associator.$associate_by_identity();
        }, 2);
        
        $def(self, '$initialize', function $$initialize(range) {
          var self = this;

          
          self.location = $$$($$$($$('Parser'), 'Source'), 'Map').$new(range);
          self.text = range.$source().$freeze();
          return self.$freeze();
        }, 1);
        
        $def(self, '$type', function $$type() {
          var self = this;

          if ($truthy(self.$text()['$start_with?']("#".$freeze()))) {
            return "inline"
          } else if ($truthy(self.$text()['$start_with?']("=begin".$freeze()))) {
            return "document"
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$inline?', function $Comment_inline$ques$1() {
          var self = this;

          return self.$type()['$==']("inline")
        }, 0);
        
        $def(self, '$document?', function $Comment_document$ques$2() {
          var self = this;

          return self.$type()['$==']("document")
        }, 0);
        
        $def(self, '$==', function $Comment_$eq_eq$3(other) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = other['$is_a?']($$$($$('Source'), 'Comment'))))) {
            return self.location['$=='](other.$location())
          } else {
            return $ret_or_1
          }
        }, 1);
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Parser::Source::Comment " + (self.location.$expression().$to_s()) + " " + (self.$text().$inspect()) + ">"
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/comment/associator"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $const_set = Opal.const_set, $truthy = Opal.truthy, $send = Opal.send, $eqeq = Opal.eqeq, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $not = Opal.not;

  Opal.add_stubs('attr_accessor,do_associate,private,freeze,[],include?,type,sort_by,compact,children,begin_pos,expression,loc,select,is_a?,new,[]=,==,compare_by_identity,advance_comment,advance_through_directives,visit,process_leading_comments,location,<=,line,last_line,each,children_in_source_order,process_trailing_comments,current_comment_before?,associate_and_advance_comment,current_comment_before_end?,current_comment_decorates?,+,!,end_pos,<<,start_with?,text,=~');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Associator');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.map_using = $proto.mapping = $proto.skip_directives = $proto.ast = $proto.current_comment = $proto.comment_num = $proto.comments = nil;
        
        self.$attr_accessor("skip_directives");
        
        $def(self, '$initialize', function $$initialize(ast, comments) {
          var self = this;

          
          self.ast = ast;
          self.comments = comments;
          return (self.skip_directives = true);
        }, 2);
        
        $def(self, '$associate', function $$associate() {
          var self = this;

          
          self.map_using = "eql";
          return self.$do_associate();
        }, 0);
        
        $def(self, '$associate_locations', function $$associate_locations() {
          var self = this;

          
          self.map_using = "location";
          return self.$do_associate();
        }, 0);
        
        $def(self, '$associate_by_identity', function $$associate_by_identity() {
          var self = this;

          
          self.map_using = "identity";
          return self.$do_associate();
        }, 0);
        self.$private();
        $const_set($nesting[0], 'POSTFIX_TYPES', $$('Set')['$[]']("if", "while", "while_post", "until", "until_post", "masgn").$freeze());
        
        $def(self, '$children_in_source_order', function $$children_in_source_order(node) {
          
          if ($truthy($$('POSTFIX_TYPES')['$include?'](node.$type()))) {
            return $send(node.$children().$compact(), 'sort_by', [], function $$1(child){
              
              
              if (child == null) child = nil;;
              return child.$loc().$expression().$begin_pos();}, 1)
          } else {
            return $send(node.$children(), 'select', [], function $$2(child){var $ret_or_1 = nil, $ret_or_2 = nil;

              
              
              if (child == null) child = nil;;
              if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = child['$is_a?']($$$($$('AST'), 'Node')))) ? (child.$loc()) : ($ret_or_2))))) {
                return child.$loc().$expression()
              } else {
                return $ret_or_1
              };}, 1)
          }
        }, 1);
        
        $def(self, '$do_associate', function $$do_associate() {
          var self = this;

          
          self.mapping = $send($$('Hash'), 'new', [], function $$3(h, k){var $a;

            
            
            if (h == null) h = nil;;
            
            if (k == null) k = nil;;
            return ($a = [k, []], $send(h, '[]=', $a), $a[$a.length - 1]);}, 2);
          if ($eqeq(self.map_using, "identity")) {
            self.mapping.$compare_by_identity()
          };
          self.comment_num = -1;
          self.$advance_comment();
          if ($truthy(self.skip_directives)) {
            self.$advance_through_directives()
          };
          if ($truthy(self.ast)) {
            self.$visit(self.ast)
          };
          return self.mapping;
        }, 0);
        
        $def(self, '$visit', function $$visit(node) {
          var self = this, node_loc = nil;

          
          self.$process_leading_comments(node);
          if (!$truthy(self.current_comment)) {
            return nil
          };
          node_loc = node.$location();
          if (($truthy($rb_le(self.current_comment.$location().$line(), node_loc.$last_line())) || ($truthy(node_loc['$is_a?']($$$($$('Map'), 'Heredoc')))))) {
            
            $send(self.$children_in_source_order(node), 'each', [], function $$4(child){var self = $$4.$$s == null ? this : $$4.$$s;

              
              
              if (child == null) child = nil;;
              return self.$visit(child);}, {$$arity: 1, $$s: self});
            return self.$process_trailing_comments(node);
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$process_leading_comments', function $$process_leading_comments(node) {
          var $a, self = this;

          
          if ($eqeq(node.$type(), "begin")) {
            return nil
          };
          while ($truthy(self['$current_comment_before?'](node))) {
            self.$associate_and_advance_comment(node)
          };
        }, 1);
        
        $def(self, '$process_trailing_comments', function $$process_trailing_comments(node) {
          var $a, self = this;

          
          while ($truthy(self['$current_comment_before_end?'](node))) {
            self.$associate_and_advance_comment(node)
          };
          while ($truthy(self['$current_comment_decorates?'](node))) {
            self.$associate_and_advance_comment(node)
          };
        }, 1);
        
        $def(self, '$advance_comment', function $$advance_comment() {
          var self = this;

          
          self.comment_num = $rb_plus(self.comment_num, 1);
          return (self.current_comment = self.comments['$[]'](self.comment_num));
        }, 0);
        
        $def(self, '$current_comment_before?', function $Associator_current_comment_before$ques$5(node) {
          var self = this, comment_loc = nil, node_loc = nil;

          
          if ($not(self.current_comment)) {
            return false
          };
          comment_loc = self.current_comment.$location().$expression();
          node_loc = node.$location().$expression();
          return $rb_le(comment_loc.$end_pos(), node_loc.$begin_pos());
        }, 1);
        
        $def(self, '$current_comment_before_end?', function $Associator_current_comment_before_end$ques$6(node) {
          var self = this, comment_loc = nil, node_loc = nil;

          
          if ($not(self.current_comment)) {
            return false
          };
          comment_loc = self.current_comment.$location().$expression();
          node_loc = node.$location().$expression();
          return $rb_le(comment_loc.$end_pos(), node_loc.$end_pos());
        }, 1);
        
        $def(self, '$current_comment_decorates?', function $Associator_current_comment_decorates$ques$7(node) {
          var self = this;

          
          if ($not(self.current_comment)) {
            return false
          };
          return self.current_comment.$location().$line()['$=='](node.$location().$last_line());
        }, 1);
        
        $def(self, '$associate_and_advance_comment', function $$associate_and_advance_comment(node) {
          var self = this, key = nil;

          
          key = ($eqeq(self.map_using, "location") ? (node.$location()) : (node));
          self.mapping['$[]'](key)['$<<'](self.current_comment);
          return self.$advance_comment();
        }, 1);
        $const_set($nesting[0], 'MAGIC_COMMENT_RE', /^#\s*(-\*-|)\s*(frozen_string_literal|warn_indent|warn_past_scope):.*\1$/);
        return $def(self, '$advance_through_directives', function $$advance_through_directives() {
          var self = this;

          
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$start_with?']("#!".$freeze()))))) {
            self.$advance_comment()
          };
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$=~']($$('MAGIC_COMMENT_RE')))))) {
            self.$advance_comment()
          };
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$=~']($$$($$('Buffer'), 'ENCODING_RE')))))) {
            return self.$advance_comment()
          } else {
            return nil
          };
        }, 0);
      })($$('Comment'), null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $def = Opal.def, $rb_minus = Opal.rb_minus, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $not = Opal.not, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, $hash2 = Opal.hash2, $const_set = Opal.const_set;

  Opal.add_stubs('attr_reader,warn_of_deprecation,class,new,consumer=,lambda,puts,render,append,freeze,begin,end,-,+,in_transaction?,raise,dup,source,each,sort,begin_pos,range,length,[]=,replacement,private,empty?,clobbered_insertion?,!,allow_multiple_insertions?,raise_clobber_error,record_insertion,adjacent_updates?,find,overlaps?,replace_compatible_with_insertion?,merge_actions!,<<,active_queue,adjacent_insertions?,merge_actions,delete,can_merge?,record_replace,active_insertions=,|,active_insertions,active_clobber=,active_clobber,clobbered_position_mask,size,!=,&,<=,end_pos,adjacent_insertion_mask,select,adjacent?,adjacent_position_mask,>=,==,[],all?,intersect,nil?,max,sort_by,push,join,first,max_by,merge_replacements,replace_actions,disjoint?,<,process,extend');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.diagnostics = $proto.insert_before_multi_order = $proto.insert_after_multi_order = $proto.source_buffer = $proto.queue = $proto.clobber = $proto.insertions = $proto.pending_queue = $proto.pending_clobber = $proto.pending_insertions = nil;
        
        self.$attr_reader("source_buffer");
        self.$attr_reader("diagnostics");
        
        $def(self, '$initialize', function $$initialize(source_buffer) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
          self.diagnostics['$consumer=']($send(self, 'lambda', [], function $$1(diag){            if ($gvars.stderr == null) $gvars.stderr = nil;

            
            
            if (diag == null) diag = nil;;
            return $gvars.stderr.$puts(diag.$render());}, 1));
          self.source_buffer = source_buffer;
          self.queue = [];
          self.clobber = 0;
          self.insertions = 0;
          self.insert_before_multi_order = 0;
          self.insert_after_multi_order = 0;
          self.pending_queue = nil;
          self.pending_clobber = nil;
          return (self.pending_insertions = nil);
        }, 1);
        
        $def(self, '$remove', function $$remove(range) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range, "".$freeze()))
        }, 1);
        
        $def(self, '$insert_before', function $$insert_before(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), content))
        }, 2);
        
        $def(self, '$wrap', function $$wrap(range, before, after) {
          var self = this;

          
          self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), before));
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), after));
        }, 3);
        
        $def(self, '$insert_before_multi', function $$insert_before_multi(range, content) {
          var self = this;

          
          self.insert_before_multi_order = $rb_minus(self.insert_before_multi_order, 1);
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), content, true, self.insert_before_multi_order));
        }, 2);
        
        $def(self, '$insert_after', function $$insert_after(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), content))
        }, 2);
        
        $def(self, '$insert_after_multi', function $$insert_after_multi(range, content) {
          var self = this;

          
          self.insert_after_multi_order = $rb_plus(self.insert_after_multi_order, 1);
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), content, true, self.insert_after_multi_order));
        }, 2);
        
        $def(self, '$replace', function $$replace(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range, content))
        }, 2);
        
        $def(self, '$process', function $$process() {
          var self = this, adjustment = nil, source = nil;

          
          if ($truthy(self['$in_transaction?']())) {
            self.$raise("Do not call " + (self.$class()) + "#" + ("process") + " inside a transaction")
          };
          adjustment = 0;
          source = self.source_buffer.$source().$dup();
          $send(self.queue.$sort(), 'each', [], function $$2(action){var begin_pos = nil, end_pos = nil;

            
            
            if (action == null) action = nil;;
            begin_pos = $rb_plus(action.$range().$begin_pos(), adjustment);
            end_pos = $rb_plus(begin_pos, action.$range().$length());
            source['$[]='](Opal.Range.$new(begin_pos,end_pos, true), action.$replacement());
            return (adjustment = $rb_plus(adjustment, $rb_minus(action.$replacement().$length(), action.$range().$length())));}, 1);
          return source;
        }, 0);
        
        $def(self, '$transaction', function $$transaction() {
          var $yield = $$transaction.$$p || nil, self = this;

          delete $$transaction.$$p;
          return (function() { try {
          
          if (!($yield !== nil)) {
            self.$raise("" + (self.$class()) + "#" + ("transaction") + " requires block")
          };
          if ($truthy(self['$in_transaction?']())) {
            self.$raise("Nested transaction is not supported")
          };
          self.pending_queue = self.queue.$dup();
          self.pending_clobber = self.clobber;
          self.pending_insertions = self.insertions;
          Opal.yieldX($yield, []);
          self.queue = self.pending_queue;
          self.clobber = self.pending_clobber;
          self.insertions = self.pending_insertions;
          return self;
          } finally {
            ((self.pending_queue = nil), (self.pending_clobber = nil), (self.pending_insertions = nil))
          }; })()
        }, 0);
        self.$private();
        
        $def(self, '$append', function $$append(action) {
          var self = this, range = nil, conflicting = nil, adjacent = nil, insertions = nil;

          
          range = action.$range();
          if ($truthy(range['$empty?']())) {
            
            if ($truthy(action.$replacement()['$empty?']())) {
              return self
            };
            if (($not(action['$allow_multiple_insertions?']()) && ($truthy((conflicting = self['$clobbered_insertion?'](range)))))) {
              self.$raise_clobber_error(action, [conflicting])
            };
            self.$record_insertion(range);
            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {
              
              conflicting = $send(adjacent, 'find', [], function $$3(a){var self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil;

                
                
                if (a == null) a = nil;;
                if ($truthy(($ret_or_1 = a.$range()['$overlaps?'](range)))) {
                  return self['$replace_compatible_with_insertion?'](a, action)['$!']()
                } else {
                  return $ret_or_1
                };}, {$$arity: 1, $$s: self});
              if ($truthy(conflicting)) {
                self.$raise_clobber_error(action, [conflicting])
              };
              self['$merge_actions!'](action, adjacent);
            } else {
              self.$active_queue()['$<<'](action)
            };
          } else {
            
            if ($truthy((insertions = self['$adjacent_insertions?'](range)))) {
              $send(insertions, 'each', [], function $$4(insertion){var self = $$4.$$s == null ? this : $$4.$$s;

                
                
                if (insertion == null) insertion = nil;;
                if (($truthy(range['$overlaps?'](insertion.$range())) && ($not(self['$replace_compatible_with_insertion?'](action, insertion))))) {
                  return self.$raise_clobber_error(action, [insertion])
                } else {
                  
                  action = self.$merge_actions(action, [insertion]);
                  return self.$active_queue().$delete(insertion);
                };}, {$$arity: 1, $$s: self})
            };
            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {
              if ($truthy(self['$can_merge?'](action, adjacent))) {
                
                self.$record_replace(range);
                self['$merge_actions!'](action, adjacent);
              } else {
                self.$raise_clobber_error(action, adjacent)
              }
            } else {
              
              self.$record_replace(range);
              self.$active_queue()['$<<'](action);
            };
          };
          return self;
        }, 1);
        
        $def(self, '$record_insertion', function $$record_insertion(range) {
          var $a, self = this;

          return ($a = [self.$active_insertions()['$|']((1)['$<<'](range.$begin_pos()))], $send(self, 'active_insertions=', $a), $a[$a.length - 1])
        }, 1);
        
        $def(self, '$record_replace', function $$record_replace(range) {
          var $a, self = this;

          return ($a = [self.$active_clobber()['$|'](self.$clobbered_position_mask(range))], $send(self, 'active_clobber=', $a), $a[$a.length - 1])
        }, 1);
        
        $def(self, '$clobbered_position_mask', function $$clobbered_position_mask(range) {
          
          return $rb_minus((1)['$<<'](range.$size()), 1)['$<<'](range.$begin_pos())
        }, 1);
        
        $def(self, '$adjacent_position_mask', function $$adjacent_position_mask(range) {
          
          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 2)), 1)['$<<']($rb_minus(range.$begin_pos(), 1))
        }, 1);
        
        $def(self, '$adjacent_insertion_mask', function $$adjacent_insertion_mask(range) {
          
          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 1)), 1)['$<<'](range.$begin_pos())
        }, 1);
        
        $def(self, '$clobbered_insertion?', function $Rewriter_clobbered_insertion$ques$5(insertion) {
          var self = this, insertion_pos = nil;

          
          insertion_pos = insertion.$begin_pos();
          if ($neqeq(self.$active_insertions()['$&']((1)['$<<'](insertion_pos)), 0)) {
            return $send(self.$active_queue(), 'find', [], function $$6(a){var $ret_or_1 = nil;

              
              
              if (a == null) a = nil;;
              if ($truthy(($ret_or_1 = $rb_le(a.$range().$begin_pos(), insertion_pos)))) {
                return $rb_le(insertion_pos, a.$range().$end_pos())
              } else {
                return $ret_or_1
              };}, 1)
          } else {
            return nil
          };
        }, 1);
        
        $def(self, '$adjacent_insertions?', function $Rewriter_adjacent_insertions$ques$7(range) {
          var self = this, result = nil;

          if ($neqeq(self.$active_insertions()['$&'](self.$adjacent_insertion_mask(range)), 0)) {
            
            result = $send(self.$active_queue(), 'select', [], function $$8(a){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;

              
              
              if (a == null) a = nil;;
              if ($truthy(($ret_or_1 = a.$range()['$empty?']()))) {
                return self['$adjacent?'](range, a.$range())
              } else {
                return $ret_or_1
              };}, {$$arity: 1, $$s: self});
            if ($truthy(result['$empty?']())) {
              return nil
            } else {
              return result
            };
          } else {
            return nil
          }
        }, 1);
        
        $def(self, '$adjacent_updates?', function $Rewriter_adjacent_updates$ques$9(range) {
          var self = this;

          if ($neqeq(self.$active_clobber()['$&'](self.$adjacent_position_mask(range)), 0)) {
            return $send(self.$active_queue(), 'select', [], function $$10(a){var self = $$10.$$s == null ? this : $$10.$$s;

              
              
              if (a == null) a = nil;;
              return self['$adjacent?'](range, a.$range());}, {$$arity: 1, $$s: self})
          } else {
            return nil
          }
        }, 1);
        
        $def(self, '$replace_compatible_with_insertion?', function $Rewriter_replace_compatible_with_insertion$ques$11(replace, insertion) {
          var $ret_or_1 = nil, $ret_or_2 = nil, offset = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $rb_ge($rb_minus(replace.$replacement().$length(), replace.$range().$size()), insertion.$range().$size()))) ? ((offset = $rb_minus(insertion.$range().$begin_pos(), replace.$range().$begin_pos()))) : ($ret_or_2))))) {
            return replace.$replacement()['$[]'](offset, insertion.$replacement().$length())['$=='](insertion.$replacement())
          } else {
            return $ret_or_1
          }
        }, 2);
        
        $def(self, '$can_merge?', function $Rewriter_can_merge$ques$12(action, existing) {
          var range = nil;

          
          range = action.$range();
          return $send(existing, 'all?', [], function $$13(other){var overlap = nil, repl1_offset = nil, repl2_offset = nil, repl1_length = nil, repl2_length = nil, replacement1 = nil, $ret_or_1 = nil, replacement2 = nil;

            
            
            if (other == null) other = nil;;
            overlap = range.$intersect(other.$range());
            if ($truthy(overlap['$nil?']())) {
              return true;
            };
            repl1_offset = $rb_minus(overlap.$begin_pos(), range.$begin_pos());
            repl2_offset = $rb_minus(overlap.$begin_pos(), other.$range().$begin_pos());
            repl1_length = [$rb_minus(other.$range().$length(), repl2_offset), $rb_minus(other.$replacement().$length(), repl2_offset)].$max();
            repl2_length = [$rb_minus(range.$length(), repl1_offset), $rb_minus(action.$replacement().$length(), repl1_offset)].$max();
            replacement1 = ($truthy(($ret_or_1 = action.$replacement()['$[]'](repl1_offset, repl1_length))) ? ($ret_or_1) : ("".$freeze()));
            replacement2 = ($truthy(($ret_or_1 = other.$replacement()['$[]'](repl2_offset, repl2_length))) ? ($ret_or_1) : ("".$freeze()));
            return replacement1['$=='](replacement2);}, 1);
        }, 2);
        
        $def(self, '$merge_actions', function $$merge_actions(action, existing) {
          var self = this, actions = nil, range = nil;

          
          actions = $send(existing.$push(action), 'sort_by', [], function $$14(a){
            
            
            if (a == null) a = nil;;
            return [a.$range().$begin_pos(), a.$range().$end_pos()];}, 1);
          range = actions.$first().$range().$join($send(actions, 'max_by', [], function $$15(a){
            
            
            if (a == null) a = nil;;
            return a.$range().$end_pos();}, 1).$range());
          return $$$($$('Rewriter'), 'Action').$new(range, self.$merge_replacements(actions));
        }, 2);
        
        $def(self, '$merge_actions!', function $Rewriter_merge_actions$excl$16(action, existing) {
          var self = this, new_action = nil;

          
          new_action = self.$merge_actions(action, existing);
          self.$active_queue().$delete(action);
          return self.$replace_actions(existing, new_action);
        }, 2);
        
        $def(self, '$merge_replacements', function $$merge_replacements(actions) {
          var result = nil, prev_act = nil;

          
          result = "".$dup();
          prev_act = nil;
          $send(actions, 'each', [], function $$17(act){var prev_end = nil, offset = nil;

            
            
            if (act == null) act = nil;;
            if (($not(prev_act) || ($truthy(act.$range()['$disjoint?'](prev_act.$range()))))) {
              result['$<<'](act.$replacement())
            } else {
              
              prev_end = [$rb_plus(prev_act.$range().$begin_pos(), prev_act.$replacement().$length()), prev_act.$range().$end_pos()].$max();
              offset = $rb_minus(prev_end, act.$range().$begin_pos());
              if ($truthy($rb_lt(offset, act.$replacement().$size()))) {
                result['$<<'](act.$replacement()['$[]'](Opal.Range.$new(offset, -1, false)))
              };
            };
            return (prev_act = act);}, 1);
          return result;
        }, 1);
        
        $def(self, '$replace_actions', function $$replace_actions(old, updated) {
          var self = this;

          
          $send(old, 'each', [], function $$18(act){var self = $$18.$$s == null ? this : $$18.$$s;

            
            
            if (act == null) act = nil;;
            return self.$active_queue().$delete(act);}, {$$arity: 1, $$s: self});
          return self.$active_queue()['$<<'](updated);
        }, 2);
        
        $def(self, '$raise_clobber_error', function $$raise_clobber_error(action, existing) {
          var self = this, diagnostic = nil;

          
          diagnostic = $$('Diagnostic').$new("error", "invalid_action", $hash2(["action"], {"action": action}), action.$range());
          self.diagnostics.$process(diagnostic);
          diagnostic = $$('Diagnostic').$new("note", "clobbered", $hash2(["action"], {"action": existing['$[]'](0)}), existing['$[]'](0).$range());
          self.diagnostics.$process(diagnostic);
          return self.$raise($$('ClobberingError'), "Parser::Source::Rewriter detected clobbering");
        }, 2);
        
        $def(self, '$in_transaction?', function $Rewriter_in_transaction$ques$19() {
          var self = this;

          return self.pending_queue['$nil?']()['$!']()
        }, 0);
        
        $def(self, '$active_queue', function $$active_queue() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_queue))) {
            return $ret_or_1
          } else {
            return self.queue
          }
        }, 0);
        
        $def(self, '$active_clobber', function $$active_clobber() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_clobber))) {
            return $ret_or_1
          } else {
            return self.clobber
          }
        }, 0);
        
        $def(self, '$active_insertions', function $$active_insertions() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_insertions))) {
            return $ret_or_1
          } else {
            return self.insertions
          }
        }, 0);
        
        $def(self, '$active_clobber=', function $Rewriter_active_clobber$eq$20(value) {
          var self = this;

          if ($truthy(self.pending_clobber)) {
            return (self.pending_clobber = value)
          } else {
            return (self.clobber = value)
          }
        }, 1);
        
        $def(self, '$active_insertions=', function $Rewriter_active_insertions$eq$21(value) {
          var self = this;

          if ($truthy(self.pending_insertions)) {
            return (self.pending_insertions = value)
          } else {
            return (self.insertions = value)
          }
        }, 1);
        
        $def(self, '$adjacent?', function $Rewriter_adjacent$ques$22(range1, range2) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = $rb_le(range1.$begin_pos(), range2.$end_pos())))) {
            return $rb_le(range2.$begin_pos(), range1.$end_pos())
          } else {
            return $ret_or_1
          }
        }, 2);
        $const_set($nesting[0], 'DEPRECATION_WARNING', ["Parser::Source::Rewriter is deprecated.", "Please update your code to use Parser::Source::TreeRewriter instead"].$join("\n").$freeze());
        return self.$extend($$('Deprecation'));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/rewriter/action"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq;

  Opal.add_stubs('include,attr_reader,alias_method,freeze,<=>,begin_pos,range,zero?,order,empty?,==,length,inspect');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Action');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.replacement = $proto.range = nil;
        
        self.$include($$('Comparable'));
        self.$attr_reader("range", "replacement", "allow_multiple_insertions", "order");
        self.$alias_method("allow_multiple_insertions?", "allow_multiple_insertions");
        
        $def(self, '$initialize', function $$initialize(range, replacement, allow_multiple_insertions, order) {
          var self = this;

          
          
          if (replacement == null) replacement = "";;
          
          if (allow_multiple_insertions == null) allow_multiple_insertions = false;;
          
          if (order == null) order = 0;;
          self.range = range;
          self.replacement = replacement;
          self.allow_multiple_insertions = allow_multiple_insertions;
          self.order = order;
          return self.$freeze();
        }, -2);
        
        $def(self, '$<=>', function $Action_$lt_eq_gt$1(other) {
          var self = this, result = nil;

          
          result = self.$range().$begin_pos()['$<=>'](other.$range().$begin_pos());
          if (!$truthy(result['$zero?']())) {
            return result
          };
          return self.$order()['$<=>'](other.$order());
        }, 1);
        return $def(self, '$to_s', function $$to_s() {
          var self = this;

          if (($eqeq(self.range.$length(), 0) && ($truthy(self.replacement['$empty?']())))) {
            return "do nothing"
          } else if ($eqeq(self.range.$length(), 0)) {
            return "insert " + (self.replacement.$inspect())
          } else if ($truthy(self.replacement['$empty?']())) {
            return "remove " + (self.range.$length()) + " character(s)"
          } else {
            return "replace " + (self.range.$length()) + " character(s) with " + (self.replacement.$inspect())
          }
        }, 0);
      })($$('Rewriter'), null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/tree_rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $lambda = Opal.lambda, $gvars = Opal.gvars, $def = Opal.def, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $return_ivar = Opal.return_ivar, $const_set = Opal.const_set, $eqeqeq = Opal.eqeqeq, $range = Opal.range, $to_ary = Opal.to_ary, $rb_minus = Opal.rb_minus, $hash = Opal.hash, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $slice = Opal.slice;

  Opal.add_stubs('attr_reader,new,consumer=,puts,render,freeze,check_policy_validity,method,adjust,source_range,empty?,==,source_buffer,raise,combine,action_root,merge!,dup,contract,+,begin_pos,range,end_pos,check_range_validity,moved,to_s,replace,wrap,source,each,ordered_replacements,<<,[],length,join,nested_actions,class,name,action_summary,warn_of_deprecation,insert_before,insert_after,extend,protected,private,as_replacements,===,size,first,map,to_range,inspect,-,values,>,<,trigger_policy,process');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TreeRewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.diagnostics = $proto.source_buffer = $proto.enforcer = $proto.action_root = $proto.in_transaction = $proto.policy = nil;
        
        self.$attr_reader("source_buffer");
        self.$attr_reader("diagnostics");
        
        $def(self, '$initialize', function $$initialize(source_buffer, $kwargs) {
          var crossing_deletions, different_replacements, swallowed_insertions, self = this, all_encompassing_range = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          crossing_deletions = $kwargs.$$smap["crossing_deletions"];
          if (crossing_deletions == null) crossing_deletions = "accept";
          
          different_replacements = $kwargs.$$smap["different_replacements"];
          if (different_replacements == null) different_replacements = "accept";
          
          swallowed_insertions = $kwargs.$$smap["swallowed_insertions"];
          if (swallowed_insertions == null) swallowed_insertions = "accept";
          self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
          self.diagnostics['$consumer=']($lambda(function $$1(diag){            if ($gvars.stderr == null) $gvars.stderr = nil;

            
            
            if (diag == null) diag = nil;;
            return $gvars.stderr.$puts(diag.$render());}, 1));
          self.source_buffer = source_buffer;
          self.in_transaction = false;
          self.policy = $hash2(["crossing_deletions", "different_replacements", "swallowed_insertions"], {"crossing_deletions": crossing_deletions, "different_replacements": different_replacements, "swallowed_insertions": swallowed_insertions}).$freeze();
          self.$check_policy_validity();
          self.enforcer = self.$method("enforce_policy");
          all_encompassing_range = self.source_buffer.$source_range().$adjust($hash2(["begin_pos", "end_pos"], {"begin_pos": -1, "end_pos": 1}));
          return (self.action_root = $$$($$('TreeRewriter'), 'Action').$new(all_encompassing_range, self.enforcer));
        }, -2);
        
        $def(self, '$empty?', function $TreeRewriter_empty$ques$2() {
          var self = this;

          return self.action_root['$empty?']()
        }, 0);
        
        $def(self, '$merge!', function $TreeRewriter_merge$excl$3(with$) {
          var self = this;

          
          if (!$eqeq(self.$source_buffer(), with$.$source_buffer())) {
            self.$raise("TreeRewriter are not for the same source_buffer")
          };
          self.action_root = self.action_root.$combine(with$.$action_root());
          return self;
        }, 1);
        
        $def(self, '$merge', function $$merge(with$) {
          var self = this;

          return self.$dup()['$merge!'](with$)
        }, 1);
        
        $def(self, '$import!', function $TreeRewriter_import$excl$4(foreign_rewriter, $kwargs) {
          var offset, self = this, contracted = nil, merge_effective_range = nil, merge_with = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          offset = $kwargs.$$smap["offset"];
          if (offset == null) offset = 0;
          if ($truthy(foreign_rewriter['$empty?']())) {
            return self
          };
          contracted = foreign_rewriter.$action_root().$contract();
          merge_effective_range = $$$($$$($$$('Parser'), 'Source'), 'Range').$new(self.source_buffer, $rb_plus(contracted.$range().$begin_pos(), offset), $rb_plus(contracted.$range().$end_pos(), offset));
          self.$check_range_validity(merge_effective_range);
          merge_with = contracted.$moved(self.source_buffer, offset);
          self.action_root = self.action_root.$combine(merge_with);
          return self;
        }, -2);
        
        $def(self, '$replace', function $$replace(range, content) {
          var self = this;

          return self.$combine(range, $hash2(["replacement"], {"replacement": content}))
        }, 2);
        
        $def(self, '$wrap', function $$wrap(range, insert_before, insert_after) {
          var self = this;

          return self.$combine(range, $hash2(["insert_before", "insert_after"], {"insert_before": insert_before.$to_s(), "insert_after": insert_after.$to_s()}))
        }, 3);
        
        $def(self, '$remove', function $$remove(range) {
          var self = this;

          return self.$replace(range, "".$freeze())
        }, 1);
        
        $def(self, '$insert_before', function $$insert_before(range, content) {
          var self = this;

          return self.$wrap(range, content, nil)
        }, 2);
        
        $def(self, '$insert_after', function $$insert_after(range, content) {
          var self = this;

          return self.$wrap(range, nil, content)
        }, 2);
        
        $def(self, '$process', function $$process() {
          var self = this, source = nil, chunks = nil, last_end = nil;

          
          source = self.source_buffer.$source();
          chunks = [];
          last_end = 0;
          $send(self.action_root.$ordered_replacements(), 'each', [], function $$5(range, replacement){
            
            
            if (range == null) range = nil;;
            
            if (replacement == null) replacement = nil;;
            chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,range.$begin_pos(), true)))['$<<'](replacement);
            return (last_end = range.$end_pos());}, 2);
          chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,source.$length(), true)));
          return chunks.$join();
        }, 0);
        
        $def(self, '$as_replacements', function $$as_replacements() {
          var self = this;

          return self.action_root.$ordered_replacements()
        }, 0);
        
        $def(self, '$as_nested_actions', function $$as_nested_actions() {
          var self = this;

          return self.action_root.$nested_actions()
        }, 0);
        
        $def(self, '$transaction', function $$transaction() {
          var $yield = $$transaction.$$p || nil, self = this, previous = nil, restore_root = nil;

          delete $$transaction.$$p;
          return (function() { try {
          
          if (!($yield !== nil)) {
            self.$raise("" + (self.$class()) + "#" + ("transaction") + " requires block")
          };
          previous = self.in_transaction;
          self.in_transaction = true;
          restore_root = self.action_root;
          Opal.yieldX($yield, []);
          restore_root = nil;
          return self;
          } finally {
            (($truthy(restore_root) ? ((self.action_root = restore_root)) : nil), (self.in_transaction = previous))
          }; })()
        }, 0);
        
        $def(self, '$in_transaction?', $return_ivar("in_transaction"), 0);
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<" + (self.$class()) + " " + (self.$source_buffer().$name()) + ": " + (self.$action_summary()) + ">"
        }, 0);
        
        $def(self, '$insert_before_multi', function $$insert_before_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_before(range, text);
        }, 2);
        
        $def(self, '$insert_after_multi', function $$insert_after_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_after(range, text);
        }, 2);
        $const_set($nesting[0], 'DEPRECATION_WARNING', ["TreeRewriter#insert_before_multi and insert_before_multi exist only for legacy compatibility.", "Please update your code to use `wrap`, `insert_before` or `insert_after` instead."].$join("\n").$freeze());
        self.$extend($$('Deprecation'));
        self.$protected();
        self.$attr_reader("action_root");
        self.$private();
        
        $def(self, '$action_summary', function $$action_summary() {
          var self = this, replacements = nil, $ret_or_1 = nil, suffix = nil, parts = nil;

          
          replacements = self.$as_replacements();
          if ($eqeqeq(0, ($ret_or_1 = replacements.$size()))) {
            return "empty"
          } else if (!$eqeqeq($range(1, 3, false), $ret_or_1)) {
            
            replacements = replacements.$first(3);
            suffix = "";
          };
          parts = $send(replacements, 'map', [], function $$6($mlhs_tmp1){var $a, $b, range = nil, str = nil;

            
            
            if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
            $b = $mlhs_tmp1, $a = $to_ary($b), (range = ($a[0] == null ? nil : $a[0])), (str = ($a[1] == null ? nil : $a[1])), $b;
            if ($truthy(str['$empty?']())) {
              return "-" + (range.$to_range())
            } else if ($eqeq(range.$size(), 0)) {
              return "+" + (str.$inspect()) + "@" + (range.$begin_pos())
            } else {
              return "^" + (str.$inspect()) + "@" + (range.$to_range())
            };}, {$$arity: 1, $$has_top_level_mlhs_arg: true});
          if ($truthy(suffix)) {
            parts['$<<'](suffix)
          };
          return parts.$join(", ");
        }, 0);
        $const_set($nesting[0], 'ACTIONS', ["accept", "warn", "raise"].$freeze());
        
        $def(self, '$check_policy_validity', function $$check_policy_validity() {
          var self = this, invalid = nil;

          
          invalid = $rb_minus(self.policy.$values(), $$('ACTIONS'));
          if ($truthy(invalid['$empty?']())) {
            return nil
          } else {
            return self.$raise($$('ArgumentError'), "Invalid policy: " + (invalid.$join(", ")))
          };
        }, 0);
        
        $def(self, '$combine', function $$combine(range, attributes) {
          var self = this, action = nil;

          
          range = self.$check_range_validity(range);
          action = $$$($$('TreeRewriter'), 'Action').$new(range, self.enforcer, Opal.to_hash(attributes));
          self.action_root = self.action_root.$combine(action);
          return self;
        }, 2);
        
        $def(self, '$check_range_validity', function $$check_range_validity(range) {
          var self = this;

          
          if (($truthy($rb_lt(range.$begin_pos(), 0)) || ($truthy($rb_gt(range.$end_pos(), self.source_buffer.$source().$size()))))) {
            self.$raise($$('IndexError'), "The range " + (range.$to_range()) + " is outside the bounds of the source")
          };
          return range;
        }, 1);
        
        $def(self, '$enforce_policy', function $$enforce_policy(event) {
          var $yield = $$enforce_policy.$$p || nil, self = this, values = nil;

          delete $$enforce_policy.$$p;
          
          if ($eqeq(self.policy['$[]'](event), "accept")) {
            return nil
          };
          if (!$truthy((values = Opal.yieldX($yield, [])))) {
            return nil
          };
          return self.$trigger_policy(event, Opal.to_hash(values));
        }, 1);
        $const_set($nesting[0], 'POLICY_TO_LEVEL', $hash2(["warn", "raise"], {"warn": "warning", "raise": "error"}).$freeze());
        return $def(self, '$trigger_policy', function $$trigger_policy(event, $kwargs) {
          var range, conflict, arguments$, $a, $b, self = this, action = nil, $ret_or_1 = nil, diag = nil, highlights = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          range = $kwargs.$$smap["range"];
          if (range == null) range = self.$raise();
          
          conflict = $kwargs.$$smap["conflict"];
          if (conflict == null) conflict = nil;
          
          arguments$ = Opal.kwrestargs($kwargs, {'range': true,'conflict': true});;
          action = ($truthy(($ret_or_1 = self.policy['$[]'](event))) ? ($ret_or_1) : ("raise"));
          diag = $$$($$('Parser'), 'Diagnostic').$new($$('POLICY_TO_LEVEL')['$[]'](action), event, arguments$, range);
          self.diagnostics.$process(diag);
          if ($truthy(conflict)) {
            
            $b = conflict, $a = $to_ary($b), (range = ($a[0] == null ? nil : $a[0])), (highlights = $slice.call($a, 1)), $b;
            diag = $$$($$('Parser'), 'Diagnostic').$new($$('POLICY_TO_LEVEL')['$[]'](action), "" + (event) + "_conflict", arguments$, range, highlights);
            self.diagnostics.$process(diag);
          };
          if ($eqeq(action, "raise")) {
            return self.$raise($$$($$('Parser'), 'ClobberingError'), "Parser::Source::TreeRewriter detected clobbering")
          } else {
            return nil
          };
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/tree_rewriter/action"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $to_a = Opal.to_a, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $neqeq = Opal.neqeq;

  Opal.add_stubs('attr_reader,freeze,empty?,do_combine,==,<<,begin,concat,flat_map,to_proc,end,!,insert_before,insert_after,replacement,raise,insertion?,with,begin_pos,range,first,children,end_pos,last,new,+,map,moved,protected,swallow,class,merge,place_in_hierarchy,analyse_hierarchy,[],fuse_deletions,combine_children,inject,size,bsearch,bsearch_child_index,>,-,>=,<=>,<=,check_fusible,<,shift,pop,compact!,each,call,call_enforcer_for_merge,!=,select');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Action');

        var $proto = self.$$prototype;

        $proto.insert_before = $proto.insert_after = $proto.children = $proto.replacement = $proto.range = $proto.enforcer = nil;
        
        self.$attr_reader("range", "replacement", "insert_before", "insert_after");
        
        $def(self, '$initialize', function $$initialize(range, enforcer, $kwargs) {
          var insert_before, replacement, insert_after, children, $a, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          insert_before = $kwargs.$$smap["insert_before"];
          if (insert_before == null) insert_before = "";
          
          replacement = $kwargs.$$smap["replacement"];
          if (replacement == null) replacement = nil;
          
          insert_after = $kwargs.$$smap["insert_after"];
          if (insert_after == null) insert_after = "";
          
          children = $kwargs.$$smap["children"];
          if (children == null) children = [];
          $a = [range, enforcer, children.$freeze(), insert_before.$freeze(), replacement, insert_after.$freeze()], (self.range = $a[0]), (self.enforcer = $a[1]), (self.children = $a[2]), (self.insert_before = $a[3]), (self.replacement = $a[4]), (self.insert_after = $a[5]), $a;
          return self.$freeze();
        }, -3);
        
        $def(self, '$combine', function $$combine(action) {
          var self = this;

          
          if ($truthy(action['$empty?']())) {
            return self
          };
          return self.$do_combine(action);
        }, 1);
        
        $def(self, '$empty?', function $Action_empty$ques$1() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.insert_before['$empty?']())) ? (self.insert_after['$empty?']()) : ($ret_or_3)))) ? (self.children['$empty?']()) : ($ret_or_2))))) {
            
            if ($truthy(($ret_or_2 = self.replacement['$=='](nil)))) {
              return $ret_or_2
            } else {
              
              if ($truthy(($ret_or_3 = self.replacement['$empty?']()))) {
                return self.range['$empty?']()
              } else {
                return $ret_or_3
              };
            };
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$ordered_replacements', function $$ordered_replacements() {
          var self = this, reps = nil;

          
          reps = [];
          if (!$truthy(self.insert_before['$empty?']())) {
            reps['$<<']([self.range.$begin(), self.insert_before])
          };
          if ($truthy(self.replacement)) {
            reps['$<<']([self.range, self.replacement])
          };
          reps.$concat($send(self.children, 'flat_map', [], "ordered_replacements".$to_proc()));
          if (!$truthy(self.insert_after['$empty?']())) {
            reps['$<<']([self.range.$end(), self.insert_after])
          };
          return reps;
        }, 0);
        
        $def(self, '$nested_actions', function $$nested_actions() {
          var self = this, actions = nil;

          
          actions = [];
          if (($not(self.insert_before['$empty?']()) || ($not(self.insert_after['$empty?']())))) {
            actions['$<<'](["wrap", self.range, self.insert_before, self.insert_after])
          };
          if ($truthy(self.replacement)) {
            actions['$<<'](["replace", self.range, self.replacement])
          };
          return actions.$concat($send(self.children, 'flat_map', [], "nested_actions".$to_proc()));
        }, 0);
        
        $def(self, '$insertion?', function $Action_insertion$ques$2() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$insert_before()['$empty?']()['$!']())) ? ($ret_or_2) : (self.$insert_after()['$empty?']()['$!']()))))) {
            return $ret_or_1
          } else {
            
            if ($truthy(($ret_or_2 = self.$replacement()))) {
              return self.$replacement()['$empty?']()['$!']()
            } else {
              return $ret_or_2
            };
          }
        }, 0);
        
        $def(self, '$contract', function $$contract() {
          var self = this, range = nil;

          
          if ($truthy(self['$empty?']())) {
            self.$raise("Empty actions can not be contracted")
          };
          if ($truthy(self['$insertion?']())) {
            return self
          };
          range = self.range.$with($hash2(["begin_pos", "end_pos"], {"begin_pos": self.$children().$first().$range().$begin_pos(), "end_pos": self.$children().$last().$range().$end_pos()}));
          return self.$with($hash2(["range"], {"range": range}));
        }, 0);
        
        $def(self, '$moved', function $$moved(source_buffer, offset) {
          var self = this, moved_range = nil;

          
          moved_range = $$$($$$($$$('Parser'), 'Source'), 'Range').$new(source_buffer, $rb_plus(self.range.$begin_pos(), offset), $rb_plus(self.range.$end_pos(), offset));
          return self.$with($hash2(["range", "children"], {"range": moved_range, "children": $send(self.$children(), 'map', [], function $$3(child){
            
            
            if (child == null) child = nil;;
            return child.$moved(source_buffer, offset);}, 1)}));
        }, 2);
        self.$protected();
        self.$attr_reader("children");
        
        $def(self, '$with', function $Action_with$4($kwargs) {
          var range, enforcer, children, insert_before, replacement, insert_after, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          range = $kwargs.$$smap["range"];
          if (range == null) range = self.range;
          
          enforcer = $kwargs.$$smap["enforcer"];
          if (enforcer == null) enforcer = self.enforcer;
          
          children = $kwargs.$$smap["children"];
          if (children == null) children = self.children;
          
          insert_before = $kwargs.$$smap["insert_before"];
          if (insert_before == null) insert_before = self.insert_before;
          
          replacement = $kwargs.$$smap["replacement"];
          if (replacement == null) replacement = self.replacement;
          
          insert_after = $kwargs.$$smap["insert_after"];
          if (insert_after == null) insert_after = self.insert_after;
          if ($truthy(replacement)) {
            children = self.$swallow(children)
          };
          return self.$class().$new(range, enforcer, $hash2(["children", "insert_before", "replacement", "insert_after"], {"children": children, "insert_before": insert_before, "replacement": replacement, "insert_after": insert_after}));
        }, -1);
        
        $def(self, '$do_combine', function $$do_combine(action) {
          var self = this;

          if ($eqeq(action.$range(), self.range)) {
            return self.$merge(action)
          } else {
            return self.$place_in_hierarchy(action)
          }
        }, 1);
        
        $def(self, '$place_in_hierarchy', function $$place_in_hierarchy(action) {
          var self = this, family = nil, extra_sibbling = nil;

          
          family = self.$analyse_hierarchy(action);
          if ($truthy(family['$[]']("fusible"))) {
            return self.$fuse_deletions(action, family['$[]']("fusible"), [].concat($to_a(family['$[]']("sibbling_left"))).concat($to_a(family['$[]']("child"))).concat($to_a(family['$[]']("sibbling_right"))))
          } else {
            
            extra_sibbling = ($truthy(family['$[]']("parent")) ? (family['$[]']("parent").$do_combine(action)) : ($truthy(family['$[]']("child")) ? (action.$with($hash2(["children", "enforcer"], {"children": family['$[]']("child"), "enforcer": self.enforcer})).$combine_children(action.$children())) : (action)));
            return self.$with($hash2(["children"], {"children": [].concat($to_a(family['$[]']("sibbling_left"))).concat([extra_sibbling]).concat($to_a(family['$[]']("sibbling_right")))}));
          };
        }, 1);
        
        $def(self, '$combine_children', function $$combine_children(more_children) {
          var self = this;

          return $send(more_children, 'inject', [self], function $$5(parent, new_child){
            
            
            if (parent == null) parent = nil;;
            
            if (new_child == null) new_child = nil;;
            return parent.$place_in_hierarchy(new_child);}, 2)
        }, 1);
        
        $def(self, '$fuse_deletions', function $$fuse_deletions(action, fusible, other_sibblings) {
          var self = this, without_fusible = nil, fused_range = nil, fused_deletion = nil;

          
          without_fusible = self.$with($hash2(["children"], {"children": other_sibblings}));
          fused_range = $send([action].concat($to_a(fusible)), 'map', [], "range".$to_proc()).$inject("join");
          fused_deletion = action.$with($hash2(["range"], {"range": fused_range}));
          return without_fusible.$do_combine(fused_deletion);
        }, 3);
        
        $def(self, '$bsearch_child_index', function $$bsearch_child_index(from) {
          var $yield = $$bsearch_child_index.$$p || nil, self = this, size = nil, $ret_or_1 = nil;

          delete $$bsearch_child_index.$$p;
          
          
          if (from == null) from = 0;;
          size = self.children.$size();
          if ($truthy(($ret_or_1 = $send(Opal.Range.$new(from,size, true), 'bsearch', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s;
            if (self.children == null) self.children = nil;

            
            
            if (i == null) i = nil;;
            return Opal.yield1($yield, self.children['$[]'](i));;}, {$$arity: 1, $$s: self})))) {
            return $ret_or_1
          } else {
            return size
          };
        }, -1);
        
        $def(self, '$analyse_hierarchy', function $$analyse_hierarchy(action) {
          var self = this, r = nil, left_index = nil, start = nil, right_index = nil, center = nil, parent = nil, overlap_left = nil, overlap_right = nil, contained = nil, fusible = nil;

          
          r = action.$range();
          left_index = $send(self, 'bsearch_child_index', [], function $$7(child){
            
            
            if (child == null) child = nil;;
            return $rb_gt(child.$range().$end_pos(), r.$begin_pos());}, 1);
          start = ($eqeq(left_index, 0) ? (0) : ($rb_minus(left_index, 1)));
          right_index = $send(self, 'bsearch_child_index', [start], function $$8(child){
            
            
            if (child == null) child = nil;;
            return $rb_ge(child.$range().$begin_pos(), r.$end_pos());}, 1);
          center = $rb_minus(right_index, left_index);
          
          switch (center) {
            case 0:
              
              break;
            case -1:
              
              left_index = $rb_minus(left_index, 1);
              right_index = $rb_plus(right_index, 1);
              parent = self.children['$[]'](left_index);
              break;
            default:
              
              overlap_left = self.children['$[]'](left_index).$range().$begin_pos()['$<=>'](r.$begin_pos());
              overlap_right = self.children['$[]']($rb_minus(right_index, 1)).$range().$end_pos()['$<=>'](r.$end_pos());
              if ((($eqeq(center, 1) && ($truthy($rb_le(overlap_left, 0)))) && ($truthy($rb_ge(overlap_right, 0))))) {
                parent = self.children['$[]'](left_index)
              } else {
                
                contained = self.children['$[]'](Opal.Range.$new(left_index,right_index, true));
                fusible = self.$check_fusible(action, ($truthy($rb_lt(overlap_left, 0)) ? (contained.$shift()) : nil), ($truthy($rb_gt(overlap_right, 0)) ? (contained.$pop()) : nil));
              };
          };
          return $hash2(["parent", "sibbling_left", "sibbling_right", "fusible", "child"], {"parent": parent, "sibbling_left": self.children['$[]'](Opal.Range.$new(0,left_index, true)), "sibbling_right": self.children['$[]'](Opal.Range.$new(right_index,self.children.$size(), true)), "fusible": fusible, "child": contained});
        }, 1);
        
        $def(self, '$check_fusible', function $$check_fusible(action, $a) {
          var $post_args, fusible, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          fusible = $post_args;;
          fusible['$compact!']();
          if ($truthy(fusible['$empty?']())) {
            return nil
          };
          $send(fusible, 'each', [], function $$9(child){var self = $$9.$$s == null ? this : $$9.$$s, kind = nil;
            if (self.enforcer == null) self.enforcer = nil;

            
            
            if (child == null) child = nil;;
            kind = (($truthy(action['$insertion?']()) || ($truthy(child['$insertion?']()))) ? ("crossing_insertions") : ("crossing_deletions"));
            return $send(self.enforcer, 'call', [kind], function $$10(){
              return $hash2(["range", "conflict"], {"range": action.$range(), "conflict": child.$range()})}, 0);}, {$$arity: 1, $$s: self});
          return fusible;
        }, -2);
        
        $def(self, '$merge', function $$merge(action) {
          var self = this, $ret_or_1 = nil;

          
          self.$call_enforcer_for_merge(action);
          return self.$with($hash2(["insert_before", "replacement", "insert_after"], {"insert_before": "" + (action.$insert_before()) + (self.$insert_before()), "replacement": ($truthy(($ret_or_1 = action.$replacement())) ? ($ret_or_1) : (self.replacement)), "insert_after": "" + (self.$insert_after()) + (action.$insert_after())})).$combine_children(action.$children());
        }, 1);
        
        $def(self, '$call_enforcer_for_merge', function $$call_enforcer_for_merge(action) {
          var self = this;

          return $send(self.enforcer, 'call', ["different_replacements"], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s;
            if (self.replacement == null) self.replacement = nil;
            if (self.range == null) self.range = nil;

            if ((($truthy(self.replacement) && ($truthy(action.$replacement()))) && ($neqeq(self.replacement, action.$replacement())))) {
              return $hash2(["range", "replacement", "other_replacement"], {"range": self.range, "replacement": action.$replacement(), "other_replacement": self.replacement})
            } else {
              return nil
            }}, {$$arity: 0, $$s: self})
        }, 1);
        return $def(self, '$swallow', function $$swallow(children) {
          var self = this;

          
          $send(self.enforcer, 'call', ["swallowed_insertions"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s, insertions = nil;
            if (self.range == null) self.range = nil;

            
            insertions = $send(children, 'select', [], "insertion?".$to_proc());
            if ($truthy(insertions['$empty?']())) {
              return nil
            } else {
              return $hash2(["range", "conflict"], {"range": self.range, "conflict": $send(insertions, 'map', [], "range".$to_proc())})
            };}, {$$arity: 0, $$s: self});
          return [];
        }, 1);
      })($$('TreeRewriter'), null)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $assign_ivar = Opal.assign_ivar, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $range = Opal.range;

  Opal.add_stubs('attr_reader,freeze,line,alias_method,column,last_line,last_column,with,update_expression,==,class,reduce,map,instance_variables,instance_variable_get,send,inject,to_sym,[]=,[],protected,tap,dup,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Map');

        var $proto = self.$$prototype;

        $proto.node = $proto.expression = nil;
        
        self.$attr_reader("node");
        self.$attr_reader("expression");
        
        $def(self, '$initialize', $assign_ivar("expression"), 0);
        
        $def(self, '$initialize_copy', function $$initialize_copy(other) {
          var $yield = $$initialize_copy.$$p || nil, self = this;

          delete $$initialize_copy.$$p;
          
          $send2(self, $find_super(self, 'initialize_copy', $$initialize_copy, false, true), 'initialize_copy', [other], $yield);
          return (self.node = nil);
        }, 1);
        
        $def(self, '$node=', function $Map_node$eq$1(node) {
          var self = this;

          
          self.node = node;
          self.$freeze();
          return self.node;
        }, 1);
        
        $def(self, '$line', function $$line() {
          var self = this;

          return self.expression.$line()
        }, 0);
        self.$alias_method("first_line", "line");
        
        $def(self, '$column', function $$column() {
          var self = this;

          return self.expression.$column()
        }, 0);
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return self.expression.$last_line()
        }, 0);
        
        $def(self, '$last_column', function $$last_column() {
          var self = this;

          return self.expression.$last_column()
        }, 0);
        
        $def(self, '$with_expression', function $$with_expression(expression_l) {
          var self = this;

          return $send(self, 'with', [], function $$2(map){
            
            
            if (map == null) map = nil;;
            return map.$update_expression(expression_l);}, 1)
        }, 1);
        
        $def(self, '$==', function $Map_$eq_eq$3(other) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = other.$class()['$=='](self.$class())))) {
            return $send(self.$instance_variables(), 'map', [], function $$4(ivar){var self = $$4.$$s == null ? this : $$4.$$s;

              
              
              if (ivar == null) ivar = nil;;
              return self.$instance_variable_get(ivar)['$=='](other.$send("instance_variable_get", ivar));}, {$$arity: 1, $$s: self}).$reduce("&")
          } else {
            return $ret_or_1
          }
        }, 1);
        
        $def(self, '$to_hash', function $$to_hash() {
          var self = this;

          return $send(self.$instance_variables(), 'inject', [$hash2([], {})], function $$5(hash, ivar){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (hash == null) hash = nil;;
            
            if (ivar == null) ivar = nil;;
            if ($eqeq(ivar.$to_sym(), "@node")) {
              return hash;
            };
            hash['$[]='](ivar['$[]']($range(1, -1, false)).$to_sym(), self.$instance_variable_get(ivar));
            return hash;}, {$$arity: 2, $$s: self})
        }, 0);
        self.$protected();
        
        $def(self, '$with', function $Map_with$6() {
          var block = $Map_with$6.$$p || nil, self = this;

          delete $Map_with$6.$$p;
          
          ;
          return $send(self.$dup(), 'tap', [], block.$to_proc());
        }, 0);
        return $def(self, '$update_expression', $assign_ivar("expression"), 0);
      })($nesting[0], null)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/operator"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Operator');

        
        
        self.$attr_reader("operator");
        return $def(self, '$initialize', function $$initialize(operator, expression) {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.operator = operator;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression], null);
        }, 2);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/collection"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Collection');

        
        
        self.$attr_reader("begin");
        self.$attr_reader("end");
        return $def(self, '$initialize', function $$initialize(begin_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 3);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/constant"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $assign_ivar = Opal.assign_ivar;

  Opal.add_stubs('attr_reader,with,update_operator,protected');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Constant');

        
        
        self.$attr_reader("double_colon");
        self.$attr_reader("name");
        self.$attr_reader("operator");
        
        $def(self, '$initialize', function $$initialize(double_colon, name, expression) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [double_colon, name], (self.double_colon = $a[0]), (self.name = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression], null);
        }, 3);
        
        $def(self, '$with_operator', function $$with_operator(operator_l) {
          var self = this;

          return $send(self, 'with', [], function $$1(map){
            
            
            if (map == null) map = nil;;
            return map.$update_operator(operator_l);}, 1)
        }, 1);
        self.$protected();
        return $def(self, '$update_operator', $assign_ivar("operator"), 0);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/variable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $assign_ivar = Opal.assign_ivar;

  Opal.add_stubs('attr_reader,with,update_operator,protected');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Variable');

        
        
        self.$attr_reader("name");
        self.$attr_reader("operator");
        
        $def(self, '$initialize', function $$initialize(name_l, expression_l) {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          if (expression_l == null) expression_l = name_l;;
          self.name = name_l;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, -2);
        
        $def(self, '$with_operator', function $$with_operator(operator_l) {
          var self = this;

          return $send(self, 'with', [], function $$1(map){
            
            
            if (map == null) map = nil;;
            return map.$update_operator(operator_l);}, 1)
        }, 1);
        self.$protected();
        return $def(self, '$update_operator', $assign_ivar("operator"), 0);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/keyword"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Keyword');

        
        
        self.$attr_reader("keyword");
        self.$attr_reader("begin");
        self.$attr_reader("end");
        return $def(self, '$initialize', function $$initialize(keyword_l, begin_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.keyword = keyword_l;
          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 4);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/definition"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader,join');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Definition');

        var $proto = self.$$prototype;

        $proto.keyword = $proto.end = nil;
        
        self.$attr_reader("keyword");
        self.$attr_reader("operator");
        self.$attr_reader("name");
        self.$attr_reader("end");
        return $def(self, '$initialize', function $$initialize(keyword_l, operator_l, name_l, end_l) {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.keyword = keyword_l;
          self.operator = operator_l;
          self.name = name_l;
          self.end = end_l;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.keyword.$join(self.end)], null);
        }, 4);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/method_definition"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('attr_reader,join');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'MethodDefinition');

        var $proto = self.$$prototype;

        $proto.keyword = nil;
        
        self.$attr_reader("keyword");
        self.$attr_reader("operator");
        self.$attr_reader("name");
        self.$attr_reader("end");
        self.$attr_reader("assignment");
        return $def(self, '$initialize', function $$initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l) {
          var $yield = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

          delete $$initialize.$$p;
          
          self.keyword = keyword_l;
          self.operator = operator_l;
          self.name = name_l;
          self.end = end_l;
          self.assignment = assignment_l;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.keyword.$join(($truthy(($ret_or_1 = end_l)) ? ($ret_or_1) : (body_l)))], null);
        }, 6);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/send"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $assign_ivar = Opal.assign_ivar;

  Opal.add_stubs('attr_reader,with,update_operator,protected');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Send');

        
        
        self.$attr_reader("dot");
        self.$attr_reader("selector");
        self.$attr_reader("operator");
        self.$attr_reader("begin");
        self.$attr_reader("end");
        
        $def(self, '$initialize', function $$initialize(dot_l, selector_l, begin_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.dot = dot_l;
          self.selector = selector_l;
          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 5);
        
        $def(self, '$with_operator', function $$with_operator(operator_l) {
          var self = this;

          return $send(self, 'with', [], function $$1(map){
            
            
            if (map == null) map = nil;;
            return map.$update_operator(operator_l);}, 1)
        }, 1);
        self.$protected();
        return $def(self, '$update_operator', $assign_ivar("operator"), 0);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/index"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $assign_ivar = Opal.assign_ivar;

  Opal.add_stubs('attr_reader,with,update_operator,protected');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Index');

        
        
        self.$attr_reader("begin");
        self.$attr_reader("end");
        self.$attr_reader("operator");
        
        $def(self, '$initialize', function $$initialize(begin_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;
          self.operator = nil;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 3);
        
        $def(self, '$with_operator', function $$with_operator(operator_l) {
          var self = this;

          return $send(self, 'with', [], function $$1(map){
            
            
            if (map == null) map = nil;;
            return map.$update_operator(operator_l);}, 1)
        }, 1);
        self.$protected();
        return $def(self, '$update_operator', $assign_ivar("operator"), 0);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/condition"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Condition');

        
        
        self.$attr_reader("keyword");
        self.$attr_reader("begin");
        self.$attr_reader("else");
        self.$attr_reader("end");
        return $def(self, '$initialize', function $$initialize(keyword_l, begin_l, else_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.keyword = keyword_l;
          $a = [begin_l, else_l, end_l], (self.begin = $a[0]), (self["else"] = $a[1]), (self.end = $a[2]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 5);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/ternary"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Ternary');

        
        
        self.$attr_reader("question");
        self.$attr_reader("colon");
        return $def(self, '$initialize', function $$initialize(question_l, colon_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [question_l, colon_l], (self.question = $a[0]), (self.colon = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 3);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/for"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'For');

        
        
        self.$attr_reader("keyword", "in");
        self.$attr_reader("begin", "end");
        return $def(self, '$initialize', function $$initialize(keyword_l, in_l, begin_l, end_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [keyword_l, in_l], (self.keyword = $a[0]), (self["in"] = $a[1]), $a;
          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 5);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/rescue_body"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'RescueBody');

        
        
        self.$attr_reader("keyword");
        self.$attr_reader("assoc");
        self.$attr_reader("begin");
        return $def(self, '$initialize', function $$initialize(keyword_l, assoc_l, begin_l, expression_l) {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.keyword = keyword_l;
          self.assoc = assoc_l;
          self.begin = begin_l;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 4);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/heredoc"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Heredoc');

        
        
        self.$attr_reader("heredoc_body");
        self.$attr_reader("heredoc_end");
        return $def(self, '$initialize', function $$initialize(begin_l, body_l, end_l) {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.heredoc_body = body_l;
          self.heredoc_end = end_l;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [begin_l], null);
        }, 3);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/source/map/objc_kwarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ObjcKwarg');

        
        
        self.$attr_reader("keyword");
        self.$attr_reader("operator");
        self.$attr_reader("argument");
        return $def(self, '$initialize', function $$initialize(keyword_l, operator_l, argument_l, expression_l) {
          var $a, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          $a = [keyword_l, operator_l, argument_l], (self.keyword = $a[0]), (self.operator = $a[1]), (self.argument = $a[2]), $a;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [expression_l], null);
        }, 4);
      })($$('Map'), $$('Map'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/syntax_error"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def;

  Opal.add_stubs('attr_reader,message');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'SyntaxError');

      
      
      self.$attr_reader("diagnostic");
      return $def(self, '$initialize', function $$initialize(diagnostic) {
        var $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        self.diagnostic = diagnostic;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [diagnostic.$message()], null);
      }, 1);
    })($nesting[0], $$('StandardError'))
  })($nesting[0], $nesting)
};

Opal.modules["parser/clobbering_error"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return ($klass($nesting[0], $$('RuntimeError'), 'ClobberingError'), nil)
  })($nesting[0], $nesting)
};

Opal.modules["parser/diagnostic"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $truthy = Opal.truthy, $hash2 = Opal.hash2, $def = Opal.def, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $send = Opal.send, $rb_ge = Opal.rb_ge, $not = Opal.not, $neqeq = Opal.neqeq;

  Opal.add_stubs('freeze,attr_reader,include?,raise,join,inspect,dup,compile,is?,==,line,last_line,+,message,render_line,first_line_only,last_line_only,-,source_buffer,decompose_position,end_pos,>,private,source_line,*,length,each,line_range,intersect,[]=,column_range,size,>=,!,map,name,!=,resize,=~,source,adjust');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Diagnostic');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.reason = $proto["arguments"] = $proto.location = $proto.level = $proto.highlights = nil;
      
      $const_set($nesting[0], 'LEVELS', ["note", "warning", "error", "fatal"].$freeze());
      self.$attr_reader("level", "reason", "arguments");
      self.$attr_reader("location", "highlights");
      
      $def(self, '$initialize', function $$initialize(level, reason, arguments$, location, highlights) {
        var self = this, $ret_or_1 = nil;

        
        
        if (highlights == null) highlights = [];;
        if (!$truthy($$('LEVELS')['$include?'](level))) {
          self.$raise($$('ArgumentError'), "" + ("Diagnostic#level must be one of " + ($$('LEVELS').$join(", ")) + "; ") + ("" + (level.$inspect()) + " provided."))
        };
        if (!$truthy(location)) {
          self.$raise("Expected a location")
        };
        self.level = level;
        self.reason = reason;
        self["arguments"] = ($truthy(($ret_or_1 = arguments$)) ? ($ret_or_1) : ($hash2([], {}))).$dup().$freeze();
        self.location = location;
        self.highlights = highlights.$dup().$freeze();
        return self.$freeze();
      }, -5);
      
      $def(self, '$message', function $$message() {
        var self = this;

        return $$('Messages').$compile(self.reason, self["arguments"])
      }, 0);
      
      $def(self, '$render', function $$render() {
        var $a, $b, self = this, first_line = nil, last_line = nil, num_lines = nil, buffer = nil, last_lineno = nil, last_column = nil;

        if (($eqeq(self.location.$line(), self.location.$last_line()) || ($truthy(self.location['$is?']("\n"))))) {
          return $rb_plus(["" + (self.location) + ": " + (self.level) + ": " + (self.$message())], self.$render_line(self.location))
        } else {
          
          first_line = self.$first_line_only(self.location);
          last_line = self.$last_line_only(self.location);
          num_lines = $rb_plus($rb_minus(self.location.$last_line(), self.location.$line()), 1);
          buffer = self.location.$source_buffer();
          $b = buffer.$decompose_position(self.location.$end_pos()), $a = $to_ary($b), (last_lineno = ($a[0] == null ? nil : $a[0])), (last_column = ($a[1] == null ? nil : $a[1])), $b;
          return $rb_plus($rb_plus(["" + (self.location) + "-" + (last_lineno) + ":" + (last_column) + ": " + (self.level) + ": " + (self.$message())], self.$render_line(first_line, $rb_gt(num_lines, 2), false)), self.$render_line(last_line, false, true));
        }
      }, 0);
      self.$private();
      
      $def(self, '$render_line', function $$render_line(range, ellipsis, range_end) {
        var self = this, source_line = nil, highlight_line = nil;

        
        
        if (ellipsis == null) ellipsis = false;;
        
        if (range_end == null) range_end = false;;
        source_line = range.$source_line();
        highlight_line = $rb_times(" ", source_line.$length());
        $send(self.highlights, 'each', [], function $$1(highlight){var $a, line_range = nil;

          
          
          if (highlight == null) highlight = nil;;
          line_range = range.$source_buffer().$line_range(range.$line());
          if ($truthy((highlight = highlight.$intersect(line_range)))) {
            return ($a = [highlight.$column_range(), $rb_times("~", highlight.$size())], $send(highlight_line, '[]=', $a), $a[$a.length - 1])
          } else {
            return nil
          };}, 1);
        if ($truthy(range['$is?']("\n"))) {
          highlight_line = $rb_plus(highlight_line, "^")
        } else if (($not(range_end) && ($truthy($rb_ge(range.$size(), 1))))) {
          highlight_line['$[]='](range.$column_range(), $rb_plus("^", $rb_times("~", $rb_minus(range.$size(), 1))))
        } else {
          highlight_line['$[]='](range.$column_range(), $rb_times("~", range.$size()))
        };
        if ($truthy(ellipsis)) {
          highlight_line = $rb_plus(highlight_line, "...")
        };
        return $send([source_line, highlight_line], 'map', [], function $$2(line){
          
          
          if (line == null) line = nil;;
          return "" + (range.$source_buffer().$name()) + ":" + (range.$line()) + ": " + (line);}, 1);
      }, -2);
      
      $def(self, '$first_line_only', function $$first_line_only(range) {
        
        if ($neqeq(range.$line(), range.$last_line())) {
          return range.$resize(range.$source()['$=~'](/\n/))
        } else {
          return range
        }
      }, 1);
      return $def(self, '$last_line_only', function $$last_line_only(range) {
        
        if ($neqeq(range.$line(), range.$last_line())) {
          return range.$adjust($hash2(["begin_pos"], {"begin_pos": range.$source()['$=~'](/[^\n]*$/)}))
        } else {
          return range
        }
      }, 1);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/diagnostic/engine"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy;

  Opal.add_stubs('attr_accessor,ignore?,call,raise?,raise,protected,==,level');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Engine');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.consumer = $proto.ignore_warnings = $proto.all_errors_are_fatal = nil;
      
      self.$attr_accessor("consumer");
      self.$attr_accessor("all_errors_are_fatal");
      self.$attr_accessor("ignore_warnings");
      
      $def(self, '$initialize', function $$initialize(consumer) {
        var self = this;

        
        
        if (consumer == null) consumer = nil;;
        self.consumer = consumer;
        self.all_errors_are_fatal = false;
        return (self.ignore_warnings = false);
      }, -1);
      
      $def(self, '$process', function $$process(diagnostic) {
        var self = this;

        
        if (!$truthy(self['$ignore?'](diagnostic))) {
          if ($truthy(self.consumer)) {
            self.consumer.$call(diagnostic)
          }
        };
        if ($truthy(self['$raise?'](diagnostic))) {
          self.$raise($$$($$('Parser'), 'SyntaxError'), diagnostic)
        };
        return self;
      }, 1);
      self.$protected();
      
      $def(self, '$ignore?', function $Engine_ignore$ques$1(diagnostic) {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.ignore_warnings))) {
          return diagnostic.$level()['$==']("warning")
        } else {
          return $ret_or_1
        }
      }, 1);
      return $def(self, '$raise?', function $Engine_raise$ques$2(diagnostic) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.all_errors_are_fatal)) ? (diagnostic.$level()['$==']("error")) : ($ret_or_2))))) {
          return $ret_or_1
        } else {
          return diagnostic.$level()['$==']("fatal")
        }
      }, 1);
    })($$('Diagnostic'), null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/static_environment"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def;

  Opal.add_stubs('reset,[],push,dup,pop,add,to_sym,include?,declare,declared?,empty?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'StaticEnvironment');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.stack = $proto.variables = nil;
      
      $const_set($nesting[0], 'FORWARD_ARGS', "FORWARD_ARGS");
      $const_set($nesting[0], 'ANONYMOUS_BLOCKARG', "ANONYMOUS_BLOCKARG");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        return self.$reset()
      }, 0);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        
        self.variables = $$('Set')['$[]']();
        return (self.stack = []);
      }, 0);
      
      $def(self, '$extend_static', function $$extend_static() {
        var self = this;

        
        self.stack.$push(self.variables);
        self.variables = $$('Set')['$[]']();
        return self;
      }, 0);
      
      $def(self, '$extend_dynamic', function $$extend_dynamic() {
        var self = this;

        
        self.stack.$push(self.variables);
        self.variables = self.variables.$dup();
        return self;
      }, 0);
      
      $def(self, '$unextend', function $$unextend() {
        var self = this;

        
        self.variables = self.stack.$pop();
        return self;
      }, 0);
      
      $def(self, '$declare', function $$declare(name) {
        var self = this;

        
        self.variables.$add(name.$to_sym());
        return self;
      }, 1);
      
      $def(self, '$declared?', function $StaticEnvironment_declared$ques$1(name) {
        var self = this;

        return self.variables['$include?'](name.$to_sym())
      }, 1);
      
      $def(self, '$declare_forward_args', function $$declare_forward_args() {
        var self = this;

        return self.$declare($$('FORWARD_ARGS'))
      }, 0);
      
      $def(self, '$declared_forward_args?', function $StaticEnvironment_declared_forward_args$ques$2() {
        var self = this;

        return self['$declared?']($$('FORWARD_ARGS'))
      }, 0);
      
      $def(self, '$declare_anonymous_blockarg', function $$declare_anonymous_blockarg() {
        var self = this;

        return self.$declare($$('ANONYMOUS_BLOCKARG'))
      }, 0);
      
      $def(self, '$declared_anonymous_blockarg?', function $StaticEnvironment_declared_anonymous_blockarg$ques$3() {
        var self = this;

        return self['$declared?']($$('ANONYMOUS_BLOCKARG'))
      }, 0);
      return $def(self, '$empty?', function $StaticEnvironment_empty$ques$4() {
        var self = this;

        return self.stack['$empty?']()
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/lexer"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $hash = Opal.hash, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $to_ary = Opal.to_ary, $rb_le = Opal.rb_le, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $neqeq = Opal.neqeq, $not = Opal.not, $rb_ge = Opal.rb_ge, $range = Opal.range, $rb_lt = Opal.rb_lt, $gvars = Opal.gvars;

  Opal.add_stubs('attr_accessor,private,_lex_trans_keys=,_lex_key_spans=,_lex_index_offsets=,_lex_indicies=,_lex_trans_targs=,_lex_trans_actions=,_lex_to_state_actions=,_lex_from_state_actions=,_lex_eof_trans=,lex_start=,lex_error=,lex_en_interp_words=,lex_en_interp_string=,lex_en_plain_words=,lex_en_plain_string=,lex_en_interp_backslash_delimited=,lex_en_plain_backslash_delimited=,lex_en_interp_backslash_delimited_words=,lex_en_plain_backslash_delimited_words=,lex_en_regexp_modifiers=,lex_en_expr_variable=,lex_en_expr_fname=,lex_en_expr_endfn=,lex_en_expr_dot=,lex_en_expr_arg=,lex_en_expr_cmdarg=,lex_en_expr_endarg=,lex_en_expr_mid=,lex_en_expr_beg=,lex_en_expr_labelarg=,lex_en_expr_value=,lex_en_expr_end=,lex_en_leading_dot=,lex_en_line_comment=,lex_en_line_begin=,freeze,ord,union,chars,attr_reader,reset,lex_en_line_begin,class,new,source,==,encoding,unpack,[],lex_en_expr_dot,lex_en_expr_fname,lex_en_expr_value,lex_en_expr_beg,lex_en_expr_mid,lex_en_expr_arg,lex_en_expr_cmdarg,lex_en_expr_end,lex_en_expr_endarg,lex_en_expr_endfn,lex_en_expr_labelarg,lex_en_interp_string,lex_en_interp_words,lex_en_plain_string,fetch,invert,push,count,pop,any?,shift,send,+,size,<=,<<,>,-,!=,emit_comment,tok,literal,flush_string,extend_content,emit,heredoc?,saved_herebody_s=,start_interp_brace,[]=,diagnostic,range,str_s,gsub,version?,nest_and_try_closing,heredoc_e,pop_literal,infer_indent_level,!,eof_codepoint?,words?,extend_space,extend_string,active?,>=,slice,start_with?,chr,munge_escape?,match,regexp?,squiggly_heredoc?,supports_line_continuation_via_slash?,include?,scan,join,=~,to_i,stack_pop,emit_table,push_literal,in_argdef,arg_or_cmdarg,<,emit_do,declared?,nil?,last,getbyte,inspect,end_with?,empty?,index,call,Float,to_f,length,lambda,Rational,Complex,each,encode_escape,%,in_kwarg,end_interp_brace_and_try_closing,lexpop,saved_herebody_s,next_state_for_literal,rstrip,&,|,lex_error,protected,force_encoding,process,backslash_delimited?,interpolate?,lex_en_interp_backslash_delimited_words,lex_en_plain_backslash_delimited_words,lex_en_plain_words,lex_en_interp_backslash_delimited,lex_en_plain_backslash_delimited,dedent_level,type,lex_en_regexp_modifiers,upcase');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Lexer');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.source_buffer = $proto.source_pts = $proto.cs = $proto.cmdarg_stack = $proto.cmdarg = $proto.cond_stack = $proto.cond = $proto.dedent_level = $proto.token_queue = $proto.p = $proto.command_start = $proto.herebody_s = $proto.sharp_s = $proto.ts = $proto.te = $proto.stack = $proto.top = $proto.version = $proto.escape_s = $proto.escape = $proto.act = $proto.context = $proto.static_env = $proto.newline_s = $proto.lambda_stack = $proto.paren_nest = $proto.num_digits_s = $proto.num_suffix_s = $proto.num_base = $proto.num_xfrm = $proto.eq_begin_s = $proto.cs_before_block_comment = $proto.tokens = $proto.comments = $proto.diagnostics = $proto.literal_stack = nil;
    
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_trans_keys");
      return self.$private("_lex_trans_keys", "_lex_trans_keys=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_trans_keys=']([0, 0, 101, 101, 103, 103, 105, 105, 110, 110, 69, 69, 78, 78, 68, 68, 95, 95, 95, 95, 0, 26, 0, 127, 0, 127, 0, 127, 0, 127, 0, 45, 0, 120, 0, 120, 0, 92, 0, 120, 0, 120, 0, 45, 0, 120, 0, 120, 67, 99, 45, 45, 0, 92, 0, 120, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 45, 0, 120, 0, 120, 0, 92, 0, 120, 0, 120, 0, 45, 0, 120, 0, 120, 67, 99, 45, 45, 0, 92, 0, 120, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 58, 58, 58, 58, 46, 46, 0, 127, 58, 58, 60, 60, 62, 62, 10, 10, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 115, 115, 99, 99, 117, 117, 101, 101, 108, 116, 101, 101, 115, 115, 115, 115, 105, 105, 108, 108, 105, 105, 108, 108, 58, 58, 0, 127, 10, 10, 0, 127, 9, 92, 10, 10, 9, 92, 58, 58, 98, 98, 101, 101, 103, 103, 105, 105, 110, 110, 0, 127, 61, 61, 9, 92, 9, 92, 9, 92, 9, 92, 9, 92, 10, 10, 0, 127, 0, 127, 61, 126, 93, 93, 0, 127, 0, 127, 10, 10, 34, 34, 10, 10, 39, 39, 0, 127, 10, 96, 96, 96, 0, 45, 0, 120, 0, 120, 0, 92, 0, 120, 0, 120, 0, 45, 0, 120, 0, 120, 67, 99, 45, 45, 0, 92, 0, 120, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 58, 58, 58, 58, 0, 127, 43, 57, 48, 57, 48, 57, 48, 57, 48, 57, 115, 115, 99, 99, 117, 117, 101, 101, 99, 99, 117, 117, 101, 101, 0, 127, 58, 58, 9, 92, 9, 92, 9, 92, 9, 92, 9, 92, 9, 92, 60, 60, 10, 10, 9, 92, 9, 92, 10, 10, 10, 10, 10, 10, 10, 10, 46, 46, 0, 95, 9, 32, 0, 0, 10, 10, 10, 10, 98, 98, 9, 32, 10, 10, 95, 95, 0, 92, 9, 32, 36, 123, 0, 127, 48, 57, 0, 127, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 48, 102, 48, 102, 0, 0, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 0, 45, 10, 10, 0, 92, 48, 123, 48, 102, 48, 102, 48, 102, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 0, 48, 102, 0, 0, 0, 92, 36, 123, 0, 127, 48, 57, 0, 127, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 48, 102, 48, 102, 0, 0, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 0, 45, 10, 10, 0, 92, 48, 123, 48, 102, 48, 102, 48, 102, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 0, 48, 102, 0, 0, 0, 92, 9, 32, 0, 26, 0, 92, 0, 26, 0, 35, 36, 123, 0, 127, 48, 57, 0, 127, 0, 26, 0, 35, 9, 32, 36, 123, 0, 127, 48, 57, 0, 127, 0, 32, 9, 32, 65, 122, 65, 122, 36, 64, 0, 127, 48, 57, 0, 127, 0, 127, 0, 127, 0, 127, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 0, 127, 0, 127, 48, 57, 115, 115, 38, 38, 42, 42, 64, 64, 58, 58, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 93, 93, 10, 10, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 124, 124, 0, 127, 0, 127, 9, 32, 10, 10, 10, 10, 46, 46, 10, 10, 0, 0, 0, 127, 0, 127, 61, 61, 0, 0, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 38, 38, 42, 42, 64, 64, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 93, 93, 10, 10, 124, 124, 0, 126, 0, 127, 0, 61, 9, 61, 9, 61, 0, 0, 9, 61, 9, 62, 46, 46, 46, 46, 58, 58, 9, 32, 0, 0, 0, 127, 0, 0, 9, 124, 0, 0, 10, 10, 10, 10, 0, 0, 9, 61, 58, 58, 60, 60, 62, 62, 9, 32, 10, 10, 0, 127, 102, 102, 101, 101, 110, 110, 104, 104, 0, 127, 0, 127, 0, 127, 0, 0, 0, 127, 10, 10, 0, 123, 9, 32, 10, 10, 10, 10, 10, 10, 0, 0, 111, 111, 0, 0, 0, 127, 0, 127, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 58, 61, 0, 0, 61, 126, 61, 61, 0, 0, 0, 0, 0, 0, 9, 32, 61, 61, 9, 32, 61, 126, 10, 10, 10, 10, 0, 127, 38, 61, 0, 0, 42, 61, 61, 61, 9, 92, 9, 92, 9, 92, 46, 46, 46, 46, 10, 10, 0, 26, 0, 127, 0, 127, 61, 61, 0, 0, 61, 126, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0, 61, 126, 0, 127, 48, 57, 38, 38, 42, 42, 64, 64, 60, 61, 62, 62, 61, 61, 61, 62, 0, 127, 48, 57, 0, 127, 124, 124, 64, 64, 60, 61, 0, 0, 10, 34, 10, 39, 96, 96, 62, 62, 61, 126, 61, 62, 0, 122, 0, 0, 0, 127, 0, 127, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 48, 102, 48, 102, 0, 0, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 48, 102, 48, 102, 0, 0, 0, 45, 10, 10, 0, 92, 48, 123, 48, 102, 48, 102, 48, 102, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 0, 48, 102, 0, 0, 0, 127, 0, 127, 0, 127, 0, 0, 10, 10, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 61, 126, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 61, 124, 0, 92, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 61, 61, 0, 0, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 0, 127, 0, 127, 48, 57, 61, 61, 38, 61, 0, 0, 0, 0, 42, 61, 61, 62, 46, 57, 46, 46, 10, 10, 48, 101, 48, 95, 46, 120, 48, 114, 43, 57, 48, 105, 102, 102, 0, 0, 101, 105, 0, 0, 0, 0, 48, 114, 48, 114, 48, 114, 48, 114, 105, 114, 102, 102, 0, 0, 101, 105, 115, 115, 0, 0, 0, 0, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 46, 114, 48, 114, 46, 114, 48, 114, 58, 58, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 0, 127, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 10, 10, 0, 0, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 9, 92, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 61, 124, 0, 0, 9, 92, 9, 92, 9, 92, 46, 46, 46, 46, 10, 10, 46, 46, 10, 10, 10, 61, 10, 10, 10, 101, 10, 110, 10, 100, 10, 10, 0]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_key_spans");
      return self.$private("_lex_key_spans", "_lex_key_spans=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_key_spans=']([0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 128, 128, 128, 128, 46, 121, 121, 93, 121, 121, 46, 121, 121, 33, 1, 93, 121, 103, 128, 128, 128, 128, 46, 121, 121, 93, 121, 121, 46, 121, 121, 33, 1, 93, 121, 103, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 1, 1, 1, 128, 1, 1, 1, 1, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 128, 1, 128, 84, 1, 84, 1, 1, 1, 1, 1, 1, 128, 1, 84, 84, 84, 84, 84, 1, 128, 128, 66, 1, 128, 128, 1, 1, 1, 1, 128, 87, 1, 46, 121, 121, 93, 121, 121, 46, 121, 121, 33, 1, 93, 121, 103, 128, 128, 128, 128, 128, 128, 1, 1, 128, 15, 10, 10, 10, 10, 1, 1, 1, 1, 1, 1, 1, 128, 1, 84, 84, 84, 84, 84, 84, 1, 1, 84, 84, 1, 1, 1, 1, 1, 96, 24, 0, 1, 1, 1, 24, 1, 1, 93, 24, 88, 128, 10, 128, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 55, 55, 0, 55, 55, 0, 46, 93, 93, 0, 0, 93, 55, 55, 0, 46, 1, 93, 76, 55, 55, 55, 0, 126, 126, 0, 126, 0, 126, 126, 126, 126, 0, 126, 126, 126, 126, 126, 126, 0, 0, 55, 0, 93, 88, 128, 10, 128, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 55, 55, 0, 55, 55, 0, 46, 93, 93, 0, 0, 93, 55, 55, 0, 46, 1, 93, 76, 55, 55, 55, 0, 126, 126, 0, 126, 0, 126, 126, 126, 126, 0, 126, 126, 126, 126, 126, 126, 0, 0, 55, 0, 93, 24, 27, 93, 27, 36, 88, 128, 10, 128, 27, 36, 24, 88, 128, 10, 128, 33, 24, 58, 58, 29, 128, 10, 128, 128, 128, 128, 24, 0, 66, 1, 1, 128, 128, 10, 1, 1, 1, 1, 1, 2, 1, 66, 1, 2, 128, 128, 128, 128, 128, 128, 128, 1, 1, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 1, 128, 128, 24, 1, 1, 1, 1, 0, 128, 128, 1, 0, 24, 0, 66, 1, 1, 1, 1, 1, 2, 1, 66, 1, 2, 128, 1, 1, 1, 127, 128, 62, 53, 53, 0, 53, 54, 1, 1, 1, 24, 0, 128, 0, 116, 0, 1, 1, 0, 53, 1, 1, 1, 24, 1, 128, 1, 1, 1, 1, 128, 128, 128, 0, 128, 1, 124, 24, 1, 1, 1, 0, 1, 0, 128, 128, 24, 0, 1, 1, 1, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 4, 0, 66, 1, 0, 0, 0, 24, 1, 24, 66, 1, 1, 128, 24, 0, 20, 1, 84, 84, 84, 1, 1, 1, 27, 128, 128, 1, 0, 66, 2, 0, 0, 0, 0, 66, 128, 10, 1, 1, 1, 2, 1, 1, 2, 128, 10, 128, 1, 1, 2, 0, 25, 30, 1, 1, 66, 2, 123, 0, 128, 128, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 55, 55, 0, 55, 55, 0, 46, 93, 93, 0, 0, 93, 55, 55, 0, 46, 1, 93, 76, 55, 55, 55, 0, 126, 126, 0, 126, 0, 126, 126, 126, 126, 0, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 0, 55, 0, 128, 128, 128, 0, 1, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 64, 93, 24, 0, 1, 1, 1, 0, 128, 128, 24, 0, 1, 1, 1, 0, 128, 128, 1, 0, 24, 0, 66, 1, 1, 128, 128, 10, 1, 24, 0, 0, 20, 2, 12, 1, 1, 54, 48, 75, 67, 15, 58, 1, 0, 5, 0, 0, 67, 67, 67, 67, 10, 1, 0, 5, 1, 0, 0, 67, 67, 67, 67, 67, 67, 67, 67, 69, 67, 69, 67, 1, 2, 1, 66, 1, 2, 128, 128, 0, 128, 128, 128, 128, 128, 128, 0, 1, 0, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 84, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 64, 0, 84, 84, 84, 1, 1, 1, 1, 1, 52, 1, 92, 101, 91, 1]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_index_offsets");
      return self.$private("_lex_index_offsets", "_lex_index_offsets=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_index_offsets=']([0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 46, 175, 304, 433, 562, 609, 731, 853, 947, 1069, 1191, 1238, 1360, 1482, 1516, 1518, 1612, 1734, 1838, 1967, 2096, 2225, 2354, 2401, 2523, 2645, 2739, 2861, 2983, 3030, 3152, 3274, 3308, 3310, 3404, 3526, 3630, 3759, 3888, 4017, 4146, 4275, 4404, 4533, 4662, 4791, 4920, 5049, 5178, 5307, 5436, 5565, 5567, 5569, 5571, 5700, 5702, 5704, 5706, 5708, 5837, 5966, 6095, 6224, 6353, 6482, 6611, 6740, 6869, 6998, 7127, 7256, 7385, 7514, 7643, 7772, 7901, 8030, 8032, 8034, 8036, 8038, 8048, 8050, 8052, 8054, 8056, 8058, 8060, 8062, 8064, 8193, 8195, 8324, 8409, 8411, 8496, 8498, 8500, 8502, 8504, 8506, 8508, 8637, 8639, 8724, 8809, 8894, 8979, 9064, 9066, 9195, 9324, 9391, 9393, 9522, 9651, 9653, 9655, 9657, 9659, 9788, 9876, 9878, 9925, 10047, 10169, 10263, 10385, 10507, 10554, 10676, 10798, 10832, 10834, 10928, 11050, 11154, 11283, 11412, 11541, 11670, 11799, 11928, 11930, 11932, 12061, 12077, 12088, 12099, 12110, 12121, 12123, 12125, 12127, 12129, 12131, 12133, 12135, 12264, 12266, 12351, 12436, 12521, 12606, 12691, 12776, 12778, 12780, 12865, 12950, 12952, 12954, 12956, 12958, 12960, 13057, 13082, 13083, 13085, 13087, 13089, 13114, 13116, 13118, 13212, 13237, 13326, 13455, 13466, 13595, 13717, 13718, 13719, 13728, 13737, 13738, 13739, 13833, 13834, 13835, 13836, 13930, 13932, 13933, 13934, 13935, 14029, 14085, 14141, 14142, 14198, 14254, 14255, 14302, 14396, 14490, 14491, 14492, 14586, 14642, 14698, 14699, 14746, 14748, 14842, 14919, 14975, 15031, 15087, 15088, 15215, 15342, 15343, 15470, 15471, 15598, 15725, 15852, 15979, 15980, 16107, 16234, 16361, 16488, 16615, 16742, 16743, 16744, 16800, 16801, 16895, 16984, 17113, 17124, 17253, 17375, 17376, 17377, 17386, 17395, 17396, 17397, 17491, 17492, 17493, 17494, 17588, 17590, 17591, 17592, 17593, 17687, 17743, 17799, 17800, 17856, 17912, 17913, 17960, 18054, 18148, 18149, 18150, 18244, 18300, 18356, 18357, 18404, 18406, 18500, 18577, 18633, 18689, 18745, 18746, 18873, 19000, 19001, 19128, 19129, 19256, 19383, 19510, 19637, 19638, 19765, 19892, 20019, 20146, 20273, 20400, 20401, 20402, 20458, 20459, 20553, 20578, 20606, 20700, 20728, 20765, 20854, 20983, 20994, 21123, 21151, 21188, 21213, 21302, 21431, 21442, 21571, 21605, 21630, 21689, 21748, 21778, 21907, 21918, 22047, 22176, 22305, 22434, 22459, 22460, 22527, 22529, 22531, 22660, 22789, 22800, 22802, 22804, 22806, 22808, 22810, 22813, 22815, 22882, 22884, 22887, 23016, 23145, 23274, 23403, 23532, 23661, 23790, 23792, 23794, 23923, 24052, 24181, 24310, 24439, 24568, 24697, 24826, 24955, 25084, 25213, 25342, 25471, 25600, 25729, 25858, 25987, 26116, 26245, 26374, 26503, 26632, 26761, 26890, 27019, 27148, 27277, 27406, 27535, 27664, 27793, 27922, 28051, 28180, 28309, 28438, 28567, 28696, 28825, 28954, 29083, 29212, 29341, 29470, 29599, 29728, 29857, 29986, 30115, 30244, 30373, 30502, 30631, 30760, 30889, 31018, 31147, 31276, 31405, 31534, 31663, 31792, 31921, 32050, 32179, 32308, 32437, 32566, 32695, 32824, 32953, 33082, 33211, 33340, 33469, 33598, 33727, 33856, 33985, 34114, 34243, 34372, 34501, 34503, 34632, 34761, 34786, 34788, 34790, 34792, 34794, 34795, 34924, 35053, 35055, 35056, 35081, 35082, 35149, 35151, 35153, 35155, 35157, 35159, 35162, 35164, 35231, 35233, 35236, 35365, 35367, 35369, 35371, 35499, 35628, 35691, 35745, 35799, 35800, 35854, 35909, 35911, 35913, 35915, 35940, 35941, 36070, 36071, 36188, 36189, 36191, 36193, 36194, 36248, 36250, 36252, 36254, 36279, 36281, 36410, 36412, 36414, 36416, 36418, 36547, 36676, 36805, 36806, 36935, 36937, 37062, 37087, 37089, 37091, 37093, 37094, 37096, 37097, 37226, 37355, 37380, 37381, 37383, 37385, 37387, 37388, 37517, 37646, 37775, 37904, 38033, 38162, 38291, 38420, 38549, 38678, 38807, 38936, 39065, 39194, 39323, 39452, 39581, 39710, 39715, 39716, 39783, 39785, 39786, 39787, 39788, 39813, 39815, 39840, 39907, 39909, 39911, 40040, 40065, 40066, 40087, 40089, 40174, 40259, 40344, 40346, 40348, 40350, 40378, 40507, 40636, 40638, 40639, 40706, 40709, 40710, 40711, 40712, 40713, 40780, 40909, 40920, 40922, 40924, 40926, 40929, 40931, 40933, 40936, 41065, 41076, 41205, 41207, 41209, 41212, 41213, 41239, 41270, 41272, 41274, 41341, 41344, 41468, 41469, 41598, 41727, 41849, 41850, 41851, 41860, 41869, 41870, 41871, 41965, 41966, 41967, 41968, 42062, 42064, 42065, 42066, 42067, 42161, 42217, 42273, 42274, 42330, 42386, 42387, 42434, 42528, 42622, 42623, 42624, 42718, 42774, 42830, 42831, 42878, 42880, 42974, 43051, 43107, 43163, 43219, 43220, 43347, 43474, 43475, 43602, 43603, 43730, 43857, 43984, 44111, 44112, 44239, 44366, 44493, 44620, 44747, 44874, 45001, 45128, 45255, 45382, 45509, 45636, 45763, 45890, 46017, 46144, 46271, 46398, 46525, 46526, 46527, 46583, 46584, 46713, 46842, 46971, 46972, 46974, 46975, 47104, 47233, 47362, 47491, 47620, 47749, 47878, 48007, 48136, 48265, 48394, 48523, 48652, 48781, 48910, 49039, 49168, 49297, 49426, 49555, 49684, 49813, 49942, 50071, 50200, 50329, 50458, 50587, 50716, 50845, 50974, 51103, 51232, 51361, 51490, 51619, 51748, 51877, 52006, 52135, 52264, 52393, 52522, 52651, 52780, 52909, 53038, 53167, 53296, 53425, 53554, 53683, 53812, 53941, 54070, 54199, 54328, 54457, 54586, 54715, 54844, 54911, 55040, 55169, 55298, 55427, 55556, 55685, 55814, 55943, 56072, 56201, 56330, 56459, 56588, 56717, 56846, 56975, 57104, 57233, 57362, 57491, 57620, 57749, 57878, 58007, 58136, 58137, 58202, 58296, 58321, 58322, 58324, 58326, 58328, 58329, 58458, 58587, 58612, 58613, 58615, 58617, 58619, 58620, 58749, 58878, 58880, 58881, 58906, 58907, 58974, 58976, 58978, 59107, 59236, 59247, 59249, 59274, 59275, 59276, 59297, 59300, 59313, 59315, 59317, 59372, 59421, 59497, 59565, 59581, 59640, 59642, 59643, 59649, 59650, 59651, 59719, 59787, 59855, 59923, 59934, 59936, 59937, 59943, 59945, 59946, 59947, 60015, 60083, 60151, 60219, 60287, 60355, 60423, 60491, 60561, 60629, 60699, 60767, 60769, 60772, 60774, 60841, 60843, 60846, 60975, 61104, 61105, 61234, 61363, 61492, 61621, 61750, 61879, 61880, 61882, 61883, 61884, 62013, 62142, 62271, 62400, 62529, 62658, 62787, 62916, 63045, 63174, 63303, 63432, 63561, 63690, 63819, 63948, 64077, 64206, 64335, 64464, 64593, 64722, 64851, 64980, 65109, 65238, 65367, 65496, 65625, 65754, 65883, 66012, 66141, 66270, 66399, 66528, 66657, 66742, 66871, 67000, 67129, 67258, 67387, 67516, 67645, 67774, 67903, 68032, 68161, 68290, 68419, 68548, 68677, 68806, 68935, 69064, 69193, 69322, 69451, 69580, 69709, 69838, 69967, 70096, 70225, 70354, 70483, 70612, 70741, 70870, 70999, 71128, 71257, 71386, 71515, 71644, 71773, 71902, 72031, 72160, 72289, 72418, 72547, 72676, 72805, 72934, 73063, 73192, 73321, 73450, 73579, 73708, 73837, 73966, 74095, 74224, 74353, 74482, 74611, 74740, 74869, 74998, 75127, 75128, 75193, 75194, 75279, 75364, 75449, 75451, 75453, 75455, 75457, 75459, 75512, 75514, 75607, 75709, 75801]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_indicies");
      return self.$private("_lex_indicies", "_lex_indicies=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_indicies=']([1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 0, 0, 10, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 14, 12, 14, 12, 14, 14, 12, 12, 14, 14, 14, 15, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 14, 12, 12, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 14, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 12, 12, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 14, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 12, 14, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 12, 12, 12, 12, 12, 12, 18, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 13, 19, 20, 20, 20, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 20, 19, 22, 22, 22, 19, 22, 22, 22, 22, 22, 23, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 24, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 22, 19, 22, 22, 22, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 26, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 22, 19, 27, 27, 27, 19, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 19, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 29, 27, 19, 30, 30, 30, 19, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 19, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 32, 30, 19, 30, 30, 30, 19, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 19, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 32, 30, 19, 20, 20, 20, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 33, 20, 19, 34, 34, 34, 19, 34, 34, 34, 34, 34, 35, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 19, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 36, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 37, 34, 34, 34, 34, 34, 34, 38, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 39, 34, 19, 34, 34, 34, 19, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 19, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 39, 34, 40, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 41, 19, 41, 19, 19, 42, 42, 42, 19, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 19, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 44, 42, 19, 22, 22, 22, 19, 22, 22, 22, 22, 22, 23, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 26, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 22, 19, 45, 45, 45, 19, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 19, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 45, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 49, 49, 47, 49, 47, 49, 49, 47, 47, 49, 49, 49, 50, 49, 49, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 49, 49, 49, 49, 49, 49, 49, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 49, 47, 47, 48, 49, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 49, 47, 48, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 47, 47, 47, 47, 47, 47, 47, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 47, 47, 47, 47, 49, 47, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 47, 47, 47, 47, 47, 49, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 47, 47, 47, 47, 47, 47, 53, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 47, 48, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 47, 47, 48, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 47, 48, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 47, 47, 47, 47, 47, 48, 54, 55, 55, 55, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 55, 54, 57, 57, 57, 54, 57, 57, 57, 57, 57, 58, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 54, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 59, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 60, 57, 54, 57, 57, 57, 54, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 54, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 61, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 60, 57, 54, 62, 62, 62, 54, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 54, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 64, 62, 54, 65, 65, 65, 54, 65, 65, 65, 65, 65, 66, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 54, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 67, 65, 54, 65, 65, 65, 54, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 54, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 67, 65, 54, 55, 55, 55, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 68, 55, 54, 69, 69, 69, 54, 69, 69, 69, 69, 69, 70, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 54, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 71, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 72, 69, 69, 69, 69, 69, 69, 73, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 74, 69, 54, 69, 69, 69, 54, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 54, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 74, 69, 75, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 76, 54, 76, 54, 54, 77, 77, 77, 54, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 54, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 79, 77, 54, 57, 57, 57, 54, 57, 57, 57, 57, 57, 58, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 54, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 61, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 60, 57, 54, 80, 80, 80, 54, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 54, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 80, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 84, 84, 82, 84, 82, 84, 84, 82, 82, 84, 84, 84, 85, 84, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 84, 84, 84, 84, 84, 84, 84, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 84, 82, 82, 83, 84, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 82, 82, 84, 82, 83, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 82, 82, 82, 82, 82, 82, 82, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 82, 82, 82, 82, 84, 82, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 82, 82, 82, 82, 82, 84, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 82, 82, 82, 82, 82, 82, 88, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 82, 82, 82, 83, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 82, 82, 82, 82, 83, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 82, 82, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 82, 82, 82, 83, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 82, 82, 82, 82, 82, 83, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 91, 91, 89, 91, 89, 91, 91, 89, 89, 91, 91, 91, 92, 91, 91, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 91, 91, 91, 91, 91, 91, 91, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 91, 89, 89, 90, 91, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 89, 89, 91, 89, 90, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 89, 89, 89, 89, 89, 89, 89, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 89, 89, 89, 89, 91, 89, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 89, 89, 89, 89, 89, 91, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 89, 89, 89, 89, 89, 89, 95, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 89, 89, 89, 90, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 89, 89, 89, 89, 90, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 89, 89, 89, 90, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 89, 89, 89, 89, 89, 90, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 97, 97, 98, 97, 98, 97, 97, 98, 98, 97, 97, 97, 99, 97, 97, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 97, 97, 97, 97, 97, 97, 97, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 98, 97, 98, 98, 96, 97, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 98, 98, 98, 97, 98, 96, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 97, 98, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 98, 98, 98, 98, 98, 98, 102, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 98, 98, 98, 98, 101, 98, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 98, 98, 98, 98, 98, 101, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 98, 98, 98, 98, 98, 98, 98, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 98, 98, 98, 98, 103, 98, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 98, 98, 98, 98, 98, 103, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 104, 104, 104, 104, 104, 104, 104, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 104, 104, 104, 104, 105, 104, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 104, 104, 104, 104, 104, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 107, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 106, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 110, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 111, 108, 108, 108, 108, 110, 108, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 108, 108, 108, 108, 109, 108, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 108, 108, 108, 108, 108, 109, 111, 108, 108, 112, 113, 108, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 116, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 114, 114, 114, 114, 116, 114, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 114, 114, 114, 114, 115, 114, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 114, 114, 114, 114, 114, 115, 117, 114, 119, 118, 120, 118, 121, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 123, 118, 123, 123, 123, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 123, 118, 118, 118, 118, 124, 125, 118, 126, 118, 127, 128, 129, 130, 131, 124, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 132, 118, 133, 129, 134, 135, 118, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 136, 137, 129, 138, 122, 118, 122, 122, 122, 122, 122, 122, 122, 122, 139, 122, 122, 122, 122, 122, 122, 122, 122, 140, 122, 122, 141, 122, 142, 122, 122, 122, 143, 144, 118, 138, 118, 122, 118, 118, 118, 118, 118, 118, 118, 118, 118, 145, 118, 145, 145, 145, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 145, 118, 118, 118, 118, 146, 147, 118, 148, 118, 149, 150, 151, 152, 153, 146, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 154, 118, 155, 151, 156, 157, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 158, 159, 151, 120, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 160, 115, 115, 115, 115, 115, 115, 115, 115, 161, 115, 115, 162, 115, 163, 115, 115, 115, 164, 165, 118, 120, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 166, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 167, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 168, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 169, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 170, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 166, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 171, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 172, 115, 115, 115, 115, 115, 115, 115, 173, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 174, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 175, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 166, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 176, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 166, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 177, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 178, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 116, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 118, 118, 118, 118, 116, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 115, 118, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 170, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 115, 180, 179, 181, 179, 182, 179, 151, 179, 183, 179, 179, 179, 179, 179, 179, 179, 184, 179, 185, 179, 186, 179, 151, 179, 187, 179, 151, 179, 188, 179, 182, 179, 190, 189, 191, 191, 191, 191, 191, 191, 191, 191, 191, 193, 191, 193, 193, 193, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 193, 191, 191, 191, 191, 191, 191, 191, 194, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 191, 195, 191, 191, 192, 191, 192, 192, 192, 196, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 191, 191, 191, 191, 191, 192, 197, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 199, 191, 199, 199, 199, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 199, 191, 191, 191, 191, 191, 191, 191, 200, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 191, 201, 191, 191, 198, 191, 198, 198, 198, 202, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 191, 191, 191, 191, 191, 198, 204, 203, 204, 204, 204, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 204, 203, 203, 203, 203, 203, 203, 203, 205, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 206, 203, 207, 203, 208, 203, 208, 208, 208, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 208, 203, 203, 203, 203, 203, 203, 203, 209, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 210, 203, 211, 212, 214, 213, 215, 213, 216, 213, 217, 213, 218, 213, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 220, 220, 220, 220, 220, 220, 220, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 220, 220, 220, 220, 220, 220, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 220, 220, 220, 220, 220, 219, 221, 211, 222, 223, 222, 222, 222, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 222, 211, 211, 224, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 226, 211, 227, 228, 227, 227, 227, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 227, 211, 211, 229, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 231, 211, 233, 234, 233, 233, 233, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 233, 232, 232, 235, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 237, 232, 239, 240, 239, 239, 239, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 239, 238, 238, 241, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 243, 238, 239, 244, 239, 239, 239, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 239, 238, 238, 241, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 243, 238, 223, 211, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 247, 247, 245, 247, 245, 247, 247, 245, 245, 247, 247, 247, 248, 247, 247, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 247, 247, 247, 247, 247, 247, 247, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 245, 247, 245, 245, 246, 247, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 245, 245, 245, 247, 245, 246, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 245, 245, 245, 245, 245, 245, 245, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 245, 245, 245, 245, 247, 245, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 245, 245, 245, 245, 245, 247, 250, 247, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 247, 245, 250, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 252, 245, 245, 245, 245, 253, 245, 245, 245, 245, 245, 254, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 221, 245, 245, 245, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 245, 245, 245, 245, 251, 255, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 245, 245, 245, 254, 245, 251, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 258, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 257, 257, 257, 257, 257, 257, 257, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 257, 257, 257, 257, 256, 257, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 257, 257, 257, 257, 257, 256, 260, 259, 263, 262, 258, 257, 263, 264, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 252, 245, 245, 245, 245, 253, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 245, 245, 245, 245, 251, 255, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 245, 245, 245, 245, 245, 251, 266, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 263, 265, 263, 266, 267, 268, 268, 268, 267, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 267, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 269, 268, 267, 270, 270, 270, 267, 270, 270, 270, 270, 270, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 267, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 272, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 273, 270, 267, 270, 270, 270, 267, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 267, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 274, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 273, 270, 267, 275, 275, 275, 267, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 267, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 276, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 277, 275, 267, 278, 278, 278, 267, 278, 278, 278, 278, 278, 279, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 267, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 280, 278, 267, 278, 278, 278, 267, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 267, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 280, 278, 267, 268, 268, 268, 267, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 267, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 281, 268, 267, 282, 282, 282, 267, 282, 282, 282, 282, 282, 283, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 267, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 284, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 285, 282, 282, 282, 282, 282, 282, 286, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 287, 282, 267, 282, 282, 282, 267, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 267, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 287, 282, 288, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 289, 267, 289, 267, 267, 290, 290, 290, 267, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 267, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 291, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 292, 290, 267, 270, 270, 270, 267, 270, 270, 270, 270, 270, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 267, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 274, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 273, 270, 267, 293, 293, 293, 267, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 267, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 293, 293, 293, 293, 293, 293, 293, 294, 294, 294, 294, 294, 294, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 294, 294, 294, 294, 294, 294, 293, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 296, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 211, 211, 298, 211, 296, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 211, 211, 211, 211, 295, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 211, 211, 211, 211, 211, 295, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 296, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 245, 245, 298, 245, 296, 245, 295, 295, 295, 295, 295, 295, 299, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 295, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 245, 295, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 296, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 245, 245, 298, 245, 296, 245, 295, 295, 295, 295, 295, 295, 295, 295, 300, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 295, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 245, 295, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 296, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 245, 245, 298, 245, 296, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 301, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 295, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 245, 295, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 296, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 245, 245, 298, 245, 296, 245, 295, 295, 295, 301, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 295, 245, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 245, 245, 245, 245, 245, 295, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 304, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 305, 302, 302, 302, 302, 304, 302, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 302, 302, 302, 302, 303, 302, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 302, 302, 302, 302, 302, 303, 305, 302, 302, 306, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 307, 307, 307, 307, 307, 307, 307, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 307, 307, 307, 307, 308, 307, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 307, 307, 307, 307, 307, 308, 310, 309, 310, 309, 309, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 309, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 309, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 309, 314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 313, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 313, 317, 316, 318, 316, 319, 316, 320, 316, 322, 321, 323, 321, 324, 321, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 307, 307, 307, 307, 307, 307, 307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 307, 307, 307, 307, 325, 307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 307, 307, 307, 307, 307, 325, 326, 313, 327, 328, 327, 327, 327, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 327, 313, 313, 329, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 330, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 331, 313, 332, 333, 332, 332, 332, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 332, 313, 313, 334, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 335, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 336, 313, 338, 339, 338, 338, 338, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 338, 337, 337, 340, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 341, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 342, 337, 344, 345, 344, 344, 344, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 344, 343, 343, 346, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 347, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 348, 343, 344, 345, 344, 344, 344, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 344, 343, 343, 346, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 349, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 348, 343, 344, 350, 344, 344, 344, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 344, 343, 343, 346, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 347, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 348, 343, 351, 313, 328, 313, 353, 354, 353, 353, 353, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 353, 352, 352, 355, 352, 352, 356, 352, 352, 352, 352, 352, 352, 352, 357, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 352, 358, 352, 360, 354, 360, 360, 360, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 360, 359, 359, 355, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 359, 358, 359, 363, 362, 365, 364, 366, 361, 367, 361, 368, 352, 370, 369, 369, 369, 370, 369, 369, 369, 369, 371, 372, 371, 371, 371, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 370, 369, 369, 369, 369, 369, 371, 369, 369, 373, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 374, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 375, 369, 369, 376, 369, 371, 377, 371, 371, 371, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 371, 377, 378, 379, 380, 381, 382, 384, 383, 386, 387, 386, 386, 386, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 386, 385, 372, 383, 388, 383, 390, 389, 389, 389, 390, 389, 389, 389, 389, 391, 392, 391, 391, 391, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 390, 389, 389, 389, 389, 389, 391, 389, 389, 393, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 394, 389, 391, 395, 391, 391, 391, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 391, 395, 397, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 398, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 399, 396, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 400, 400, 400, 400, 400, 400, 400, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 400, 400, 400, 400, 13, 400, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 400, 400, 400, 400, 400, 13, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 400, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 401, 401, 401, 401, 401, 401, 401, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 401, 401, 401, 401, 17, 401, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 401, 401, 401, 401, 401, 17, 404, 403, 403, 403, 404, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 404, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 405, 405, 405, 405, 405, 405, 405, 405, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 406, 403, 403, 403, 403, 403, 403, 403, 403, 403, 407, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 408, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 409, 403, 403, 410, 403, 411, 412, 414, 414, 414, 414, 414, 414, 414, 414, 413, 415, 415, 415, 415, 415, 415, 415, 415, 413, 413, 416, 416, 42, 42, 42, 416, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 416, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 417, 42, 418, 419, 420, 420, 42, 42, 42, 420, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 420, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 421, 42, 41, 420, 422, 423, 424, 424, 27, 27, 27, 424, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 424, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 425, 27, 426, 426, 426, 426, 426, 426, 426, 426, 426, 426, 424, 424, 424, 424, 424, 424, 424, 426, 426, 426, 426, 426, 426, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 426, 426, 426, 426, 426, 426, 424, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 427, 427, 427, 427, 427, 427, 427, 428, 428, 428, 428, 428, 428, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 427, 428, 428, 428, 428, 428, 428, 427, 427, 429, 429, 429, 429, 429, 429, 429, 429, 429, 429, 420, 420, 420, 420, 420, 420, 420, 429, 429, 429, 429, 429, 429, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 429, 429, 429, 429, 429, 429, 420, 431, 431, 431, 431, 431, 431, 431, 431, 431, 431, 430, 430, 430, 430, 430, 430, 430, 431, 431, 431, 431, 431, 431, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 431, 431, 431, 431, 431, 431, 430, 430, 420, 20, 20, 20, 420, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 420, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 432, 20, 416, 27, 27, 27, 416, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 416, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 29, 27, 416, 433, 433, 433, 416, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 416, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 434, 433, 435, 436, 436, 433, 433, 433, 436, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 436, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 437, 433, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 436, 436, 436, 436, 436, 436, 436, 438, 438, 438, 438, 438, 438, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 438, 438, 438, 438, 438, 438, 436, 440, 440, 440, 440, 440, 440, 440, 440, 440, 440, 439, 439, 439, 439, 439, 439, 439, 440, 440, 440, 440, 440, 440, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 440, 440, 440, 440, 440, 440, 439, 439, 436, 20, 20, 20, 436, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 436, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 432, 20, 441, 436, 436, 27, 27, 27, 436, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 436, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 29, 27, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 442, 442, 442, 442, 442, 442, 442, 443, 443, 443, 443, 443, 443, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 443, 443, 443, 443, 443, 443, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 444, 442, 445, 445, 445, 445, 445, 445, 445, 445, 445, 445, 442, 442, 442, 442, 442, 442, 442, 445, 445, 445, 445, 445, 445, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 445, 445, 445, 445, 445, 445, 442, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 442, 442, 442, 442, 442, 442, 442, 446, 446, 446, 446, 446, 446, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 446, 446, 446, 446, 446, 446, 442, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 442, 442, 442, 442, 442, 442, 442, 447, 447, 447, 447, 447, 447, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 447, 447, 447, 447, 447, 447, 442, 448, 451, 450, 450, 450, 451, 450, 450, 450, 450, 452, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 451, 450, 450, 450, 450, 450, 452, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 453, 453, 453, 453, 453, 453, 453, 453, 453, 453, 450, 450, 450, 450, 450, 450, 450, 453, 453, 453, 453, 453, 453, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 453, 453, 453, 453, 453, 453, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 454, 450, 451, 450, 450, 450, 451, 450, 450, 450, 450, 449, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 451, 450, 450, 450, 450, 450, 449, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 450, 450, 450, 450, 450, 450, 450, 455, 455, 455, 455, 455, 455, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 455, 455, 455, 455, 455, 455, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 456, 450, 449, 451, 455, 455, 455, 451, 455, 455, 455, 455, 449, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 451, 455, 455, 455, 455, 455, 449, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 449, 455, 457, 451, 458, 458, 458, 451, 458, 458, 458, 458, 452, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 452, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 449, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 449, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 449, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 455, 455, 455, 455, 455, 455, 455, 455, 455, 455, 458, 458, 458, 458, 458, 458, 458, 455, 455, 455, 455, 455, 455, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 455, 455, 455, 455, 455, 455, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 458, 458, 458, 458, 458, 458, 458, 460, 460, 460, 460, 460, 460, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 460, 460, 460, 460, 460, 460, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 453, 453, 453, 453, 453, 453, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 462, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 458, 458, 458, 458, 458, 458, 458, 463, 463, 463, 463, 463, 463, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 463, 463, 463, 463, 463, 463, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 458, 458, 458, 458, 458, 458, 458, 464, 464, 464, 464, 464, 464, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 464, 464, 464, 464, 464, 464, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 465, 465, 465, 465, 465, 465, 465, 465, 465, 465, 458, 458, 458, 458, 458, 458, 458, 465, 465, 465, 465, 465, 465, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 465, 465, 465, 465, 465, 465, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 466, 466, 466, 466, 466, 466, 466, 466, 466, 466, 458, 458, 458, 458, 458, 458, 458, 466, 466, 466, 466, 466, 466, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 466, 466, 466, 466, 466, 466, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 459, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 461, 458, 451, 458, 458, 458, 451, 458, 458, 458, 458, 449, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 451, 458, 458, 458, 458, 458, 449, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 467, 467, 467, 467, 467, 467, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 449, 458, 468, 469, 471, 471, 471, 471, 471, 471, 471, 471, 471, 471, 470, 470, 470, 470, 470, 470, 470, 471, 471, 471, 471, 471, 471, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 471, 471, 471, 471, 471, 471, 470, 470, 473, 472, 472, 472, 473, 472, 472, 472, 472, 472, 474, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 473, 472, 472, 472, 472, 472, 472, 472, 472, 475, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 476, 472, 478, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 479, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 480, 477, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 481, 481, 481, 481, 481, 481, 481, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 481, 481, 481, 481, 48, 481, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 481, 481, 481, 481, 481, 48, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 481, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 482, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 482, 482, 482, 482, 482, 482, 482, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 482, 482, 482, 482, 52, 482, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 482, 482, 482, 482, 482, 52, 485, 484, 484, 484, 485, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 485, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 486, 486, 486, 486, 486, 486, 486, 486, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 487, 484, 484, 484, 484, 484, 484, 484, 484, 484, 488, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 489, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 484, 490, 484, 484, 491, 484, 492, 493, 495, 495, 495, 495, 495, 495, 495, 495, 494, 496, 496, 496, 496, 496, 496, 496, 496, 494, 494, 497, 497, 77, 77, 77, 497, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 497, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 498, 77, 499, 500, 501, 501, 77, 77, 77, 501, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 501, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 502, 77, 76, 501, 503, 504, 505, 505, 62, 62, 62, 505, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 505, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 506, 62, 507, 507, 507, 507, 507, 507, 507, 507, 507, 507, 505, 505, 505, 505, 505, 505, 505, 507, 507, 507, 507, 507, 507, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 505, 507, 507, 507, 507, 507, 507, 505, 509, 509, 509, 509, 509, 509, 509, 509, 509, 509, 508, 508, 508, 508, 508, 508, 508, 509, 509, 509, 509, 509, 509, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 508, 509, 509, 509, 509, 509, 509, 508, 508, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 501, 501, 501, 501, 501, 501, 501, 510, 510, 510, 510, 510, 510, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 501, 510, 510, 510, 510, 510, 510, 501, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 511, 511, 511, 511, 511, 511, 511, 512, 512, 512, 512, 512, 512, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 512, 512, 512, 512, 512, 512, 511, 511, 501, 55, 55, 55, 501, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 501, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 513, 55, 497, 62, 62, 62, 497, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 497, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 64, 62, 497, 514, 514, 514, 497, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 497, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 515, 514, 516, 517, 517, 514, 514, 514, 517, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 517, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 514, 518, 514, 519, 519, 519, 519, 519, 519, 519, 519, 519, 519, 517, 517, 517, 517, 517, 517, 517, 519, 519, 519, 519, 519, 519, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 519, 519, 519, 519, 519, 519, 517, 521, 521, 521, 521, 521, 521, 521, 521, 521, 521, 520, 520, 520, 520, 520, 520, 520, 521, 521, 521, 521, 521, 521, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 521, 521, 521, 521, 521, 521, 520, 520, 517, 55, 55, 55, 517, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 517, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 513, 55, 522, 517, 517, 62, 62, 62, 517, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 517, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 64, 62, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 523, 523, 523, 523, 523, 523, 523, 524, 524, 524, 524, 524, 524, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 524, 524, 524, 524, 524, 524, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 525, 523, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 523, 523, 523, 523, 523, 523, 523, 526, 526, 526, 526, 526, 526, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 526, 526, 526, 526, 526, 526, 523, 527, 527, 527, 527, 527, 527, 527, 527, 527, 527, 523, 523, 523, 523, 523, 523, 523, 527, 527, 527, 527, 527, 527, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 527, 527, 527, 527, 527, 527, 523, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 523, 523, 523, 523, 523, 523, 523, 528, 528, 528, 528, 528, 528, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 523, 528, 528, 528, 528, 528, 528, 523, 529, 532, 531, 531, 531, 532, 531, 531, 531, 531, 533, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 532, 531, 531, 531, 531, 531, 533, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 534, 534, 534, 534, 534, 534, 534, 534, 534, 534, 531, 531, 531, 531, 531, 531, 531, 534, 534, 534, 534, 534, 534, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 534, 534, 534, 534, 534, 534, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 535, 531, 532, 531, 531, 531, 532, 531, 531, 531, 531, 530, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 532, 531, 531, 531, 531, 531, 530, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 531, 531, 531, 531, 531, 531, 531, 536, 536, 536, 536, 536, 536, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 536, 536, 536, 536, 536, 536, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 537, 531, 530, 532, 536, 536, 536, 532, 536, 536, 536, 536, 530, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 532, 536, 536, 536, 536, 536, 530, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 530, 536, 538, 532, 539, 539, 539, 532, 539, 539, 539, 539, 533, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 533, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 530, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 530, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 530, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 539, 539, 539, 539, 539, 539, 539, 536, 536, 536, 536, 536, 536, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 536, 536, 536, 536, 536, 536, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 539, 539, 539, 539, 539, 539, 539, 541, 541, 541, 541, 541, 541, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 541, 541, 541, 541, 541, 541, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 534, 534, 534, 534, 534, 534, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 543, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 544, 544, 544, 544, 544, 544, 544, 544, 544, 544, 539, 539, 539, 539, 539, 539, 539, 544, 544, 544, 544, 544, 544, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 544, 544, 544, 544, 544, 544, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 545, 545, 545, 545, 545, 545, 545, 545, 545, 545, 539, 539, 539, 539, 539, 539, 539, 545, 545, 545, 545, 545, 545, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 545, 545, 545, 545, 545, 545, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 539, 539, 539, 539, 539, 539, 539, 546, 546, 546, 546, 546, 546, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 546, 546, 546, 546, 546, 546, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 547, 547, 547, 547, 547, 547, 547, 547, 547, 547, 539, 539, 539, 539, 539, 539, 539, 547, 547, 547, 547, 547, 547, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 547, 547, 547, 547, 547, 547, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 540, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 542, 539, 532, 539, 539, 539, 532, 539, 539, 539, 539, 530, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 532, 539, 539, 539, 539, 539, 530, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 548, 548, 548, 548, 548, 548, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 539, 530, 539, 549, 550, 552, 552, 552, 552, 552, 552, 552, 552, 552, 552, 551, 551, 551, 551, 551, 551, 551, 552, 552, 552, 552, 552, 552, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 551, 552, 552, 552, 552, 552, 552, 551, 551, 554, 553, 553, 553, 554, 553, 553, 553, 553, 555, 556, 555, 555, 555, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 554, 553, 553, 553, 553, 553, 555, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 557, 553, 555, 558, 555, 555, 555, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 558, 555, 558, 559, 560, 560, 560, 559, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 559, 560, 562, 561, 561, 561, 562, 561, 561, 561, 561, 561, 563, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 562, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 564, 561, 565, 566, 566, 566, 565, 566, 566, 566, 566, 566, 567, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 565, 566, 569, 568, 568, 568, 569, 568, 568, 568, 568, 568, 570, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 568, 569, 568, 568, 568, 568, 568, 568, 568, 568, 571, 568, 573, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 574, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 572, 575, 572, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 576, 576, 576, 576, 576, 576, 576, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 576, 576, 576, 576, 83, 576, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 576, 576, 576, 576, 576, 83, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 576, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 577, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 577, 577, 577, 577, 577, 577, 577, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 577, 577, 577, 577, 87, 577, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 577, 577, 577, 577, 577, 87, 579, 578, 578, 578, 579, 578, 578, 578, 578, 578, 580, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 579, 578, 582, 581, 581, 581, 582, 581, 581, 581, 581, 583, 584, 583, 583, 583, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 582, 581, 581, 581, 581, 581, 583, 581, 581, 585, 581, 583, 586, 583, 583, 583, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 583, 586, 588, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 589, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 590, 587, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 591, 591, 591, 591, 591, 591, 591, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 591, 591, 591, 591, 90, 591, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 591, 591, 591, 591, 591, 90, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 591, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 592, 592, 592, 592, 592, 592, 592, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 592, 592, 592, 592, 94, 592, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 592, 592, 592, 592, 592, 94, 594, 593, 593, 593, 594, 593, 593, 593, 593, 595, 596, 595, 595, 595, 593, 593, 593, 593, 593, 593, 593, 593, 593, 593, 593, 593, 594, 593, 593, 593, 593, 593, 595, 593, 595, 597, 595, 595, 595, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 595, 597, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 598, 598, 598, 598, 598, 598, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 598, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 600, 600, 600, 600, 600, 600, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 600, 601, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 602, 98, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 603, 603, 603, 603, 603, 603, 603, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 603, 603, 603, 603, 96, 603, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 603, 603, 603, 603, 603, 96, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 603, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 604, 604, 604, 604, 604, 604, 604, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 604, 604, 604, 604, 101, 604, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 604, 604, 604, 604, 604, 101, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 605, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 605, 605, 605, 605, 605, 605, 605, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 605, 605, 605, 605, 103, 605, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 605, 605, 605, 605, 605, 103, 607, 608, 608, 608, 607, 608, 608, 608, 608, 609, 610, 609, 609, 609, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 607, 608, 608, 608, 608, 608, 609, 611, 608, 612, 613, 614, 615, 608, 608, 608, 616, 617, 608, 617, 608, 618, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 619, 608, 620, 621, 622, 608, 608, 623, 624, 623, 623, 625, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 626, 627, 608, 618, 628, 618, 629, 630, 631, 632, 633, 634, 606, 606, 635, 606, 606, 606, 636, 637, 638, 606, 606, 639, 640, 641, 642, 606, 643, 606, 644, 606, 608, 645, 608, 617, 608, 606, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 647, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 646, 646, 646, 647, 646, 647, 646, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 646, 646, 646, 646, 606, 646, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 646, 646, 646, 646, 646, 606, 609, 648, 609, 609, 609, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 648, 609, 648, 649, 618, 650, 650, 618, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 618, 650, 651, 652, 653, 654, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 105, 105, 655, 105, 655, 105, 105, 655, 655, 105, 105, 105, 657, 105, 105, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 105, 105, 105, 105, 105, 105, 105, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 655, 105, 655, 655, 656, 105, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 655, 655, 655, 105, 655, 656, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 659, 659, 659, 659, 659, 659, 659, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 659, 659, 659, 659, 656, 659, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 656, 659, 659, 659, 659, 659, 656, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 659, 660, 650, 618, 650, 618, 650, 618, 650, 662, 661, 618, 663, 650, 618, 650, 664, 618, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 618, 655, 618, 650, 618, 618, 650, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 647, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 646, 646, 646, 647, 646, 647, 646, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 646, 646, 646, 646, 623, 646, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 646, 646, 646, 646, 646, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 623, 666, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 623, 623, 623, 667, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 623, 623, 623, 623, 623, 668, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 669, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 670, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 647, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 647, 665, 647, 665, 623, 623, 623, 669, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 623, 665, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 665, 665, 665, 665, 665, 623, 664, 655, 610, 655, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 672, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 673, 674, 606, 606, 606, 606, 606, 675, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 676, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 677, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 678, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 679, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 680, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 681, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 682, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 683, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 684, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 685, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 686, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 682, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 687, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 686, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 688, 606, 689, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 690, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 691, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 692, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 693, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 694, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 695, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 696, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 697, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 698, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 699, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 700, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 701, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 691, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 702, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 703, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 647, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 704, 704, 704, 647, 704, 647, 704, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 704, 704, 704, 704, 606, 704, 606, 606, 606, 606, 606, 606, 606, 606, 705, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 704, 704, 704, 704, 704, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 706, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 707, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 708, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 709, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 710, 606, 711, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 712, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 684, 606, 606, 606, 713, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 714, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 715, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 700, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 716, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 638, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 698, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 717, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 718, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 719, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 700, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 720, 606, 606, 606, 721, 606, 606, 606, 606, 606, 722, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 722, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 723, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 724, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 725, 726, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 727, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 700, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 728, 606, 606, 729, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 684, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 695, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 730, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 731, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 713, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 732, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 638, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 733, 606, 606, 606, 606, 606, 606, 606, 606, 606, 727, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 695, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 734, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 735, 606, 606, 606, 606, 606, 606, 606, 736, 606, 606, 606, 606, 606, 606, 606, 737, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 713, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 701, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 721, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 738, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 695, 606, 606, 606, 719, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 739, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 740, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 647, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 647, 671, 647, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 606, 671, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 689, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 671, 671, 671, 671, 671, 606, 618, 650, 742, 743, 743, 743, 742, 743, 743, 743, 743, 744, 743, 744, 744, 744, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 742, 743, 743, 743, 743, 743, 744, 743, 743, 745, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 746, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 743, 747, 743, 743, 741, 743, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 741, 743, 743, 743, 743, 743, 741, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 110, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 748, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 111, 748, 748, 748, 748, 110, 748, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 748, 748, 748, 748, 109, 748, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 748, 748, 748, 748, 748, 109, 744, 749, 744, 744, 744, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 749, 744, 749, 750, 751, 752, 753, 754, 748, 755, 748, 756, 758, 759, 759, 759, 758, 759, 759, 759, 759, 760, 761, 760, 760, 760, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 758, 759, 759, 759, 759, 759, 760, 762, 759, 763, 759, 764, 765, 759, 759, 759, 766, 767, 759, 767, 759, 764, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 768, 769, 770, 759, 759, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 772, 773, 759, 764, 757, 764, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 759, 774, 759, 767, 759, 757, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 776, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 775, 775, 775, 775, 775, 776, 775, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 775, 775, 775, 775, 757, 775, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 775, 775, 775, 775, 775, 757, 778, 777, 779, 760, 780, 760, 760, 760, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 780, 760, 780, 781, 764, 782, 782, 764, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 782, 764, 782, 783, 784, 785, 786, 764, 782, 764, 782, 764, 782, 764, 787, 782, 764, 782, 789, 764, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 764, 788, 764, 782, 764, 764, 782, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 776, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 790, 790, 790, 790, 790, 776, 790, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 790, 790, 790, 790, 771, 790, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 790, 790, 790, 790, 790, 771, 789, 788, 761, 788, 764, 782, 792, 791, 791, 791, 792, 791, 791, 791, 791, 793, 794, 793, 793, 793, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 792, 791, 791, 791, 791, 791, 793, 791, 791, 795, 791, 120, 796, 791, 797, 791, 798, 120, 151, 799, 153, 120, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 800, 791, 801, 151, 802, 803, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 151, 804, 151, 120, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 805, 791, 791, 791, 791, 791, 791, 791, 791, 806, 791, 791, 807, 791, 808, 791, 791, 791, 164, 165, 791, 120, 791, 809, 809, 809, 809, 809, 809, 809, 809, 809, 793, 809, 793, 793, 793, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 793, 809, 809, 809, 809, 146, 147, 809, 148, 809, 149, 150, 151, 152, 153, 146, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 154, 809, 155, 151, 156, 157, 809, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 158, 159, 151, 120, 115, 809, 115, 115, 115, 115, 115, 115, 115, 115, 160, 115, 115, 115, 115, 115, 115, 115, 115, 161, 115, 115, 162, 115, 163, 115, 115, 115, 164, 165, 809, 120, 809, 115, 810, 811, 811, 811, 810, 811, 811, 811, 811, 151, 812, 151, 151, 151, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 810, 811, 811, 811, 811, 811, 151, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 811, 151, 811, 151, 812, 151, 151, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 114, 114, 114, 114, 114, 120, 114, 114, 114, 114, 114, 114, 114, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 114, 151, 812, 151, 151, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 114, 813, 151, 812, 151, 151, 151, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 151, 814, 814, 814, 814, 814, 814, 814, 814, 814, 815, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 151, 814, 151, 812, 151, 151, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 151, 151, 114, 816, 810, 151, 810, 818, 817, 820, 821, 820, 820, 820, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 820, 819, 822, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 116, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 117, 810, 810, 810, 810, 116, 810, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 810, 810, 810, 810, 115, 810, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 810, 810, 810, 810, 810, 115, 823, 151, 812, 151, 151, 151, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 151, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 151, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 120, 810, 824, 825, 826, 827, 828, 829, 151, 812, 151, 151, 151, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 151, 810, 810, 810, 810, 810, 810, 810, 810, 810, 120, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 151, 810, 151, 817, 120, 830, 120, 830, 831, 832, 831, 831, 831, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 819, 831, 819, 833, 830, 834, 834, 834, 834, 834, 834, 834, 834, 834, 123, 834, 123, 123, 123, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 123, 834, 834, 834, 834, 124, 125, 834, 126, 834, 127, 128, 129, 130, 131, 124, 834, 834, 834, 834, 834, 834, 834, 834, 834, 834, 132, 834, 133, 129, 134, 135, 834, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 136, 137, 129, 138, 122, 834, 122, 122, 122, 122, 122, 122, 122, 122, 139, 122, 122, 122, 122, 122, 122, 122, 122, 140, 122, 122, 141, 122, 142, 122, 122, 122, 143, 144, 834, 138, 834, 122, 151, 830, 835, 830, 836, 830, 837, 830, 838, 190, 190, 190, 838, 190, 190, 190, 190, 839, 190, 839, 839, 839, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 838, 190, 190, 190, 190, 190, 839, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 190, 840, 190, 190, 192, 190, 192, 192, 192, 196, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 190, 190, 190, 190, 190, 192, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 841, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 190, 189, 189, 189, 189, 841, 189, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 189, 189, 189, 189, 192, 189, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 189, 189, 189, 189, 189, 192, 842, 842, 842, 842, 842, 842, 842, 842, 842, 193, 842, 193, 193, 193, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 193, 842, 842, 842, 842, 842, 842, 842, 194, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 842, 195, 842, 842, 192, 842, 192, 192, 192, 196, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 842, 842, 842, 842, 842, 192, 843, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 841, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 190, 842, 842, 842, 842, 841, 842, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 842, 842, 842, 842, 192, 842, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 844, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 842, 842, 842, 842, 842, 192, 197, 842, 846, 845, 845, 845, 846, 845, 845, 845, 845, 847, 845, 847, 847, 847, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 846, 845, 845, 845, 845, 845, 847, 845, 845, 848, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 849, 845, 845, 845, 845, 845, 845, 845, 850, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 851, 845, 847, 852, 847, 847, 847, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 847, 852, 853, 854, 855, 856, 858, 857, 859, 860, 857, 861, 863, 864, 864, 864, 863, 864, 864, 864, 864, 865, 866, 865, 865, 865, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 863, 864, 864, 864, 864, 864, 865, 864, 864, 867, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 864, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 864, 868, 864, 864, 862, 864, 862, 862, 862, 862, 862, 862, 862, 862, 869, 862, 862, 862, 862, 862, 862, 862, 862, 870, 862, 862, 871, 862, 872, 862, 862, 862, 864, 864, 864, 864, 864, 862, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 873, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 873, 873, 873, 873, 873, 873, 873, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 873, 873, 873, 873, 862, 873, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 873, 873, 873, 873, 873, 862, 865, 874, 865, 865, 865, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 874, 865, 874, 875, 876, 877, 878, 879, 881, 880, 882, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 884, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 885, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 886, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 887, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 888, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 884, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 889, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 890, 862, 862, 862, 862, 862, 862, 862, 891, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 892, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 893, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 884, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 894, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 884, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 895, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 896, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 883, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 862, 883, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 888, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 883, 883, 883, 883, 883, 862, 898, 221, 221, 221, 898, 221, 221, 221, 221, 899, 900, 899, 899, 899, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 898, 221, 221, 221, 221, 221, 899, 901, 221, 902, 221, 903, 904, 221, 905, 221, 906, 907, 221, 908, 909, 910, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 911, 221, 912, 913, 914, 915, 221, 916, 917, 916, 916, 918, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 919, 920, 221, 921, 922, 221, 923, 924, 925, 926, 927, 928, 897, 897, 929, 897, 897, 897, 930, 931, 932, 897, 897, 933, 934, 935, 936, 897, 937, 897, 938, 897, 939, 940, 221, 921, 221, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 945, 944, 944, 946, 944, 947, 949, 950, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 951, 948, 953, 952, 954, 955, 956, 899, 957, 899, 899, 899, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 899, 957, 959, 958, 961, 962, 961, 961, 961, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 961, 960, 221, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 221, 963, 964, 965, 966, 967, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 968, 968, 968, 968, 968, 968, 968, 968, 968, 968, 969, 969, 969, 969, 969, 969, 969, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 969, 969, 969, 969, 969, 969, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 969, 969, 969, 969, 969, 968, 972, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 221, 971, 973, 975, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 974, 221, 974, 221, 211, 222, 223, 222, 222, 222, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 222, 971, 971, 224, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 971, 971, 971, 221, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 226, 971, 239, 240, 239, 239, 239, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 239, 238, 238, 241, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 243, 238, 222, 223, 222, 222, 222, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 222, 971, 971, 224, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 971, 971, 971, 221, 221, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 226, 971, 977, 963, 979, 978, 981, 980, 963, 982, 982, 982, 963, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 963, 982, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 984, 985, 963, 986, 247, 987, 985, 963, 963, 988, 989, 963, 989, 963, 247, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 990, 963, 991, 992, 993, 963, 994, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 995, 963, 963, 247, 983, 247, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 963, 996, 963, 997, 963, 983, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 999, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 998, 998, 998, 1000, 998, 999, 998, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 998, 998, 998, 998, 983, 998, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 998, 998, 998, 998, 998, 983, 1002, 1001, 1003, 1005, 1006, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1007, 1004, 1009, 1010, 1008, 1011, 1012, 1013, 1014, 247, 998, 998, 1015, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 247, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 998, 998, 998, 998, 998, 998, 998, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 998, 998, 998, 998, 246, 998, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 998, 998, 998, 998, 998, 246, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 998, 1016, 998, 247, 998, 247, 998, 247, 1017, 998, 247, 998, 247, 998, 247, 247, 998, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1018, 1018, 1018, 1018, 1018, 1018, 1021, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1018, 1018, 1018, 1018, 1019, 1018, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1018, 1018, 1018, 1018, 1018, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1022, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1024, 1024, 1024, 1024, 1025, 1024, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1024, 1024, 1024, 1024, 1024, 1025, 1016, 998, 1015, 998, 1027, 1028, 963, 1029, 262, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 263, 252, 264, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 263, 253, 263, 266, 221, 963, 921, 221, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 221, 963, 221, 972, 963, 1033, 1032, 1032, 1032, 1033, 1032, 1032, 1032, 1032, 1034, 1035, 1034, 1034, 1034, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1033, 1032, 1032, 1032, 1032, 1032, 1034, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1032, 1037, 1032, 1032, 1036, 1032, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1032, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1038, 1038, 1038, 1038, 1039, 1038, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1038, 1038, 1038, 1038, 1038, 1039, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1040, 1040, 1040, 1040, 1041, 1040, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1040, 1040, 1040, 1040, 1040, 1041, 1044, 1043, 1043, 1043, 1044, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1044, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1045, 1045, 1045, 1045, 1045, 1045, 1045, 1045, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1046, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1047, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1048, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1049, 1043, 1043, 1050, 1043, 1051, 1052, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1053, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1053, 1053, 1056, 1056, 290, 290, 290, 1056, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1056, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 291, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1057, 290, 1058, 1059, 1060, 1060, 290, 290, 290, 1060, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1060, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 291, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1061, 290, 289, 1060, 1062, 1063, 1064, 1064, 275, 275, 275, 1064, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 1064, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 276, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 1065, 275, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1066, 1066, 1066, 1066, 1066, 1066, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1066, 1066, 1066, 1066, 1066, 1066, 1064, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1068, 1068, 1068, 1068, 1068, 1068, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1068, 1068, 1068, 1068, 1068, 1068, 1067, 1067, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1069, 1069, 1069, 1069, 1069, 1069, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1069, 1069, 1069, 1069, 1069, 1069, 1060, 1071, 1071, 1071, 1071, 1071, 1071, 1071, 1071, 1071, 1071, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1071, 1071, 1071, 1071, 1071, 1071, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1071, 1071, 1071, 1071, 1071, 1071, 1070, 1070, 1060, 268, 268, 268, 1060, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1060, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1072, 268, 1056, 275, 275, 275, 1056, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 1056, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 276, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 277, 275, 1056, 1073, 1073, 1073, 1056, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1056, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1074, 1073, 1075, 1076, 1076, 1073, 1073, 1073, 1076, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1076, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1077, 1073, 1078, 1078, 1078, 1078, 1078, 1078, 1078, 1078, 1078, 1078, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1078, 1078, 1078, 1078, 1078, 1078, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1078, 1078, 1078, 1078, 1078, 1078, 1076, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1080, 1080, 1080, 1080, 1080, 1080, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1080, 1080, 1080, 1080, 1080, 1080, 1079, 1079, 1076, 268, 268, 268, 1076, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1076, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1072, 268, 1081, 1076, 1076, 275, 275, 275, 1076, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 1076, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 276, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 275, 277, 275, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1083, 1083, 1083, 1083, 1083, 1083, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1083, 1083, 1083, 1083, 1083, 1083, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1084, 1082, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1085, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1085, 1085, 1085, 1085, 1085, 1085, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1085, 1085, 1085, 1085, 1085, 1085, 1082, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1086, 1086, 1086, 1086, 1086, 1086, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1086, 1086, 1086, 1086, 1086, 1086, 1082, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1087, 1087, 1087, 1087, 1087, 1087, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1087, 1087, 1087, 1087, 1087, 1087, 1082, 1088, 1091, 1090, 1090, 1090, 1091, 1090, 1090, 1090, 1090, 1092, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1091, 1090, 1090, 1090, 1090, 1090, 1092, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1093, 1093, 1093, 1093, 1093, 1093, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1093, 1093, 1093, 1093, 1093, 1093, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1094, 1090, 1091, 1090, 1090, 1090, 1091, 1090, 1090, 1090, 1090, 1089, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1091, 1090, 1090, 1090, 1090, 1090, 1089, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1095, 1095, 1095, 1095, 1095, 1095, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1095, 1095, 1095, 1095, 1095, 1095, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1096, 1090, 1089, 1091, 1095, 1095, 1095, 1091, 1095, 1095, 1095, 1095, 1089, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1091, 1095, 1095, 1095, 1095, 1095, 1089, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1089, 1095, 1097, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1092, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1092, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1089, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1095, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1095, 1095, 1095, 1095, 1095, 1095, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1095, 1095, 1095, 1095, 1095, 1095, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1101, 1101, 1101, 1101, 1101, 1101, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1101, 1101, 1101, 1101, 1101, 1101, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1099, 1099, 1099, 1099, 1099, 1099, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1103, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1104, 1104, 1104, 1104, 1104, 1104, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1104, 1104, 1104, 1104, 1104, 1104, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1105, 1105, 1105, 1105, 1105, 1105, 1105, 1105, 1105, 1105, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1105, 1105, 1105, 1105, 1105, 1105, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1105, 1105, 1105, 1105, 1105, 1105, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1106, 1106, 1106, 1106, 1106, 1106, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1106, 1106, 1106, 1106, 1106, 1106, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1107, 1107, 1107, 1107, 1107, 1107, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1107, 1107, 1107, 1107, 1107, 1107, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1100, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1089, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1110, 1110, 1110, 1110, 1110, 1110, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1110, 1110, 1110, 1110, 1110, 1110, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1111, 1111, 1111, 1111, 1111, 1111, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1111, 1111, 1111, 1111, 1111, 1111, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1112, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1112, 1112, 1112, 1112, 1112, 1112, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1112, 1112, 1112, 1112, 1112, 1112, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1113, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1113, 1113, 1113, 1113, 1113, 1113, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1113, 1113, 1113, 1113, 1113, 1113, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1114, 1114, 1114, 1114, 1114, 1114, 1114, 1114, 1114, 1114, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1114, 1114, 1114, 1114, 1114, 1114, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1114, 1114, 1114, 1114, 1114, 1114, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1115, 1115, 1115, 1115, 1115, 1115, 1115, 1115, 1115, 1115, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1115, 1115, 1115, 1115, 1115, 1115, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1115, 1115, 1115, 1115, 1115, 1115, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1116, 1116, 1116, 1116, 1116, 1116, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1116, 1116, 1116, 1116, 1116, 1116, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1089, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1117, 1117, 1117, 1117, 1117, 1117, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1117, 1117, 1117, 1117, 1117, 1117, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1118, 1118, 1118, 1118, 1118, 1118, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1118, 1118, 1118, 1118, 1118, 1118, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1119, 1119, 1119, 1119, 1119, 1119, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1119, 1119, 1119, 1119, 1119, 1119, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1120, 1120, 1120, 1120, 1120, 1120, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1120, 1120, 1120, 1120, 1120, 1120, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1091, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1091, 1098, 1098, 1098, 1098, 1098, 1109, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1108, 1108, 1108, 1108, 1108, 1108, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1102, 1098, 1121, 1122, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1124, 1124, 1124, 1124, 1124, 1124, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1123, 1124, 1124, 1124, 1124, 1124, 1124, 1123, 1123, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 296, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 211, 211, 298, 211, 296, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 211, 211, 211, 211, 295, 211, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 211, 211, 211, 211, 211, 295, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 296, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 963, 963, 298, 963, 296, 963, 295, 295, 295, 295, 1125, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 963, 963, 963, 963, 295, 963, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 963, 963, 963, 963, 963, 295, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 296, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 297, 963, 963, 298, 963, 296, 963, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 1126, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 963, 963, 963, 963, 295, 963, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 963, 963, 963, 963, 963, 295, 1127, 1128, 963, 958, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 1129, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 1130, 1131, 897, 897, 897, 897, 897, 1132, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1133, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 1134, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1135, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 1136, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1137, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1138, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 1139, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 1140, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 1141, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 296, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 211, 211, 298, 211, 296, 211, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 211, 211, 211, 211, 897, 211, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 211, 211, 211, 211, 211, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1142, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1143, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 1139, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1144, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1143, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1145, 897, 1146, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1147, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 1148, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1149, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1150, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 1151, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1152, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1153, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 1154, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 1155, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1156, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1157, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 1158, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1148, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1159, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1160, 897, 1161, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1162, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1141, 897, 897, 897, 1159, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1163, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1164, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1157, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 1165, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 932, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1155, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 1166, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1167, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 1168, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1169, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1157, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1170, 897, 897, 897, 1171, 897, 897, 897, 897, 897, 1172, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1172, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1173, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 1174, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1175, 1176, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 1177, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1178, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1179, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1182, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1180, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1183, 1180, 1180, 1184, 1180, 1182, 1180, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1180, 1180, 1180, 1180, 1181, 1180, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1180, 1180, 1180, 1180, 1180, 1181, 949, 1185, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 951, 948, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1186, 897, 897, 1187, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1141, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1152, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1188, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1189, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1159, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1190, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 932, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 1191, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1192, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1152, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1157, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1193, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 1194, 897, 897, 897, 897, 897, 897, 897, 1195, 897, 897, 897, 897, 897, 897, 897, 1196, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1159, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1197, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1198, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1166, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1199, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1166, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 1200, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1152, 897, 897, 897, 1201, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1202, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1166, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 1203, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 1204, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 941, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 942, 296, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 297, 941, 941, 298, 941, 296, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 943, 941, 941, 897, 941, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 1146, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 941, 941, 941, 941, 941, 897, 1205, 221, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 1206, 963, 1208, 1207, 1207, 1207, 1208, 1207, 1207, 1207, 1207, 1209, 1210, 1209, 1209, 1209, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1208, 1207, 1207, 1207, 1207, 1207, 1209, 1207, 1207, 1211, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1207, 1212, 1207, 1209, 1213, 1209, 1209, 1209, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1209, 1213, 1214, 1215, 1216, 1217, 1218, 1220, 1219, 1221, 1223, 1224, 1224, 1224, 1223, 1224, 1224, 1224, 1224, 1225, 1226, 1225, 1225, 1225, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1223, 1224, 1224, 1224, 1224, 1224, 1225, 1224, 1227, 1228, 1224, 1224, 1224, 1227, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1224, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1224, 1229, 1224, 1224, 1222, 1224, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1222, 1224, 1224, 1224, 1224, 1224, 1222, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 304, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 305, 1230, 1230, 1230, 1230, 304, 1230, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 1230, 1230, 1230, 1230, 303, 1230, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 1230, 1230, 1230, 1230, 1230, 303, 1225, 1231, 1225, 1225, 1225, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1231, 1225, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1230, 1238, 1240, 1241, 1241, 1241, 1240, 1241, 1241, 1241, 1241, 1242, 1243, 1242, 1242, 1242, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1241, 1240, 1241, 1241, 1241, 1241, 1241, 1242, 1244, 1245, 1246, 1247, 1248, 1249, 1245, 1250, 1251, 1252, 1248, 1253, 1254, 1255, 1248, 1256, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1265, 1265, 1267, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1268, 1269, 1270, 1248, 1271, 1245, 1272, 1273, 1274, 1275, 1276, 1277, 1239, 1239, 1278, 1239, 1239, 1239, 1279, 1280, 1281, 1239, 1239, 1282, 1283, 1284, 1285, 1239, 1286, 1239, 1287, 1239, 1288, 1289, 1290, 1291, 1241, 1239, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 1292, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 313, 313, 313, 313, 313, 1292, 313, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 313, 313, 313, 313, 1239, 313, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 313, 313, 313, 313, 313, 1239, 1294, 1293, 1295, 1242, 1296, 1242, 1242, 1242, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1296, 1242, 1296, 1297, 1299, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1299, 1298, 1300, 1301, 1302, 1303, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 308, 308, 1304, 308, 1304, 308, 308, 1304, 1304, 308, 308, 308, 1305, 308, 308, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 308, 308, 308, 308, 308, 308, 308, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1304, 308, 1304, 1304, 325, 308, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1304, 1304, 1304, 308, 1304, 325, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1307, 1307, 1307, 1307, 1307, 1307, 1307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1307, 1307, 1307, 1307, 325, 1307, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1307, 1307, 1307, 1307, 1307, 325, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1306, 1307, 1308, 313, 1248, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1310, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1309, 1308, 1309, 1311, 1312, 1248, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1308, 1313, 1308, 1314, 1309, 1316, 1315, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 1315, 1318, 1317, 1319, 1317, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1321, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1322, 1320, 1320, 1320, 1320, 1320, 1321, 1320, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 1320, 310, 1320, 1324, 1323, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1326, 1323, 1327, 1328, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1329, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1330, 1323, 1323, 1323, 1323, 1323, 1323, 1331, 1323, 1323, 1326, 1323, 1327, 1328, 1323, 1323, 1323, 1332, 1323, 1323, 1323, 1323, 1323, 1329, 1323, 1323, 1333, 1323, 1323, 1323, 1323, 1323, 1330, 1323, 314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1335, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1336, 1334, 1334, 1334, 1334, 1334, 1335, 1334, 1334, 1334, 1337, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1334, 1338, 1334, 1339, 313, 1339, 313, 313, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 313, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1339, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1340, 1341, 1340, 1343, 1342, 1344, 1346, 1345, 1345, 1345, 1347, 1345, 1348, 1349, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1331, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1332, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1333, 1323, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1351, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1332, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1333, 1323, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1354, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1353, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1357, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1359, 1358, 1360, 1362, 1361, 1361, 1361, 1363, 1361, 1365, 1364, 1366, 1367, 1369, 1369, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1370, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1371, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1368, 1372, 1368, 1373, 1373, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1374, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1373, 1373, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1357, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1376, 1376, 1376, 1376, 1376, 1376, 1376, 1376, 1376, 1376, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1377, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1378, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1375, 1379, 1375, 1381, 1381, 1381, 1381, 1381, 1381, 1381, 1381, 1381, 1381, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1382, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1383, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1380, 1384, 1380, 1386, 1386, 1386, 1386, 1386, 1386, 1386, 1386, 1386, 1386, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1386, 1386, 1386, 1386, 1386, 1386, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1387, 1385, 1386, 1386, 1386, 1386, 1386, 1386, 1385, 1385, 1388, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1385, 1389, 1385, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1391, 1352, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1357, 1352, 1390, 1390, 1390, 1390, 1390, 1390, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1393, 1392, 1394, 1394, 1394, 1394, 1394, 1394, 1394, 1394, 1394, 1394, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1395, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1396, 1392, 1392, 1392, 1392, 1392, 1395, 1392, 1392, 1392, 1397, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1398, 1392, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1400, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1397, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1398, 1392, 1401, 1352, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1403, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1404, 1352, 1352, 1352, 1352, 1352, 1403, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1357, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1355, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1352, 1356, 1352, 1310, 1317, 1248, 1405, 1309, 1299, 1309, 1406, 1407, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1317, 1299, 1317, 1299, 1309, 1299, 1248, 1309, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 1304, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1304, 1304, 1304, 1304, 1304, 1304, 1408, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1304, 1304, 1304, 1304, 325, 1304, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325, 1304, 1304, 1304, 1304, 1304, 325, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 1292, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 313, 313, 313, 313, 1292, 313, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 313, 313, 313, 313, 1265, 313, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 313, 313, 313, 313, 313, 1265, 1410, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1265, 1412, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1413, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1414, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1415, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1416, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1292, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1409, 1411, 1411, 1411, 1411, 1292, 1411, 1265, 1265, 1265, 1415, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1265, 1411, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1411, 1411, 1411, 1411, 1411, 1265, 1417, 1419, 1418, 1420, 1421, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1423, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1424, 1425, 1239, 1239, 1239, 1239, 1239, 1426, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1427, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1428, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1429, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1430, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1431, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1432, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1433, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1434, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1435, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1436, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1437, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1438, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1439, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1440, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1441, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1437, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1442, 1239, 1443, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1444, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1445, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1446, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1448, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1449, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1450, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1451, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1452, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1453, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1454, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1455, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1456, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1457, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1458, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1459, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1460, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 327, 328, 327, 327, 327, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 327, 1292, 1461, 329, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1461, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1461, 1461, 330, 1461, 1461, 1292, 1461, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1461, 331, 1461, 1461, 1239, 1461, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1461, 1461, 1461, 1461, 1461, 1239, 344, 345, 344, 344, 344, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 344, 343, 343, 346, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 349, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 348, 343, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1463, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1464, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1465, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1292, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1466, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1466, 1466, 1466, 1466, 1466, 1292, 1466, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1466, 1466, 1466, 1466, 1239, 1466, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1467, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1466, 1466, 1466, 1466, 1466, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1468, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1469, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1470, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1471, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1472, 1239, 1473, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1474, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1475, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1440, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1476, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1477, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1457, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1478, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1281, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1479, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1480, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1440, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1481, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1447, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1482, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1483, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1484, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1457, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1485, 1239, 1239, 1239, 1486, 1239, 1239, 1239, 1239, 1239, 1487, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1488, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1454, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1440, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1489, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1490, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1491, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1492, 1493, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1440, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1494, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1495, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1481, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1496, 1239, 1239, 1497, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1440, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1498, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1454, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1499, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1500, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1501, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1440, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1502, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1503, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1489, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1504, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1505, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1451, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1480, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1506, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1507, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1508, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1509, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1510, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1446, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1511, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1512, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1481, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1513, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1481, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1514, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1451, 1239, 1239, 1239, 1515, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1516, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1481, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1517, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1518, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1519, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1292, 1422, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1239, 1422, 1239, 1239, 1239, 1489, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1239, 1422, 1422, 1422, 1422, 1422, 1239, 1520, 1308, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1298, 1248, 1298, 1521, 1523, 1522, 1523, 1523, 1523, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1523, 1522, 1522, 1524, 1522, 1522, 1525, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 357, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1522, 1526, 1522, 353, 354, 353, 353, 353, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 353, 1527, 1527, 355, 1527, 1527, 356, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 357, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 358, 1527, 360, 1528, 360, 360, 360, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 360, 1528, 1528, 355, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 1528, 358, 1528, 1530, 1529, 1532, 1531, 363, 362, 368, 1527, 366, 1527, 1534, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1535, 1533, 1534, 1533, 1534, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1537, 1533, 1534, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1538, 1533, 1534, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 1539, 1533, 1541, 1539, 0]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_trans_targs");
      return self.$private("_lex_trans_targs", "_lex_trans_targs=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_trans_targs=']([186, 2, 3, 4, 192, 6, 7, 8, 9, 10, 186, 186, 195, 198, 195, 12, 199, 200, 14, 195, 207, 208, 211, 212, 224, 221, 213, 214, 215, 19, 216, 217, 218, 226, 228, 229, 233, 234, 235, 230, 25, 18, 209, 210, 27, 258, 259, 261, 263, 261, 30, 264, 265, 32, 261, 272, 273, 276, 277, 289, 286, 278, 279, 280, 37, 281, 282, 283, 291, 293, 294, 298, 299, 300, 295, 43, 36, 274, 275, 45, 323, 324, 331, 333, 331, 48, 334, 335, 50, 337, 340, 337, 52, 341, 342, 54, 348, 347, 0, 56, 349, 350, 58, 351, 352, 352, 352, 352, 465, 61, 62, 63, 465, 465, 494, 65, 66, 494, 494, 498, 498, 70, 65, 71, 496, 497, 499, 500, 498, 494, 501, 502, 504, 67, 68, 505, 506, 69, 498, 72, 73, 78, 85, 508, 509, 71, 496, 497, 499, 500, 498, 494, 501, 502, 504, 67, 68, 505, 506, 69, 72, 73, 78, 85, 508, 509, 507, 74, 75, 76, 77, 79, 80, 83, 81, 82, 84, 86, 87, 494, 89, 90, 91, 93, 96, 94, 95, 97, 99, 525, 525, 525, 526, 101, 528, 102, 529, 103, 526, 101, 528, 102, 529, 563, 104, 563, 105, 106, 104, 563, 105, 563, 563, 563, 109, 110, 111, 112, 574, 563, 563, 563, 115, 116, 117, 563, 120, 115, 116, 117, 563, 120, 118, 118, 116, 117, 584, 119, 118, 118, 116, 117, 584, 119, 116, 563, 601, 563, 122, 602, 608, 126, 617, 618, 131, 132, 126, 127, 616, 127, 616, 563, 128, 129, 130, 619, 133, 563, 633, 634, 637, 638, 650, 647, 639, 640, 641, 138, 642, 643, 644, 652, 654, 655, 659, 660, 661, 656, 144, 137, 635, 636, 146, 697, 698, 148, 565, 107, 567, 150, 151, 700, 802, 153, 154, 155, 802, 810, 810, 810, 158, 832, 831, 810, 834, 836, 810, 163, 164, 165, 840, 810, 167, 168, 851, 820, 873, 171, 172, 173, 177, 178, 171, 172, 173, 177, 178, 174, 174, 172, 173, 175, 176, 174, 174, 172, 173, 175, 176, 921, 172, 810, 990, 179, 992, 181, 185, 993, 183, 990, 180, 990, 182, 992, 182, 992, 184, 992, 990, 186, 186, 187, 188, 189, 191, 193, 194, 186, 186, 186, 190, 186, 190, 186, 1, 186, 186, 186, 5, 195, 195, 196, 195, 197, 201, 195, 195, 11, 13, 195, 195, 195, 195, 202, 203, 204, 15, 21, 26, 236, 28, 195, 195, 195, 205, 206, 195, 16, 195, 195, 195, 17, 195, 195, 195, 20, 219, 195, 220, 222, 195, 223, 225, 227, 22, 195, 195, 23, 231, 195, 232, 24, 195, 237, 241, 238, 239, 240, 195, 195, 242, 243, 246, 248, 257, 244, 245, 195, 247, 249, 251, 250, 195, 252, 253, 254, 255, 256, 195, 195, 195, 260, 261, 261, 261, 262, 266, 261, 29, 31, 261, 261, 261, 261, 267, 268, 269, 33, 39, 44, 301, 46, 261, 261, 261, 270, 271, 261, 34, 261, 261, 261, 35, 261, 261, 261, 38, 284, 261, 285, 287, 261, 288, 290, 292, 40, 261, 261, 41, 296, 261, 297, 42, 261, 302, 306, 303, 304, 305, 261, 261, 307, 308, 311, 313, 322, 309, 310, 261, 312, 314, 316, 315, 261, 317, 318, 319, 320, 321, 261, 261, 261, 325, 326, 326, 327, 326, 328, 326, 326, 326, 329, 329, 329, 330, 329, 329, 329, 331, 331, 331, 332, 331, 47, 49, 331, 331, 331, 336, 336, 336, 337, 337, 338, 337, 339, 337, 337, 51, 53, 337, 337, 337, 343, 343, 344, 343, 343, 345, 346, 345, 55, 57, 347, 347, 347, 353, 352, 352, 354, 355, 356, 357, 359, 362, 363, 364, 365, 352, 366, 367, 369, 371, 372, 373, 377, 379, 380, 381, 397, 402, 409, 414, 421, 428, 431, 432, 436, 430, 440, 448, 452, 454, 459, 461, 464, 352, 352, 352, 352, 352, 352, 358, 352, 358, 352, 360, 59, 361, 352, 60, 352, 352, 368, 370, 352, 374, 375, 376, 372, 378, 352, 382, 383, 392, 395, 384, 385, 386, 387, 388, 389, 390, 391, 353, 393, 394, 396, 398, 401, 399, 400, 403, 406, 404, 405, 407, 408, 410, 412, 411, 413, 415, 416, 352, 417, 418, 419, 420, 352, 422, 425, 423, 424, 426, 427, 429, 433, 434, 435, 437, 439, 438, 441, 442, 443, 445, 444, 446, 447, 449, 450, 451, 453, 455, 456, 457, 458, 460, 462, 463, 466, 465, 465, 467, 468, 470, 471, 465, 465, 465, 469, 465, 469, 64, 472, 465, 474, 473, 473, 477, 478, 479, 480, 473, 482, 483, 484, 485, 487, 489, 490, 491, 492, 493, 473, 475, 473, 476, 473, 473, 473, 473, 473, 481, 473, 481, 486, 473, 488, 473, 494, 494, 495, 510, 511, 497, 513, 514, 501, 515, 516, 517, 518, 519, 521, 522, 523, 524, 494, 494, 494, 494, 494, 494, 498, 503, 494, 494, 494, 494, 494, 494, 494, 494, 494, 512, 494, 512, 494, 494, 494, 494, 520, 494, 88, 92, 98, 525, 527, 530, 100, 525, 525, 526, 531, 531, 532, 533, 535, 537, 538, 531, 531, 534, 531, 534, 531, 536, 531, 531, 531, 540, 539, 539, 541, 542, 543, 545, 547, 548, 553, 560, 539, 539, 539, 539, 544, 539, 544, 539, 546, 539, 539, 540, 549, 550, 551, 552, 554, 555, 558, 556, 557, 559, 561, 562, 564, 563, 572, 573, 575, 576, 578, 579, 580, 581, 583, 585, 586, 589, 590, 615, 621, 622, 623, 700, 701, 702, 703, 704, 582, 706, 723, 728, 735, 740, 742, 748, 751, 752, 756, 750, 760, 771, 775, 778, 786, 790, 793, 794, 563, 104, 105, 563, 107, 566, 563, 563, 568, 570, 571, 563, 569, 563, 563, 563, 563, 563, 108, 563, 563, 563, 563, 563, 577, 563, 577, 563, 563, 113, 563, 114, 563, 563, 582, 563, 587, 563, 588, 563, 563, 563, 591, 600, 563, 121, 603, 604, 605, 563, 606, 123, 609, 610, 124, 613, 614, 563, 592, 594, 563, 593, 563, 563, 595, 598, 599, 563, 596, 597, 563, 563, 563, 563, 563, 563, 607, 563, 601, 611, 612, 563, 611, 563, 601, 611, 125, 620, 563, 563, 563, 624, 563, 563, 563, 625, 627, 563, 626, 563, 626, 563, 628, 629, 630, 134, 140, 145, 662, 147, 563, 563, 563, 631, 632, 563, 135, 563, 563, 563, 136, 563, 563, 563, 139, 645, 563, 646, 648, 563, 649, 651, 653, 141, 563, 563, 142, 657, 563, 658, 143, 563, 663, 667, 664, 665, 666, 563, 563, 668, 669, 672, 683, 696, 670, 671, 563, 673, 674, 675, 677, 676, 563, 678, 679, 680, 681, 682, 684, 691, 685, 686, 687, 688, 689, 690, 692, 693, 694, 695, 563, 563, 563, 699, 149, 152, 563, 705, 707, 708, 718, 721, 709, 710, 711, 712, 713, 714, 715, 716, 717, 719, 720, 722, 724, 727, 725, 726, 729, 732, 730, 731, 733, 734, 736, 738, 737, 739, 741, 743, 745, 744, 746, 747, 749, 717, 753, 754, 755, 757, 759, 758, 761, 762, 763, 768, 764, 765, 766, 563, 564, 565, 107, 767, 570, 769, 770, 772, 773, 774, 776, 777, 779, 780, 781, 784, 782, 783, 785, 787, 788, 789, 791, 792, 563, 582, 795, 795, 796, 797, 798, 800, 795, 795, 795, 799, 795, 799, 795, 801, 795, 803, 802, 802, 804, 805, 802, 806, 808, 802, 802, 802, 802, 807, 802, 807, 809, 802, 811, 810, 810, 814, 815, 816, 810, 817, 819, 822, 823, 824, 825, 826, 810, 827, 828, 833, 861, 865, 810, 866, 868, 870, 810, 871, 872, 874, 878, 880, 881, 883, 884, 902, 907, 914, 922, 929, 936, 941, 942, 946, 940, 951, 961, 967, 970, 979, 983, 987, 988, 989, 822, 812, 810, 813, 810, 810, 810, 810, 810, 810, 818, 810, 818, 810, 156, 821, 810, 810, 810, 810, 810, 810, 810, 810, 810, 829, 810, 830, 810, 810, 157, 159, 810, 160, 842, 853, 856, 835, 857, 858, 843, 847, 849, 810, 835, 160, 837, 839, 161, 810, 837, 810, 838, 810, 810, 162, 841, 810, 810, 844, 846, 810, 844, 845, 847, 849, 846, 810, 848, 810, 810, 850, 852, 810, 166, 810, 810, 810, 854, 846, 847, 849, 854, 855, 810, 844, 846, 847, 849, 810, 844, 846, 847, 849, 810, 859, 846, 847, 849, 859, 860, 810, 160, 861, 835, 862, 847, 849, 863, 846, 160, 863, 835, 864, 867, 869, 810, 169, 170, 810, 810, 875, 876, 877, 872, 879, 810, 810, 882, 810, 810, 810, 885, 886, 895, 900, 887, 888, 889, 890, 891, 892, 893, 894, 811, 896, 897, 898, 899, 811, 901, 903, 906, 904, 905, 811, 811, 908, 911, 909, 910, 912, 913, 811, 915, 917, 916, 918, 919, 920, 810, 810, 923, 811, 924, 810, 925, 926, 927, 928, 812, 930, 933, 931, 932, 934, 935, 937, 938, 939, 811, 943, 944, 945, 947, 949, 950, 948, 811, 952, 953, 954, 957, 955, 956, 958, 959, 960, 962, 964, 963, 965, 966, 968, 969, 971, 972, 974, 977, 973, 975, 976, 978, 980, 981, 982, 984, 985, 986, 810, 810, 990, 991, 995, 996, 997, 990, 990, 990, 994, 990, 990, 999, 998, 1000, 998, 1001, 1002, 1003, 998, 998]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_trans_actions");
      return self.$private("_lex_trans_actions", "_lex_trans_actions=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_trans_actions=']([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 5, 0, 0, 0, 0, 6, 0, 7, 0, 8, 0, 0, 7, 0, 0, 0, 0, 8, 0, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 0, 0, 11, 0, 7, 0, 8, 0, 0, 7, 0, 0, 0, 0, 8, 0, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 13, 0, 0, 0, 0, 14, 0, 15, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 0, 0, 0, 22, 23, 24, 0, 0, 25, 26, 27, 28, 29, 30, 30, 31, 32, 30, 33, 32, 34, 32, 30, 30, 31, 30, 35, 30, 30, 36, 30, 30, 30, 30, 30, 30, 0, 37, 38, 0, 39, 38, 40, 38, 0, 0, 37, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 46, 0, 0, 0, 46, 29, 47, 30, 30, 30, 47, 48, 0, 49, 0, 29, 30, 50, 30, 51, 52, 53, 0, 0, 0, 0, 0, 54, 55, 56, 0, 29, 0, 57, 0, 30, 58, 30, 59, 30, 60, 61, 62, 61, 63, 61, 0, 64, 65, 64, 66, 64, 67, 68, 0, 69, 0, 0, 0, 0, 70, 70, 0, 0, 71, 71, 72, 0, 29, 73, 0, 0, 0, 70, 0, 74, 0, 7, 0, 8, 0, 0, 7, 0, 0, 0, 0, 8, 0, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 75, 76, 0, 0, 0, 77, 78, 79, 80, 0, 7, 7, 81, 82, 82, 83, 0, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 30, 58, 30, 30, 30, 60, 61, 62, 61, 61, 61, 0, 64, 65, 64, 64, 64, 85, 67, 86, 87, 0, 88, 0, 89, 89, 0, 90, 0, 91, 60, 92, 0, 93, 29, 94, 95, 98, 99, 0, 29, 0, 7, 0, 7, 100, 101, 102, 60, 103, 0, 104, 0, 105, 106, 107, 0, 108, 109, 0, 110, 7, 7, 111, 112, 0, 0, 113, 114, 115, 116, 117, 117, 117, 117, 117, 117, 117, 117, 118, 119, 120, 0, 0, 121, 0, 122, 123, 124, 0, 125, 126, 127, 0, 0, 128, 0, 0, 129, 0, 7, 0, 0, 130, 131, 0, 0, 132, 0, 29, 133, 0, 0, 0, 0, 0, 134, 135, 0, 0, 0, 0, 0, 0, 0, 136, 0, 0, 0, 0, 137, 0, 0, 0, 0, 0, 138, 139, 140, 0, 141, 142, 143, 7, 7, 144, 0, 0, 145, 146, 147, 148, 117, 117, 117, 117, 117, 117, 117, 117, 149, 150, 151, 0, 0, 152, 0, 153, 154, 155, 0, 156, 157, 158, 0, 0, 159, 0, 0, 160, 0, 7, 0, 0, 161, 162, 0, 0, 163, 0, 29, 164, 0, 0, 0, 0, 0, 165, 166, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 169, 170, 171, 0, 172, 173, 0, 174, 0, 175, 176, 177, 178, 179, 180, 0, 181, 182, 183, 184, 185, 186, 7, 187, 0, 0, 188, 189, 190, 191, 192, 193, 194, 195, 0, 196, 7, 197, 198, 0, 0, 199, 200, 201, 202, 203, 0, 204, 205, 206, 0, 207, 0, 0, 208, 209, 210, 211, 212, 213, 0, 29, 0, 0, 7, 7, 0, 0, 0, 214, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 217, 218, 219, 220, 221, 60, 222, 0, 223, 0, 0, 0, 224, 0, 225, 226, 0, 0, 227, 0, 0, 0, 228, 0, 229, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 232, 233, 0, 0, 7, 0, 234, 235, 236, 60, 237, 0, 0, 29, 238, 0, 239, 240, 0, 29, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 243, 0, 244, 245, 246, 247, 248, 60, 249, 0, 0, 250, 0, 251, 252, 253, 254, 29, 0, 28, 0, 0, 28, 0, 0, 0, 0, 0, 0, 7, 7, 7, 255, 256, 257, 258, 259, 260, 261, 0, 262, 263, 264, 265, 266, 267, 268, 269, 270, 60, 271, 0, 272, 273, 274, 275, 276, 277, 0, 0, 0, 278, 7, 7, 0, 279, 280, 281, 282, 283, 0, 0, 0, 0, 0, 284, 285, 60, 286, 0, 287, 29, 288, 289, 290, 291, 292, 293, 0, 29, 0, 0, 0, 0, 0, 0, 294, 295, 296, 297, 60, 298, 0, 299, 29, 300, 301, 302, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 303, 304, 0, 8, 0, 0, 7, 305, 0, 0, 305, 305, 0, 0, 7, 306, 0, 306, 0, 306, 306, 306, 0, 0, 306, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 0, 0, 307, 308, 308, 309, 310, 0, 311, 312, 0, 75, 0, 313, 0, 314, 315, 316, 317, 318, 30, 319, 320, 321, 322, 323, 60, 324, 0, 325, 326, 0, 327, 0, 328, 329, 305, 330, 0, 331, 0, 332, 333, 334, 0, 0, 335, 0, 0, 0, 0, 336, 0, 0, 0, 0, 0, 0, 0, 337, 0, 0, 338, 0, 339, 340, 0, 0, 0, 341, 0, 0, 342, 343, 344, 345, 346, 347, 0, 348, 349, 349, 0, 350, 0, 351, 352, 352, 0, 0, 353, 354, 355, 0, 356, 357, 358, 0, 7, 359, 360, 361, 0, 362, 117, 117, 117, 117, 117, 117, 117, 117, 363, 364, 365, 0, 0, 366, 0, 367, 368, 369, 0, 370, 371, 372, 0, 0, 373, 0, 0, 374, 0, 7, 0, 0, 375, 376, 0, 0, 377, 0, 29, 378, 0, 0, 0, 0, 0, 379, 380, 0, 0, 0, 0, 0, 0, 0, 381, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 383, 384, 385, 0, 0, 0, 386, 29, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 75, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 387, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 388, 389, 390, 391, 392, 392, 388, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 393, 394, 395, 396, 0, 29, 0, 0, 397, 398, 399, 60, 400, 0, 401, 29, 402, 7, 403, 404, 0, 29, 405, 0, 0, 406, 407, 408, 409, 60, 410, 0, 29, 411, 412, 413, 414, 0, 29, 0, 415, 0, 7, 416, 0, 0, 0, 0, 417, 0, 0, 418, 418, 0, 419, 0, 0, 0, 420, 7, 421, 421, 421, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 422, 423, 424, 0, 425, 426, 427, 428, 429, 430, 60, 431, 0, 432, 0, 0, 433, 434, 435, 436, 437, 438, 439, 440, 441, 0, 442, 0, 443, 444, 0, 0, 445, 446, 447, 0, 0, 448, 0, 0, 447, 449, 449, 450, 451, 0, 452, 453, 0, 454, 455, 456, 0, 457, 458, 0, 0, 459, 460, 447, 447, 461, 0, 0, 462, 462, 0, 463, 0, 464, 465, 7, 0, 466, 0, 467, 468, 469, 470, 470, 471, 471, 0, 0, 472, 473, 473, 474, 474, 475, 476, 476, 477, 477, 478, 479, 479, 480, 480, 0, 0, 481, 482, 483, 484, 485, 486, 486, 483, 485, 487, 418, 488, 0, 0, 0, 489, 0, 0, 490, 491, 421, 421, 421, 492, 421, 493, 494, 29, 495, 496, 497, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 492, 0, 0, 0, 0, 0, 499, 500, 0, 0, 0, 0, 0, 0, 501, 0, 0, 0, 0, 0, 500, 502, 503, 0, 504, 0, 505, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 507, 0, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 508, 509, 510, 511, 511, 89, 511, 512, 513, 514, 0, 515, 516, 0, 517, 0, 518, 0, 0, 0, 519, 520]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_to_state_actions");
      return self.$private("_lex_to_state_actions", "_lex_to_state_actions=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_to_state_actions=']([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 96, 0, 96, 0, 0, 0, 0, 96, 96, 0, 0, 0, 0, 0, 96, 0, 96, 0, 96, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_from_state_actions");
      return self.$private("_lex_from_state_actions", "_lex_from_state_actions=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_from_state_actions=']([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 97, 0, 97, 0, 0, 0, 0, 97, 97, 0, 0, 0, 0, 0, 97, 0, 97, 0, 97, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0, 0, 0, 0]);
    (function(self, $parent_nesting) {
      
      
      self.$attr_accessor("_lex_eof_trans");
      return self.$private("_lex_eof_trans", "_lex_eof_trans=");
    })(Opal.get_singleton_class(self), $nesting);
    self['$_lex_eof_trans=']([0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 48, 48, 48, 48, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 83, 83, 83, 83, 90, 90, 90, 90, 0, 0, 0, 0, 105, 107, 109, 109, 109, 109, 115, 115, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 190, 192, 192, 192, 204, 204, 204, 212, 214, 214, 214, 214, 214, 220, 212, 212, 212, 212, 212, 212, 212, 246, 246, 246, 246, 246, 246, 212, 262, 212, 262, 246, 246, 212, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 212, 246, 246, 246, 246, 303, 303, 303, 308, 310, 310, 310, 314, 314, 317, 317, 317, 317, 322, 322, 322, 308, 314, 314, 314, 314, 314, 314, 314, 314, 314, 353, 360, 362, 362, 362, 362, 353, 0, 378, 379, 380, 382, 384, 386, 384, 384, 0, 396, 397, 401, 401, 402, 403, 412, 413, 414, 414, 414, 417, 417, 419, 420, 421, 421, 421, 423, 424, 425, 425, 425, 428, 428, 421, 431, 431, 421, 417, 417, 436, 437, 437, 437, 440, 440, 437, 437, 437, 443, 443, 443, 443, 449, 450, 450, 450, 450, 458, 450, 450, 450, 450, 463, 450, 450, 450, 450, 450, 450, 469, 470, 471, 471, 0, 478, 482, 482, 483, 484, 493, 494, 495, 495, 495, 498, 498, 500, 501, 502, 502, 502, 504, 505, 506, 506, 506, 509, 509, 502, 512, 512, 502, 498, 498, 517, 518, 518, 518, 521, 521, 518, 518, 518, 524, 524, 524, 524, 530, 531, 531, 531, 531, 539, 531, 531, 531, 531, 544, 531, 531, 531, 531, 531, 531, 550, 551, 552, 552, 0, 559, 560, 0, 566, 0, 573, 577, 577, 578, 0, 0, 587, 588, 592, 592, 593, 0, 598, 0, 601, 0, 604, 604, 605, 606, 0, 647, 649, 650, 651, 652, 654, 656, 660, 660, 651, 651, 651, 651, 662, 651, 651, 656, 651, 651, 647, 666, 666, 666, 666, 666, 666, 656, 656, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 705, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 651, 0, 749, 750, 751, 753, 749, 749, 757, 0, 776, 778, 780, 781, 782, 783, 784, 786, 783, 783, 783, 783, 783, 789, 783, 783, 791, 789, 789, 783, 0, 810, 811, 115, 115, 814, 815, 115, 811, 811, 818, 820, 823, 811, 824, 811, 825, 826, 828, 830, 811, 818, 831, 831, 820, 831, 835, 831, 831, 831, 831, 0, 190, 843, 844, 843, 843, 0, 853, 854, 856, 858, 860, 858, 862, 0, 874, 875, 876, 877, 879, 881, 883, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 884, 0, 942, 945, 948, 949, 953, 955, 956, 957, 958, 959, 961, 964, 965, 967, 969, 972, 974, 975, 212, 972, 977, 972, 964, 979, 981, 964, 964, 999, 1002, 1004, 1005, 1009, 1012, 1013, 1014, 1015, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 1019, 1023, 1025, 999, 999, 964, 1030, 1031, 1031, 1031, 964, 964, 964, 1032, 1039, 1039, 1041, 1043, 1052, 1053, 1054, 1054, 1054, 1057, 1057, 1059, 1060, 1061, 1061, 1061, 1063, 1064, 1065, 1065, 1065, 1068, 1068, 1061, 1071, 1071, 1061, 1057, 1057, 1076, 1077, 1077, 1077, 1080, 1080, 1077, 1077, 1077, 1083, 1083, 1083, 1083, 1089, 1090, 1090, 1090, 1090, 1098, 1090, 1090, 1090, 1090, 1104, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1122, 1123, 1124, 1124, 212, 964, 964, 1128, 964, 959, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 212, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 1181, 949, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 1206, 964, 0, 1214, 1215, 1216, 1218, 1220, 1222, 0, 1231, 1232, 1233, 1234, 1236, 1231, 1239, 0, 314, 1294, 1296, 1297, 1298, 1299, 1301, 1303, 1305, 1308, 1308, 314, 1310, 1312, 1313, 1314, 1310, 1316, 1318, 1318, 1321, 1321, 1324, 1335, 314, 1341, 1343, 1345, 1346, 1349, 1350, 1324, 1324, 1353, 1353, 1353, 1359, 1361, 1362, 1365, 1367, 1368, 1369, 1353, 1353, 1376, 1381, 1386, 1353, 1353, 1393, 1393, 1353, 1353, 1318, 1310, 1310, 1318, 1310, 1310, 1305, 314, 1411, 1412, 1412, 1412, 1412, 1412, 1412, 1418, 1305, 1421, 1422, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1462, 1463, 1423, 1423, 1467, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1521, 1299, 1522, 0, 1528, 1529, 1530, 1532, 1528, 1528, 1528, 0, 1537, 1537, 1537, 1537, 1541]);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_start")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_start='](186);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_error")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_error='](0);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_interp_words")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_interp_words='](195);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_interp_string")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_interp_string='](261);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_plain_words")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_plain_words='](326);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_plain_string")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_plain_string='](329);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_interp_backslash_delimited")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_interp_backslash_delimited='](331);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_plain_backslash_delimited")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_plain_backslash_delimited='](336);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_interp_backslash_delimited_words")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_interp_backslash_delimited_words='](337);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_plain_backslash_delimited_words")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_plain_backslash_delimited_words='](343);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_regexp_modifiers")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_regexp_modifiers='](345);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_variable")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_variable='](347);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_fname")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_fname='](352);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_endfn")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_endfn='](465);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_dot")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_dot='](473);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_arg")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_arg='](494);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_cmdarg")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_cmdarg='](525);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_endarg")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_endarg='](531);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_mid")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_mid='](539);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_beg")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_beg='](563);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_labelarg")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_labelarg='](795);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_value")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_value='](802);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_expr_end")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_expr_end='](810);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_leading_dot")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_leading_dot='](990);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_line_comment")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_line_comment='](998);
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("lex_en_line_begin")
    })(Opal.get_singleton_class(self), $nesting);
    self['$lex_en_line_begin='](186);
    $const_set($nesting[0], 'ESCAPES', $hash("a".$ord(), "\u0007", "b".$ord(), "\b", "e".$ord(), "\u001b", "f".$ord(), "\f", "n".$ord(), "\n", "r".$ord(), "\r", "s".$ord(), " ", "t".$ord(), "\t", "v".$ord(), "\v", "\\".$ord(), "\\").$freeze());
    $const_set($nesting[0], 'REGEXP_META_CHARACTERS', $send($$('Regexp'), 'union', $to_a("\\$()*+.<>?[]^{|}".$chars())).$freeze());
    self.$attr_reader("source_buffer");
    self.$attr_accessor("diagnostics");
    self.$attr_accessor("static_env");
    self.$attr_accessor("force_utf32");
    self.$attr_accessor("cond", "cmdarg", "context", "command_start");
    self.$attr_accessor("tokens", "comments");
    self.$attr_reader("paren_nest", "cmdarg_stack", "cond_stack", "lambda_stack");
    
    $def(self, '$initialize', function $$initialize(version) {
      var self = this;

      
      self.version = version;
      self.static_env = nil;
      self.context = nil;
      self.tokens = nil;
      self.comments = nil;
      return self.$reset();
    }, 1);
    
    $def(self, '$reset', function $$reset(reset_state) {
      var self = this;

      
      
      if (reset_state == null) reset_state = true;;
      if ($truthy(reset_state)) {
        
        self.cs = self.$class().$lex_en_line_begin();
        self.cond = $$('StackState').$new("cond");
        self.cmdarg = $$('StackState').$new("cmdarg");
        self.cond_stack = [];
        self.cmdarg_stack = [];
      };
      self.force_utf32 = false;
      self.source_pts = nil;
      self.p = 0;
      self.ts = nil;
      self.te = nil;
      self.act = 0;
      self.stack = [];
      self.top = 0;
      self.token_queue = [];
      self.literal_stack = [];
      self.eq_begin_s = nil;
      self.sharp_s = nil;
      self.newline_s = nil;
      self.num_base = nil;
      self.num_digits_s = nil;
      self.num_suffix_s = nil;
      self.num_xfrm = nil;
      self.escape_s = nil;
      self.escape = nil;
      self.herebody_s = nil;
      self.paren_nest = 0;
      self.lambda_stack = [];
      self.dedent_level = nil;
      self.command_start = true;
      return (self.cs_before_block_comment = self.$class().$lex_en_line_begin());
    }, -1);
    
    $def(self, '$source_buffer=', function $Lexer_source_buffer$eq$1(source_buffer) {
      var self = this, source = nil;

      
      self.source_buffer = source_buffer;
      if ($truthy(self.source_buffer)) {
        
        source = self.source_buffer.$source();
        if ($eqeq(source.$encoding(), $$$($$('Encoding'), 'UTF_8'))) {
          self.source_pts = source.$unpack("U*")
        } else {
          self.source_pts = source.$unpack("C*")
        };
        if ($eqeq(self.source_pts['$[]'](0), 65279)) {
          return (self.p = 1)
        } else {
          return nil
        };
      } else {
        return (self.source_pts = nil)
      };
    }, 1);
    
    $def(self, '$encoding', function $$encoding() {
      var self = this;

      return self.source_buffer.$source().$encoding()
    }, 0);
    $const_set($nesting[0], 'LEX_STATES', $hash2(["line_begin", "expr_dot", "expr_fname", "expr_value", "expr_beg", "expr_mid", "expr_arg", "expr_cmdarg", "expr_end", "expr_endarg", "expr_endfn", "expr_labelarg", "interp_string", "interp_words", "plain_string", "plain_words"], {"line_begin": self.$lex_en_line_begin(), "expr_dot": self.$lex_en_expr_dot(), "expr_fname": self.$lex_en_expr_fname(), "expr_value": self.$lex_en_expr_value(), "expr_beg": self.$lex_en_expr_beg(), "expr_mid": self.$lex_en_expr_mid(), "expr_arg": self.$lex_en_expr_arg(), "expr_cmdarg": self.$lex_en_expr_cmdarg(), "expr_end": self.$lex_en_expr_end(), "expr_endarg": self.$lex_en_expr_endarg(), "expr_endfn": self.$lex_en_expr_endfn(), "expr_labelarg": self.$lex_en_expr_labelarg(), "interp_string": self.$lex_en_interp_string(), "interp_words": self.$lex_en_interp_words(), "plain_string": self.$lex_en_plain_string(), "plain_words": self.$lex_en_plain_string()}));
    
    $def(self, '$state', function $$state() {
      var self = this;

      return $$('LEX_STATES').$invert().$fetch(self.cs, self.cs)
    }, 0);
    
    $def(self, '$state=', function $Lexer_state$eq$2(state) {
      var self = this;

      return (self.cs = $$('LEX_STATES').$fetch(state))
    }, 1);
    
    $def(self, '$push_cmdarg', function $$push_cmdarg() {
      var self = this;

      
      self.cmdarg_stack.$push(self.cmdarg);
      return (self.cmdarg = $$('StackState').$new("cmdarg." + (self.cmdarg_stack.$count())));
    }, 0);
    
    $def(self, '$pop_cmdarg', function $$pop_cmdarg() {
      var self = this;

      return (self.cmdarg = self.cmdarg_stack.$pop())
    }, 0);
    
    $def(self, '$push_cond', function $$push_cond() {
      var self = this;

      
      self.cond_stack.$push(self.cond);
      return (self.cond = $$('StackState').$new("cond." + (self.cond_stack.$count())));
    }, 0);
    
    $def(self, '$pop_cond', function $$pop_cond() {
      var self = this;

      return (self.cond = self.cond_stack.$pop())
    }, 0);
    
    $def(self, '$dedent_level', function $$dedent_level() {
      var $a, self = this, dedent_level = nil;

      
      $a = [self.dedent_level, nil], (dedent_level = $a[0]), (self.dedent_level = $a[1]), $a;
      return dedent_level;
    }, 0);
    
    $def(self, '$advance', function $$advance() {
      var $a, $b, self = this, klass = nil, _lex_trans_keys = nil, _lex_key_spans = nil, _lex_index_offsets = nil, _lex_indicies = nil, _lex_trans_targs = nil, _lex_trans_actions = nil, _lex_to_state_actions = nil, _lex_from_state_actions = nil, _lex_eof_trans = nil, pe = nil, p = nil, eof = nil, cmd_state = nil, testEof = nil, _slen = nil, _trans = nil, _keys = nil, _inds = nil, _acts = nil, _nacts = nil, _goto_level = nil, _resume = nil, _eof_trans = nil, _again = nil, _test_eof = nil, _out = nil, _wide = nil, $ret_or_1 = nil, tm = nil, heredoc_e = nil, diag_msg = nil, ident_tok = nil, ident_ts = nil, ident_te = nil, current_literal = nil, line = nil, string = nil, lookahead = nil, token = nil, message = nil, escaped_char = nil, $ret_or_2 = nil, unknown_options = nil, type = nil, delimiter = nil, escape = nil, ident = nil, followed_by_nl = nil, nl_emitted = nil, dots_te = nil, value = nil, digits = nil, invalid_idx = nil, invalid_s = nil, codepoints = nil, codepoint_s = nil, spaces_p = nil, codepoint = nil, new_herebody_s = nil, indent = nil, dedent_body = nil;

      
      if ($truthy(self.token_queue['$any?']())) {
        return self.token_queue.$shift()
      };
      klass = self.$class();
      _lex_trans_keys = klass.$send("_lex_trans_keys");
      _lex_key_spans = klass.$send("_lex_key_spans");
      _lex_index_offsets = klass.$send("_lex_index_offsets");
      _lex_indicies = klass.$send("_lex_indicies");
      _lex_trans_targs = klass.$send("_lex_trans_targs");
      _lex_trans_actions = klass.$send("_lex_trans_actions");
      _lex_to_state_actions = klass.$send("_lex_to_state_actions");
      _lex_from_state_actions = klass.$send("_lex_from_state_actions");
      _lex_eof_trans = klass.$send("_lex_eof_trans");
      pe = $rb_plus(self.source_pts.$size(), 2);
      $a = [self.p, pe], (p = $a[0]), (eof = $a[1]), $a;
      cmd_state = self.command_start;
      self.command_start = false;
      
      testEof = false;
      $b = nil, $a = $to_ary($b), (_slen = ($a[0] == null ? nil : $a[0])), (_trans = ($a[1] == null ? nil : $a[1])), (_keys = ($a[2] == null ? nil : $a[2])), (_inds = ($a[3] == null ? nil : $a[3])), (_acts = ($a[4] == null ? nil : $a[4])), (_nacts = ($a[5] == null ? nil : $a[5])), $b;
      _goto_level = 0;
      _resume = 10;
      _eof_trans = 15;
      _again = 20;
      _test_eof = 30;
      _out = 40;
      while ($truthy(true)) {
        
        if ($truthy($rb_le(_goto_level, 0))) {
          
          if ($eqeq(p, pe)) {
            
            _goto_level = _test_eof;
            continue;;
          };
          if ($eqeq(self.cs, 0)) {
            
            _goto_level = _out;
            continue;;
          };
        };
        if ($truthy($rb_le(_goto_level, _resume))) {
          
          
          switch (_lex_from_state_actions['$[]'](self.cs)) {
            case 97:
              
              self.ts = p;
              break;
            default:
              nil
          };
          _keys = self.cs['$<<'](1);
          _inds = _lex_index_offsets['$[]'](self.cs);
          _slen = _lex_key_spans['$[]'](self.cs);
          _wide = ($truthy(($ret_or_1 = self.source_pts['$[]'](p))) ? ($ret_or_1) : (0));
          _trans = ((($truthy($rb_gt(_slen, 0)) && ($truthy($rb_le(_lex_trans_keys['$[]'](_keys), _wide)))) && ($truthy($rb_le(_wide, _lex_trans_keys['$[]']($rb_plus(_keys, 1)))))) ? (_lex_indicies['$[]']($rb_minus($rb_plus(_inds, _wide), _lex_trans_keys['$[]'](_keys)))) : (_lex_indicies['$[]']($rb_plus(_inds, _slen))));
        };
        if ($truthy($rb_le(_goto_level, _eof_trans))) {
          
          self.cs = _lex_trans_targs['$[]'](_trans);
          if ($neqeq(_lex_trans_actions['$[]'](_trans), 0)) {
            
            switch (_lex_trans_actions['$[]'](_trans)) {
              case 29:
                
                self.newline_s = p;
                break;
              case 117:
                
                self.escape_s = p;
                self.escape = nil;
                break;
              case 30:
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };
                break;
              case 60:
                
                self.sharp_s = $rb_minus(p, 1);
                break;
              case 64:
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));
                break;
              case 310:
                
                tm = p;
                break;
              case 37:
                
                tm = p;
                break;
              case 39:
                
                tm = p;
                break;
              case 41:
                
                tm = p;
                break;
              case 71:
                
                heredoc_e = p;
                break;
              case 349:
                
                tm = $rb_minus(p, 1);
                diag_msg = "ivar_name";
                break;
              case 352:
                
                tm = $rb_minus(p, 2);
                diag_msg = "cvar_name";
                break;
              case 360:
                
                self.escape = nil;
                break;
              case 392:
                
                tm = p;
                break;
              case 308:
                
                ident_tok = self.$tok();
                ident_ts = self.ts;
                ident_te = self.te;
                break;
              case 479:
                
                self.num_base = 16;
                self.num_digits_s = p;
                break;
              case 473:
                
                self.num_base = 10;
                self.num_digits_s = p;
                break;
              case 476:
                
                self.num_base = 8;
                self.num_digits_s = p;
                break;
              case 470:
                
                self.num_base = 2;
                self.num_digits_s = p;
                break;
              case 485:
                
                self.num_base = 10;
                self.num_digits_s = self.ts;
                break;
              case 447:
                
                self.num_base = 8;
                self.num_digits_s = self.ts;
                break;
              case 462:
                
                self.num_suffix_s = p;
                break;
              case 455:
                
                self.num_suffix_s = p;
                break;
              case 452:
                
                self.num_suffix_s = p;
                break;
              case 89:
                
                tm = p;
                break;
              case 7:
                
                self.te = $rb_plus(p, 1);
                break;
              case 113:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DBEG", "\#{".$freeze());
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  current_literal['$saved_herebody_s='](self.herebody_s);
                  self.herebody_s = nil;
                };
                current_literal.$start_interp_brace();
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 5:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 109:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 108:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 115:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$literal().$extend_string(self.$tok(), self.ts, self.te)
                } else {
                  
                  message = ($truthy(self.$tok()['$start_with?']("\#@@")) ? ("cvar_name") : ("ivar_name"));
                  self.$diagnostic("error", message, $hash2(["name"], {"name": self.$tok($rb_plus(self.ts, 1), self.te)}), self.$range($rb_plus(self.ts, 1), self.te));
                };;
                break;
              case 114:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 111:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$literal().$extend_space(self.ts, self.te);;
                break;
              case 112:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 6:
                
                
                p = $rb_minus(self.te, 1);;
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;
                break;
              case 4:
                
                
                p = $rb_minus(self.te, 1);;
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 145:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DBEG", "\#{".$freeze());
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  current_literal['$saved_herebody_s='](self.herebody_s);
                  self.herebody_s = nil;
                };
                current_literal.$start_interp_brace();
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 10:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 142:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 141:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 147:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$literal().$extend_string(self.$tok(), self.ts, self.te)
                } else {
                  
                  message = ($truthy(self.$tok()['$start_with?']("\#@@")) ? ("cvar_name") : ("ivar_name"));
                  self.$diagnostic("error", message, $hash2(["name"], {"name": self.$tok($rb_plus(self.ts, 1), self.te)}), self.$range($rb_plus(self.ts, 1), self.te));
                };;
                break;
              case 146:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 144:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 11:
                
                
                p = $rb_minus(self.te, 1);;
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;
                break;
              case 9:
                
                
                p = $rb_minus(self.te, 1);;
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 173:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 172:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 175:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$literal().$extend_space(self.ts, self.te);;
                break;
              case 176:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 179:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 178:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 181:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 188:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DBEG", "\#{".$freeze());
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  current_literal['$saved_herebody_s='](self.herebody_s);
                  self.herebody_s = nil;
                };
                current_literal.$start_interp_brace();
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 13:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 185:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 184:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 190:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$literal().$extend_string(self.$tok(), self.ts, self.te)
                } else {
                  
                  message = ($truthy(self.$tok()['$start_with?']("\#@@")) ? ("cvar_name") : ("ivar_name"));
                  self.$diagnostic("error", message, $hash2(["name"], {"name": self.$tok($rb_plus(self.ts, 1), self.te)}), self.$range($rb_plus(self.ts, 1), self.te));
                };;
                break;
              case 189:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 187:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 12:
                
                
                p = $rb_minus(self.te, 1);;
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 192:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 191:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 199:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DBEG", "\#{".$freeze());
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  current_literal['$saved_herebody_s='](self.herebody_s);
                  self.herebody_s = nil;
                };
                current_literal.$start_interp_brace();
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 15:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 195:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 194:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 201:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$literal().$extend_string(self.$tok(), self.ts, self.te)
                } else {
                  
                  message = ($truthy(self.$tok()['$start_with?']("\#@@")) ? ("cvar_name") : ("ivar_name"));
                  self.$diagnostic("error", message, $hash2(["name"], {"name": self.$tok($rb_plus(self.ts, 1), self.te)}), self.$range($rb_plus(self.ts, 1), self.te));
                };;
                break;
              case 200:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                current_literal.$flush_string();
                current_literal.$extend_content();
                self.$emit("tSTRING_DVAR", nil, self.ts, $rb_plus(self.ts, 1));
                p = self.ts;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 197:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$literal().$extend_space(self.ts, self.te);;
                break;
              case 198:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 14:
                
                
                p = $rb_minus(self.te, 1);;
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 203:
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;
                break;
              case 202:
                
                self.te = $rb_plus(p, 1);
                
                string = self.$tok();
                if (($truthy($rb_ge(self.version, 22)) && ($not(self.cond['$active?']())))) {
                  lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))
                };
                current_literal = self.$literal();
                if (($not(current_literal['$heredoc?']()) && ($truthy((token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)))))) {
                  
                  if ($eqeq(token['$[]'](0), "tLABEL_END")) {
                    
                    p = $rb_plus(p, 1);
                    self.$pop_literal();
                    self.cs = 795;
                  } else {
                    self.cs = self.$pop_literal()
                  };
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  current_literal.$extend_string(string, self.ts, self.te)
                };;
                break;
              case 205:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$literal().$extend_space(self.ts, self.te);;
                break;
              case 206:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tREGEXP_OPT", self.$tok(self.ts, $rb_minus(self.te, 1)), self.ts, $rb_minus(self.te, 1));
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 207:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                unknown_options = self.$tok().$scan(/[^imxouesn]/);
                if ($truthy(unknown_options['$any?']())) {
                  self.$diagnostic("error", "regexp_options", $hash2(["options"], {"options": unknown_options.$join()}))
                };
                self.$emit("tREGEXP_OPT");
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 16:
                
                self.te = $rb_plus(p, 1);
                
                if ($truthy(self.$tok()['$=~'](/^\$([1-9][0-9]*)$/))) {
                  self.$emit("tNTH_REF", self.$tok($rb_plus(self.ts, 1)).$to_i())
                } else if ($truthy(self.$tok()['$=~'](/^\$([&`'+])$/))) {
                  self.$emit("tBACK_REF")
                } else {
                  self.$emit("tGVAR")
                };
                self.cs = self.$stack_pop();
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 208:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy(self.$tok()['$=~'](/^\$([1-9][0-9]*)$/))) {
                  self.$emit("tNTH_REF", self.$tok($rb_plus(self.ts, 1)).$to_i())
                } else if ($truthy(self.$tok()['$=~'](/^\$([&`'+])$/))) {
                  self.$emit("tBACK_REF")
                } else {
                  self.$emit("tGVAR")
                };
                self.cs = self.$stack_pop();
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 210:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy(self.$tok()['$=~'](/^@@[0-9]/))) {
                  self.$diagnostic("error", "cvar_name", $hash2(["name"], {"name": self.$tok()}))
                };
                self.$emit("tCVAR");
                self.cs = self.$stack_pop();
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 209:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy(self.$tok()['$=~'](/^@[0-9]/))) {
                  self.$diagnostic("error", "ivar_name", $hash2(["name"], {"name": self.$tok()}))
                };
                self.$emit("tIVAR");
                self.cs = self.$stack_pop();
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 231:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('KEYWORDS_BEGIN'));
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 217:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tIDENTIFIER");
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 18:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                self.cs = 810;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 214:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 226:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 20:
                
                self.te = $rb_plus(p, 1);
                
                if ($truthy(self['$version?'](23))) {
                  
                  $b = [self.$tok()['$[]']($range(0, -2, false)), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;
                  
                  self.cs = self.$push_literal(type, delimiter, self.ts);
                  _goto_level = _again;
                  continue;;;
                } else {
                  
                  p = $rb_minus(self.ts, 1);
                  
                  self.cs = 810;
                  _goto_level = _again;
                  continue;;;
                };;
                break;
              case 213:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 212:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 230:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('KEYWORDS_BEGIN'));
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 227:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tCONSTANT");
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 229:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tIDENTIFIER");
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 224:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                self.cs = 810;
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 220:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 225:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 218:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 223:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 19:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 17:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 216:
                
                
                switch (self.act) {
                  case 43:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS_BEGIN'));
                    self.cs = 465;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 44:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tCONSTANT");
                    self.cs = 465;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 45:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tIDENTIFIER");
                    self.cs = 465;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 22:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tLABEL", self.$tok(self.ts, $rb_minus(self.te, 2)), self.ts, $rb_minus(self.te, 1));
                p = $rb_minus(p, 1);
                self.cs = 795;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 23:
                
                self.te = $rb_plus(p, 1);
                
                if (($truthy($rb_ge(self.version, 31)) && ($truthy(self.context.$in_argdef())))) {
                  
                  self.$emit("tBDOT3", "...".$freeze());
                  self.cs = 810;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  p = $rb_minus(p, 3);
                  
                  self.cs = 810;
                  _goto_level = _again;
                  continue;;;
                };;
                break;
              case 233:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 232:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 235:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 234:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 21:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 241:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 494;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 240:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 239:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 251:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tCONSTANT");
                self.cs = self.$arg_or_cmdarg(cmd_state);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 242:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tIDENTIFIER");
                self.cs = self.$arg_or_cmdarg(cmd_state);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 247:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 494;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 245:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 250:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 274:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 257:
                
                self.te = $rb_plus(p, 1);
                
                if ($eqeq(self.$tok(tm, $rb_plus(tm, 1)), "/".$freeze())) {
                  if ($truthy($rb_lt(self.version, 30))) {
                    self.$diagnostic("warning", "ambiguous_literal", nil, self.$range(tm, $rb_plus(tm, 1)))
                  } else {
                    self.$diagnostic("warning", "ambiguous_regexp", nil, self.$range(tm, $rb_plus(tm, 1)))
                  }
                };
                p = $rb_minus(tm, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 263:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 25:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 265:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(tm, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 40:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 252:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 253:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 264:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 260:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("warning", "ambiguous_prefix", $hash2(["prefix"], {"prefix": self.$tok(tm, self.te)}), self.$range(tm, self.te));
                p = $rb_minus(tm, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 262:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 256:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 255:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 273:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 26:
                
                
                p = $rb_minus(self.te, 1);;
                break;
              case 42:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 24:
                
                
                switch (self.act) {
                  case 72:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($eqeq(self.$tok(tm, $rb_plus(tm, 1)), "/".$freeze())) {
                      if ($truthy($rb_lt(self.version, 30))) {
                        self.$diagnostic("warning", "ambiguous_literal", nil, self.$range(tm, $rb_plus(tm, 1)))
                      } else {
                        self.$diagnostic("warning", "ambiguous_regexp", nil, self.$range(tm, $rb_plus(tm, 1)))
                      }
                    };
                    p = $rb_minus(tm, 1);
                    
                    self.cs = 563;
                    _goto_level = _again;
                    continue;;;
                    break;
                  case 73:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$diagnostic("warning", "ambiguous_prefix", $hash2(["prefix"], {"prefix": self.$tok(tm, self.te)}), self.$range(tm, self.te));
                    p = $rb_minus(tm, 1);
                    
                    self.cs = 563;
                    _goto_level = _again;
                    continue;;;
                    break;
                  case 78:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 810;
                    _goto_level = _again;
                    continue;;;
                    break;
                  default:
                    
                    
                    p = $rb_minus(self.te, 1);;
                };
                break;
              case 44:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 494;
                _goto_level = _again;
                continue;;;;
                break;
              case 278:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 279:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 494;
                _goto_level = _again;
                continue;;;;
                break;
              case 45:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 494;
                _goto_level = _again;
                continue;;;;
                break;
              case 43:
                
                
                switch (self.act) {
                  case 85:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self.cond['$active?']())) {
                      self.$emit("kDO_COND", "do".$freeze(), $rb_minus(self.te, 2), self.te)
                    } else {
                      self.$emit("kDO", "do".$freeze(), $rb_minus(self.te, 2), self.te)
                    };
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 86:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 494;
                    _goto_level = _again;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 289:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_do(true);
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 282:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 283:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 284:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 287:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 293:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 292:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 301:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 295:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 299:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 294:
                
                
                switch (self.act) {
                  case 93:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 563;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 94:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 563;
                    _goto_level = _again;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 57:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tUNARY_NUM", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                p = $rb_minus(p, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 334:
                
                self.te = $rb_plus(p, 1);
                
                type = (delimiter = self.$tok()['$[]'](0).$chr());
                p = $rb_minus(p, 1);
                
                self.cs = self.$push_literal(type, delimiter, self.ts);
                _goto_level = _again;
                continue;;;;
                break;
              case 326:
                
                self.te = $rb_plus(p, 1);
                
                $b = [self.source_buffer.$slice(self.ts).$chr(), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;
                
                self.cs = self.$push_literal(type, delimiter, self.ts);
                _goto_level = _again;
                continue;;;;
                break;
              case 55:
                
                self.te = $rb_plus(p, 1);
                
                $b = [self.$tok()['$[]']($range(0, -2, false)), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;
                
                self.cs = self.$push_literal(type, delimiter, self.ts);
                _goto_level = _again;
                continue;;;;
                break;
              case 347:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                p = $rb_minus(p, 1);
                self.$emit("tSYMBEG", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                
                self.cs = 352;
                _goto_level = _again;
                continue;;;;
                break;
              case 335:
                
                self.te = $rb_plus(p, 1);
                
                $b = [self.$tok(), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;
                
                self.cs = self.$push_literal(type, delimiter, self.ts);
                _goto_level = _again;
                continue;;;;
                break;
              case 346:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), $rb_plus(self.ts, 2)));
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 69:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1)), self.ts);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 357:
                
                self.te = $rb_plus(p, 1);
                
                escape = $hash2([" ", "\r", "\n", "\t", "\v", "\f"], {" ": "\\s", "\r": "\\r", "\n": "\\n", "\t": "\\t", "\v": "\\v", "\f": "\\f"})['$[]'](self.source_buffer.$slice($rb_plus(self.ts, 1)));
                self.$diagnostic("warning", "invalid_escape_use", $hash2(["escape"], {"escape": escape}), self.$range());
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 356:
                
                self.te = $rb_plus(p, 1);
                
                self.$diagnostic("fatal", "incomplete_escape", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 336:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION_BEGIN'));
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 52:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                if ($truthy(self['$version?'](18))) {
                  
                  ident = self.$tok(self.ts, $rb_minus(self.te, 2));
                  self.$emit(($truthy(self.source_buffer.$slice(self.ts)['$=~'](/[A-Z]/)) ? ("tCONSTANT") : ("tIDENTIFIER")), ident, self.ts, $rb_minus(self.te, 2));
                  p = $rb_minus(p, 1);
                  if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](ident))))) {
                    self.cs = 810
                  } else {
                    self.cs = self.$arg_or_cmdarg(cmd_state)
                  };
                } else {
                  
                  self.$emit("tLABEL", self.$tok(self.ts, $rb_minus(self.te, 2)), self.ts, $rb_minus(self.te, 1));
                  self.cs = 795;
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 49:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tIDENTIFIER", ident_tok, ident_ts, ident_te);
                p = $rb_minus(ident_te, 1);
                if ((($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](ident_tok)))) && ($truthy($rb_lt(self.version, 25))))) {
                  self.cs = 465
                } else {
                  self.cs = 525
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 320:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                self.cs_before_block_comment = self.cs;
                
                self.cs = 186;
                _goto_level = _again;
                continue;;;;
                break;
              case 56:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 304:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 330:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tUNARY_NUM", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                p = $rb_minus(p, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 329:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSTAR", "*".$freeze());
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 325:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("fatal", "string_eof", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 354:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("error", "unterminated_heredoc_id", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 337:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1)), self.ts);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 350:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$diagnostic("error", diag_msg, $hash2(["name"], {"name": self.$tok(tm, self.te)}), self.$range(tm, self.te))
                } else {
                  
                  self.$emit("tCOLON", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                  p = self.ts;
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 355:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("fatal", "incomplete_escape", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 361:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 327:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION_BEGIN'));
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 331:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$emit("tBDOT2")
                } else {
                  self.$emit("tDOT2")
                };
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 332:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                followed_by_nl = $rb_minus(self.te, 1)['$=='](self.newline_s);
                nl_emitted = false;
                dots_te = ($truthy(followed_by_nl) ? ($rb_minus(self.te, 1)) : (self.te));
                if ($truthy($rb_ge(self.version, 30))) {
                  if (($truthy(self.lambda_stack['$any?']()) && ($eqeq($rb_plus(self.lambda_stack.$last(), 1), self.paren_nest)))) {
                    self.$emit("tDOT3", "...".$freeze(), self.ts, dots_te)
                  } else {
                    
                    self.$emit("tBDOT3", "...".$freeze(), self.ts, dots_te);
                    if ((($truthy($rb_ge(self.version, 31)) && ($truthy(followed_by_nl))) && ($truthy(self.context.$in_argdef())))) {
                      
                      self.$emit("tNL", $rb_minus(self.te, 1), self.te);
                      nl_emitted = true;
                    };
                  }
                } else if ($truthy($rb_ge(self.version, 27))) {
                  self.$emit("tBDOT3", "...".$freeze(), self.ts, dots_te)
                } else {
                  self.$emit("tDOT3", "...".$freeze(), self.ts, dots_te)
                };
                if (($truthy(followed_by_nl) && ($not(nl_emitted)))) {
                  p = $rb_minus(p, 1)
                };
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 307:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tIDENTIFIER");
                if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                  
                  self.cs = 465;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.cs = self.$arg_or_cmdarg(cmd_state);
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 317:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 319:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                self.cs_before_block_comment = self.cs;
                
                self.cs = 186;
                _goto_level = _again;
                continue;;;;
                break;
              case 322:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 54:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$diagnostic("fatal", "string_eof", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 73:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$diagnostic("error", "unterminated_heredoc_id", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;
                break;
              case 74:
                
                
                p = $rb_minus(self.te, 1);;
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 48:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$emit("tIDENTIFIER");
                if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                  
                  self.cs = 465;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.cs = self.$arg_or_cmdarg(cmd_state);
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 53:
                
                
                p = $rb_minus(self.te, 1);;
                break;
              case 68:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 51:
                
                
                switch (self.act) {
                  case 99:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tUNARY_NUM", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                    p = $rb_minus(p, 1);
                    self.cs = 810;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 106:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$diagnostic("error", "unterminated_heredoc_id", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));
                    break;
                  case 117:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy($rb_ge(self.version, 27))) {
                      
                      self.$emit("tPIPE", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                      p = $rb_minus(p, 1);
                      self.cs = 563;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      p = $rb_minus(p, 2);
                      
                      self.cs = 810;
                      _goto_level = _again;
                      continue;;;
                    };
                    break;
                  case 121:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION_BEGIN'));
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 122:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("kRESCUE", "rescue".$freeze(), self.ts, tm);
                    p = $rb_minus(tm, 1);
                    self.cs = 539;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 123:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS_BEGIN'));
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 127:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 810;
                    _goto_level = _again;
                    continue;;;
                    break;
                  case 128:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tIDENTIFIER");
                    if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                      
                      self.cs = 465;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = self.$arg_or_cmdarg(cmd_state);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 132:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 810;
                    _goto_level = _again;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 395:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 396:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 397:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 401:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 77:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 405:
                
                self.te = $rb_plus(p, 1);
                
                
                self.cs = self.$push_literal(self.$tok(), self.$tok(), self.ts);
                _goto_level = _again;
                continue;;;;
                break;
              case 404:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 403:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 407:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 406:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 76:
                
                
                p = $rb_minus(self.te, 1);;
                
                p = $rb_minus(p, 1);
                
                self.cs = 563;
                _goto_level = _again;
                continue;;;;
                break;
              case 440:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tLAMBDA", "->".$freeze(), self.ts, $rb_plus(self.ts, 2));
                self.lambda_stack.$push(self.paren_nest);
                self.cs = 465;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 86:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("kCLASS", "class".$freeze(), self.ts, $rb_plus(self.ts, 5));
                self.$emit("tLSHFT", "<<".$freeze(), $rb_minus(self.te, 2), self.te);
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 415:
                
                self.te = $rb_plus(p, 1);
                
                $b = [self.$tok(), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;
                
                self.cs = self.$push_literal(type, delimiter, self.ts, nil, false, false, true);
                _goto_level = _again;
                continue;;;;
                break;
              case 79:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 436:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 473;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 489:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 429:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 434:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tOP_ASGN", self.$tok(self.ts, $rb_minus(self.te, 1)));
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 420:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tEH", "?".$freeze());
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 417:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 419:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tSEMI", ";".$freeze());
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 494:
                
                self.te = $rb_plus(p, 1);
                
                self.$diagnostic("error", "bare_backslash", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));
                p = $rb_minus(p, 1);;
                break;
              case 414:
                
                self.te = $rb_plus(p, 1);
                
                self.$diagnostic("fatal", "unexpected", $hash2(["character"], {"character": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;
                break;
              case 413:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 505:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('KEYWORDS'));
                self.cs = 352;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 503:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("kCLASS", "class".$freeze(), self.ts, $rb_plus(self.ts, 5));
                self.$emit("tLSHFT", "<<".$freeze(), $rb_minus(self.te, 2), self.te);
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 502:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('KEYWORDS'));
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 444:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("error", "no_dot_digit_literal");;
                break;
              case 491:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tCONSTANT");
                self.cs = self.$arg_or_cmdarg(cmd_state);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 433:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.stack['$[]='](self.top, self.cs);
                self.top = $rb_plus(self.top, 1);
                self.cs = 347;
                _goto_level = _again;
                continue;;;;
                break;
              case 441:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 473;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 497:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tIDENTIFIER");
                if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                  
                  self.cs = 465;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.cs = self.$arg_or_cmdarg(cmd_state);
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 439:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 435:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 428:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 442:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 426:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 432:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("fatal", "unexpected", $hash2(["character"], {"character": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;
                break;
              case 84:
                
                
                p = $rb_minus(self.te, 1);;
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 80:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$diagnostic("error", "no_dot_digit_literal");;
                break;
              case 83:
                
                
                p = $rb_minus(self.te, 1);;
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 78:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$diagnostic("fatal", "unexpected", $hash2(["character"], {"character": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;
                break;
              case 81:
                
                
                switch (self.act) {
                  case 145:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                      
                      self.lambda_stack.$pop();
                      if ($eqeq(self.$tok(), "{".$freeze())) {
                        self.$emit("tLAMBEG", "{".$freeze())
                      } else {
                        self.$emit("kDO_LAMBDA", "do".$freeze())
                      };
                    } else if ($eqeq(self.$tok(), "{".$freeze())) {
                      self.$emit("tLCURLY", "{".$freeze())
                    } else {
                      self.$emit_do()
                    };
                    if ($eqeq(self.$tok(), "{".$freeze())) {
                      self.paren_nest = $rb_plus(self.paren_nest, 1)
                    };
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 146:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 352;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 147:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("kCLASS", "class".$freeze(), self.ts, $rb_plus(self.ts, 5));
                    self.$emit("tLSHFT", "<<".$freeze(), $rb_minus(self.te, 2), self.te);
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 148:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 563;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 149:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 150:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 539;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 151:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    if (($truthy(self['$version?'](18)) && ($eqeq(self.$tok(), "not".$freeze())))) {
                      
                      self.cs = 563;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = 494;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 152:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18))) {
                      
                      self.$emit("tIDENTIFIER");
                      if (!($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                        self.cs = self.$arg_or_cmdarg(cmd_state)
                      };
                    } else {
                      self.$emit("k__ENCODING__", "__ENCODING__".$freeze())
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 153:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 154:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                    if ($truthy(digits['$end_with?']("_".$freeze()))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                    } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                      digits = "0".$freeze()
                    } else if ($truthy(digits['$empty?']())) {
                      self.$diagnostic("error", "empty_numeric")
                    } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                      
                      invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                      self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                    };
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      
                      self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                      p = $rb_minus(self.num_suffix_s, 1);
                    } else {
                      self.num_xfrm.$call(digits.$to_i(self.num_base))
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 156:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))
                    } else {
                      
                      self.$emit("tINTEGER", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_i(), self.ts, $rb_minus(self.te, 1));
                      p = $rb_minus(p, 1);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 157:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))
                    } else {
                      
                      self.$emit("tFLOAT", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_f(), self.ts, $rb_minus(self.te, 1));
                      p = $rb_minus(p, 1);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 158:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    digits = self.$tok(self.ts, self.num_suffix_s);
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      
                      self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                      p = $rb_minus(self.num_suffix_s, 1);
                    } else {
                      self.num_xfrm.$call(digits)
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 160:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tCONSTANT");
                    self.cs = self.$arg_or_cmdarg(cmd_state);
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 164:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tIDENTIFIER");
                    if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                      
                      self.cs = 465;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = self.$arg_or_cmdarg(cmd_state);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 165:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($eqeq(tm, self.te)) {
                      self.$emit("tFID")
                    } else {
                      
                      self.$emit("tIDENTIFIER", self.$tok(self.ts, tm), self.ts, tm);
                      p = $rb_minus(tm, 1);
                    };
                    self.cs = 494;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 167:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION'));
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 168:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION'));
                    self.cs = 563;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 516:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                if ($truthy($rb_lt(self.version, 27))) {
                  
                  p = $rb_minus(p, 1);
                  self.cs = 186;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.$emit("tBDOT3");
                  self.cs = 563;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 95:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(tm, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 510:
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                p = $rb_minus(p, 1);
                self.cs = 186;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 513:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_lt(self.version, 27))) {
                  
                  self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                  p = $rb_minus(p, 1);
                  self.cs = 186;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 515:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                if ($truthy($rb_lt(self.version, 27))) {
                  
                  p = $rb_minus(p, 1);
                  self.cs = 186;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.$emit("tBDOT2");
                  self.cs = 563;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 514:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(tm, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;
                break;
              case 512:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                p = $rb_minus(p, 1);
                self.cs = 186;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 90:
                
                
                p = $rb_minus(self.te, 1);;
                
                if ($truthy($rb_lt(self.version, 27))) {
                  
                  self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                  p = $rb_minus(p, 1);
                  self.cs = 186;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;
                break;
              case 87:
                
                
                p = $rb_minus(self.te, 1);;
                
                self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                p = $rb_minus(p, 1);
                self.cs = 186;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 91:
                
                
                switch (self.act) {
                  case 181:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy($rb_lt(self.version, 27))) {
                      
                      self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                      p = $rb_minus(p, 1);
                      self.cs = 186;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 185:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tNL", nil, self.newline_s, $rb_plus(self.newline_s, 1));
                    p = $rb_minus(p, 1);
                    self.cs = 186;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  default:
                    nil
                };
                break;
              case 519:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_comment(self.eq_begin_s, self.te);
                
                self.cs = self.cs_before_block_comment;
                _goto_level = _again;
                continue;;;;
                break;
              case 518:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$diagnostic("fatal", "embedded_document", nil, self.$range(self.eq_begin_s, $rb_plus(self.eq_begin_s, "=begin".$length())));;
                break;
              case 106:
                
                self.te = $rb_plus(p, 1);
                
                self.eq_begin_s = self.ts;
                
                self.cs = 998;
                _goto_level = _again;
                continue;;;;
                break;
              case 2:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(pe, 3);;
                break;
              case 98:
                
                self.te = $rb_plus(p, 1);
                
                cmd_state = true;
                p = $rb_minus(p, 1);
                
                self.cs = 802;
                _goto_level = _again;
                continue;;;;
                break;
              case 99:
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(p, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;
                break;
              case 100:
                
                self.te = p;
                p = $rb_minus(p, 1);
                break;
              case 105:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.eq_begin_s = self.ts;
                
                self.cs = 998;
                _goto_level = _again;
                continue;;;;
                break;
              case 104:
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                cmd_state = true;
                p = $rb_minus(p, 1);
                
                self.cs = 802;
                _goto_level = _again;
                continue;;;;
                break;
              case 1:
                
                
                p = $rb_minus(self.te, 1);;
                
                cmd_state = true;
                p = $rb_minus(p, 1);
                
                self.cs = 802;
                _goto_level = _again;
                continue;;;;
                break;
              case 67:
                
                
                self.newline_s = p;;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                break;
              case 110:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 143:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 174:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 180:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 186:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 193:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 196:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 204:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                break;
              case 275:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 266:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(tm, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 258:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 358:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                escape = $hash2([" ", "\r", "\n", "\t", "\v", "\f"], {" ": "\\s", "\r": "\\r", "\n": "\\n", "\t": "\\t", "\v": "\\v", "\f": "\\f"})['$[]'](self.source_buffer.$slice($rb_plus(self.ts, 1)));
                self.$diagnostic("warning", "invalid_escape_use", $hash2(["escape"], {"escape": escape}), self.$range());
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 333:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                followed_by_nl = $rb_minus(self.te, 1)['$=='](self.newline_s);
                nl_emitted = false;
                dots_te = ($truthy(followed_by_nl) ? ($rb_minus(self.te, 1)) : (self.te));
                if ($truthy($rb_ge(self.version, 30))) {
                  if (($truthy(self.lambda_stack['$any?']()) && ($eqeq($rb_plus(self.lambda_stack.$last(), 1), self.paren_nest)))) {
                    self.$emit("tDOT3", "...".$freeze(), self.ts, dots_te)
                  } else {
                    
                    self.$emit("tBDOT3", "...".$freeze(), self.ts, dots_te);
                    if ((($truthy($rb_ge(self.version, 31)) && ($truthy(followed_by_nl))) && ($truthy(self.context.$in_argdef())))) {
                      
                      self.$emit("tNL", $rb_minus(self.te, 1), self.te);
                      nl_emitted = true;
                    };
                  }
                } else if ($truthy($rb_ge(self.version, 27))) {
                  self.$emit("tBDOT3", "...".$freeze(), self.ts, dots_te)
                } else {
                  self.$emit("tDOT3", "...".$freeze(), self.ts, dots_te)
                };
                if (($truthy(followed_by_nl) && ($not(nl_emitted)))) {
                  p = $rb_minus(p, 1)
                };
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 321:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                self.cs_before_block_comment = self.cs;
                
                self.cs = 186;
                _goto_level = _again;
                continue;;;;;
                break;
              case 443:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                if ($eqeq(self.paren_nest, 0)) {
                  self.$diagnostic("warning", "triple_dot_at_eol", nil, self.$range(self.ts, $rb_minus(self.te, 1)))
                };
                self.$emit("tDOT3", "...".$freeze(), self.ts, $rb_minus(self.te, 1));
                p = $rb_minus(p, 1);
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 520:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                self.$emit_comment(self.eq_begin_s, self.te);
                
                self.cs = self.cs_before_block_comment;
                _goto_level = _again;
                continue;;;;;
                break;
              case 517:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);;
                break;
              case 107:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                self.eq_begin_s = self.ts;
                
                self.cs = 998;
                _goto_level = _again;
                continue;;;;;
                break;
              case 3:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(pe, 3);;;
                break;
              case 465:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$3(chars){var self = $$3.$$s == null ? this : $$3.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tRATIONAL", self.$Rational(chars));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 463:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$4(chars){var self = $$4.$$s == null ? this : $$4.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tIMAGINARY", self.$Complex(0, chars));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 468:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$5(chars){var self = $$5.$$s == null ? this : $$5.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tIMAGINARY", self.$Complex(0, self.$Rational(chars)));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 466:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$6(chars){var self = $$6.$$s == null ? this : $$6.$$s;
                  if (self.ts == null) self.ts = nil;
                  if (self.te == null) self.te = nil;

                  
                  
                  if (chars == null) chars = nil;;
                  self.$emit("tINTEGER", chars, self.ts, $rb_minus(self.te, 2));
                  return (p = $rb_minus(p, 2));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 464:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$7(chars){var self = $$7.$$s == null ? this : $$7.$$s;
                  if (self.ts == null) self.ts = nil;
                  if (self.te == null) self.te = nil;

                  
                  
                  if (chars == null) chars = nil;;
                  self.$emit("tINTEGER", chars, self.ts, $rb_minus(self.te, 2));
                  return (p = $rb_minus(p, 2));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 467:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$8(chars){var self = $$8.$$s == null ? this : $$8.$$s;
                  if (self.ts == null) self.ts = nil;
                  if (self.te == null) self.te = nil;

                  
                  
                  if (chars == null) chars = nil;;
                  self.$emit("tINTEGER", chars, self.ts, $rb_minus(self.te, 6));
                  return (p = $rb_minus(p, 6));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 456:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$9(chars){var self = $$9.$$s == null ? this : $$9.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tIMAGINARY", self.$Complex(0, self.$Float(chars)));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 457:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$10(chars){var self = $$10.$$s == null ? this : $$10.$$s;
                  if (self.ts == null) self.ts = nil;
                  if (self.te == null) self.te = nil;

                  
                  
                  if (chars == null) chars = nil;;
                  self.$emit("tFLOAT", self.$Float(chars), self.ts, $rb_minus(self.te, 2));
                  return (p = $rb_minus(p, 2));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 458:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$11(chars){var self = $$11.$$s == null ? this : $$11.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tRATIONAL", self.$Rational(chars));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 460:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$12(chars){var self = $$12.$$s == null ? this : $$12.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tIMAGINARY", self.$Complex(0, self.$Rational(chars)));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 459:
                
                
                self.num_xfrm = $send(self, 'lambda', [], function $$13(chars){var self = $$13.$$s == null ? this : $$13.$$s;
                  if (self.ts == null) self.ts = nil;
                  if (self.te == null) self.te = nil;

                  
                  
                  if (chars == null) chars = nil;;
                  self.$emit("tFLOAT", self.$Float(chars), self.ts, $rb_minus(self.te, 6));
                  return (p = $rb_minus(p, 6));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 137:
                
                
                self.escape = "";
                codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));
                codepoint_s = $rb_plus(self.escape_s, 2);
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  if (($truthy(codepoints['$start_with?'](" ")) || ($truthy(codepoints['$start_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus(self.escape_s, 2), $rb_plus(self.escape_s, 3)))
                  };
                  if ($truthy((spaces_p = codepoints.$index(/[ \t]{2}/)))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus($rb_plus(codepoint_s, spaces_p), 1), $rb_plus($rb_plus(codepoint_s, spaces_p), 2)))
                  };
                  if (($truthy(codepoints['$end_with?'](" ")) || ($truthy(codepoints['$end_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(p, 1), p))
                  };
                };
                (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$scan(/([0-9a-fA-F]+)|([ \t]+)/), 'each', [], function $$14($mlhs_tmp1){var $c, $d, self = $$14.$$s == null ? this : $$14.$$s, codepoint_str = nil, spaces = nil, codepoint = nil;
                  if (self.escape == null) self.escape = nil;

                  
                  
                  if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
                  $d = $mlhs_tmp1, $c = $to_ary($d), (codepoint_str = ($c[0] == null ? nil : $c[0])), (spaces = ($c[1] == null ? nil : $c[1])), $d;
                  if ($truthy(spaces)) {
                    return (codepoint_s = $rb_plus(codepoint_s, spaces.$length()))
                  } else {
                    
                    codepoint = codepoint_str.$to_i(16);
                    if ($truthy($rb_ge(codepoint, 1114112))) {
                      
                      self.$diagnostic("error", "unicode_point_too_large", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));
                      
                      Opal.brk(nil, $brk);
                    };
                    self.escape = $rb_plus(self.escape, codepoint.$chr($$$($$('Encoding'), 'UTF_8')));
                    return (codepoint_s = $rb_plus(codepoint_s, codepoint_str.$length()));
                  };}, {$$arity: 1, $$s: self, $$brk: $brk, $$has_top_level_mlhs_arg: true})
                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 168:
                
                
                self.escape = "";
                codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));
                codepoint_s = $rb_plus(self.escape_s, 2);
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  if (($truthy(codepoints['$start_with?'](" ")) || ($truthy(codepoints['$start_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus(self.escape_s, 2), $rb_plus(self.escape_s, 3)))
                  };
                  if ($truthy((spaces_p = codepoints.$index(/[ \t]{2}/)))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus($rb_plus(codepoint_s, spaces_p), 1), $rb_plus($rb_plus(codepoint_s, spaces_p), 2)))
                  };
                  if (($truthy(codepoints['$end_with?'](" ")) || ($truthy(codepoints['$end_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(p, 1), p))
                  };
                };
                (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$scan(/([0-9a-fA-F]+)|([ \t]+)/), 'each', [], function $$15($mlhs_tmp1){var $c, $d, self = $$15.$$s == null ? this : $$15.$$s, codepoint_str = nil, spaces = nil, codepoint = nil;
                  if (self.escape == null) self.escape = nil;

                  
                  
                  if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
                  $d = $mlhs_tmp1, $c = $to_ary($d), (codepoint_str = ($c[0] == null ? nil : $c[0])), (spaces = ($c[1] == null ? nil : $c[1])), $d;
                  if ($truthy(spaces)) {
                    return (codepoint_s = $rb_plus(codepoint_s, spaces.$length()))
                  } else {
                    
                    codepoint = codepoint_str.$to_i(16);
                    if ($truthy($rb_ge(codepoint, 1114112))) {
                      
                      self.$diagnostic("error", "unicode_point_too_large", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));
                      
                      Opal.brk(nil, $brk);
                    };
                    self.escape = $rb_plus(self.escape, codepoint.$chr($$$($$('Encoding'), 'UTF_8')));
                    return (codepoint_s = $rb_plus(codepoint_s, codepoint_str.$length()));
                  };}, {$$arity: 1, $$s: self, $$brk: $brk, $$has_top_level_mlhs_arg: true})
                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 382:
                
                
                self.escape = "";
                codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));
                codepoint_s = $rb_plus(self.escape_s, 2);
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  if (($truthy(codepoints['$start_with?'](" ")) || ($truthy(codepoints['$start_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus(self.escape_s, 2), $rb_plus(self.escape_s, 3)))
                  };
                  if ($truthy((spaces_p = codepoints.$index(/[ \t]{2}/)))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_plus($rb_plus(codepoint_s, spaces_p), 1), $rb_plus($rb_plus(codepoint_s, spaces_p), 2)))
                  };
                  if (($truthy(codepoints['$end_with?'](" ")) || ($truthy(codepoints['$end_with?']("\t"))))) {
                    self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(p, 1), p))
                  };
                };
                (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$scan(/([0-9a-fA-F]+)|([ \t]+)/), 'each', [], function $$16($mlhs_tmp1){var $c, $d, self = $$16.$$s == null ? this : $$16.$$s, codepoint_str = nil, spaces = nil, codepoint = nil;
                  if (self.escape == null) self.escape = nil;

                  
                  
                  if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
                  $d = $mlhs_tmp1, $c = $to_ary($d), (codepoint_str = ($c[0] == null ? nil : $c[0])), (spaces = ($c[1] == null ? nil : $c[1])), $d;
                  if ($truthy(spaces)) {
                    return (codepoint_s = $rb_plus(codepoint_s, spaces.$length()))
                  } else {
                    
                    codepoint = codepoint_str.$to_i(16);
                    if ($truthy($rb_ge(codepoint, 1114112))) {
                      
                      self.$diagnostic("error", "unicode_point_too_large", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));
                      
                      Opal.brk(nil, $brk);
                    };
                    self.escape = $rb_plus(self.escape, codepoint.$chr($$$($$('Encoding'), 'UTF_8')));
                    return (codepoint_s = $rb_plus(codepoint_s, codepoint_str.$length()));
                  };}, {$$arity: 1, $$s: self, $$brk: $brk, $$has_top_level_mlhs_arg: true})
                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 118:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 149:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 363:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 121:
                
                
                self.$diagnostic("fatal", "invalid_escape");;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 152:
                
                
                self.$diagnostic("fatal", "invalid_escape");;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 366:
                
                
                self.$diagnostic("fatal", "invalid_escape");;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 123:
                
                
                self.escape = "\u007F";;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 154:
                
                
                self.escape = "\u007F";;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 368:
                
                
                self.escape = "\u007F";;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 120:
                
                
                self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 151:
                
                
                self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 365:
                
                
                self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 140:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 171:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 385:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 139:
                
                
                self.$diagnostic("fatal", "invalid_hex_escape", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 170:
                
                
                self.$diagnostic("fatal", "invalid_hex_escape", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 384:
                
                
                self.$diagnostic("fatal", "invalid_hex_escape", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 134:
                
                
                self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr($$$($$('Encoding'), 'UTF_8'));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 165:
                
                
                self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr($$$($$('Encoding'), 'UTF_8'));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 379:
                
                
                self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr($$$($$('Encoding'), 'UTF_8'));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 133:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 164:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 378:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 138:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 169:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 383:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 135:
                
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 166:
                
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 380:
                
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 119:
                
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 150:
                
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 364:
                
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 177:
                
                
                self.escape_s = p;
                self.escape = nil;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 182:
                
                
                self.escape_s = p;
                self.escape = nil;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 58:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.newline_s = p;;
                break;
              case 31:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                tm = p;;
                break;
              case 33:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                tm = p;;
                break;
              case 35:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                tm = p;;
                break;
              case 219:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 238:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 246:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 34:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = $rb_plus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 277:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 269:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 288:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 300:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 296:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(p, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 59:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tUNARY_NUM", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                p = $rb_minus(p, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 50:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = $rb_plus(p, 1);
                
                self.$emit("tIDENTIFIER", ident_tok, ident_ts, ident_te);
                p = $rb_minus(ident_te, 1);
                if ((($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](ident_tok)))) && ($truthy($rb_lt(self.version, 25))))) {
                  self.cs = 465
                } else {
                  self.cs = 525
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 318:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 402:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 398:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy(self.context.$in_kwarg())) {
                  
                  p = $rb_minus(p, 1);
                  
                  self.cs = 810;
                  _goto_level = _again;
                  continue;;;
                } else {
                  
                  self.cs = 186;
                  _goto_level = _again;
                  continue;;
                };;;
                break;
              case 411:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 408:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                
                self.cs = 186;
                _goto_level = _again;
                continue;;;;;
                break;
              case 495:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 427:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                
                self.cs = 990;
                _goto_level = _again;
                continue;;;;;
                break;
              case 101:
                
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 268:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                current_literal = self.$literal();
                if ($truthy(current_literal)) {
                  current_literal.$start_interp_brace()
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                  
                  self.lambda_stack.$pop();
                  self.$emit("tLAMBEG", "{".$freeze(), $rb_minus(self.te, 1), self.te);
                } else {
                  self.$emit("tLCURLY", "{".$freeze(), $rb_minus(self.te, 1), self.te)
                };
                self.command_start = true;
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 290:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                current_literal = self.$literal();
                if ($truthy(current_literal)) {
                  current_literal.$start_interp_brace()
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                  
                  self.lambda_stack.$pop();
                  self.$emit("tLAMBEG", "{".$freeze());
                } else {
                  self.$emit("tLBRACE_ARG", "{".$freeze())
                };
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 393:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                current_literal = self.$literal();
                if ($truthy(current_literal)) {
                  current_literal.$start_interp_brace()
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                  
                  self.lambda_stack.$pop();
                  self.command_start = true;
                  self.$emit("tLAMBEG", "{".$freeze());
                } else {
                  self.$emit("tLBRACE", "{".$freeze())
                };
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 508:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                current_literal = self.$literal();
                if ($truthy(current_literal)) {
                  current_literal.$start_interp_brace()
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                  
                  self.lambda_stack.$pop();
                  if ($eqeq(self.$tok(), "{".$freeze())) {
                    self.$emit("tLAMBEG", "{".$freeze())
                  } else {
                    self.$emit("kDO_LAMBDA", "do".$freeze())
                  };
                } else if ($eqeq(self.$tok(), "{".$freeze())) {
                  self.$emit("tLCURLY", "{".$freeze())
                } else {
                  self.$emit_do()
                };
                if ($eqeq(self.$tok(), "{".$freeze())) {
                  self.paren_nest = $rb_plus(self.paren_nest, 1)
                };
                self.command_start = true;
                self.cs = 802;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 509:
                
                
                current_literal = self.$literal();
                if ($truthy(current_literal)) {
                  if ($truthy(current_literal.$end_interp_brace_and_try_closing())) {
                    
                    if ($truthy(self['$version?'](18, 19))) {
                      
                      self.$emit("tRCURLY", "}".$freeze(), $rb_minus(p, 1), p);
                      self.cond.$lexpop();
                      self.cmdarg.$lexpop();
                    } else {
                      self.$emit("tSTRING_DEND", "}".$freeze(), $rb_minus(p, 1), p)
                    };
                    if ($truthy(current_literal.$saved_herebody_s())) {
                      self.herebody_s = current_literal.$saved_herebody_s()
                    };
                    p = $rb_minus(p, 1);
                    self.cs = self.$next_state_for_literal(current_literal);
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  }
                };
                self.paren_nest = $rb_minus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  self.cond.$lexpop();
                  self.cmdarg.$lexpop();
                } else {
                  
                  self.cond.$pop();
                  self.cmdarg.$pop();
                };
                if (($eqeq(self.$tok(), "}".$freeze()) || ($eqeq(self.$tok(), "]".$freeze())))) {
                  if ($truthy($rb_ge(self.version, 25))) {
                    self.cs = 810
                  } else {
                    self.cs = 531
                  }
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 61:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                break;
              case 65:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.newline_s = p;;
                break;
              case 222:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 237:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 249:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 271:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 286:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 298:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 324:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 400:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 410:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 431:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 103:
                
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 243:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tFID", self.$tok(self.ts, tm), self.ts, tm);
                self.cs = self.$arg_or_cmdarg(cmd_state);
                p = $rb_minus(tm, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 338:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 309:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 424:
                
                
                tm = p;;
                
                
                switch (self.act) {
                  case 145:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($eqeq(self.lambda_stack.$last(), self.paren_nest)) {
                      
                      self.lambda_stack.$pop();
                      if ($eqeq(self.$tok(), "{".$freeze())) {
                        self.$emit("tLAMBEG", "{".$freeze())
                      } else {
                        self.$emit("kDO_LAMBDA", "do".$freeze())
                      };
                    } else if ($eqeq(self.$tok(), "{".$freeze())) {
                      self.$emit("tLCURLY", "{".$freeze())
                    } else {
                      self.$emit_do()
                    };
                    if ($eqeq(self.$tok(), "{".$freeze())) {
                      self.paren_nest = $rb_plus(self.paren_nest, 1)
                    };
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 146:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 352;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 147:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("kCLASS", "class".$freeze(), self.ts, $rb_plus(self.ts, 5));
                    self.$emit("tLSHFT", "<<".$freeze(), $rb_minus(self.te, 2), self.te);
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 148:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 563;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 149:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 150:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    self.cs = 539;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 151:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    if (($truthy(self['$version?'](18)) && ($eqeq(self.$tok(), "not".$freeze())))) {
                      
                      self.cs = 563;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = 494;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 152:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18))) {
                      
                      self.$emit("tIDENTIFIER");
                      if (!($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                        self.cs = self.$arg_or_cmdarg(cmd_state)
                      };
                    } else {
                      self.$emit("k__ENCODING__", "__ENCODING__".$freeze())
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 153:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS'));
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 154:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                    if ($truthy(digits['$end_with?']("_".$freeze()))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                    } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                      digits = "0".$freeze()
                    } else if ($truthy(digits['$empty?']())) {
                      self.$diagnostic("error", "empty_numeric")
                    } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                      
                      invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                      self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                    };
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      
                      self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                      p = $rb_minus(self.num_suffix_s, 1);
                    } else {
                      self.num_xfrm.$call(digits.$to_i(self.num_base))
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 156:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))
                    } else {
                      
                      self.$emit("tINTEGER", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_i(), self.ts, $rb_minus(self.te, 1));
                      p = $rb_minus(p, 1);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 157:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))
                    } else {
                      
                      self.$emit("tFLOAT", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_f(), self.ts, $rb_minus(self.te, 1));
                      p = $rb_minus(p, 1);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 158:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    digits = self.$tok(self.ts, self.num_suffix_s);
                    if ($truthy(self['$version?'](18, 19, 20))) {
                      
                      self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                      p = $rb_minus(self.num_suffix_s, 1);
                    } else {
                      self.num_xfrm.$call(digits)
                    };
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 160:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tCONSTANT");
                    self.cs = self.$arg_or_cmdarg(cmd_state);
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 164:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tIDENTIFIER");
                    if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                      
                      self.cs = 465;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = self.$arg_or_cmdarg(cmd_state);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 165:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($eqeq(tm, self.te)) {
                      self.$emit("tFID")
                    } else {
                      
                      self.$emit("tIDENTIFIER", self.$tok(self.ts, tm), self.ts, tm);
                      p = $rb_minus(tm, 1);
                    };
                    self.cs = 494;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 167:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION'));
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 168:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION'));
                    self.cs = 563;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  default:
                    nil
                };;
                break;
              case 244:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tFID", self.$tok(self.ts, tm), self.ts, tm);
                self.cs = self.$arg_or_cmdarg(cmd_state);
                p = $rb_minus(tm, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 339:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 311:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 425:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($eqeq(tm, self.te)) {
                  self.$emit("tFID")
                } else {
                  
                  self.$emit("tIDENTIFIER", self.$tok(self.ts, tm), self.ts, tm);
                  p = $rb_minus(tm, 1);
                };
                self.cs = 494;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 340:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 312:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 341:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 313:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 345:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 316:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 344:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 315:
                
                
                tm = $rb_minus(p, 2);;
                
                
                switch (self.act) {
                  case 99:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tUNARY_NUM", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                    p = $rb_minus(p, 1);
                    self.cs = 810;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 106:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$diagnostic("error", "unterminated_heredoc_id", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));
                    break;
                  case 117:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    if ($truthy($rb_ge(self.version, 27))) {
                      
                      self.$emit("tPIPE", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                      p = $rb_minus(p, 1);
                      self.cs = 563;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      p = $rb_minus(p, 2);
                      
                      self.cs = 810;
                      _goto_level = _again;
                      continue;;;
                    };
                    break;
                  case 121:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('PUNCTUATION_BEGIN'));
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 122:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("kRESCUE", "rescue".$freeze(), self.ts, tm);
                    p = $rb_minus(tm, 1);
                    self.cs = 539;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 123:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit_table($$('KEYWORDS_BEGIN'));
                    self.command_start = true;
                    self.cs = 802;
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                    break;
                  case 127:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 810;
                    _goto_level = _again;
                    continue;;;
                    break;
                  case 128:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    self.$emit("tIDENTIFIER");
                    if (($not(self.static_env['$nil?']()) && ($truthy(self.static_env['$declared?'](self.$tok()))))) {
                      
                      self.cs = 465;
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    } else {
                      
                      self.cs = self.$arg_or_cmdarg(cmd_state);
                      
                      p = $rb_plus(p, 1);
                      _goto_level = _out;
                      continue;;;
                    };
                    break;
                  case 132:
                    
                    
                    p = $rb_minus(self.te, 1);;
                    p = $rb_minus(self.ts, 1);
                    
                    self.cs = 810;
                    _goto_level = _again;
                    continue;;;
                    break;
                  default:
                    nil
                };;
                break;
              case 342:
                
                
                tm = $rb_minus(p, 3);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 314:
                
                
                tm = $rb_minus(p, 3);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                p = $rb_minus(self.ts, 1);
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 343:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tSYMBOL", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 490:
                
                
                tm = $rb_minus(p, 2);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tCONSTANT", self.$tok(self.ts, tm), self.ts, tm);
                p = $rb_minus(tm, 1);
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 267:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLBRACK", "[".$freeze(), $rb_minus(self.te, 1), self.te);
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 386:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLBRACK", "[".$freeze());
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 493:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLBRACK2", "[".$freeze());
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 496:
                
                
                self.paren_nest = $rb_minus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  self.cond.$lexpop();
                  self.cmdarg.$lexpop();
                } else {
                  
                  self.cond.$pop();
                  self.cmdarg.$pop();
                };
                if (($eqeq(self.$tok(), "}".$freeze()) || ($eqeq(self.$tok(), "]".$freeze())))) {
                  if ($truthy($rb_ge(self.version, 25))) {
                    self.cs = 810
                  } else {
                    self.cs = 531
                  }
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 259:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                if ($truthy(self['$version?'](18))) {
                  self.command_start = true
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy(self['$version?'](18))) {
                  
                  self.$emit("tLPAREN2", "(".$freeze(), $rb_minus(self.te, 1), self.te);
                  self.cs = 802;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.$emit("tLPAREN_ARG", "(".$freeze(), $rb_minus(self.te, 1), self.te);
                  self.cs = 563;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;;
                break;
              case 272:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                if ($truthy(self['$version?'](18))) {
                  self.command_start = true
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLPAREN2", "(".$freeze());
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 280:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                if ($truthy(self['$version?'](18))) {
                  self.command_start = true
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLPAREN_ARG", "(".$freeze(), $rb_minus(self.te, 1), self.te);
                if ($truthy(self['$version?'](18))) {
                  
                  self.cs = 802;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.cs = 563;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                };;;
                break;
              case 328:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                if ($truthy(self['$version?'](18))) {
                  self.command_start = true
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("tLPAREN", "(".$freeze());
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 437:
                
                
                self.cond.$push(false);
                self.cmdarg.$push(false);
                self.paren_nest = $rb_plus(self.paren_nest, 1);
                if ($truthy(self['$version?'](18))) {
                  self.command_start = true
                };;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                self.cs = 563;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 438:
                
                
                self.paren_nest = $rb_minus(self.paren_nest, 1);;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit_table($$('PUNCTUATION'));
                if ($truthy($rb_lt(self.version, 24))) {
                  
                  self.cond.$lexpop();
                  self.cmdarg.$lexpop();
                } else {
                  
                  self.cond.$pop();
                  self.cmdarg.$pop();
                };
                if (($eqeq(self.$tok(), "}".$freeze()) || ($eqeq(self.$tok(), "]".$freeze())))) {
                  if ($truthy($rb_ge(self.version, 25))) {
                    self.cs = 810
                  } else {
                    self.cs = 531
                  }
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 72:
                
                
                heredoc_e = p;;
                
                self.newline_s = p;;
                break;
              case 353:
                
                
                new_herebody_s = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$tok(self.ts, heredoc_e)['$=~'](/^<<(-?)(~?)(["'`]?)(.*)\3$/m);
                indent = ($truthy(($ret_or_2 = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$empty?']()['$!']())) ? ($ret_or_2) : ((($b = $gvars['~']) === nil ? nil : $b['$[]'](2))['$empty?']()['$!']()));
                dedent_body = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))['$empty?']()['$!']();
                type = ($truthy((($b = $gvars['~']) === nil ? nil : $b['$[]'](3))['$empty?']()) ? ("<<\"".$freeze()) : ($rb_plus("<<".$freeze(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3)))));
                delimiter = (($b = $gvars['~']) === nil ? nil : $b['$[]'](4));
                if ($truthy($rb_ge(self.version, 27))) {
                  if (($truthy($rb_gt(delimiter.$count("\n"), 0)) || ($truthy($rb_gt(delimiter.$count("\r"), 0))))) {
                    self.$diagnostic("error", "unterminated_heredoc_id", nil, self.$range(self.ts, $rb_plus(self.ts, 1)))
                  }
                } else if ($truthy($rb_ge(self.version, 24))) {
                  if ($truthy($rb_gt(delimiter.$count("\n"), 0))) {
                    if ($truthy(delimiter['$end_with?']("\n"))) {
                      
                      self.$diagnostic("warning", "heredoc_id_ends_with_nl", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));
                      delimiter = delimiter.$rstrip();
                    } else {
                      self.$diagnostic("fatal", "heredoc_id_has_newline", nil, self.$range(self.ts, $rb_plus(self.ts, 1)))
                    }
                  }
                };
                if (($truthy(dedent_body) && ($truthy(self['$version?'](18, 19, 20, 21, 22))))) {
                  
                  self.$emit("tLSHFT", "<<".$freeze(), self.ts, $rb_plus(self.ts, 2));
                  p = $rb_plus(self.ts, 1);
                  self.cs = 563;
                  
                  p = $rb_plus(p, 1);
                  _goto_level = _out;
                  continue;;;
                } else {
                  
                  self.cs = self.$push_literal(type, delimiter, self.ts, heredoc_e, indent, dedent_body);
                  self.herebody_s = ($truthy(($ret_or_2 = self.herebody_s)) ? ($ret_or_2) : (new_herebody_s));
                  p = $rb_minus(self.herebody_s, 1);
                };;;
                break;
              case 348:
                
                
                tm = $rb_minus(p, 1);
                diag_msg = "ivar_name";;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$diagnostic("error", diag_msg, $hash2(["name"], {"name": self.$tok(tm, self.te)}), self.$range(tm, self.te))
                } else {
                  
                  self.$emit("tCOLON", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                  p = self.ts;
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 351:
                
                
                tm = $rb_minus(p, 2);
                diag_msg = "cvar_name";;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                if ($truthy($rb_ge(self.version, 27))) {
                  self.$diagnostic("error", diag_msg, $hash2(["name"], {"name": self.$tok(tm, self.te)}), self.$range(tm, self.te))
                } else {
                  
                  self.$emit("tCOLON", self.$tok(self.ts, $rb_plus(self.ts, 1)), self.ts, $rb_plus(self.ts, 1));
                  p = self.ts;
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 359:
                
                
                self.escape = nil;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 389:
                
                
                tm = p;;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                self.$emit("kRESCUE", "rescue".$freeze(), self.ts, tm);
                p = $rb_minus(tm, 1);
                self.cs = 539;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 480:
                
                
                self.num_base = 16;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                break;
              case 474:
                
                
                self.num_base = 10;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                break;
              case 477:
                
                
                self.num_base = 8;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                break;
              case 471:
                
                
                self.num_base = 2;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                break;
              case 486:
                
                
                self.num_base = 10;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                break;
              case 449:
                
                
                self.num_base = 8;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                break;
              case 487:
                
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$17(chars){var self = $$17.$$s == null ? this : $$17.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                break;
              case 8:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.newline_s = p;;
                break;
              case 453:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.num_suffix_s = p;;
                break;
              case 228:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 43;;
                break;
              case 215:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 44;;
                break;
              case 211:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 45;;
                break;
              case 27:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 72;;
                break;
              case 261:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 73;;
                break;
              case 28:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 78;;
                break;
              case 254:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 79;;
                break;
              case 281:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 85;;
                break;
              case 46:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 86;;
                break;
              case 302:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 93;;
                break;
              case 291:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 94;;
                break;
              case 70:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 106;;
                break;
              case 394:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 117;;
                break;
              case 305:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 121;;
                break;
              case 388:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 122;;
                break;
              case 387:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 123;;
                break;
              case 75:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 127;;
                break;
              case 303:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 128;;
                break;
              case 306:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 132;;
                break;
              case 504:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 145;;
                break;
              case 499:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 146;;
                break;
              case 507:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 148;;
                break;
              case 500:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 149;;
                break;
              case 501:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 150;;
                break;
              case 506:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 151;;
                break;
              case 498:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 152;;
                break;
              case 492:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 153;;
                break;
              case 418:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 154;;
                break;
              case 451:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 157;;
                break;
              case 82:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 158;;
                break;
              case 421:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 160;;
                break;
              case 412:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 164;;
                break;
              case 423:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 165;;
                break;
              case 416:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 167;;
                break;
              case 422:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 168;;
                break;
              case 88:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 181;;
                break;
              case 511:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.act = 185;;
                break;
              case 183:
                
                
                self.newline_s = p;;
                
                self.te = $rb_plus(p, 1);
                
                current_literal = self.$literal();
                if ($eqeq(self.te, pe)) {
                  self.$diagnostic("fatal", "string_eof", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))
                };
                if ($truthy(current_literal['$heredoc?']())) {
                  
                  line = self.$tok(self.herebody_s, self.ts).$gsub(/\r+$/, "".$freeze());
                  if ($truthy(self['$version?'](18, 19, 20))) {
                    line = line.$gsub(/\r.*$/, "".$freeze())
                  };
                  if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {
                    
                    self.herebody_s = self.te;
                    p = $rb_minus(current_literal.$heredoc_e(), 1);
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  } else {
                    
                    current_literal.$infer_indent_level(line);
                    self.herebody_s = self.te;
                  };
                } else {
                  
                  if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {
                    
                    self.cs = self.$pop_literal();
                    
                    p = $rb_plus(p, 1);
                    _goto_level = _out;
                    continue;;;
                  };
                  if ($truthy(self.herebody_s)) {
                    
                    p = $rb_minus(self.herebody_s, 1);
                    self.herebody_s = nil;
                  };
                };
                if (($truthy(current_literal['$words?']()) && ($not(self['$eof_codepoint?'](self.source_pts['$[]'](p)))))) {
                  current_literal.$extend_space(self.ts, self.te)
                } else {
                  
                  current_literal.$extend_string(self.$tok(), self.ts, self.te);
                  current_literal.$flush_string();
                };;;
                
                self.escape_s = p;
                self.escape = nil;;
                break;
              case 124:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 155:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 369:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 131:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 162:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 376:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 122:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 153:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 367:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 130:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 161:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 375:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 126:
                
                
                self.escape = "\u007F";;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 157:
                
                
                self.escape = "\u007F";;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 371:
                
                
                self.escape = "\u007F";;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 129:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 160:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 374:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 136:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 167:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 381:
                
                
                self.$diagnostic("fatal", "invalid_unicode_escape", nil, self.$range($rb_minus(self.escape_s, 1), p));;
                
                self.$diagnostic("fatal", "unterminated_unicode", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 116:
                
                
                self.escape_s = p;
                self.escape = nil;;
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 148:
                
                
                self.escape_s = p;
                self.escape = nil;;
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 362:
                
                
                self.escape_s = p;
                self.escape = nil;;
                
                self.$diagnostic("fatal", "escape_eof", nil, self.$range($rb_minus(p, 1), p));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 62:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.newline_s = p;;
                break;
              case 221:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 236:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 248:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 270:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                
                self.cs = 810;
                _goto_level = _again;
                continue;;;;;
                break;
              case 285:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 297:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 323:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 399:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 409:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 430:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 102:
                
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.te = p;
                p = $rb_minus(p, 1);;
                break;
              case 482:
                
                
                self.num_base = 10;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$18(chars){var self = $$18.$$s == null ? this : $$18.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                break;
              case 446:
                
                
                self.num_base = 8;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$19(chars){var self = $$19.$$s == null ? this : $$19.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                break;
              case 461:
                
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$20(chars){var self = $$20.$$s == null ? this : $$20.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 454:
                
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$21(chars){var self = $$21.$$s == null ? this : $$21.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tFLOAT", self.$Float(chars));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 450:
                
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$22(chars){var self = $$22.$$s == null ? this : $$22.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tFLOAT", self.$Float(chars));}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.ts, self.num_suffix_s);
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tFLOAT", self.$Float(digits), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits)
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 276:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.newline_s = p;;
                
                self.act = 79;;
                break;
              case 36:
                
                
                self.te = $rb_plus(p, 1);;
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.act = 78;;
                break;
              case 47:
                
                
                self.te = $rb_plus(p, 1);;
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.act = 86;;
                break;
              case 94:
                
                
                self.te = $rb_plus(p, 1);;
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                self.act = 181;;
                break;
              case 66:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.act = 99;;
                break;
              case 85:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.act = 147;;
                break;
              case 93:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.act = 181;;
                break;
              case 38:
                
                
                self.te = $rb_plus(p, 1);;
                
                tm = p;;
                
                self.act = 73;;
                break;
              case 391:
                
                
                self.te = $rb_plus(p, 1);;
                
                tm = p;;
                
                self.act = 127;;
                break;
              case 390:
                
                
                self.te = $rb_plus(p, 1);;
                
                tm = p;;
                
                self.act = 128;;
                break;
              case 483:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.num_base = 10;
                self.num_digits_s = self.ts;;
                
                self.act = 154;;
                break;
              case 127:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 158:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 372:
                
                
                codepoint = self.source_pts['$[]']($rb_minus(p, 1));
                if (($truthy($rb_ge(self.version, 30)) && (($eqeq(codepoint, 117) || ($eqeq(codepoint, 85)))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };
                if ($truthy((self.escape = $$('ESCAPES')['$[]'](codepoint))['$nil?']())) {
                  self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 125:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 156:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 370:
                
                
                self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();
                if (($truthy($rb_ge(self.version, 27)) && (($truthy($range(0, 8, false)['$include?'](self.escape.$ord())) || ($truthy($range(14, 31, false)['$include?'](self.escape.$ord()))))))) {
                  self.$diagnostic("fatal", "invalid_escape")
                };;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 132:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 163:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 377:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 128:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 159:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                current_literal = self.$literal();
                escaped_char = self.source_buffer.$slice(self.escape_s).$chr();
                if ($truthy(current_literal['$munge_escape?'](escaped_char))) {
                  if (($truthy(current_literal['$regexp?']()) && ($truthy($$('REGEXP_META_CHARACTERS').$match(escaped_char))))) {
                    current_literal.$extend_string(self.$tok(), self.ts, self.te)
                  } else {
                    current_literal.$extend_string(escaped_char, self.ts, self.te)
                  }
                } else if (($truthy(current_literal['$squiggly_heredoc?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok(), self.ts, self.te)
                } else if (($truthy(current_literal['$supports_line_continuation_via_slash?']()) && ($eqeq(escaped_char, "\n".$freeze())))) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else if ((($truthy(current_literal['$regexp?']()) && ($truthy($rb_ge(self.version, 31)))) && ($truthy(["c", "C", "m", "M"]['$include?'](escaped_char))))) {
                  current_literal.$extend_string(self.escape, self.ts, self.te)
                } else if ($truthy(current_literal['$regexp?']())) {
                  current_literal.$extend_string(self.$tok().$gsub("\\\n".$freeze(), "".$freeze()), self.ts, self.te)
                } else {
                  current_literal.$extend_string(($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok())), self.ts, self.te)
                };;;
                break;
              case 373:
                
                
                self.escape = self.$encode_escape(self.$tok($rb_minus(p, 2), p).$to_i(16));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;
                
                self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                value = ($truthy(($ret_or_2 = self.escape)) ? ($ret_or_2) : (self.$tok($rb_plus(self.ts, 1))));
                if ($truthy(self['$version?'](18))) {
                  self.$emit("tINTEGER", value.$getbyte(0))
                } else {
                  self.$emit("tCHARACTER", value)
                };
                self.cs = 810;
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 478:
                
                
                self.num_base = 16;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$23(chars){var self = $$23.$$s == null ? this : $$23.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 472:
                
                
                self.num_base = 10;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$24(chars){var self = $$24.$$s == null ? this : $$24.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 475:
                
                
                self.num_base = 8;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$25(chars){var self = $$25.$$s == null ? this : $$25.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 469:
                
                
                self.num_base = 2;
                self.num_digits_s = p;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$26(chars){var self = $$26.$$s == null ? this : $$26.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 481:
                
                
                self.num_base = 10;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$27(chars){var self = $$27.$$s == null ? this : $$27.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 445:
                
                
                self.num_base = 8;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$28(chars){var self = $$28.$$s == null ? this : $$28.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.te = p;
                p = $rb_minus(p, 1);
                
                digits = self.$tok(self.num_digits_s, self.num_suffix_s);
                if ($truthy(digits['$end_with?']("_".$freeze()))) {
                  self.$diagnostic("error", "trailing_in_number", $hash2(["character"], {"character": "_".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))
                } else if ((($truthy(digits['$empty?']()) && ($eqeq(self.num_base, 8))) && ($truthy(self['$version?'](18))))) {
                  digits = "0".$freeze()
                } else if ($truthy(digits['$empty?']())) {
                  self.$diagnostic("error", "empty_numeric")
                } else if (($eqeq(self.num_base, 8) && ($truthy((invalid_idx = digits.$index(/[89]/)))))) {
                  
                  invalid_s = $rb_plus(self.num_digits_s, invalid_idx);
                  self.$diagnostic("error", "invalid_octal", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));
                };
                if ($truthy(self['$version?'](18, 19, 20))) {
                  
                  self.$emit("tINTEGER", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);
                  p = $rb_minus(self.num_suffix_s, 1);
                } else {
                  self.num_xfrm.$call(digits.$to_i(self.num_base))
                };
                
                p = $rb_plus(p, 1);
                _goto_level = _out;
                continue;;;;;
                break;
              case 32:
                
                
                self.te = $rb_plus(p, 1);;
                
                if ($truthy(self.herebody_s)) {
                  
                  p = self.herebody_s;
                  self.herebody_s = nil;
                };;
                
                tm = p;;
                
                self.act = 73;;
                break;
              case 63:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.act = 99;;
                break;
              case 92:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.sharp_s = $rb_minus(p, 1);;
                
                self.$emit_comment(self.sharp_s, ($eqeq(p, pe) ? ($rb_minus(p, 2)) : (p)));;
                
                self.act = 181;;
                break;
              case 488:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$29(chars){var self = $$29.$$s == null ? this : $$29.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.act = 156;;
                break;
              case 484:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.num_base = 10;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$30(chars){var self = $$30.$$s == null ? this : $$30.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.act = 156;;
                break;
              case 448:
                
                
                self.te = $rb_plus(p, 1);;
                
                self.num_base = 8;
                self.num_digits_s = self.ts;;
                
                self.num_suffix_s = p;;
                
                self.num_xfrm = $send(self, 'lambda', [], function $$31(chars){var self = $$31.$$s == null ? this : $$31.$$s;

                  
                  
                  if (chars == null) chars = nil;;
                  return self.$emit("tINTEGER", chars);}, {$$arity: 1, $$s: self});;
                
                self.act = 156;;
                break;
              default:
                nil
            }
          };
        };
        if ($truthy($rb_le(_goto_level, _again))) {
          
          
          switch (_lex_to_state_actions['$[]'](self.cs)) {
            case 96:
              
              self.ts = nil;
              break;
            default:
              nil
          };
          if ($eqeq(self.cs, 0)) {
            
            _goto_level = _out;
            continue;;
          };
          p = $rb_plus(p, 1);
          if ($neqeq(p, pe)) {
            
            _goto_level = _resume;
            continue;;
          };
        };
        if ($truthy($rb_le(_goto_level, _test_eof))) {
          if ($eqeq(p, eof)) {
            if ($truthy($rb_gt(_lex_eof_trans['$[]'](self.cs), 0))) {
              
              _trans = $rb_minus(_lex_eof_trans['$[]'](self.cs), 1);
              _goto_level = _eof_trans;
              continue;;
            }
          }
        };
        if ($truthy($rb_le(_goto_level, _out))) {
          break;
        };
      };;
      if ($truthy(false)) {
        testEof
      };
      self.p = p;
      if ($truthy(self.token_queue['$any?']())) {
        return self.token_queue.$shift()
      } else if ($eqeq(self.cs, klass.$lex_error())) {
        return [false, ["$error".$freeze(), self.$range($rb_minus(p, 1), p)]]
      } else {
        
        eof = self.source_pts.$size();
        return [false, ["$eof".$freeze(), self.$range(eof, eof)]];
      };
    }, 0);
    self.$protected();
    
    $def(self, '$eof_codepoint?', function $Lexer_eof_codepoint$ques$32(point) {
      
      return [4, 26, 0]['$include?'](point)
    }, 1);
    
    $def(self, '$version?', function $Lexer_version$ques$33($a) {
      var $post_args, versions, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      versions = $post_args;;
      return versions['$include?'](self.version);
    }, -1);
    
    $def(self, '$stack_pop', function $$stack_pop() {
      var self = this;

      
      self.top = $rb_minus(self.top, 1);
      return self.stack['$[]'](self.top);
    }, 0);
    
    $def(self, '$encode_escape', function $$encode_escape(ord) {
      var self = this;

      return ord.$chr().$force_encoding(self.source_buffer.$source().$encoding())
    }, 1);
    
    $def(self, '$tok', function $$tok(s, e) {
      var self = this;

      
      
      if (s == null) s = self.ts;;
      
      if (e == null) e = self.te;;
      return self.source_buffer.$slice(Opal.Range.$new(s,e, true));
    }, -1);
    
    $def(self, '$range', function $$range(s, e) {
      var self = this;

      
      
      if (s == null) s = self.ts;;
      
      if (e == null) e = self.te;;
      return $$$($$$($$('Parser'), 'Source'), 'Range').$new(self.source_buffer, s, e);
    }, -1);
    
    $def(self, '$emit', function $$emit(type, value, s, e) {
      var self = this, token = nil;

      
      
      if (value == null) value = self.$tok();;
      
      if (s == null) s = self.ts;;
      
      if (e == null) e = self.te;;
      token = [type, [value, self.$range(s, e)]];
      self.token_queue.$push(token);
      if ($truthy(self.tokens)) {
        self.tokens.$push(token)
      };
      return token;
    }, -2);
    
    $def(self, '$emit_table', function $$emit_table(table, s, e) {
      var self = this, value = nil;

      
      
      if (s == null) s = self.ts;;
      
      if (e == null) e = self.te;;
      value = self.$tok(s, e);
      return self.$emit(table['$[]'](value), value, s, e);
    }, -2);
    
    $def(self, '$emit_do', function $$emit_do(do_block) {
      var self = this;

      
      
      if (do_block == null) do_block = false;;
      if ($truthy(self.cond['$active?']())) {
        return self.$emit("kDO_COND", "do".$freeze())
      } else if (($truthy(self.cmdarg['$active?']()) || ($truthy(do_block)))) {
        return self.$emit("kDO_BLOCK", "do".$freeze())
      } else {
        return self.$emit("kDO", "do".$freeze())
      };
    }, -1);
    
    $def(self, '$arg_or_cmdarg', function $$arg_or_cmdarg(cmd_state) {
      var self = this;

      if ($truthy(cmd_state)) {
        return self.$class().$lex_en_expr_cmdarg()
      } else {
        return self.$class().$lex_en_expr_arg()
      }
    }, 1);
    
    $def(self, '$emit_comment', function $$emit_comment(s, e) {
      var self = this;

      
      
      if (s == null) s = self.ts;;
      
      if (e == null) e = self.te;;
      if ($truthy(self.comments)) {
        self.comments.$push($$$($$$($$('Parser'), 'Source'), 'Comment').$new(self.$range(s, e)))
      };
      if ($truthy(self.tokens)) {
        self.tokens.$push(["tCOMMENT", [self.$tok(s, e), self.$range(s, e)]])
      };
      return nil;
    }, -1);
    
    $def(self, '$diagnostic', function $$diagnostic(type, reason, arguments$, location, highlights) {
      var self = this;

      
      
      if (arguments$ == null) arguments$ = nil;;
      
      if (location == null) location = self.$range();;
      
      if (highlights == null) highlights = [];;
      return self.diagnostics.$process($$$($$('Parser'), 'Diagnostic').$new(type, reason, arguments$, location, highlights));
    }, -3);
    
    $def(self, '$push_literal', function $$push_literal($a) {
      var $post_args, args, self = this, new_literal = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      new_literal = $send($$('Literal'), 'new', [self].concat($to_a(args)));
      self.literal_stack.$push(new_literal);
      return self.$next_state_for_literal(new_literal);
    }, -1);
    
    $def(self, '$next_state_for_literal', function $$next_state_for_literal(literal) {
      var self = this;

      if (($truthy(literal['$words?']()) && ($truthy(literal['$backslash_delimited?']())))) {
        if ($truthy(literal['$interpolate?']())) {
          return self.$class().$lex_en_interp_backslash_delimited_words()
        } else {
          return self.$class().$lex_en_plain_backslash_delimited_words()
        }
      } else if (($truthy(literal['$words?']()) && ($not(literal['$backslash_delimited?']())))) {
        if ($truthy(literal['$interpolate?']())) {
          return self.$class().$lex_en_interp_words()
        } else {
          return self.$class().$lex_en_plain_words()
        }
      } else if (($not(literal['$words?']()) && ($truthy(literal['$backslash_delimited?']())))) {
        if ($truthy(literal['$interpolate?']())) {
          return self.$class().$lex_en_interp_backslash_delimited()
        } else {
          return self.$class().$lex_en_plain_backslash_delimited()
        }
      } else if ($truthy(literal['$interpolate?']())) {
        return self.$class().$lex_en_interp_string()
      } else {
        return self.$class().$lex_en_plain_string()
      }
    }, 1);
    
    $def(self, '$literal', function $$literal() {
      var self = this;

      return self.literal_stack.$last()
    }, 0);
    
    $def(self, '$pop_literal', function $$pop_literal() {
      var self = this, old_literal = nil;

      
      old_literal = self.literal_stack.$pop();
      self.dedent_level = old_literal.$dedent_level();
      if ($eqeq(old_literal.$type(), "tREGEXP_BEG")) {
        return self.$class().$lex_en_regexp_modifiers()
      } else {
        return self.$class().$lex_en_expr_end()
      };
    }, 0);
    $const_set($nesting[0], 'PUNCTUATION', $hash2(["=", "&", "|", "!", "^", "+", "-", "*", "/", "%", "~", ",", ";", ".", "..", "...", "[", "]", "(", ")", "?", ":", "&&", "||", "-@", "+@", "~@", "**", "->", "=~", "!~", "==", "!=", ">", ">>", ">=", "<", "<<", "<=", "=>", "::", "===", "<=>", "[]", "[]=", "{", "}", "`", "!@", "&."], {"=": "tEQL", "&": "tAMPER2", "|": "tPIPE", "!": "tBANG", "^": "tCARET", "+": "tPLUS", "-": "tMINUS", "*": "tSTAR2", "/": "tDIVIDE", "%": "tPERCENT", "~": "tTILDE", ",": "tCOMMA", ";": "tSEMI", ".": "tDOT", "..": "tDOT2", "...": "tDOT3", "[": "tLBRACK2", "]": "tRBRACK", "(": "tLPAREN2", ")": "tRPAREN", "?": "tEH", ":": "tCOLON", "&&": "tANDOP", "||": "tOROP", "-@": "tUMINUS", "+@": "tUPLUS", "~@": "tTILDE", "**": "tPOW", "->": "tLAMBDA", "=~": "tMATCH", "!~": "tNMATCH", "==": "tEQ", "!=": "tNEQ", ">": "tGT", ">>": "tRSHFT", ">=": "tGEQ", "<": "tLT", "<<": "tLSHFT", "<=": "tLEQ", "=>": "tASSOC", "::": "tCOLON2", "===": "tEQQ", "<=>": "tCMP", "[]": "tAREF", "[]=": "tASET", "{": "tLCURLY", "}": "tRCURLY", "`": "tBACK_REF2", "!@": "tBANG", "&.": "tANDDOT"}));
    $const_set($nesting[0], 'PUNCTUATION_BEGIN', $hash2(["&", "*", "**", "+", "-", "::", "(", "{", "["], {"&": "tAMPER", "*": "tSTAR", "**": "tDSTAR", "+": "tUPLUS", "-": "tUMINUS", "::": "tCOLON3", "(": "tLPAREN", "{": "tLBRACE", "[": "tLBRACK"}));
    $const_set($nesting[0], 'KEYWORDS', $hash2(["if", "unless", "while", "until", "rescue", "defined?", "BEGIN", "END"], {"if": "kIF_MOD", "unless": "kUNLESS_MOD", "while": "kWHILE_MOD", "until": "kUNTIL_MOD", "rescue": "kRESCUE_MOD", "defined?": "kDEFINED", "BEGIN": "klBEGIN", "END": "klEND"}));
    $const_set($nesting[0], 'KEYWORDS_BEGIN', $hash2(["if", "unless", "while", "until", "rescue", "defined?", "BEGIN", "END"], {"if": "kIF", "unless": "kUNLESS", "while": "kWHILE", "until": "kUNTIL", "rescue": "kRESCUE", "defined?": "kDEFINED", "BEGIN": "klBEGIN", "END": "klEND"}));
    return $send(["class", "module", "def", "undef", "begin", "end", "then", "elsif", "else", "ensure", "case", "when", "for", "break", "next", "redo", "retry", "in", "do", "return", "yield", "super", "self", "nil", "true", "false", "and", "or", "not", "alias", "__FILE__", "__LINE__", "__ENCODING__"], 'each', [], function $Lexer$34(keyword){var $a, $b;

      
      
      if (keyword == null) keyword = nil;;
      return ($a = [keyword, ($b = [keyword, "k" + (keyword.$upcase())], $send($$('KEYWORDS'), '[]=', $b), $b[$b.length - 1])], $send($$('KEYWORDS_BEGIN'), '[]=', $a), $a[$a.length - 1]);}, 1);
  })($$('Parser'), null, $nesting)
};

Opal.modules["parser/lexer/literal"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $enc = Opal.enc, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $to_ary = Opal.to_ary, $def = Opal.def, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $neqeq = Opal.neqeq, $not = Opal.not, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('attr_reader,attr_accessor,coerce_encoding,include?,send,+,[],fetch,==,!,heredoc?,start_with?,freeze,clear_buffer,emit_start_tok,type,=~,words?,delimiter?,-,extend_space,!=,flush_string,emit,each_char,===,%,>,nil?,<<,empty?,extend_content,protected,lstrip,b,dup,force_encoding,encoding,source,source_buffer,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Literal');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.lexer = $proto.start_tok = $proto.str_type = $proto.monolithic = $proto.heredoc_e = $proto.dedent_body = $proto.end_delim = $proto.start_delim = $proto.nesting = $proto.label_allowed = $proto.buffer = $proto.str_s = $proto.interp_braces = $proto.buffer_s = $proto.buffer_e = $proto.space_emitted = $proto.interpolate = $proto.indent = nil;
      
      $const_set($nesting[0], 'DELIMITERS', $hash2(["(", "[", "{", "<"], {"(": $enc(")", "ASCII-8BIT"), "[": $enc("]", "ASCII-8BIT"), "{": $enc("}", "ASCII-8BIT"), "<": $enc(">", "ASCII-8BIT")}));
      $const_set($nesting[0], 'TYPES', $hash2(["'", "<<'", "%q", "\"", "<<\"", "%", "%Q", "%w", "%W", "%i", "%I", ":'", "%s", ":\"", "/", "%r", "%x", "`", "<<`"], {"'": ["tSTRING_BEG", false], "<<'": ["tSTRING_BEG", false], "%q": ["tSTRING_BEG", false], "\"": ["tSTRING_BEG", true], "<<\"": ["tSTRING_BEG", true], "%": ["tSTRING_BEG", true], "%Q": ["tSTRING_BEG", true], "%w": ["tQWORDS_BEG", false], "%W": ["tWORDS_BEG", true], "%i": ["tQSYMBOLS_BEG", false], "%I": ["tSYMBOLS_BEG", true], ":'": ["tSYMBEG", false], "%s": ["tSYMBEG", false], ":\"": ["tSYMBEG", true], "/": ["tREGEXP_BEG", true], "%r": ["tREGEXP_BEG", true], "%x": ["tXSTRING_BEG", true], "`": ["tXSTRING_BEG", true], "<<`": ["tXSTRING_BEG", true]}));
      self.$attr_reader("heredoc_e", "str_s", "dedent_level");
      self.$attr_accessor("saved_herebody_s");
      
      $def(self, '$initialize', function $$initialize(lexer, str_type, delimiter, str_s, heredoc_e, indent, dedent_body, label_allowed) {
        var $a, $b, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        
        
        if (heredoc_e == null) heredoc_e = nil;;
        
        if (indent == null) indent = false;;
        
        if (dedent_body == null) dedent_body = false;;
        
        if (label_allowed == null) label_allowed = false;;
        self.lexer = lexer;
        self.nesting = 1;
        str_type = self.$coerce_encoding(str_type);
        delimiter = self.$coerce_encoding(delimiter);
        if (!$truthy($$('TYPES')['$include?'](str_type))) {
          lexer.$send("diagnostic", "error", "unexpected_percent_str", $hash2(["type"], {"type": str_type}), self.lexer.$send("range", str_s, $rb_plus(str_s, 2)))
        };
        self.str_type = str_type;
        self.str_s = str_s;
        $b = $$('TYPES')['$[]'](str_type), $a = $to_ary($b), (self.start_tok = ($a[0] == null ? nil : $a[0])), (self.interpolate = ($a[1] == null ? nil : $a[1])), $b;
        self.start_delim = ($truthy($$('DELIMITERS')['$include?'](delimiter)) ? (delimiter) : (nil));
        self.end_delim = $$('DELIMITERS').$fetch(delimiter, delimiter);
        self.heredoc_e = heredoc_e;
        self.indent = indent;
        self.label_allowed = label_allowed;
        self.dedent_body = dedent_body;
        self.dedent_level = nil;
        self.interp_braces = 0;
        self.space_emitted = true;
        self.monolithic = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.start_tok['$==']("tSTRING_BEG"))) ? ([$enc("'", "ASCII-8BIT"), $enc("\"", "ASCII-8BIT")]['$include?'](str_type)) : ($ret_or_2)))) ? (self['$heredoc?']()['$!']()) : ($ret_or_1));
        if ($truthy(self.str_type['$start_with?']($enc("%", "ASCII-8BIT").$freeze()))) {
          self.str_type = $rb_plus(self.str_type, delimiter)
        };
        self.$clear_buffer();
        if ($truthy(self.monolithic)) {
          return nil
        } else {
          return self.$emit_start_tok()
        };
      }, -5);
      
      $def(self, '$interpolate?', $return_ivar("interpolate"), 0);
      
      $def(self, '$words?', function $Literal_words$ques$1() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.$type()['$==']("tWORDS_BEG"))) ? ($ret_or_3) : (self.$type()['$==']("tQWORDS_BEG"))))) ? ($ret_or_2) : (self.$type()['$==']("tSYMBOLS_BEG")))))) {
          return $ret_or_1
        } else {
          return self.$type()['$==']("tQSYMBOLS_BEG")
        }
      }, 0);
      
      $def(self, '$regexp?', function $Literal_regexp$ques$2() {
        var self = this;

        return self.$type()['$==']("tREGEXP_BEG")
      }, 0);
      
      $def(self, '$heredoc?', function $Literal_heredoc$ques$3() {
        var self = this;

        return self.heredoc_e['$!']()['$!']()
      }, 0);
      
      $def(self, '$plain_heredoc?', function $Literal_plain_heredoc$ques$4() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$heredoc?']()))) {
          return self.dedent_body['$!']()
        } else {
          return $ret_or_1
        }
      }, 0);
      
      $def(self, '$squiggly_heredoc?', function $Literal_squiggly_heredoc$ques$5() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$heredoc?']()))) {
          return self.dedent_body
        } else {
          return $ret_or_1
        }
      }, 0);
      
      $def(self, '$backslash_delimited?', function $Literal_backslash_delimited$ques$6() {
        var self = this;

        return self.end_delim['$==']($enc("\\", "ASCII-8BIT").$freeze())
      }, 0);
      
      $def(self, '$type', $return_ivar("start_tok"), 0);
      
      $def(self, '$munge_escape?', function $Literal_munge_escape$ques$7(character) {
        var self = this;

        
        character = self.$coerce_encoding(character);
        if (($truthy(self['$words?']()) && ($truthy(character['$=~'](/[ \t\v\r\f\n]/))))) {
          return true
        } else {
          return [$enc("\\", "ASCII-8BIT").$freeze(), self.start_delim, self.end_delim]['$include?'](character)
        };
      }, 1);
      
      $def(self, '$nest_and_try_closing', function $$nest_and_try_closing(delimiter, ts, te, lookahead) {
        var self = this;

        
        
        if (lookahead == null) lookahead = nil;;
        delimiter = self.$coerce_encoding(delimiter);
        if (($truthy(self.start_delim) && ($eqeq(self.start_delim, delimiter)))) {
          self.nesting = $rb_plus(self.nesting, 1)
        } else if ($truthy(self['$delimiter?'](delimiter))) {
          self.nesting = $rb_minus(self.nesting, 1)
        };
        if ($eqeq(self.nesting, 0)) {
          
          if ($truthy(self['$words?']())) {
            self.$extend_space(ts, ts)
          };
          if ((((($truthy(lookahead) && ($truthy(self.label_allowed))) && ($eqeq(lookahead['$[]'](0), $enc(":", "ASCII-8BIT")))) && ($neqeq(lookahead['$[]'](1), $enc(":", "ASCII-8BIT")))) && ($eqeq(self.start_tok, "tSTRING_BEG")))) {
            
            self.$flush_string();
            return self.$emit("tLABEL_END", self.end_delim, ts, $rb_plus(te, 1));
          } else if ($truthy(self.monolithic)) {
            return self.$emit("tSTRING", self.buffer, self.str_s, te)
          } else {
            
            if (!$truthy(self['$heredoc?']())) {
              self.$flush_string()
            };
            return self.$emit("tSTRING_END", self.end_delim, ts, te);
          };
        } else {
          return nil
        };
      }, -4);
      
      $def(self, '$infer_indent_level', function $$infer_indent_level(line) {
        var self = this, indent_level = nil;

        
        if ($not(self.dedent_body)) {
          return nil
        };
        indent_level = 0;
        return (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_char', [], function $$8(char$){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          
          if (char$ == null) char$ = nil;;
          if ($eqeqeq(" ", ($ret_or_1 = char$))) {
            return (indent_level = $rb_plus(indent_level, 1))
          } else if ($eqeqeq("\t", $ret_or_1)) {
            return (indent_level = $rb_plus(indent_level, $rb_minus(8, indent_level['$%'](8))))
          } else {
            
            if (($truthy(self.dedent_level['$nil?']()) || ($truthy($rb_gt(self.dedent_level, indent_level))))) {
              self.dedent_level = indent_level
            };
            
            Opal.brk(nil, $brk);
          };}, {$$arity: 1, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      }, 1);
      
      $def(self, '$start_interp_brace', function $$start_interp_brace() {
        var self = this;

        return (self.interp_braces = $rb_plus(self.interp_braces, 1))
      }, 0);
      
      $def(self, '$end_interp_brace_and_try_closing', function $$end_interp_brace_and_try_closing() {
        var self = this;

        
        self.interp_braces = $rb_minus(self.interp_braces, 1);
        
        return self.interp_braces['$=='](0);;
      }, 0);
      
      $def(self, '$extend_string', function $$extend_string(string, ts, te) {
        var self = this, $ret_or_1 = nil;

        
        self.buffer_s = ($truthy(($ret_or_1 = self.buffer_s)) ? ($ret_or_1) : (ts));
        self.buffer_e = te;
        return self.buffer['$<<'](string);
      }, 3);
      
      $def(self, '$flush_string', function $$flush_string() {
        var self = this;

        
        if ($truthy(self.monolithic)) {
          
          self.$emit_start_tok();
          self.monolithic = false;
        };
        if ($truthy(self.buffer['$empty?']())) {
          return nil
        } else {
          
          self.$emit("tSTRING_CONTENT", self.buffer, self.buffer_s, self.buffer_e);
          self.$clear_buffer();
          return self.$extend_content();
        };
      }, 0);
      
      $def(self, '$extend_content', $assign_ivar_val("space_emitted", false), 0);
      
      $def(self, '$extend_space', function $$extend_space(ts, te) {
        var self = this;

        
        self.$flush_string();
        if ($truthy(self.space_emitted)) {
          return nil
        } else {
          
          self.$emit("tSPACE", nil, ts, te);
          return (self.space_emitted = true);
        };
      }, 2);
      
      $def(self, '$supports_line_continuation_via_slash?', function $Literal_supports_line_continuation_via_slash$ques$9() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$words?']()['$!']()))) {
          return self.interpolate
        } else {
          return $ret_or_1
        }
      }, 0);
      self.$protected();
      
      $def(self, '$delimiter?', function $Literal_delimiter$ques$10(delimiter) {
        var self = this;

        if ($truthy(self.indent)) {
          return self.end_delim['$=='](delimiter.$lstrip())
        } else {
          return self.end_delim['$=='](delimiter)
        }
      }, 1);
      
      $def(self, '$coerce_encoding', function $$coerce_encoding(string) {
        
        return string.$b()
      }, 1);
      
      $def(self, '$clear_buffer', function $$clear_buffer() {
        var self = this;

        
        self.buffer = $enc("", "ASCII-8BIT").$dup();
        self.buffer.$force_encoding(self.lexer.$source_buffer().$source().$encoding());
        self.buffer_s = nil;
        return (self.buffer_e = nil);
      }, 0);
      
      $def(self, '$emit_start_tok', function $$emit_start_tok() {
        var self = this, str_e = nil, $ret_or_1 = nil;

        
        str_e = ($truthy(($ret_or_1 = self.heredoc_e)) ? ($ret_or_1) : ($rb_plus(self.str_s, self.str_type.$length())));
        return self.$emit(self.start_tok, self.str_type, self.str_s, str_e);
      }, 0);
      return $def(self, '$emit', function $$emit(token, type, s, e) {
        var self = this;

        return self.lexer.$send("emit", token, type, s, e)
      }, 4);
    })($$('Lexer'), null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/lexer/stack_state"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $assign_ivar_val = Opal.assign_ivar_val, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs('freeze,clear,|,<<,&,>>,==,[],to_s');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'StackState');

      var $proto = self.$$prototype;

      $proto.stack = $proto.name = nil;
      
      
      $def(self, '$initialize', function $$initialize(name) {
        var self = this;

        
        self.name = name.$freeze();
        return self.$clear();
      }, 1);
      
      $def(self, '$clear', $assign_ivar_val("stack", 0), 0);
      
      $def(self, '$push', function $$push(bit) {
        var self = this, bit_value = nil;

        
        bit_value = ($truthy(bit) ? (1) : (0));
        self.stack = self.stack['$<<'](1)['$|'](bit_value);
        return bit;
      }, 1);
      
      $def(self, '$pop', function $$pop() {
        var self = this, bit_value = nil;

        
        bit_value = self.stack['$&'](1);
        self.stack = self.stack['$>>'](1);
        return bit_value['$=='](1);
      }, 0);
      
      $def(self, '$lexpop', function $$lexpop() {
        var self = this;

        
        self.stack = self.stack['$>>'](1)['$|'](self.stack['$&'](1));
        return self.stack['$[]'](0)['$=='](1);
      }, 0);
      
      $def(self, '$active?', function $StackState_active$ques$1() {
        var self = this;

        return self.stack['$[]'](0)['$=='](1)
      }, 0);
      
      $def(self, '$empty?', function $StackState_empty$ques$2() {
        var self = this;

        return self.stack['$=='](0)
      }, 0);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return "[" + (self.stack.$to_s(2)) + " <= " + (self.name) + "]"
      }, 0);
      return $alias(self, "inspect", "to_s");
    })($$('Lexer'), null)
  })($nesting[0], $nesting)
};

Opal.modules["parser/lexer/dedenter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $eqeq = Opal.eqeq, $send = Opal.send, $truthy = Opal.truthy, $to_ary = Opal.to_ary, $slice = Opal.slice, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('encoding,split,force_encoding,==,length,map!,each,each_char,<=,===,+,-,>,*,/,slice!,replace,join,end_with?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Dedenter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.at_line_begin = nil;
      
      $const_set($nesting[0], 'TAB_WIDTH', 8);
      
      $def(self, '$initialize', function $$initialize(dedent_level) {
        var self = this;

        
        self.dedent_level = dedent_level;
        self.at_line_begin = true;
        return (self.indent_level = 0);
      }, 1);
      
      $def(self, '$dedent', function $$dedent(string) {
        var $a, $b, self = this, original_encoding = nil, lines = nil, lines_to_dedent = nil, _first = nil;

        
        original_encoding = string.$encoding();
        lines = string.$force_encoding($$$($$('Encoding'), 'BINARY')).$split("\\\n");
        if ($eqeq(lines.$length(), 1)) {
          lines = [string.$force_encoding(original_encoding)]
        } else {
          $send(lines, 'map!', [], function $$1(s){
            
            
            if (s == null) s = nil;;
            return s.$force_encoding(original_encoding);}, 1)
        };
        if ($truthy(self.at_line_begin)) {
          lines_to_dedent = lines
        } else {
          $b = lines, $a = $to_ary($b), (_first = ($a[0] == null ? nil : $a[0])), (lines_to_dedent = $slice.call($a, 1)), $b
        };
        (function(){var $brk = Opal.new_brk(); try {return $send(lines_to_dedent, 'each', [], function $$2(line){var self = $$2.$$s == null ? this : $$2.$$s, left_to_remove = nil, remove = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          
          if (line == null) line = nil;;
          left_to_remove = self.dedent_level;
          remove = 0;
          (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_char', [], function $$3(char$){var self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil;
            if (self.dedent_level == null) self.dedent_level = nil;

            
            
            if (char$ == null) char$ = nil;;
            if ($truthy($rb_le(left_to_remove, 0))) {
              
              Opal.brk(nil, $brk)
            };
            if ($eqeqeq(" ", ($ret_or_1 = char$))) {
              
              remove = $rb_plus(remove, 1);
              return (left_to_remove = $rb_minus(left_to_remove, 1));
            } else if ($eqeqeq("\t", $ret_or_1)) {
              
              if ($truthy($rb_gt($rb_times($$('TAB_WIDTH'), $rb_plus($rb_divide(remove, $$('TAB_WIDTH')), 1)), self.dedent_level))) {
                
                Opal.brk(nil, $brk)
              };
              remove = $rb_plus(remove, 1);
              return (left_to_remove = $rb_minus(left_to_remove, $$('TAB_WIDTH')));
            } else {
              
              Opal.brk(nil, $brk)
            };}, {$$arity: 1, $$s: self, $$brk: $brk})
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return line['$slice!'](0, remove);}, {$$arity: 1, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        string.$replace(lines.$join());
        return (self.at_line_begin = string['$end_with?']("\n"));
      }, 1);
      return $def(self, '$interrupt', $assign_ivar_val("at_line_begin", false), 0);
    })($$('Lexer'), null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/builders/default"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $assign_ivar_val = Opal.assign_ivar_val, $to_a = Opal.to_a, $hash2 = Opal.hash2, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $neqeq = Opal.neqeq, $to_ary = Opal.to_ary, $rb_minus = Opal.rb_minus, $rb_plus = Opal.rb_plus, $rb_ge = Opal.rb_ge, $range = Opal.range, $slice = Opal.slice, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt;

  Opal.add_stubs('attr_accessor,n0,token_map,numeric,n,value,new,loc,private,+@,-@,updated,join,expression,string_value,delimited_string_map,unquoted_map,collapse_string_parts?,nil?,first,children,string_map,prefix_string_map,to_sym,collection_map,empty?,==,version,diagnostic,!,type,dedent,map,interrupt,compact,uniq,sort,each_char,to_proc,static_regexp,message,<<,regexp_map,unary_op_map,binary_op_map,!=,%,size,last,each_slice,pair_keyword_map,pair_quoted_map,symbol_compose,adjust,=~,pair_keyword,accessible,upto,-,length,+,[],>=,range_map,variable_map,name,source_buffer,dup,line,emit_encoding,class,any?,end_with?,to_s,try_declare_numparam,declared?,static_env,var_send_map,top,current_arg_stack,parser,constant_map,in_def,context,check_assignment_to_numparam,check_reserved_for_numparam,declare,with_expression,with_operator,join_exprs,module_definition_map,definition_map,endless_definition_map,validate_definee,keyword_map,check_duplicate_args,validate_no_forward_arg_after_restarg,emit_forward_arg,forward_arg,arg_prefix_map,kwarg_map,emit_procarg0,emit_arg_inside_procarg0,location,resize,end,call_type_for_dot,emit_kwargs,rewrite_hash_args_to_kwargs,send_map,emit_lambda,expr_map,keyword,include?,block_map,array,emit_index,index_map,send_index_map,send_binary_op_map,static_regexp_node,each,names,send_unary_op_map,check_condition,condition_map,keyword_mod_map,ternary_map,for_map,>,count,rescue_body_map,eh_keyword_map,push,none?,one?,begin,guard_map,check_lvar_name,check_duplicate_pattern_variable,match_hash_var_from_str,match_var,check_duplicate_pattern_key,static_string,pair_quoted,match_hash_var,<=,===,check_duplicate_arg,is_a?,[]=,arg_name_collides?,<,in_dynamic_block?,has_numparams?,max_numparam_stack,start_with?,pattern_variables,pattern_hash_keys,with,begin_pos,end_pos,encode,valid_encoding?,process,diagnostics,send,kwargs?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Default');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.parser = $proto.emit_file_line_as_literals = nil;
      
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_lambda")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_lambda = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_procarg0")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_procarg0 = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_encoding")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_encoding = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_index")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_index = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_arg_inside_procarg0")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_arg_inside_procarg0 = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_forward_arg")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_forward_arg = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_kwargs")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_kwargs = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_match_pattern")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_match_pattern = false;
      (function(self, $parent_nesting) {
        
        return $def(self, '$modernize', function $$modernize() {
          var self = this;

          
          self.emit_lambda = true;
          self.emit_procarg0 = true;
          self.emit_encoding = true;
          self.emit_index = true;
          self.emit_arg_inside_procarg0 = true;
          self.emit_forward_arg = true;
          self.emit_kwargs = true;
          return (self.emit_match_pattern = true);
        }, 0)
      })(Opal.get_singleton_class(self), $nesting);
      self.$attr_accessor("parser");
      self.$attr_accessor("emit_file_line_as_literals");
      
      $def(self, '$initialize', $assign_ivar_val("emit_file_line_as_literals", true), 0);
      
      $def(self, '$nil', function $$nil(nil_t) {
        var self = this;

        return self.$n0("nil", self.$token_map(nil_t))
      }, 1);
      
      $def(self, '$true', function $Default_true$1(true_t) {
        var self = this;

        return self.$n0("true", self.$token_map(true_t))
      }, 1);
      
      $def(self, '$false', function $Default_false$2(false_t) {
        var self = this;

        return self.$n0("false", self.$token_map(false_t))
      }, 1);
      
      $def(self, '$integer', function $$integer(integer_t) {
        var self = this;

        return self.$numeric("int", integer_t)
      }, 1);
      
      $def(self, '$float', function $Default_float$3(float_t) {
        var self = this;

        return self.$numeric("float", float_t)
      }, 1);
      
      $def(self, '$rational', function $$rational(rational_t) {
        var self = this;

        return self.$numeric("rational", rational_t)
      }, 1);
      
      $def(self, '$complex', function $$complex(complex_t) {
        var self = this;

        return self.$numeric("complex", complex_t)
      }, 1);
      
      $def(self, '$numeric', function $$numeric(kind, token) {
        var self = this;

        return self.$n(kind, [self.$value(token)], $$$($$$($$('Source'), 'Map'), 'Operator').$new(nil, self.$loc(token)))
      }, 2);
      self.$private("numeric");
      
      $def(self, '$unary_num', function $$unary_num(unary_t, numeric) {
        var $a, self = this, value = nil, operator_loc = nil;

        
        $a = [].concat($to_a(numeric)), (value = ($a[0] == null ? nil : $a[0])), $a;
        operator_loc = self.$loc(unary_t);
        
        switch (self.$value(unary_t)) {
          case "+":
            value = value['$+@']()
            break;
          case "-":
            value = value['$-@']()
            break;
          default:
            nil
        };
        return numeric.$updated(nil, [value], $hash2(["location"], {"location": $$$($$$($$('Source'), 'Map'), 'Operator').$new(operator_loc, operator_loc.$join(numeric.$loc().$expression()))}));
      }, 2);
      
      $def(self, '$__LINE__', function $$__LINE__(__LINE__t) {
        var self = this;

        return self.$n0("__LINE__", self.$token_map(__LINE__t))
      }, 1);
      
      $def(self, '$string', function $$string(string_t) {
        var self = this;

        return self.$n("str", [self.$string_value(string_t)], self.$delimited_string_map(string_t))
      }, 1);
      
      $def(self, '$string_internal', function $$string_internal(string_t) {
        var self = this;

        return self.$n("str", [self.$string_value(string_t)], self.$unquoted_map(string_t))
      }, 1);
      
      $def(self, '$string_compose', function $$string_compose(begin_t, parts, end_t) {
        var self = this;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          if (($truthy(begin_t['$nil?']()) && ($truthy(end_t['$nil?']())))) {
            return parts.$first()
          } else {
            return self.$n("str", parts.$first().$children(), self.$string_map(begin_t, parts, end_t))
          }
        } else {
          return self.$n("dstr", [].concat($to_a(parts)), self.$string_map(begin_t, parts, end_t))
        }
      }, 3);
      
      $def(self, '$character', function $$character(char_t) {
        var self = this;

        return self.$n("str", [self.$string_value(char_t)], self.$prefix_string_map(char_t))
      }, 1);
      
      $def(self, '$__FILE__', function $$__FILE__(__FILE__t) {
        var self = this;

        return self.$n0("__FILE__", self.$token_map(__FILE__t))
      }, 1);
      
      $def(self, '$symbol', function $$symbol(symbol_t) {
        var self = this;

        return self.$n("sym", [self.$string_value(symbol_t).$to_sym()], self.$prefix_string_map(symbol_t))
      }, 1);
      
      $def(self, '$symbol_internal', function $$symbol_internal(symbol_t) {
        var self = this;

        return self.$n("sym", [self.$string_value(symbol_t).$to_sym()], self.$unquoted_map(symbol_t))
      }, 1);
      
      $def(self, '$symbol_compose', function $$symbol_compose(begin_t, parts, end_t) {
        var self = this, str = nil;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          
          str = parts.$first();
          return self.$n("sym", [str.$children().$first().$to_sym()], self.$collection_map(begin_t, str.$loc().$expression(), end_t));
        } else if (($eqeq(self.parser.$version(), 18) && ($truthy(parts['$empty?']())))) {
          return self.$diagnostic("error", "empty_symbol", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        } else {
          return self.$n("dsym", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t))
        }
      }, 3);
      
      $def(self, '$xstring_compose', function $$xstring_compose(begin_t, parts, end_t) {
        var self = this;

        return self.$n("xstr", [].concat($to_a(parts)), self.$string_map(begin_t, parts, end_t))
      }, 3);
      
      $def(self, '$dedent_string', function $$dedent_string(node, dedent_level) {
        var dedenter = nil, str = nil, children = nil;

        
        if ($not(dedent_level['$nil?']())) {
          
          dedenter = $$$($$('Lexer'), 'Dedenter').$new(dedent_level);
          
          switch (node.$type()) {
            case "str":
              
              str = node.$children().$first();
              dedenter.$dedent(str);
              break;
            case "dstr":
            case "xstr":
              
              children = $send(node.$children(), 'map', [], function $$4(str_node){
                
                
                if (str_node == null) str_node = nil;;
                if ($eqeq(str_node.$type(), "str")) {
                  
                  str = str_node.$children().$first();
                  dedenter.$dedent(str);
                  if ($truthy(str['$empty?']())) {
                    return nil;
                  };
                } else {
                  dedenter.$interrupt()
                };
                return str_node;}, 1);
              node = node.$updated(nil, children.$compact());
              break;
            default:
              nil
          };
        };
        return node;
      }, 2);
      
      $def(self, '$regexp_options', function $$regexp_options(regopt_t) {
        var self = this, options = nil;

        
        options = $send(self.$value(regopt_t).$each_char().$sort().$uniq(), 'map', [], "to_sym".$to_proc());
        return self.$n("regopt", options, self.$token_map(regopt_t));
      }, 1);
      
      $def(self, '$regexp_compose', function $$regexp_compose(begin_t, parts, end_t, options) {
        var self = this, e = nil;

        
        
        try {
          self.$static_regexp(parts, options)
        } catch ($err) {
          if (Opal.rescue($err, [$$('RegexpError')])) {(e = $err)
            try {
              self.$diagnostic("error", "invalid_regexp", $hash2(["message"], {"message": e.$message()}), self.$loc(begin_t).$join(self.$loc(end_t)))
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };;
        return self.$n("regexp", parts['$<<'](options), self.$regexp_map(begin_t, end_t, options));
      }, 4);
      
      $def(self, '$array', function $$array(begin_t, elements, end_t) {
        var self = this;

        return self.$n("array", elements, self.$collection_map(begin_t, elements, end_t))
      }, 3);
      
      $def(self, '$splat', function $$splat(star_t, arg) {
        var self = this;

        
        
        if (arg == null) arg = nil;;
        if ($truthy(arg['$nil?']())) {
          return self.$n0("splat", self.$unary_op_map(star_t))
        } else {
          return self.$n("splat", [arg], self.$unary_op_map(star_t, arg))
        };
      }, -2);
      
      $def(self, '$word', function $$word(parts) {
        var self = this;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          return parts.$first()
        } else {
          return self.$n("dstr", [].concat($to_a(parts)), self.$collection_map(nil, parts, nil))
        }
      }, 1);
      
      $def(self, '$words_compose', function $$words_compose(begin_t, parts, end_t) {
        var self = this;

        return self.$n("array", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t))
      }, 3);
      
      $def(self, '$symbols_compose', function $$symbols_compose(begin_t, parts, end_t) {
        var self = this;

        
        parts = $send(parts, 'map', [], function $$5(part){var $a, value = nil;

          
          
          if (part == null) part = nil;;
          
          switch (part.$type()) {
            case "str":
              
              $a = [].concat($to_a(part)), (value = ($a[0] == null ? nil : $a[0])), $a;
              return part.$updated("sym", [value.$to_sym()]);
            case "dstr":
              return part.$updated("dsym")
            default:
              return part
          };}, 1);
        return self.$n("array", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t));
      }, 3);
      
      $def(self, '$pair', function $$pair(key, assoc_t, value) {
        var self = this;

        return self.$n("pair", [key, value], self.$binary_op_map(key, assoc_t, value))
      }, 3);
      
      $def(self, '$pair_list_18', function $$pair_list_18(list) {
        var self = this;

        if ($neqeq(list.$size()['$%'](2), 0)) {
          return self.$diagnostic("error", "odd_hash", nil, list.$last().$loc().$expression())
        } else {
          return $send(list.$each_slice(2), 'map', [], function $$6(key, value){var self = $$6.$$s == null ? this : $$6.$$s;

            
            
            if (key == null) key = nil;;
            
            if (value == null) value = nil;;
            return self.$n("pair", [key, value], self.$binary_op_map(key, nil, value));}, {$$arity: 2, $$s: self})
        }
      }, 1);
      
      $def(self, '$pair_keyword', function $$pair_keyword(key_t, value) {
        var $a, $b, self = this, key_map = nil, pair_map = nil, key = nil;

        
        $b = self.$pair_keyword_map(key_t, value), $a = $to_ary($b), (key_map = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;
        key = self.$n("sym", [self.$value(key_t).$to_sym()], key_map);
        return self.$n("pair", [key, value], pair_map);
      }, 2);
      
      $def(self, '$pair_quoted', function $$pair_quoted(begin_t, parts, end_t, value) {
        var $a, $b, self = this, pair_map = nil, key = nil;

        
        $b = self.$pair_quoted_map(begin_t, end_t, value), $a = $to_ary($b), (end_t = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;
        key = self.$symbol_compose(begin_t, parts, end_t);
        return self.$n("pair", [key, value], pair_map);
      }, 4);
      
      $def(self, '$pair_label', function $$pair_label(key_t) {
        var self = this, key_l = nil, value_l = nil, label = nil, value = nil;

        
        key_l = self.$loc(key_t);
        value_l = key_l.$adjust($hash2(["end_pos"], {"end_pos": -1}));
        label = self.$value(key_t);
        value = ($truthy(label['$=~'](/^[[:lower:]]/)) ? (self.$n("ident", [label.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Variable').$new(value_l))) : (self.$n("const", [nil, label.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Constant').$new(nil, value_l, value_l))));
        return self.$pair_keyword(key_t, self.$accessible(value));
      }, 1);
      
      $def(self, '$kwsplat', function $$kwsplat(dstar_t, arg) {
        var self = this;

        return self.$n("kwsplat", [arg], self.$unary_op_map(dstar_t, arg))
      }, 2);
      
      $def(self, '$associate', function $$associate(begin_t, pairs, end_t) {
        var self = this;

        
        $send((0), 'upto', [$rb_minus(pairs.$length(), 1)], function $$7(i){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (i == null) i = nil;;
          return $send($rb_plus(i, 1), 'upto', [$rb_minus(pairs.$length(), 1)], function $$8(j){var $a, self = $$8.$$s == null ? this : $$8.$$s, key1 = nil, key2 = nil, do_warn = nil;
            if (self.parser == null) self.parser = nil;

            
            
            if (j == null) j = nil;;
            $a = [].concat($to_a(pairs['$[]'](i))), (key1 = ($a[0] == null ? nil : $a[0])), $a;
            $a = [].concat($to_a(pairs['$[]'](j))), (key2 = ($a[0] == null ? nil : $a[0])), $a;
            do_warn = false;
            
            switch (key1.$type()) {
              case "sym":
              case "str":
              case "int":
              case "float":
                if ($eqeq(key1, key2)) {
                  do_warn = true
                }
                break;
              case "rational":
              case "complex":
              case "regexp":
                if (($truthy($rb_ge(self.parser.$version(), 31)) && ($eqeq(key1, key2)))) {
                  do_warn = true
                }
                break;
              default:
                nil
            };
            if ($truthy(do_warn)) {
              return self.$diagnostic("warning", "duplicate_hash_key", nil, key2.$loc().$expression())
            } else {
              return nil
            };}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
        return self.$n("hash", [].concat($to_a(pairs)), self.$collection_map(begin_t, pairs, end_t));
      }, 3);
      
      $def(self, '$range_inclusive', function $$range_inclusive(lhs, dot2_t, rhs) {
        var self = this;

        return self.$n("irange", [lhs, rhs], self.$range_map(lhs, dot2_t, rhs))
      }, 3);
      
      $def(self, '$range_exclusive', function $$range_exclusive(lhs, dot3_t, rhs) {
        var self = this;

        return self.$n("erange", [lhs, rhs], self.$range_map(lhs, dot3_t, rhs))
      }, 3);
      
      $def(self, '$self', function $$self(token) {
        var self = this;

        return self.$n0("self", self.$token_map(token))
      }, 1);
      
      $def(self, '$ident', function $$ident(token) {
        var self = this;

        return self.$n("ident", [self.$value(token).$to_sym()], self.$variable_map(token))
      }, 1);
      
      $def(self, '$ivar', function $$ivar(token) {
        var self = this;

        return self.$n("ivar", [self.$value(token).$to_sym()], self.$variable_map(token))
      }, 1);
      
      $def(self, '$gvar', function $$gvar(token) {
        var self = this;

        return self.$n("gvar", [self.$value(token).$to_sym()], self.$variable_map(token))
      }, 1);
      
      $def(self, '$cvar', function $$cvar(token) {
        var self = this;

        return self.$n("cvar", [self.$value(token).$to_sym()], self.$variable_map(token))
      }, 1);
      
      $def(self, '$back_ref', function $$back_ref(token) {
        var self = this;

        return self.$n("back_ref", [self.$value(token).$to_sym()], self.$token_map(token))
      }, 1);
      
      $def(self, '$nth_ref', function $$nth_ref(token) {
        var self = this;

        return self.$n("nth_ref", [self.$value(token)], self.$token_map(token))
      }, 1);
      
      $def(self, '$accessible', function $$accessible(node) {
        var $a, self = this, name = nil;

        
        switch (node.$type()) {
          case "__FILE__":
            if ($truthy(self.emit_file_line_as_literals)) {
              return self.$n("str", [node.$loc().$expression().$source_buffer().$name()], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "__LINE__":
            if ($truthy(self.emit_file_line_as_literals)) {
              return self.$n("int", [node.$loc().$expression().$line()], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "__ENCODING__":
            if ($not(self.$class().$emit_encoding())) {
              return self.$n("const", [self.$n("const", [nil, "Encoding"], nil), "UTF_8"], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "ident":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            if ($truthy($send(["?", "!"], 'any?', [], function $$9(c){
              
              
              if (c == null) c = nil;;
              return name.$to_s()['$end_with?'](c);}, 1))) {
              self.$diagnostic("error", "invalid_id_to_get", $hash2(["identifier"], {"identifier": name.$to_s()}), node.$loc().$expression())
            };
            if (($truthy($rb_ge(self.parser.$version(), 27)) && ($truthy(self.parser.$try_declare_numparam(node))))) {
              return node.$updated("lvar")
            };
            if (!$truthy(self.parser.$static_env()['$declared?'](name))) {
              return self.$n("send", [nil, name], self.$var_send_map(node))
            };
            if ($eqeq(name.$to_s(), self.$parser().$current_arg_stack().$top())) {
              self.$diagnostic("error", "circular_argument_reference", $hash2(["var_name"], {"var_name": name.$to_s()}), node.$loc().$expression())
            };
            return node.$updated("lvar");
          default:
            return node
        }
      }, 1);
      
      $def(self, '$const', function $Default_const$10(name_t) {
        var self = this;

        return self.$n("const", [nil, self.$value(name_t).$to_sym()], self.$constant_map(nil, nil, name_t))
      }, 1);
      
      $def(self, '$const_global', function $$const_global(t_colon3, name_t) {
        var self = this, cbase = nil;

        
        cbase = self.$n0("cbase", self.$token_map(t_colon3));
        return self.$n("const", [cbase, self.$value(name_t).$to_sym()], self.$constant_map(cbase, t_colon3, name_t));
      }, 2);
      
      $def(self, '$const_fetch', function $$const_fetch(scope, t_colon2, name_t) {
        var self = this;

        return self.$n("const", [scope, self.$value(name_t).$to_sym()], self.$constant_map(scope, t_colon2, name_t))
      }, 3);
      
      $def(self, '$__ENCODING__', function $$__ENCODING__(__ENCODING__t) {
        var self = this;

        return self.$n0("__ENCODING__", self.$token_map(__ENCODING__t))
      }, 1);
      
      $def(self, '$assignable', function $$assignable(node) {
        var $a, self = this, name = nil, var_name = nil, name_loc = nil;

        
        switch (node.$type()) {
          case "cvar":
            return node.$updated("cvasgn")
          case "ivar":
            return node.$updated("ivasgn")
          case "gvar":
            return node.$updated("gvasgn")
          case "const":
            
            if ($truthy(self.parser.$context().$in_def())) {
              self.$diagnostic("error", "dynamic_const", nil, node.$loc().$expression())
            };
            return node.$updated("casgn");
          case "ident":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            var_name = node.$children()['$[]'](0).$to_s();
            name_loc = node.$loc().$expression();
            self.$check_assignment_to_numparam(var_name, name_loc);
            self.$check_reserved_for_numparam(var_name, name_loc);
            self.parser.$static_env().$declare(name);
            return node.$updated("lvasgn");
          case "match_var":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            var_name = node.$children()['$[]'](0).$to_s();
            name_loc = node.$loc().$expression();
            self.$check_assignment_to_numparam(var_name, name_loc);
            self.$check_reserved_for_numparam(var_name, name_loc);
            return node;
          case "nil":
          case "self":
          case "true":
          case "false":
          case "__FILE__":
          case "__LINE__":
          case "__ENCODING__":
            return self.$diagnostic("error", "invalid_assignment", nil, node.$loc().$expression())
          case "back_ref":
          case "nth_ref":
            return self.$diagnostic("error", "backref_assignment", nil, node.$loc().$expression())
          default:
            return nil
        }
      }, 1);
      
      $def(self, '$const_op_assignable', function $$const_op_assignable(node) {
        
        return node.$updated("casgn")
      }, 1);
      
      $def(self, '$assign', function $$assign(lhs, eql_t, rhs) {
        var self = this;

        return lhs['$<<'](rhs).$updated(nil, nil, $hash2(["location"], {"location": lhs.$loc().$with_operator(self.$loc(eql_t)).$with_expression(self.$join_exprs(lhs, rhs))}))
      }, 3);
      
      $def(self, '$op_assign', function $$op_assign(lhs, op_t, rhs) {
        var self = this, operator = nil, source_map = nil;

        
        switch (lhs.$type()) {
          case "gvasgn":
          case "ivasgn":
          case "lvasgn":
          case "cvasgn":
          case "casgn":
          case "send":
          case "csend":
          case "index":
            
            operator = self.$value(op_t)['$[]']($range(0, -1, false)).$to_sym();
            source_map = lhs.$loc().$with_operator(self.$loc(op_t)).$with_expression(self.$join_exprs(lhs, rhs));
            if ($eqeq(lhs.$type(), "index")) {
              lhs = lhs.$updated("indexasgn")
            };
            
            switch (operator) {
              case "&&":
                return self.$n("and_asgn", [lhs, rhs], source_map)
              case "||":
                return self.$n("or_asgn", [lhs, rhs], source_map)
              default:
                return self.$n("op_asgn", [lhs, operator, rhs], source_map)
            };
            break;
          case "back_ref":
          case "nth_ref":
            return self.$diagnostic("error", "backref_assignment", nil, lhs.$loc().$expression())
          default:
            return nil
        }
      }, 3);
      
      $def(self, '$multi_lhs', function $$multi_lhs(begin_t, items, end_t) {
        var self = this;

        return self.$n("mlhs", [].concat($to_a(items)), self.$collection_map(begin_t, items, end_t))
      }, 3);
      
      $def(self, '$multi_assign', function $$multi_assign(lhs, eql_t, rhs) {
        var self = this;

        return self.$n("masgn", [lhs, rhs], self.$binary_op_map(lhs, eql_t, rhs))
      }, 3);
      
      $def(self, '$def_class', function $$def_class(class_t, name, lt_t, superclass, body, end_t) {
        var self = this;

        return self.$n("class", [name, superclass, body], self.$module_definition_map(class_t, name, lt_t, end_t))
      }, 6);
      
      $def(self, '$def_sclass', function $$def_sclass(class_t, lshft_t, expr, body, end_t) {
        var self = this;

        return self.$n("sclass", [expr, body], self.$module_definition_map(class_t, nil, lshft_t, end_t))
      }, 5);
      
      $def(self, '$def_module', function $$def_module(module_t, name, body, end_t) {
        var self = this;

        return self.$n("module", [name, body], self.$module_definition_map(module_t, name, nil, end_t))
      }, 4);
      
      $def(self, '$def_method', function $$def_method(def_t, name_t, args, body, end_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("def", [self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, nil, name_t, end_t));
      }, 5);
      
      $def(self, '$def_endless_method', function $$def_endless_method(def_t, name_t, args, assignment_t, body) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("def", [self.$value(name_t).$to_sym(), args, body], self.$endless_definition_map(def_t, nil, name_t, assignment_t, body));
      }, 5);
      
      $def(self, '$def_singleton', function $$def_singleton(def_t, definee, dot_t, name_t, args, body, end_t) {
        var self = this;

        
        self.$validate_definee(definee);
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("defs", [definee, self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, dot_t, name_t, end_t));
      }, 7);
      
      $def(self, '$def_endless_singleton', function $$def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body) {
        var self = this;

        
        self.$validate_definee(definee);
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("defs", [definee, self.$value(name_t).$to_sym(), args, body], self.$endless_definition_map(def_t, dot_t, name_t, assignment_t, body));
      }, 7);
      
      $def(self, '$undef_method', function $$undef_method(undef_t, names) {
        var self = this;

        return self.$n("undef", [].concat($to_a(names)), self.$keyword_map(undef_t, nil, names, nil))
      }, 2);
      
      $def(self, '$alias', function $$alias(alias_t, to, from) {
        var self = this;

        return self.$n("alias", [to, from], self.$keyword_map(alias_t, nil, [to, from], nil))
      }, 3);
      
      $def(self, '$args', function $$args(begin_t, args, end_t, check_args) {
        var self = this, map = nil;

        
        
        if (check_args == null) check_args = true;;
        if ($truthy(check_args)) {
          args = self.$check_duplicate_args(args)
        };
        self.$validate_no_forward_arg_after_restarg(args);
        map = self.$collection_map(begin_t, args, end_t);
        if ((($not(self.$class().$emit_forward_arg()) && ($eqeq(args.$length(), 1))) && ($eqeq(args['$[]'](0).$type(), "forward_arg")))) {
          return self.$n("forward_args", [], map)
        } else {
          return self.$n("args", args, map)
        };
      }, -4);
      
      $def(self, '$numargs', function $$numargs(max_numparam) {
        var self = this;

        return self.$n("numargs", [max_numparam], nil)
      }, 1);
      
      $def(self, '$forward_only_args', function $$forward_only_args(begin_t, dots_t, end_t) {
        var self = this, arg = nil;

        if ($truthy(self.$class().$emit_forward_arg())) {
          
          arg = self.$forward_arg(dots_t);
          return self.$n("args", [arg], self.$collection_map(begin_t, [arg], end_t));
        } else {
          return self.$n("forward_args", [], self.$collection_map(begin_t, self.$token_map(dots_t), end_t))
        }
      }, 3);
      
      $def(self, '$forward_arg', function $$forward_arg(dots_t) {
        var self = this;

        return self.$n("forward_arg", [], self.$token_map(dots_t))
      }, 1);
      
      $def(self, '$arg', function $$arg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("arg", [self.$value(name_t).$to_sym()], self.$variable_map(name_t));
      }, 1);
      
      $def(self, '$optarg', function $$optarg(name_t, eql_t, value) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("optarg", [self.$value(name_t).$to_sym(), value], self.$variable_map(name_t).$with_operator(self.$loc(eql_t)).$with_expression(self.$loc(name_t).$join(value.$loc().$expression())));
      }, 3);
      
      $def(self, '$restarg', function $$restarg(star_t, name_t) {
        var self = this;

        
        
        if (name_t == null) name_t = nil;;
        if ($truthy(name_t)) {
          
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
          return self.$n("restarg", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(star_t, name_t));
        } else {
          return self.$n0("restarg", self.$arg_prefix_map(star_t))
        };
      }, -2);
      
      $def(self, '$kwarg', function $$kwarg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("kwarg", [self.$value(name_t).$to_sym()], self.$kwarg_map(name_t));
      }, 1);
      
      $def(self, '$kwoptarg', function $$kwoptarg(name_t, value) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("kwoptarg", [self.$value(name_t).$to_sym(), value], self.$kwarg_map(name_t, value));
      }, 2);
      
      $def(self, '$kwrestarg', function $$kwrestarg(dstar_t, name_t) {
        var self = this;

        
        
        if (name_t == null) name_t = nil;;
        if ($truthy(name_t)) {
          
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
          return self.$n("kwrestarg", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(dstar_t, name_t));
        } else {
          return self.$n0("kwrestarg", self.$arg_prefix_map(dstar_t))
        };
      }, -2);
      
      $def(self, '$kwnilarg', function $$kwnilarg(dstar_t, nil_t) {
        var self = this;

        return self.$n0("kwnilarg", self.$arg_prefix_map(dstar_t, nil_t))
      }, 2);
      
      $def(self, '$shadowarg', function $$shadowarg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("shadowarg", [self.$value(name_t).$to_sym()], self.$variable_map(name_t));
      }, 1);
      
      $def(self, '$blockarg', function $$blockarg(amper_t, name_t) {
        var self = this, arg_name = nil;

        
        if ($not(name_t['$nil?']())) {
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t))
        };
        arg_name = ($truthy(name_t) ? (self.$value(name_t).$to_sym()) : (nil));
        return self.$n("blockarg", [arg_name], self.$arg_prefix_map(amper_t, name_t));
      }, 2);
      
      $def(self, '$procarg0', function $$procarg0(arg) {
        var self = this;

        if ($truthy(self.$class().$emit_procarg0())) {
          if (($eqeq(arg.$type(), "arg") && ($truthy(self.$class().$emit_arg_inside_procarg0())))) {
            return self.$n("procarg0", [arg], $$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, arg.$location().$expression()))
          } else {
            return arg.$updated("procarg0")
          }
        } else {
          return arg
        }
      }, 1);
      
      $def(self, '$arg_expr', function $$arg_expr(expr) {
        var self = this;

        if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("arg")
        } else {
          return self.$n("arg_expr", [expr], expr.$loc().$dup())
        }
      }, 1);
      
      $def(self, '$restarg_expr', function $$restarg_expr(star_t, expr) {
        var self = this;

        
        
        if (expr == null) expr = nil;;
        if ($truthy(expr['$nil?']())) {
          return self.$n0("restarg", self.$token_map(star_t))
        } else if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("restarg")
        } else {
          return self.$n("restarg_expr", [expr], expr.$loc().$dup())
        };
      }, -2);
      
      $def(self, '$blockarg_expr', function $$blockarg_expr(amper_t, expr) {
        var self = this;

        if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("blockarg")
        } else {
          return self.$n("blockarg_expr", [expr], expr.$loc().$dup())
        }
      }, 2);
      
      $def(self, '$objc_kwarg', function $$objc_kwarg(kwname_t, assoc_t, name_t) {
        var self = this, kwname_l = nil, operator_l = nil;

        
        kwname_l = self.$loc(kwname_t);
        if ($truthy(assoc_t['$nil?']())) {
          
          kwname_l = kwname_l.$resize($rb_minus(kwname_l.$size(), 1));
          operator_l = kwname_l.$end().$resize(1);
        } else {
          operator_l = self.$loc(assoc_t)
        };
        return self.$n("objc_kwarg", [self.$value(kwname_t).$to_sym(), self.$value(name_t).$to_sym()], $$$($$$($$('Source'), 'Map'), 'ObjcKwarg').$new(kwname_l, operator_l, self.$loc(name_t), kwname_l.$join(self.$loc(name_t))));
      }, 3);
      
      $def(self, '$objc_restarg', function $$objc_restarg(star_t, name) {
        var self = this;

        
        
        if (name == null) name = nil;;
        if ($truthy(name['$nil?']())) {
          return self.$n0("restarg", self.$arg_prefix_map(star_t))
        } else if ($eqeq(name.$type(), "arg")) {
          return name.$updated("restarg", nil, $hash2(["location"], {"location": name.$loc().$with_operator(self.$loc(star_t))}))
        } else {
          return self.$n("objc_restarg", [name], self.$unary_op_map(star_t, name))
        };
      }, -2);
      
      $def(self, '$call_type_for_dot', function $$call_type_for_dot(dot_t) {
        var self = this;

        if (($not(dot_t['$nil?']()) && ($eqeq(self.$value(dot_t), "anddot")))) {
          return "csend"
        } else {
          return "send"
        }
      }, 1);
      
      $def(self, '$forwarded_args', function $$forwarded_args(dots_t) {
        var self = this;

        return self.$n("forwarded_args", [], self.$token_map(dots_t))
      }, 1);
      
      $def(self, '$call_method', function $$call_method(receiver, dot_t, selector_t, lparen_t, args, rparen_t) {
        var self = this, type = nil;

        
        
        if (lparen_t == null) lparen_t = nil;;
        
        if (args == null) args = [];;
        
        if (rparen_t == null) rparen_t = nil;;
        type = self.$call_type_for_dot(dot_t);
        if ($truthy(self.$class().$emit_kwargs())) {
          self.$rewrite_hash_args_to_kwargs(args)
        };
        if ($truthy(selector_t['$nil?']())) {
          return self.$n(type, [receiver, "call"].concat($to_a(args)), self.$send_map(receiver, dot_t, nil, lparen_t, args, rparen_t))
        } else {
          return self.$n(type, [receiver, self.$value(selector_t).$to_sym()].concat($to_a(args)), self.$send_map(receiver, dot_t, selector_t, lparen_t, args, rparen_t))
        };
      }, -4);
      
      $def(self, '$call_lambda', function $$call_lambda(lambda_t) {
        var self = this;

        if ($truthy(self.$class().$emit_lambda())) {
          return self.$n0("lambda", self.$expr_map(self.$loc(lambda_t)))
        } else {
          return self.$n("send", [nil, "lambda"], self.$send_map(nil, nil, lambda_t))
        }
      }, 1);
      
      $def(self, '$block', function $$block(method_call, begin_t, args, body, end_t) {
        var $a, self = this, _receiver = nil, _selector = nil, call_args = nil, last_arg = nil, block_type = nil, actual_send = nil, block = nil;

        
        $a = [].concat($to_a(method_call)), (_receiver = ($a[0] == null ? nil : $a[0])), (_selector = ($a[1] == null ? nil : $a[1])), (call_args = $slice.call($a, 2)), $a;
        if ($eqeq(method_call.$type(), "yield")) {
          self.$diagnostic("error", "block_given_to_yield", nil, method_call.$loc().$keyword(), [self.$loc(begin_t)])
        };
        last_arg = call_args.$last();
        if (($truthy(last_arg) && (($eqeq(last_arg.$type(), "block_pass") || ($eqeq(last_arg.$type(), "forwarded_args")))))) {
          self.$diagnostic("error", "block_and_blockarg", nil, last_arg.$loc().$expression(), [self.$loc(begin_t)])
        };
        if ($eqeq(args.$type(), "numargs")) {
          
          block_type = "numblock";
          args = args.$children()['$[]'](0);
        } else {
          block_type = "block"
        };
        if ($truthy(["send", "csend", "index", "super", "zsuper", "lambda"]['$include?'](method_call.$type()))) {
          return self.$n(block_type, [method_call, args, body], self.$block_map(method_call.$loc().$expression(), begin_t, end_t))
        } else {
          
          $a = [].concat($to_a(method_call)), (actual_send = ($a[0] == null ? nil : $a[0])), $a;
          block = self.$n(block_type, [actual_send, args, body], self.$block_map(actual_send.$loc().$expression(), begin_t, end_t));
          return self.$n(method_call.$type(), [block], method_call.$loc().$with_expression(self.$join_exprs(method_call, block)));
        };
      }, 5);
      
      $def(self, '$block_pass', function $$block_pass(amper_t, arg) {
        var self = this;

        return self.$n("block_pass", [arg], self.$unary_op_map(amper_t, arg))
      }, 2);
      
      $def(self, '$objc_varargs', function $$objc_varargs(pair, rest_of_varargs) {
        var $a, self = this, value = nil, first_vararg = nil, vararg_array = nil;

        
        $a = [].concat($to_a(pair)), (value = ($a[0] == null ? nil : $a[0])), (first_vararg = ($a[1] == null ? nil : $a[1])), $a;
        vararg_array = self.$array(nil, [first_vararg].concat($to_a(rest_of_varargs)), nil).$updated("objc_varargs");
        return pair.$updated(nil, [value, vararg_array], $hash2(["location"], {"location": pair.$loc().$with_expression(pair.$loc().$expression().$join(vararg_array.$loc().$expression()))}));
      }, 2);
      
      $def(self, '$attr_asgn', function $$attr_asgn(receiver, dot_t, selector_t) {
        var self = this, method_name = nil, type = nil;

        
        method_name = $rb_plus(self.$value(selector_t), "=").$to_sym();
        type = self.$call_type_for_dot(dot_t);
        return self.$n(type, [receiver, method_name], self.$send_map(receiver, dot_t, selector_t));
      }, 3);
      
      $def(self, '$index', function $$index(receiver, lbrack_t, indexes, rbrack_t) {
        var self = this;

        
        if ($truthy(self.$class().$emit_kwargs())) {
          self.$rewrite_hash_args_to_kwargs(indexes)
        };
        if ($truthy(self.$class().$emit_index())) {
          return self.$n("index", [receiver].concat($to_a(indexes)), self.$index_map(receiver, lbrack_t, rbrack_t))
        } else {
          return self.$n("send", [receiver, "[]"].concat($to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))
        };
      }, 4);
      
      $def(self, '$index_asgn', function $$index_asgn(receiver, lbrack_t, indexes, rbrack_t) {
        var self = this;

        if ($truthy(self.$class().$emit_index())) {
          return self.$n("indexasgn", [receiver].concat($to_a(indexes)), self.$index_map(receiver, lbrack_t, rbrack_t))
        } else {
          return self.$n("send", [receiver, "[]="].concat($to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))
        }
      }, 4);
      
      $def(self, '$binary_op', function $$binary_op(receiver, operator_t, arg) {
        var self = this, source_map = nil, operator = nil, method_call = nil;

        
        source_map = self.$send_binary_op_map(receiver, operator_t, arg);
        if ($eqeq(self.parser.$version(), 18)) {
          
          operator = self.$value(operator_t);
          if ($eqeq(operator, "!=")) {
            method_call = self.$n("send", [receiver, "==", arg], source_map)
          } else if ($eqeq(operator, "!~")) {
            method_call = self.$n("send", [receiver, "=~", arg], source_map)
          };
          if ($truthy(["!=", "!~"]['$include?'](operator))) {
            return self.$n("not", [method_call], self.$expr_map(source_map.$expression()))
          };
        };
        return self.$n("send", [receiver, self.$value(operator_t).$to_sym(), arg], source_map);
      }, 3);
      
      $def(self, '$match_op', function $$match_op(receiver, match_t, arg) {
        var self = this, source_map = nil, regexp = nil;

        
        source_map = self.$send_binary_op_map(receiver, match_t, arg);
        if ($truthy((regexp = self.$static_regexp_node(receiver)))) {
          
          $send(regexp.$names(), 'each', [], function $$11(name){var self = $$11.$$s == null ? this : $$11.$$s;
            if (self.parser == null) self.parser = nil;

            
            
            if (name == null) name = nil;;
            return self.parser.$static_env().$declare(name);}, {$$arity: 1, $$s: self});
          return self.$n("match_with_lvasgn", [receiver, arg], source_map);
        } else {
          return self.$n("send", [receiver, "=~", arg], source_map)
        };
      }, 3);
      
      $def(self, '$unary_op', function $$unary_op(op_t, receiver) {
        var self = this, method = nil;

        
        
        switch (self.$value(op_t)) {
          case "+":
          case "-":
            method = $rb_plus(self.$value(op_t), "@")
            break;
          default:
            method = self.$value(op_t)
        };
        return self.$n("send", [receiver, method.$to_sym()], self.$send_unary_op_map(op_t, receiver));
      }, 2);
      
      $def(self, '$not_op', function $$not_op(not_t, begin_t, receiver, end_t) {
        var self = this, nil_node = nil;

        
        
        if (begin_t == null) begin_t = nil;;
        
        if (receiver == null) receiver = nil;;
        
        if (end_t == null) end_t = nil;;
        if ($eqeq(self.parser.$version(), 18)) {
          return self.$n("not", [self.$check_condition(receiver)], self.$unary_op_map(not_t, receiver))
        } else if ($truthy(receiver['$nil?']())) {
          
          nil_node = self.$n0("begin", self.$collection_map(begin_t, nil, end_t));
          return self.$n("send", [nil_node, "!"], self.$send_unary_op_map(not_t, nil_node));
        } else {
          return self.$n("send", [self.$check_condition(receiver), "!"], self.$send_map(nil, nil, not_t, begin_t, [receiver], end_t))
        };
      }, -2);
      
      $def(self, '$logical_op', function $$logical_op(type, lhs, op_t, rhs) {
        var self = this;

        return self.$n(type, [lhs, rhs], self.$binary_op_map(lhs, op_t, rhs))
      }, 4);
      
      $def(self, '$condition', function $$condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t) {
        var self = this;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$condition_map(cond_t, cond, then_t, if_true, else_t, if_false, end_t))
      }, 7);
      
      $def(self, '$condition_mod', function $$condition_mod(if_true, if_false, cond_t, cond) {
        var self = this, $ret_or_1 = nil;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$keyword_mod_map(($truthy(($ret_or_1 = if_true)) ? ($ret_or_1) : (if_false)), cond_t, cond))
      }, 4);
      
      $def(self, '$ternary', function $$ternary(cond, question_t, if_true, colon_t, if_false) {
        var self = this;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$ternary_map(cond, question_t, if_true, colon_t, if_false))
      }, 5);
      
      $def(self, '$when', function $$when(when_t, patterns, then_t, body) {
        var self = this, children = nil;

        
        children = patterns['$<<'](body);
        return self.$n("when", children, self.$keyword_map(when_t, then_t, children, nil));
      }, 4);
      
      $def(self, '$case', function $Default_case$12(case_t, expr, when_bodies, else_t, else_body, end_t) {
        var self = this;

        return self.$n("case", [expr].concat($to_a(when_bodies['$<<'](else_body))), self.$condition_map(case_t, expr, nil, nil, else_t, else_body, end_t))
      }, 6);
      
      $def(self, '$loop', function $$loop(type, keyword_t, cond, do_t, body, end_t) {
        var self = this;

        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_map(keyword_t, do_t, nil, end_t))
      }, 6);
      
      $def(self, '$loop_mod', function $$loop_mod(type, body, keyword_t, cond) {
        var self = this;

        
        if ($eqeq(body.$type(), "kwbegin")) {
          type = "" + (type) + "_post"
        };
        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_mod_map(body, keyword_t, cond));
      }, 4);
      
      $def(self, '$for', function $Default_for$13(for_t, iterator, in_t, iteratee, do_t, body, end_t) {
        var self = this;

        return self.$n("for", [iterator, iteratee, body], self.$for_map(for_t, in_t, do_t, end_t))
      }, 7);
      
      $def(self, '$keyword_cmd', function $$keyword_cmd(type, keyword_t, lparen_t, args, rparen_t) {
        var self = this, last_arg = nil;

        
        
        if (lparen_t == null) lparen_t = nil;;
        
        if (args == null) args = [];;
        
        if (rparen_t == null) rparen_t = nil;;
        if (($eqeq(type, "yield") && ($truthy($rb_gt(args.$count(), 0))))) {
          
          last_arg = args.$last();
          if ($eqeq(last_arg.$type(), "block_pass")) {
            self.$diagnostic("error", "block_given_to_yield", nil, self.$loc(keyword_t), [last_arg.$loc().$expression()])
          };
        };
        if (($truthy(["yield", "super"]['$include?'](type)) && ($truthy(self.$class().$emit_kwargs())))) {
          self.$rewrite_hash_args_to_kwargs(args)
        };
        return self.$n(type, args, self.$keyword_map(keyword_t, lparen_t, args, rparen_t));
      }, -3);
      
      $def(self, '$preexe', function $$preexe(preexe_t, lbrace_t, compstmt, rbrace_t) {
        var self = this;

        return self.$n("preexe", [compstmt], self.$keyword_map(preexe_t, lbrace_t, [], rbrace_t))
      }, 4);
      
      $def(self, '$postexe', function $$postexe(postexe_t, lbrace_t, compstmt, rbrace_t) {
        var self = this;

        return self.$n("postexe", [compstmt], self.$keyword_map(postexe_t, lbrace_t, [], rbrace_t))
      }, 4);
      
      $def(self, '$rescue_body', function $$rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt) {
        var self = this;

        return self.$n("resbody", [exc_list, exc_var, compound_stmt], self.$rescue_body_map(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt))
      }, 6);
      
      $def(self, '$begin_body', function $$begin_body(compound_stmt, rescue_bodies, else_t, else_, ensure_t, ensure_) {
        var self = this, statements = nil;

        
        
        if (rescue_bodies == null) rescue_bodies = [];;
        
        if (else_t == null) else_t = nil;;
        
        if (else_ == null) else_ = nil;;
        
        if (ensure_t == null) ensure_t = nil;;
        
        if (ensure_ == null) ensure_ = nil;;
        if ($truthy(rescue_bodies['$any?']())) {
          if ($truthy(else_t)) {
            compound_stmt = self.$n("rescue", [compound_stmt].concat($to_a($rb_plus(rescue_bodies, [else_]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, else_t, else_))
          } else {
            compound_stmt = self.$n("rescue", [compound_stmt].concat($to_a($rb_plus(rescue_bodies, [nil]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, nil, nil))
          }
        } else if ($truthy(else_t)) {
          
          statements = [];
          if ($not(compound_stmt['$nil?']())) {
            if ($eqeq(compound_stmt.$type(), "begin")) {
              statements = $rb_plus(statements, compound_stmt.$children())
            } else {
              statements.$push(compound_stmt)
            }
          };
          statements.$push(self.$n("begin", [else_], self.$collection_map(else_t, [else_], nil)));
          compound_stmt = self.$n("begin", statements, self.$collection_map(nil, statements, nil));
        };
        if ($truthy(ensure_t)) {
          compound_stmt = self.$n("ensure", [compound_stmt, ensure_], self.$eh_keyword_map(compound_stmt, ensure_t, [ensure_], nil, nil))
        };
        return compound_stmt;
      }, -2);
      
      $def(self, '$compstmt', function $$compstmt(statements) {
        var self = this;

        if ($truthy(statements['$none?']())) {
          return nil
        } else if ($truthy(statements['$one?']())) {
          return statements.$first()
        } else {
          return self.$n("begin", statements, self.$collection_map(nil, statements, nil))
        }
      }, 1);
      
      $def(self, '$begin', function $$begin(begin_t, body, end_t) {
        var self = this;

        if ($truthy(body['$nil?']())) {
          return self.$n0("begin", self.$collection_map(begin_t, nil, end_t))
        } else if (($eqeq(body.$type(), "mlhs") || ((($eqeq(body.$type(), "begin") && ($truthy(body.$loc().$begin()['$nil?']()))) && ($truthy(body.$loc().$end()['$nil?']())))))) {
          return self.$n(body.$type(), body.$children(), self.$collection_map(begin_t, body.$children(), end_t))
        } else {
          return self.$n("begin", [body], self.$collection_map(begin_t, [body], end_t))
        }
      }, 3);
      
      $def(self, '$begin_keyword', function $$begin_keyword(begin_t, body, end_t) {
        var self = this;

        if ($truthy(body['$nil?']())) {
          return self.$n0("kwbegin", self.$collection_map(begin_t, nil, end_t))
        } else if ((($eqeq(body.$type(), "begin") && ($truthy(body.$loc().$begin()['$nil?']()))) && ($truthy(body.$loc().$end()['$nil?']())))) {
          return self.$n("kwbegin", body.$children(), self.$collection_map(begin_t, body.$children(), end_t))
        } else {
          return self.$n("kwbegin", [body], self.$collection_map(begin_t, [body], end_t))
        }
      }, 3);
      
      $def(self, '$case_match', function $$case_match(case_t, expr, in_bodies, else_t, else_body, end_t) {
        var self = this;

        
        if (($truthy(else_t) && ($not(else_body)))) {
          else_body = self.$n("empty_else", nil, self.$token_map(else_t))
        };
        return self.$n("case_match", [expr].concat($to_a(in_bodies['$<<'](else_body))), self.$condition_map(case_t, expr, nil, nil, else_t, else_body, end_t));
      }, 6);
      
      $def(self, '$in_match', function $$in_match(lhs, in_t, rhs) {
        var self = this;

        return self.$n("in_match", [lhs, rhs], self.$binary_op_map(lhs, in_t, rhs))
      }, 3);
      
      $def(self, '$match_pattern', function $$match_pattern(lhs, match_t, rhs) {
        var self = this;

        return self.$n("match_pattern", [lhs, rhs], self.$binary_op_map(lhs, match_t, rhs))
      }, 3);
      
      $def(self, '$match_pattern_p', function $$match_pattern_p(lhs, match_t, rhs) {
        var self = this;

        return self.$n("match_pattern_p", [lhs, rhs], self.$binary_op_map(lhs, match_t, rhs))
      }, 3);
      
      $def(self, '$in_pattern', function $$in_pattern(in_t, pattern, guard, then_t, body) {
        var self = this, children = nil;

        
        children = [pattern, guard, body];
        return self.$n("in_pattern", children, self.$keyword_map(in_t, then_t, children.$compact(), nil));
      }, 5);
      
      $def(self, '$if_guard', function $$if_guard(if_t, if_body) {
        var self = this;

        return self.$n("if_guard", [if_body], self.$guard_map(if_t, if_body))
      }, 2);
      
      $def(self, '$unless_guard', function $$unless_guard(unless_t, unless_body) {
        var self = this;

        return self.$n("unless_guard", [unless_body], self.$guard_map(unless_t, unless_body))
      }, 2);
      
      $def(self, '$match_var', function $$match_var(name_t) {
        var self = this, name = nil, name_l = nil;

        
        name = self.$value(name_t).$to_sym();
        name_l = self.$loc(name_t);
        self.$check_lvar_name(name, name_l);
        self.$check_duplicate_pattern_variable(name, name_l);
        self.parser.$static_env().$declare(name);
        return self.$n("match_var", [name], self.$variable_map(name_t));
      }, 1);
      
      $def(self, '$match_hash_var', function $$match_hash_var(name_t) {
        var self = this, name = nil, expr_l = nil, name_l = nil;

        
        name = self.$value(name_t).$to_sym();
        expr_l = self.$loc(name_t);
        name_l = expr_l.$adjust($hash2(["end_pos"], {"end_pos": -1}));
        self.$check_lvar_name(name, name_l);
        self.$check_duplicate_pattern_variable(name, name_l);
        self.parser.$static_env().$declare(name);
        return self.$n("match_var", [name], $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_l, expr_l));
      }, 1);
      
      $def(self, '$match_hash_var_from_str', function $$match_hash_var_from_str(begin_t, strings, end_t) {
        var $a, self = this, string = nil, name = nil, name_l = nil, begin_l = nil, end_l = nil, expr_l = nil;

        
        if ($truthy($rb_gt(strings.$length(), 1))) {
          self.$diagnostic("error", "pm_interp_in_var_name", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        };
        string = strings['$[]'](0);
        
        switch (string.$type()) {
          case "str":
            
            $a = [].concat($to_a(string)), (name = ($a[0] == null ? nil : $a[0])), $a;
            name_l = string.$loc().$expression();
            self.$check_lvar_name(name, name_l);
            self.$check_duplicate_pattern_variable(name, name_l);
            self.parser.$static_env().$declare(name);
            if ($truthy((begin_l = string.$loc().$begin()))) {
              name_l = name_l.$adjust($hash2(["begin_pos"], {"begin_pos": begin_l.$length()}))
            };
            if ($truthy((end_l = string.$loc().$end()))) {
              name_l = name_l.$adjust($hash2(["end_pos"], {"end_pos": end_l.$length()['$-@']()}))
            };
            expr_l = self.$loc(begin_t).$join(string.$loc().$expression()).$join(self.$loc(end_t));
            return self.$n("match_var", [name.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_l, expr_l));
          case "begin":
            return self.$match_hash_var_from_str(begin_t, string.$children(), end_t)
          default:
            return self.$diagnostic("error", "pm_interp_in_var_name", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        };
      }, 3);
      
      $def(self, '$match_rest', function $$match_rest(star_t, name_t) {
        var self = this, name = nil;

        
        
        if (name_t == null) name_t = nil;;
        if ($truthy(name_t['$nil?']())) {
          return self.$n0("match_rest", self.$unary_op_map(star_t))
        } else {
          
          name = self.$match_var(name_t);
          return self.$n("match_rest", [name], self.$unary_op_map(star_t, name));
        };
      }, -2);
      
      $def(self, '$hash_pattern', function $$hash_pattern(lbrace_t, kwargs, rbrace_t) {
        var self = this, args = nil;

        
        args = self.$check_duplicate_args(kwargs);
        return self.$n("hash_pattern", args, self.$collection_map(lbrace_t, args, rbrace_t));
      }, 3);
      
      $def(self, '$array_pattern', function $$array_pattern(lbrack_t, elements, rbrack_t) {
        var self = this, trailing_comma = nil, node_elements = nil, node_type = nil;

        
        if ($truthy(elements['$nil?']())) {
          return self.$n("array_pattern", nil, self.$collection_map(lbrack_t, [], rbrack_t))
        };
        trailing_comma = false;
        node_elements = $send(elements, 'map', [], function $$14(element){
          
          
          if (element == null) element = nil;;
          if ($eqeq(element.$type(), "match_with_trailing_comma")) {
            
            trailing_comma = true;
            return element.$children().$first();
          } else {
            
            trailing_comma = false;
            return element;
          };}, 1);
        node_type = ($truthy(trailing_comma) ? ("array_pattern_with_tail") : ("array_pattern"));
        return self.$n(node_type, node_elements, self.$collection_map(lbrack_t, elements, rbrack_t));
      }, 3);
      
      $def(self, '$find_pattern', function $$find_pattern(lbrack_t, elements, rbrack_t) {
        var self = this;

        return self.$n("find_pattern", elements, self.$collection_map(lbrack_t, elements, rbrack_t))
      }, 3);
      
      $def(self, '$match_with_trailing_comma', function $$match_with_trailing_comma(match, comma_t) {
        var self = this;

        return self.$n("match_with_trailing_comma", [match], self.$expr_map(match.$loc().$expression().$join(self.$loc(comma_t))))
      }, 2);
      
      $def(self, '$const_pattern', function $$const_pattern(const$, ldelim_t, pattern, rdelim_t) {
        var self = this;

        return self.$n("const_pattern", [const$, pattern], $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(ldelim_t), self.$loc(rdelim_t), const$.$loc().$expression().$join(self.$loc(rdelim_t))))
      }, 4);
      
      $def(self, '$pin', function $$pin(pin_t, var$) {
        var self = this;

        return self.$n("pin", [var$], self.$send_unary_op_map(pin_t, var$))
      }, 2);
      
      $def(self, '$match_alt', function $$match_alt(left, pipe_t, right) {
        var self = this, source_map = nil;

        
        source_map = self.$binary_op_map(left, pipe_t, right);
        return self.$n("match_alt", [left, right], source_map);
      }, 3);
      
      $def(self, '$match_as', function $$match_as(value, assoc_t, as) {
        var self = this, source_map = nil;

        
        source_map = self.$binary_op_map(value, assoc_t, as);
        return self.$n("match_as", [value, as], source_map);
      }, 3);
      
      $def(self, '$match_nil_pattern', function $$match_nil_pattern(dstar_t, nil_t) {
        var self = this;

        return self.$n0("match_nil_pattern", self.$arg_prefix_map(dstar_t, nil_t))
      }, 2);
      
      $def(self, '$match_pair', function $$match_pair(label_type, label, value) {
        var $a, $b, self = this, begin_t = nil, parts = nil, end_t = nil, label_loc = nil, var_name = nil;

        if ($eqeq(label_type, "label")) {
          
          self.$check_duplicate_pattern_key(label['$[]'](0), label['$[]'](1));
          return self.$pair_keyword(label, value);
        } else {
          
          $b = label, $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (parts = ($a[1] == null ? nil : $a[1])), (end_t = ($a[2] == null ? nil : $a[2])), $b;
          label_loc = self.$loc(begin_t).$join(self.$loc(end_t));
          if ($truthy((var_name = self.$static_string(parts)))) {
            self.$check_duplicate_pattern_key(var_name, label_loc)
          } else {
            self.$diagnostic("error", "pm_interp_in_var_name", nil, label_loc)
          };
          return self.$pair_quoted(begin_t, parts, end_t, value);
        }
      }, 3);
      
      $def(self, '$match_label', function $$match_label(label_type, label) {
        var $a, $b, self = this, begin_t = nil, strings = nil, end_t = nil;

        if ($eqeq(label_type, "label")) {
          return self.$match_hash_var(label)
        } else {
          
          $b = label, $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (strings = ($a[1] == null ? nil : $a[1])), (end_t = ($a[2] == null ? nil : $a[2])), $b;
          return self.$match_hash_var_from_str(begin_t, strings, end_t);
        }
      }, 2);
      self.$private();
      
      $def(self, '$check_condition', function $$check_condition(cond) {
        var $a, self = this, lhs = nil, rhs = nil, type = nil, $ret_or_2 = nil;

        
        switch (cond.$type()) {
          case "masgn":
            if ($truthy($rb_le(self.parser.$version(), 23))) {
              return self.$diagnostic("error", "masgn_as_condition", nil, cond.$loc().$expression())
            } else {
              return cond
            }
            break;
          case "begin":
            if ($eqeq(cond.$children().$count(), 1)) {
              return cond.$updated(nil, [self.$check_condition(cond.$children().$last())])
            } else {
              return cond
            }
            break;
          case "and":
          case "or":
          case "irange":
          case "erange":
            
            $a = [].concat($to_a(cond)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
            type = ($eqeqeq("irange", ($ret_or_2 = cond.$type())) ? ("iflipflop") : ($eqeqeq("erange", $ret_or_2) ? ("eflipflop") : (nil)));
            if (($truthy(["and", "or"]['$include?'](cond.$type())) && ($eqeq(self.parser.$version(), 18)))) {
              return cond
            } else {
              return cond.$updated(type, [self.$check_condition(lhs), self.$check_condition(rhs)])
            };
            break;
          case "regexp":
            return self.$n("match_current_line", [cond], self.$expr_map(cond.$loc().$expression()))
          default:
            return cond
        }
      }, 1);
      
      $def(self, '$check_duplicate_args', function $$check_duplicate_args(args, map) {
        var self = this;

        
        
        if (map == null) map = $hash2([], {});;
        return $send(args, 'each', [], function $$15(this_arg){var self = $$15.$$s == null ? this : $$15.$$s;

          
          
          if (this_arg == null) this_arg = nil;;
          
          switch (this_arg.$type()) {
            case "arg":
            case "optarg":
            case "restarg":
            case "blockarg":
            case "kwarg":
            case "kwoptarg":
            case "kwrestarg":
            case "shadowarg":
              return self.$check_duplicate_arg(this_arg, map)
            case "procarg0":
              if ($truthy(this_arg.$children()['$[]'](0)['$is_a?']($$('Symbol')))) {
                return self.$check_duplicate_arg(this_arg, map)
              } else {
                return self.$check_duplicate_args(this_arg.$children(), map)
              }
              break;
            case "mlhs":
              return self.$check_duplicate_args(this_arg.$children(), map)
            default:
              return nil
          };}, {$$arity: 1, $$s: self});
      }, -2);
      
      $def(self, '$check_duplicate_arg', function $$check_duplicate_arg(this_arg, map) {
        var $a, self = this, this_name = nil, that_arg = nil, that_name = nil;

        
        
        if (map == null) map = $hash2([], {});;
        $a = [].concat($to_a(this_arg)), (this_name = ($a[0] == null ? nil : $a[0])), $a;
        that_arg = map['$[]'](this_name);
        $a = [].concat($to_a(that_arg)), (that_name = ($a[0] == null ? nil : $a[0])), $a;
        if ($truthy(that_arg['$nil?']())) {
          return ($a = [this_name, this_arg], $send(map, '[]=', $a), $a[$a.length - 1])
        } else if ($truthy(self['$arg_name_collides?'](this_name, that_name))) {
          return self.$diagnostic("error", "duplicate_argument", nil, this_arg.$loc().$name(), [that_arg.$loc().$name()])
        } else {
          return nil
        };
      }, -2);
      
      $def(self, '$validate_no_forward_arg_after_restarg', function $$validate_no_forward_arg_after_restarg(args) {
        var self = this, restarg = nil, forward_arg = nil;

        
        restarg = nil;
        forward_arg = nil;
        $send(args, 'each', [], function $$16(arg){
          
          
          if (arg == null) arg = nil;;
          
          switch (arg.$type()) {
            case "restarg":
              return (restarg = arg)
            case "forward_arg":
              return (forward_arg = arg)
            default:
              return nil
          };}, 1);
        if (($not(forward_arg['$nil?']()) && ($not(restarg['$nil?']())))) {
          return self.$diagnostic("error", "forward_arg_after_restarg", nil, forward_arg.$loc().$expression(), [restarg.$loc().$expression()])
        } else {
          return nil
        };
      }, 1);
      
      $def(self, '$check_assignment_to_numparam', function $$check_assignment_to_numparam(name, loc) {
        var self = this, assigning_to_numparam = nil, $ret_or_1 = nil, $ret_or_2 = nil;

        
        if ($truthy($rb_lt(self.parser.$version(), 27))) {
          return nil
        };
        assigning_to_numparam = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.parser.$context()['$in_dynamic_block?']())) ? (name['$=~'](/^_([1-9])$/)) : ($ret_or_2)))) ? (self.parser.$max_numparam_stack()['$has_numparams?']()) : ($ret_or_1));
        if ($truthy(assigning_to_numparam)) {
          return self.$diagnostic("error", "cant_assign_to_numparam", $hash2(["name"], {"name": name}), loc)
        } else {
          return nil
        };
      }, 2);
      
      $def(self, '$check_reserved_for_numparam', function $$check_reserved_for_numparam(name, loc) {
        var self = this;

        
        if ($truthy($rb_lt(self.parser.$version(), 30))) {
          return nil
        };
        if ($truthy(name['$=~'](/^_([1-9])$/))) {
          return self.$diagnostic("error", "reserved_for_numparam", $hash2(["name"], {"name": name}), loc)
        } else {
          return nil
        };
      }, 2);
      
      $def(self, '$arg_name_collides?', function $Default_arg_name_collides$ques$17(this_name, that_name) {
        var self = this, $ret_or_2 = nil, $ret_or_3 = nil;

        
        switch (self.parser.$version()) {
          case 18:
            return this_name['$=='](that_name)
          case 19:
            if ($truthy(($ret_or_2 = this_name['$!=']("_")))) {
              return this_name['$=='](that_name)
            } else {
              return $ret_or_2
            }
            break;
          default:
            if ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = this_name)) ? (this_name['$[]'](0)['$!=']("_")) : ($ret_or_3))))) {
              return this_name['$=='](that_name)
            } else {
              return $ret_or_2
            }
        }
      }, 2);
      
      $def(self, '$check_lvar_name', function $$check_lvar_name(name, loc) {
        var self = this;

        if ($truthy(name['$=~'](/^[[[:lower:]]_][[[:alnum:]]_]*$/))) {
          return nil
        } else {
          return self.$diagnostic("error", "lvar_name", $hash2(["name"], {"name": name}), loc)
        }
      }, 2);
      
      $def(self, '$check_duplicate_pattern_variable', function $$check_duplicate_pattern_variable(name, loc) {
        var self = this;

        
        if ($truthy(name.$to_s()['$start_with?']("_"))) {
          return nil
        };
        if ($truthy(self.parser.$pattern_variables()['$declared?'](name))) {
          self.$diagnostic("error", "duplicate_variable_name", $hash2(["name"], {"name": name.$to_s()}), loc)
        };
        return self.parser.$pattern_variables().$declare(name);
      }, 2);
      
      $def(self, '$check_duplicate_pattern_key', function $$check_duplicate_pattern_key(name, loc) {
        var self = this;

        
        if ($truthy(self.parser.$pattern_hash_keys()['$declared?'](name))) {
          self.$diagnostic("error", "duplicate_pattern_key", $hash2(["name"], {"name": name.$to_s()}), loc)
        };
        return self.parser.$pattern_hash_keys().$declare(name);
      }, 2);
      
      $def(self, '$n', function $$n(type, children, source_map) {
        
        return $$$($$('AST'), 'Node').$new(type, children, $hash2(["location"], {"location": source_map}))
      }, 3);
      
      $def(self, '$n0', function $$n0(type, source_map) {
        var self = this;

        return self.$n(type, [], source_map)
      }, 2);
      
      $def(self, '$join_exprs', function $$join_exprs(left_expr, right_expr) {
        
        return left_expr.$loc().$expression().$join(right_expr.$loc().$expression())
      }, 2);
      
      $def(self, '$token_map', function $$token_map(token) {
        var self = this;

        return $$$($$('Source'), 'Map').$new(self.$loc(token))
      }, 1);
      
      $def(self, '$delimited_string_map', function $$delimited_string_map(string_t) {
        var self = this, str_range = nil, begin_l = nil, end_l = nil;

        
        str_range = self.$loc(string_t);
        begin_l = str_range.$with($hash2(["end_pos"], {"end_pos": $rb_plus(str_range.$begin_pos(), 1)}));
        end_l = str_range.$with($hash2(["begin_pos"], {"begin_pos": $rb_minus(str_range.$end_pos(), 1)}));
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(begin_l, end_l, self.$loc(string_t));
      }, 1);
      
      $def(self, '$prefix_string_map', function $$prefix_string_map(symbol) {
        var self = this, str_range = nil, begin_l = nil;

        
        str_range = self.$loc(symbol);
        begin_l = str_range.$with($hash2(["end_pos"], {"end_pos": $rb_plus(str_range.$begin_pos(), 1)}));
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(begin_l, nil, self.$loc(symbol));
      }, 1);
      
      $def(self, '$unquoted_map', function $$unquoted_map(token) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, self.$loc(token))
      }, 1);
      
      $def(self, '$pair_keyword_map', function $$pair_keyword_map(key_t, value_e) {
        var self = this, key_range = nil, key_l = nil, colon_l = nil;

        
        key_range = self.$loc(key_t);
        key_l = key_range.$adjust($hash2(["end_pos"], {"end_pos": -1}));
        colon_l = key_range.$with($hash2(["begin_pos"], {"begin_pos": $rb_minus(key_range.$end_pos(), 1)}));
        return [$$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, key_l), $$$($$$($$('Source'), 'Map'), 'Operator').$new(colon_l, key_range.$join(value_e.$loc().$expression()))];
      }, 2);
      
      $def(self, '$pair_quoted_map', function $$pair_quoted_map(begin_t, end_t, value_e) {
        var self = this, end_l = nil, quote_l = nil, colon_l = nil;

        
        end_l = self.$loc(end_t);
        quote_l = end_l.$with($hash2(["begin_pos", "end_pos"], {"begin_pos": $rb_minus(end_l.$end_pos(), 2), "end_pos": $rb_minus(end_l.$end_pos(), 1)}));
        colon_l = end_l.$with($hash2(["begin_pos"], {"begin_pos": $rb_minus(end_l.$end_pos(), 1)}));
        return [[self.$value(end_t), quote_l], $$$($$$($$('Source'), 'Map'), 'Operator').$new(colon_l, self.$loc(begin_t).$join(value_e.$loc().$expression()))];
      }, 3);
      
      $def(self, '$expr_map', function $$expr_map(loc) {
        
        return $$$($$('Source'), 'Map').$new(loc)
      }, 1);
      
      $def(self, '$collection_map', function $$collection_map(begin_t, parts, end_t) {
        var self = this, expr_l = nil;

        
        if (($truthy(begin_t['$nil?']()) || ($truthy(end_t['$nil?']())))) {
          if ($truthy(parts['$any?']())) {
            expr_l = self.$join_exprs(parts.$first(), parts.$last())
          } else if ($not(begin_t['$nil?']())) {
            expr_l = self.$loc(begin_t)
          } else if ($not(end_t['$nil?']())) {
            expr_l = self.$loc(end_t)
          }
        } else {
          expr_l = self.$loc(begin_t).$join(self.$loc(end_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), expr_l);
      }, 3);
      
      $def(self, '$string_map', function $$string_map(begin_t, parts, end_t) {
        var self = this, expr_l = nil;

        if (($truthy(begin_t) && ($truthy(self.$value(begin_t)['$start_with?']("<<"))))) {
          
          if ($truthy(parts['$any?']())) {
            expr_l = self.$join_exprs(parts.$first(), parts.$last())
          } else {
            expr_l = self.$loc(end_t).$begin()
          };
          return $$$($$$($$('Source'), 'Map'), 'Heredoc').$new(self.$loc(begin_t), expr_l, self.$loc(end_t));
        } else {
          return self.$collection_map(begin_t, parts, end_t)
        }
      }, 3);
      
      $def(self, '$regexp_map', function $$regexp_map(begin_t, end_t, options_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), self.$loc(begin_t).$join(options_e.$loc().$expression()))
      }, 3);
      
      $def(self, '$constant_map', function $$constant_map(scope, colon2_t, name_t) {
        var self = this, expr_l = nil;

        
        if ($truthy(scope['$nil?']())) {
          expr_l = self.$loc(name_t)
        } else {
          expr_l = scope.$loc().$expression().$join(self.$loc(name_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Constant').$new(self.$loc(colon2_t), self.$loc(name_t), expr_l);
      }, 3);
      
      $def(self, '$variable_map', function $$variable_map(name_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(self.$loc(name_t))
      }, 1);
      
      $def(self, '$binary_op_map', function $$binary_op_map(left_e, op_t, right_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), self.$join_exprs(left_e, right_e))
      }, 3);
      
      $def(self, '$unary_op_map', function $$unary_op_map(op_t, arg_e) {
        var self = this, expr_l = nil;

        
        
        if (arg_e == null) arg_e = nil;;
        if ($truthy(arg_e['$nil?']())) {
          expr_l = self.$loc(op_t)
        } else {
          expr_l = self.$loc(op_t).$join(arg_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), expr_l);
      }, -2);
      
      $def(self, '$range_map', function $$range_map(start_e, op_t, end_e) {
        var self = this, expr_l = nil;

        
        if (($truthy(start_e) && ($truthy(end_e)))) {
          expr_l = self.$join_exprs(start_e, end_e)
        } else if ($truthy(start_e)) {
          expr_l = start_e.$loc().$expression().$join(self.$loc(op_t))
        } else if ($truthy(end_e)) {
          expr_l = self.$loc(op_t).$join(end_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), expr_l);
      }, 3);
      
      $def(self, '$arg_prefix_map', function $$arg_prefix_map(op_t, name_t) {
        var self = this, expr_l = nil;

        
        
        if (name_t == null) name_t = nil;;
        if ($truthy(name_t['$nil?']())) {
          expr_l = self.$loc(op_t)
        } else {
          expr_l = self.$loc(op_t).$join(self.$loc(name_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(self.$loc(name_t), expr_l);
      }, -2);
      
      $def(self, '$kwarg_map', function $$kwarg_map(name_t, value_e) {
        var self = this, label_range = nil, name_range = nil, expr_l = nil;

        
        
        if (value_e == null) value_e = nil;;
        label_range = self.$loc(name_t);
        name_range = label_range.$adjust($hash2(["end_pos"], {"end_pos": -1}));
        if ($truthy(value_e)) {
          expr_l = self.$loc(name_t).$join(value_e.$loc().$expression())
        } else {
          expr_l = self.$loc(name_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_range, expr_l);
      }, -2);
      
      $def(self, '$module_definition_map', function $$module_definition_map(keyword_t, name_e, operator_t, end_t) {
        var self = this, name_l = nil;

        
        if ($truthy(name_e)) {
          name_l = name_e.$loc().$expression()
        };
        return $$$($$$($$('Source'), 'Map'), 'Definition').$new(self.$loc(keyword_t), self.$loc(operator_t), name_l, self.$loc(end_t));
      }, 4);
      
      $def(self, '$definition_map', function $$definition_map(keyword_t, operator_t, name_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'MethodDefinition').$new(self.$loc(keyword_t), self.$loc(operator_t), self.$loc(name_t), self.$loc(end_t), nil, nil)
      }, 4);
      
      $def(self, '$endless_definition_map', function $$endless_definition_map(keyword_t, operator_t, name_t, assignment_t, body_e) {
        var self = this, body_l = nil;

        
        body_l = body_e.$loc().$expression();
        return $$$($$$($$('Source'), 'Map'), 'MethodDefinition').$new(self.$loc(keyword_t), self.$loc(operator_t), self.$loc(name_t), nil, self.$loc(assignment_t), body_l);
      }, 5);
      
      $def(self, '$send_map', function $$send_map(receiver_e, dot_t, selector_t, begin_t, args, end_t) {
        var self = this, begin_l = nil, end_l = nil;

        
        
        if (begin_t == null) begin_t = nil;;
        
        if (args == null) args = [];;
        
        if (end_t == null) end_t = nil;;
        if ($truthy(receiver_e)) {
          begin_l = receiver_e.$loc().$expression()
        } else if ($truthy(selector_t)) {
          begin_l = self.$loc(selector_t)
        };
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if ($truthy(args['$any?']())) {
          end_l = args.$last().$loc().$expression()
        } else if ($truthy(selector_t)) {
          end_l = self.$loc(selector_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(self.$loc(dot_t), self.$loc(selector_t), self.$loc(begin_t), self.$loc(end_t), begin_l.$join(end_l));
      }, -4);
      
      $def(self, '$var_send_map', function $$var_send_map(variable_e) {
        
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, variable_e.$loc().$expression(), nil, nil, variable_e.$loc().$expression())
      }, 1);
      
      $def(self, '$send_binary_op_map', function $$send_binary_op_map(lhs_e, selector_t, rhs_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, self.$join_exprs(lhs_e, rhs_e))
      }, 3);
      
      $def(self, '$send_unary_op_map', function $$send_unary_op_map(selector_t, arg_e) {
        var self = this, expr_l = nil;

        
        if ($truthy(arg_e['$nil?']())) {
          expr_l = self.$loc(selector_t)
        } else {
          expr_l = self.$loc(selector_t).$join(arg_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, expr_l);
      }, 2);
      
      $def(self, '$index_map', function $$index_map(receiver_e, lbrack_t, rbrack_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Index').$new(self.$loc(lbrack_t), self.$loc(rbrack_t), receiver_e.$loc().$expression().$join(self.$loc(rbrack_t)))
      }, 3);
      
      $def(self, '$send_index_map', function $$send_index_map(receiver_e, lbrack_t, rbrack_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(lbrack_t).$join(self.$loc(rbrack_t)), nil, nil, receiver_e.$loc().$expression().$join(self.$loc(rbrack_t)))
      }, 3);
      
      $def(self, '$block_map', function $$block_map(receiver_l, begin_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), receiver_l.$join(self.$loc(end_t)))
      }, 3);
      
      $def(self, '$keyword_map', function $$keyword_map(keyword_t, begin_t, args, end_t) {
        var self = this, $ret_or_1 = nil, end_l = nil;

        
        args = ($truthy(($ret_or_1 = args)) ? ($ret_or_1) : ([]));
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if (($truthy(args['$any?']()) && ($not(args.$last()['$nil?']())))) {
          end_l = args.$last().$loc().$expression()
        } else if (($truthy(args['$any?']()) && ($truthy($rb_gt(args.$count(), 1))))) {
          end_l = args['$[]'](-2).$loc().$expression()
        } else {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));
      }, 4);
      
      $def(self, '$keyword_mod_map', function $$keyword_mod_map(pre_e, keyword_t, post_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), nil, nil, self.$join_exprs(pre_e, post_e))
      }, 3);
      
      $def(self, '$condition_map', function $$condition_map(keyword_t, cond_e, begin_t, body_e, else_t, else_e, end_t) {
        var self = this, end_l = nil;

        
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if (($truthy(else_e) && ($truthy(else_e.$loc().$expression())))) {
          end_l = else_e.$loc().$expression()
        } else if ($truthy(self.$loc(else_t))) {
          end_l = self.$loc(else_t)
        } else if (($truthy(body_e) && ($truthy(body_e.$loc().$expression())))) {
          end_l = body_e.$loc().$expression()
        } else if ($truthy(self.$loc(begin_t))) {
          end_l = self.$loc(begin_t)
        } else {
          end_l = cond_e.$loc().$expression()
        };
        return $$$($$$($$('Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(else_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));
      }, 7);
      
      $def(self, '$ternary_map', function $$ternary_map(begin_e, question_t, mid_e, colon_t, end_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Ternary').$new(self.$loc(question_t), self.$loc(colon_t), self.$join_exprs(begin_e, end_e))
      }, 5);
      
      $def(self, '$for_map', function $$for_map(keyword_t, in_t, begin_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'For').$new(self.$loc(keyword_t), self.$loc(in_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(self.$loc(end_t)))
      }, 4);
      
      $def(self, '$rescue_body_map', function $$rescue_body_map(keyword_t, exc_list_e, assoc_t, exc_var_e, then_t, compstmt_e) {
        var self = this, end_l = nil;

        
        if ($truthy(compstmt_e)) {
          end_l = compstmt_e.$loc().$expression()
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(then_t)))) {
          end_l = self.$loc(then_t)
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(exc_var_e)))) {
          end_l = exc_var_e.$loc().$expression()
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(exc_list_e)))) {
          end_l = exc_list_e.$loc().$expression()
        };
        if ($truthy(end_l['$nil?']())) {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'RescueBody').$new(self.$loc(keyword_t), self.$loc(assoc_t), self.$loc(then_t), self.$loc(keyword_t).$join(end_l));
      }, 6);
      
      $def(self, '$eh_keyword_map', function $$eh_keyword_map(compstmt_e, keyword_t, body_es, else_t, else_e) {
        var self = this, begin_l = nil, end_l = nil;

        
        if ($truthy(compstmt_e['$nil?']())) {
          if ($truthy(keyword_t['$nil?']())) {
            begin_l = body_es.$first().$loc().$expression()
          } else {
            begin_l = self.$loc(keyword_t)
          }
        } else {
          begin_l = compstmt_e.$loc().$expression()
        };
        if ($truthy(else_t)) {
          if ($truthy(else_e['$nil?']())) {
            end_l = self.$loc(else_t)
          } else {
            end_l = else_e.$loc().$expression()
          }
        } else if ($not(body_es.$last()['$nil?']())) {
          end_l = body_es.$last().$loc().$expression()
        } else {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), nil, self.$loc(else_t), nil, begin_l.$join(end_l));
      }, 5);
      
      $def(self, '$guard_map', function $$guard_map(keyword_t, guard_body_e) {
        var self = this, keyword_l = nil, guard_body_l = nil;

        
        keyword_l = self.$loc(keyword_t);
        guard_body_l = guard_body_e.$loc().$expression();
        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(keyword_l, nil, nil, keyword_l.$join(guard_body_l));
      }, 2);
      
      $def(self, '$static_string', function $$static_string(nodes) {try {

        var self = this;

        return $send(nodes, 'map', [], function $$18(node){var self = $$18.$$s == null ? this : $$18.$$s, string = nil;

          
          
          if (node == null) node = nil;;
          
          switch (node.$type()) {
            case "str":
              return node.$children()['$[]'](0)
            case "begin":
              if ($truthy((string = self.$static_string(node.$children())))) {
                return string
              } else {
                Opal.ret(nil)
              }
              break;
            default:
              Opal.ret(nil)
          };}, {$$arity: 1, $$s: self}).$join()
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, 1);
      
      $def(self, '$static_regexp', function $$static_regexp(parts, options) {
        var self = this, source = nil;

        
        source = self.$static_string(parts);
        if ($truthy(source['$nil?']())) {
          return nil
        };
        source = ($truthy(options.$children()['$include?']("u")) ? (source.$encode($$$($$('Encoding'), 'UTF_8'))) : ($truthy(options.$children()['$include?']("e")) ? (source.$encode($$$($$('Encoding'), 'EUC_JP'))) : ($truthy(options.$children()['$include?']("s")) ? (source.$encode($$$($$('Encoding'), 'WINDOWS_31J'))) : ($truthy(options.$children()['$include?']("n")) ? (source.$encode($$$($$('Encoding'), 'BINARY'))) : (source)))));
        return $$('Regexp').$new(source, ($truthy(options.$children()['$include?']("x")) ? ($$$($$('Regexp'), 'EXTENDED')) : nil));
      }, 2);
      
      $def(self, '$static_regexp_node', function $$static_regexp_node(node) {
        var $a, self = this, parts = nil, options = nil;

        if ($eqeq(node.$type(), "regexp")) {
          
          $a = [node.$children()['$[]']($range(0, -2, false)), node.$children()['$[]'](-1)], (parts = $a[0]), (options = $a[1]), $a;
          return self.$static_regexp(parts, options);
        } else {
          return nil
        }
      }, 1);
      
      $def(self, '$collapse_string_parts?', function $Default_collapse_string_parts$ques$19(parts) {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = parts['$one?']()))) {
          return ["str", "dstr"]['$include?'](parts.$first().$type())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$value', function $$value(token) {
        
        return token['$[]'](0)
      }, 1);
      
      $def(self, '$string_value', function $$string_value(token) {
        var self = this;

        
        if (!$truthy(token['$[]'](0)['$valid_encoding?']())) {
          self.$diagnostic("error", "invalid_encoding", nil, token['$[]'](1))
        };
        return token['$[]'](0);
      }, 1);
      
      $def(self, '$loc', function $$loc(token) {
        
        if (($truthy(token) && ($truthy(token['$[]'](0))))) {
          return token['$[]'](1)
        } else {
          return nil
        }
      }, 1);
      
      $def(self, '$diagnostic', function $$diagnostic(type, reason, arguments$, location, highlights) {
        var self = this;

        
        
        if (highlights == null) highlights = [];;
        self.parser.$diagnostics().$process($$('Diagnostic').$new(type, reason, arguments$, location, highlights));
        if ($eqeq(type, "error")) {
          return self.parser.$send("yyerror")
        } else {
          return nil
        };
      }, -5);
      
      $def(self, '$validate_definee', function $$validate_definee(definee) {
        var self = this;

        
        switch (definee.$type()) {
          case "int":
          case "str":
          case "dstr":
          case "sym":
          case "dsym":
          case "regexp":
          case "array":
          case "hash":
            
            self.$diagnostic("error", "singleton_literal", nil, definee.$loc().$expression());
            return false;
          default:
            return true
        }
      }, 1);
      
      $def(self, '$rewrite_hash_args_to_kwargs', function $$rewrite_hash_args_to_kwargs(args) {
        var $a, self = this;

        if (($truthy(args['$any?']()) && ($truthy(self['$kwargs?'](args.$last()))))) {
          return ($a = [$rb_minus(args.$length(), 1), args['$[]']($rb_minus(args.$length(), 1)).$updated("kwargs")], $send(args, '[]=', $a), $a[$a.length - 1])
        } else if ((($truthy($rb_gt(args.$length(), 1)) && ($eqeq(args.$last().$type(), "block_pass"))) && ($truthy(self['$kwargs?'](args['$[]']($rb_minus(args.$length(), 2))))))) {
          return ($a = [$rb_minus(args.$length(), 2), args['$[]']($rb_minus(args.$length(), 2)).$updated("kwargs")], $send(args, '[]=', $a), $a[$a.length - 1])
        } else {
          return nil
        }
      }, 1);
      return $def(self, '$kwargs?', function $Default_kwargs$ques$20(node) {
        var $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = node.$type()['$==']("hash"))) ? (node.$loc().$begin()['$nil?']()) : ($ret_or_2))))) {
          return node.$loc().$end()['$nil?']()
        } else {
          return $ret_or_1
        }
      }, 1);
    })($$('Builders'), null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/context"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy;

  Opal.add_stubs('reset,attr_accessor,in_block,in_lambda');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Context');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'FLAGS', ["in_defined", "in_kwarg", "in_argdef", "in_def", "in_class", "in_block", "in_lambda"]);
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        return self.$reset()
      }, 0);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        
        self.in_defined = false;
        self.in_kwarg = false;
        self.in_argdef = false;
        self.in_def = false;
        self.in_class = false;
        self.in_block = false;
        return (self.in_lambda = false);
      }, 0);
      $send(self, 'attr_accessor', $to_a($$('FLAGS')));
      return $def(self, '$in_dynamic_block?', function $Context_in_dynamic_block$ques$1() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.$in_block()))) {
          return $ret_or_1
        } else {
          return self.$in_lambda()
        }
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/max_numparam_stack"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs('attr_reader,==,size,set,top,>,max,[],last,push,pop,private,[]=');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'MaxNumparamStack');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.stack = nil;
      
      self.$attr_reader("stack");
      $const_set($nesting[0], 'ORDINARY_PARAMS', -1);
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        return (self.stack = [])
      }, 0);
      
      $def(self, '$empty?', function $MaxNumparamStack_empty$ques$1() {
        var self = this;

        return self.stack.$size()['$=='](0)
      }, 0);
      
      $def(self, '$has_ordinary_params!', function $MaxNumparamStack_has_ordinary_params$excl$2() {
        var self = this;

        return self.$set($$('ORDINARY_PARAMS'))
      }, 0);
      
      $def(self, '$has_ordinary_params?', function $MaxNumparamStack_has_ordinary_params$ques$3() {
        var self = this;

        return self.$top()['$==']($$('ORDINARY_PARAMS'))
      }, 0);
      
      $def(self, '$has_numparams?', function $MaxNumparamStack_has_numparams$ques$4() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.$top()))) {
          return $rb_gt(self.$top(), 0)
        } else {
          return $ret_or_1
        }
      }, 0);
      
      $def(self, '$register', function $$register(numparam) {
        var self = this;

        return self.$set([self.$top(), numparam].$max())
      }, 1);
      
      $def(self, '$top', function $$top() {
        var self = this;

        return self.stack.$last()['$[]']("value")
      }, 0);
      
      $def(self, '$push', function $$push($kwargs) {
        var static$, self = this;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'static')) {
          throw Opal.ArgumentError.$new('missing keyword: static');
        }
        static$ = $kwargs.$$smap["static"];;
        return self.stack.$push($hash2(["value", "static"], {"value": 0, "static": static$}));
      }, 1);
      
      $def(self, '$pop', function $$pop() {
        var self = this;

        return self.stack.$pop()['$[]']("value")
      }, 0);
      self.$private();
      return $def(self, '$set', function $$set(value) {
        var $a, self = this;

        return ($a = ["value", value], $send(self.stack.$last(), '[]=', $a), $a[$a.length - 1])
      }, 1);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/current_arg_stack"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $rb_minus = Opal.rb_minus, $send = Opal.send;

  Opal.add_stubs('attr_reader,freeze,==,size,<<,[]=,-,length,pop,clear,last');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'CurrentArgStack');

      var $proto = self.$$prototype;

      $proto.stack = nil;
      
      self.$attr_reader("stack");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.stack = [];
        return self.$freeze();
      }, 0);
      
      $def(self, '$empty?', function $CurrentArgStack_empty$ques$1() {
        var self = this;

        return self.stack.$size()['$=='](0)
      }, 0);
      
      $def(self, '$push', function $$push(value) {
        var self = this;

        return self.stack['$<<'](value)
      }, 1);
      
      $def(self, '$set', function $$set(value) {
        var $a, self = this;

        return ($a = [$rb_minus(self.stack.$length(), 1), value], $send(self.stack, '[]=', $a), $a[$a.length - 1])
      }, 1);
      
      $def(self, '$pop', function $$pop() {
        var self = this;

        return self.stack.$pop()
      }, 0);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        return self.stack.$clear()
      }, 0);
      return $def(self, '$top', function $$top() {
        var self = this;

        return self.stack.$last()
      }, 0);
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["parser/variables_stack"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('push,empty?,<<,new,pop,clear,last,to_sym,include?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'VariablesStack');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.stack = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.stack = [];
        return self.$push();
      }, 0);
      
      $def(self, '$empty?', function $VariablesStack_empty$ques$1() {
        var self = this;

        return self.stack['$empty?']()
      }, 0);
      
      $def(self, '$push', function $$push() {
        var self = this;

        return self.stack['$<<']($$('Set').$new())
      }, 0);
      
      $def(self, '$pop', function $$pop() {
        var self = this;

        return self.stack.$pop()
      }, 0);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        return self.stack.$clear()
      }, 0);
      
      $def(self, '$declare', function $$declare(name) {
        var self = this;

        return self.stack.$last()['$<<'](name.$to_sym())
      }, 1);
      return $def(self, '$declared?', function $VariablesStack_declared$ques$2(name) {
        var self = this;

        return self.stack.$last()['$include?'](name.$to_sym())
      }, 1);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $def = Opal.def, $not = Opal.not, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $hash2 = Opal.hash2;

  Opal.add_stubs('default_parser,setup_source_buffer,default_encoding,parse,parse_with_comments,read,new,all_errors_are_fatal=,diagnostics,ignore_warnings=,consumer=,lambda,puts,render,force_encoding,dup,==,name,raw_source=,source=,private_class_method,attr_reader,version,diagnostics=,static_env=,context=,parser=,[],class,reset,source_buffer=,do_parse,comments=,comments,tokens=,!,raise,tokens,private,advance,===,diagnostic,map,process,yyerror,token_to_str');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Base');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.lexer = $proto.diagnostics = $proto.static_env = $proto.context = $proto.builder = $proto.current_arg_stack = $proto.pattern_variables = $proto.pattern_hash_keys = nil;
      
      $defs(self, '$parse', function $$parse(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        
        if (file == null) file = "(string)";;
        
        if (line == null) line = 1;;
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse(source_buffer);
      }, -2);
      $defs(self, '$parse_with_comments', function $$parse_with_comments(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        
        if (file == null) file = "(string)";;
        
        if (line == null) line = 1;;
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse_with_comments(source_buffer);
      }, -2);
      $defs(self, '$parse_file', function $$parse_file(filename) {
        var self = this;

        return self.$parse($$('File').$read(filename), filename)
      }, 1);
      $defs(self, '$parse_file_with_comments', function $$parse_file_with_comments(filename) {
        var self = this;

        return self.$parse_with_comments($$('File').$read(filename), filename)
      }, 1);
      $defs(self, '$default_parser', function $$default_parser() {
        var self = this, parser = nil;

        
        parser = self.$new();
        parser.$diagnostics()['$all_errors_are_fatal='](true);
        parser.$diagnostics()['$ignore_warnings='](true);
        parser.$diagnostics()['$consumer=']($send(self, 'lambda', [], function $$1(diagnostic){          if ($gvars.stderr == null) $gvars.stderr = nil;

          
          
          if (diagnostic == null) diagnostic = nil;;
          return $gvars.stderr.$puts(diagnostic.$render());}, 1));
        return parser;
      }, 0);
      $defs(self, '$setup_source_buffer', function $$setup_source_buffer(file, line, string, encoding) {
        var self = this, source_buffer = nil;

        
        string = string.$dup().$force_encoding(encoding);
        source_buffer = $$$($$('Source'), 'Buffer').$new(file, line);
        if ($eqeq(self.$name(), "Parser::Ruby18")) {
          source_buffer['$raw_source='](string)
        } else {
          source_buffer['$source='](string)
        };
        return source_buffer;
      }, 4);
      self.$private_class_method("setup_source_buffer");
      self.$attr_reader("lexer");
      self.$attr_reader("diagnostics");
      self.$attr_reader("builder");
      self.$attr_reader("static_env");
      self.$attr_reader("source_buffer");
      self.$attr_reader("context");
      self.$attr_reader("max_numparam_stack");
      self.$attr_reader("current_arg_stack");
      self.$attr_reader("pattern_variables");
      self.$attr_reader("pattern_hash_keys");
      
      $def(self, '$initialize', function $$initialize(builder) {
        var self = this;

        
        
        if (builder == null) builder = $$$($$$($$('Parser'), 'Builders'), 'Default').$new();;
        self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
        self.static_env = $$('StaticEnvironment').$new();
        self.context = $$('Context').$new();
        self.max_numparam_stack = $$('MaxNumparamStack').$new();
        self.current_arg_stack = $$('CurrentArgStack').$new();
        self.pattern_variables = $$('VariablesStack').$new();
        self.pattern_hash_keys = $$('VariablesStack').$new();
        self.lexer = $$('Lexer').$new(self.$version());
        self.lexer['$diagnostics='](self.diagnostics);
        self.lexer['$static_env='](self.static_env);
        self.lexer['$context='](self.context);
        self.builder = builder;
        self.builder['$parser='](self);
        self.last_token = nil;
        if (($truthy($$$(self.$class(), 'Racc_debug_parser')) && ($truthy($$('ENV')['$[]']("RACC_DEBUG"))))) {
          self.yydebug = true
        };
        return self.$reset();
      }, -1);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        
        self.source_buffer = nil;
        self.lexer.$reset();
        self.static_env.$reset();
        self.context.$reset();
        self.current_arg_stack.$reset();
        self.pattern_variables.$reset();
        self.pattern_hash_keys.$reset();
        return self;
      }, 0);
      
      $def(self, '$parse', function $$parse(source_buffer) {
        var $a, self = this, $ret_or_1 = nil;

        return (function() { try {
        
        self.lexer['$source_buffer='](source_buffer);
        self.source_buffer = source_buffer;
        if ($truthy(($ret_or_1 = self.$do_parse()))) {
          return $ret_or_1
        } else {
          return nil
        };
        } finally {
          ((self.source_buffer = nil), ($a = [nil], $send(self.lexer, 'source_buffer=', $a), $a[$a.length - 1]))
        }; })()
      }, 1);
      
      $def(self, '$parse_with_comments', function $$parse_with_comments(source_buffer) {
        var $a, self = this;

        return (function() { try {
        
        self.lexer['$comments=']([]);
        return [self.$parse(source_buffer), self.lexer.$comments()];
        } finally {
          ($a = [nil], $send(self.lexer, 'comments=', $a), $a[$a.length - 1])
        }; })()
      }, 1);
      
      $def(self, '$tokenize', function $$tokenize(source_buffer, recover) {
        var $a, self = this, ast = nil;

        
        
        if (recover == null) recover = false;;
        return (function() { try {
        
        self.lexer['$tokens=']([]);
        self.lexer['$comments=']([]);
        
        try {
          ast = self.$parse(source_buffer)
        } catch ($err) {
          if (Opal.rescue($err, [$$$($$('Parser'), 'SyntaxError')])) {
            try {
              if ($not(recover)) {
                self.$raise()
              }
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };;
        return [ast, self.lexer.$comments(), self.lexer.$tokens()];
        } finally {
          (($a = [nil], $send(self.lexer, 'tokens=', $a), $a[$a.length - 1]), ($a = [nil], $send(self.lexer, 'comments=', $a), $a[$a.length - 1]))
        }; })();
      }, -2);
      self.$private();
      
      $def(self, '$next_token', function $$next_token() {
        var self = this, token = nil;

        
        token = self.lexer.$advance();
        self.last_token = token;
        return token;
      }, 0);
      
      $def(self, '$check_kwarg_name', function $$check_kwarg_name(name_t) {
        var self = this, $ret_or_1 = nil;

        if ($eqeqeq(/^[a-z_]/, ($ret_or_1 = name_t['$[]'](0)))) {
          return nil
        } else if ($eqeqeq(/^[A-Z]/, $ret_or_1)) {
          return self.$diagnostic("error", "argument_const", nil, name_t)
        } else {
          return nil
        }
      }, 1);
      
      $def(self, '$diagnostic', function $$diagnostic(level, reason, arguments$, location_t, highlights_ts) {
        var $a, $b, self = this, _ = nil, location = nil, highlights = nil;

        
        
        if (highlights_ts == null) highlights_ts = [];;
        $b = location_t, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        highlights = $send(highlights_ts, 'map', [], function $$2(token){var $c, $d, range = nil;

          
          
          if (token == null) token = nil;;
          $d = token, $c = $to_ary($d), (_ = ($c[0] == null ? nil : $c[0])), (range = ($c[1] == null ? nil : $c[1])), $d;
          return range;}, 1);
        self.diagnostics.$process($$('Diagnostic').$new(level, reason, arguments$, location, highlights));
        if ($eqeq(level, "error")) {
          return self.$yyerror()
        } else {
          return nil
        };
      }, -5);
      return $def(self, '$on_error', function $$on_error(error_token_id, error_value, value_stack) {
        var $a, $b, self = this, token_name = nil, _ = nil, location = nil;

        
        token_name = self.$token_to_str(error_token_id);
        $b = error_value, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        return self.diagnostics.$process($$('Diagnostic').$new("error", "unexpected_token", $hash2(["token"], {"token": token_name}), location));
      }, 3);
    })($nesting[0], $$$($$('Racc'), 'Parser'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a;

  Opal.add_stubs('new,process,include?,type,remove,wrap,insert_before,insert_after,replace,freeze,join,extend,warn_of_deprecation,class,warned_of_deprecation=');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Rewriter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.source_rewriter = nil;
      
      
      $def(self, '$rewrite', function $$rewrite(source_buffer, ast) {
        var self = this;

        
        self.source_rewriter = $$$($$('Source'), 'Rewriter').$new(source_buffer);
        self.$process(ast);
        return self.source_rewriter.$process();
      }, 2);
      
      $def(self, '$assignment?', function $Rewriter_assignment$ques$1(node) {
        
        return ["lvasgn", "ivasgn", "gvasgn", "cvasgn", "casgn"]['$include?'](node.$type())
      }, 1);
      
      $def(self, '$remove', function $$remove(range) {
        var self = this;

        return self.source_rewriter.$remove(range)
      }, 1);
      
      $def(self, '$wrap', function $$wrap(range, before, after) {
        var self = this;

        return self.source_rewriter.$wrap(range, before, after)
      }, 3);
      
      $def(self, '$insert_before', function $$insert_before(range, content) {
        var self = this;

        return self.source_rewriter.$insert_before(range, content)
      }, 2);
      
      $def(self, '$insert_after', function $$insert_after(range, content) {
        var self = this;

        return self.source_rewriter.$insert_after(range, content)
      }, 2);
      
      $def(self, '$replace', function $$replace(range, content) {
        var self = this;

        return self.source_rewriter.$replace(range, content)
      }, 2);
      $const_set($nesting[0], 'DEPRECATION_WARNING', ["Parser::Rewriter is deprecated.", "Please update your code to use Parser::TreeRewriter instead"].$join("\n").$freeze());
      self.$extend($$('Deprecation'));
      return $def(self, '$initialize', function $$initialize($a) {
        var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        
        $post_args = Opal.slice.call(arguments);
        
        $rest_arg = $post_args;;
        self.$class().$warn_of_deprecation();
        $$$($$('Source'), 'Rewriter')['$warned_of_deprecation='](true);
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
      }, -1);
    })($nesting[0], $$$($$$($$('Parser'), 'AST'), 'Processor'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser/tree_rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $hash = Opal.hash, $def = Opal.def;

  Opal.add_stubs('new,process,include?,type,remove,wrap,insert_before,insert_after,replace');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'TreeRewriter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.source_rewriter = nil;
      
      
      $def(self, '$rewrite', function $$rewrite(source_buffer, ast, $kwargs) {
        var policy, self = this;

        
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        policy = Opal.kwrestargs($kwargs, {});;
        self.source_rewriter = $$$($$$($$('Parser'), 'Source'), 'TreeRewriter').$new(source_buffer, Opal.to_hash(policy));
        self.$process(ast);
        return self.source_rewriter.$process();
      }, -3);
      
      $def(self, '$assignment?', function $TreeRewriter_assignment$ques$1(node) {
        
        return ["lvasgn", "ivasgn", "gvasgn", "cvasgn", "casgn"]['$include?'](node.$type())
      }, 1);
      
      $def(self, '$remove', function $$remove(range) {
        var self = this;

        return self.source_rewriter.$remove(range)
      }, 1);
      
      $def(self, '$wrap', function $$wrap(range, before, after) {
        var self = this;

        return self.source_rewriter.$wrap(range, before, after)
      }, 3);
      
      $def(self, '$insert_before', function $$insert_before(range, content) {
        var self = this;

        return self.source_rewriter.$insert_before(range, content)
      }, 2);
      
      $def(self, '$insert_after', function $$insert_after(range, content) {
        var self = this;

        return self.source_rewriter.$insert_after(range, content)
      }, 2);
      return $def(self, '$replace', function $$replace(range, content) {
        var self = this;

        return self.source_rewriter.$replace(range, content)
      }, 2);
    })($nesting[0], $$$($$$($$('Parser'), 'AST'), 'Processor'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs('=~,require,raise');
  
  if ($truthy($$('RUBY_VERSION')['$=~'](/^1\.[89]\./))) {
    
    self.$require("parser/version");
    self.$raise($$('LoadError'), "parser v" + ($$$($$('Parser'), 'VERSION')) + " cannot run on Ruby " + ($$('RUBY_VERSION')) + ".\n" + "Please upgrade to Ruby 2.0.0 or higher, or use an older version of the parser gem.\n");
  };
  self.$require("set");
  self.$require("racc/parser");
  self.$require("ast");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    
    self.$require("parser/version");
    self.$require("parser/messages");
    self.$require("parser/deprecation");
    (function($base) {
      var self = $module($base, 'AST');

      
      
      self.$require("parser/ast/node");
      self.$require("parser/ast/processor");
      return self.$require("parser/meta");
    })($nesting[0]);
    (function($base) {
      var self = $module($base, 'Source');

      
      
      self.$require("parser/source/buffer");
      self.$require("parser/source/range");
      self.$require("parser/source/comment");
      self.$require("parser/source/comment/associator");
      self.$require("parser/source/rewriter");
      self.$require("parser/source/rewriter/action");
      self.$require("parser/source/tree_rewriter");
      self.$require("parser/source/tree_rewriter/action");
      self.$require("parser/source/map");
      self.$require("parser/source/map/operator");
      self.$require("parser/source/map/collection");
      self.$require("parser/source/map/constant");
      self.$require("parser/source/map/variable");
      self.$require("parser/source/map/keyword");
      self.$require("parser/source/map/definition");
      self.$require("parser/source/map/method_definition");
      self.$require("parser/source/map/send");
      self.$require("parser/source/map/index");
      self.$require("parser/source/map/condition");
      self.$require("parser/source/map/ternary");
      self.$require("parser/source/map/for");
      self.$require("parser/source/map/rescue_body");
      self.$require("parser/source/map/heredoc");
      return self.$require("parser/source/map/objc_kwarg");
    })($nesting[0]);
    self.$require("parser/syntax_error");
    self.$require("parser/clobbering_error");
    self.$require("parser/diagnostic");
    self.$require("parser/diagnostic/engine");
    self.$require("parser/static_environment");
    self.$require("parser/lexer");
    self.$require("parser/lexer/literal");
    self.$require("parser/lexer/stack_state");
    self.$require("parser/lexer/dedenter");
    (function($base) {
      var self = $module($base, 'Builders');

      
      return self.$require("parser/builders/default")
    })($nesting[0]);
    self.$require("parser/context");
    self.$require("parser/max_numparam_stack");
    self.$require("parser/current_arg_stack");
    self.$require("parser/variables_stack");
    self.$require("parser/base");
    self.$require("parser/rewriter");
    return self.$require("parser/tree_rewriter");
  })($nesting[0], $nesting);
};

Opal.modules["parser/ruby31"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $return_val = Opal.return_val, $def = Opal.def, $truthy = Opal.truthy, $not = Opal.not, $hash2 = Opal.hash2, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $hash = Opal.hash, $const_set = Opal.const_set, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $eqeq = Opal.eqeq, $slice = Opal.slice;

  Opal.add_stubs('require,end_with?,[],!,include?,diagnostic,extend_static,push,cmdarg,cond,unextend,pop,children,in_dynamic_block?,declared?,static_env,=~,expression,loc,has_ordinary_params?,max_numparam_stack,dup,stack,reverse_each,>,declare,register,to_i,new,each,split,empty?,[]=,+,compstmt,<<,preexe,nil?,begin_body,state=,alias,gvar,back_ref,undef_method,condition_mod,loop_mod,rescue_body,postexe,multi_assign,assign,array,op_assign,index,call_method,const_op_assignable,const_fetch,endless_method_name,def_endless_method,local_pop,in_def=,in_def,def_endless_singleton,logical_op,not_op,command_start=,in_kwarg,in_kwarg=,match_pattern,match_pattern_p,local_push,in_argdef=,in_block=,in_block,block,keyword_cmd,multi_lhs,begin,splat,concat,assignable,index_asgn,==,attr_asgn,const_global,const,symbol_internal,range_inclusive,range_exclusive,binary_op,unary_op,match_op,in_defined=,ternary,associate,declared_forward_args?,forwarded_args,block_pass,declared_anonymous_blockarg?,begin_keyword,condition,loop,case,case_match,for,in_class=,def_class,in_class,def_sclass,def_module,def_method,def_singleton,context,in_lambda,arg,restarg,size,procarg0,args,has_ordinary_params!,set,shadowarg,extend_dynamic,in_lambda=,call_lambda,has_numparams?,numargs,top,any?,when,in_pattern,if_guard,unless_guard,match_with_trailing_comma,array_pattern,find_pattern,hash_pattern,match_as,match_alt,const_pattern,match_rest,match_pair,match_label,match_nil_pattern,accessible,match_var,ident,pin,string_compose,dedent_string,dedent_level,string,character,xstring_compose,regexp_options,regexp_compose,words_compose,word,symbols_compose,string_internal,ivar,cvar,symbol,symbol_compose,respond_to?,negate,unary_num,integer,float,rational,complex,nil,self,true,false,__FILE__,__LINE__,__ENCODING__,nth_ref,declare_forward_args,forward_arg,check_kwarg_name,kwoptarg,kwarg,kwnilarg,kwrestarg,optarg,blockarg,declare_anonymous_blockarg,pair,pair_keyword,pair_label,pair_quoted,kwsplat,yyerrok');
  
  self.$require("racc/parser.rb");
  self.$require("parser");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Ruby31');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), clist = nil, racc_action_table = nil, arr = nil, idx = nil, racc_action_check = nil, racc_action_pointer = nil, racc_action_default = nil, racc_goto_table = nil, racc_goto_check = nil, racc_goto_pointer = nil, racc_goto_default = nil, racc_reduce_table = nil, racc_reduce_n = nil, racc_shift_n = nil, racc_token_table = nil, racc_nt_base = nil, racc_use_result_var = nil, $proto = self.$$prototype;

      $proto.static_env = $proto.lexer = $proto.max_numparam_stack = $proto.context = $proto.current_arg_stack = $proto.builder = $proto.pattern_variables = $proto.pattern_hash_keys = $proto.last_token = nil;
      
      
      $def(self, '$version', $return_val(31), 0);
      
      $def(self, '$default_encoding', function $$default_encoding() {
        
        return $$$($$('Encoding'), 'UTF_8')
      }, 0);
      
      $def(self, '$endless_method_name', function $$endless_method_name(name_t) {
        var self = this;

        if (($not(["===", "==", "!=", "<=", ">="]['$include?'](name_t['$[]'](0))) && ($truthy(name_t['$[]'](0)['$end_with?']("="))))) {
          return self.$diagnostic("error", "endless_setter", nil, name_t)
        } else {
          return nil
        }
      }, 1);
      
      $def(self, '$local_push', function $$local_push() {
        var self = this;

        
        self.static_env.$extend_static();
        self.lexer.$cmdarg().$push(false);
        self.lexer.$cond().$push(false);
        return self.max_numparam_stack.$push($hash2(["static"], {"static": true}));
      }, 0);
      
      $def(self, '$local_pop', function $$local_pop() {
        var self = this;

        
        self.static_env.$unextend();
        self.lexer.$cmdarg().$pop();
        self.lexer.$cond().$pop();
        return self.max_numparam_stack.$pop();
      }, 0);
      
      $def(self, '$try_declare_numparam', function $$try_declare_numparam(node) {
        var self = this, name = nil, location = nil, raw_max_numparam_stack = nil;

        
        name = node.$children()['$[]'](0);
        if ((($truthy(name['$=~'](/^_[1-9]$/)) && ($not(self.$static_env()['$declared?'](name)))) && ($truthy(self.context['$in_dynamic_block?']())))) {
          
          location = node.$loc().$expression();
          if ($truthy(self.$max_numparam_stack()['$has_ordinary_params?']())) {
            self.$diagnostic("error", "ordinary_param_defined", nil, [nil, location])
          };
          raw_max_numparam_stack = self.$max_numparam_stack().$stack().$dup();
          raw_max_numparam_stack.$pop();
          (function(){var $brk = Opal.new_brk(); try {return $send(raw_max_numparam_stack, 'reverse_each', [], function $$1(outer_scope){var self = $$1.$$s == null ? this : $$1.$$s, outer_scope_has_numparams = nil;

            
            
            if (outer_scope == null) outer_scope = nil;;
            if ($truthy(outer_scope['$[]']("static"))) {
              
              Opal.brk(nil, $brk)
            } else {
              
              outer_scope_has_numparams = $rb_gt(outer_scope['$[]']("value"), 0);
              if ($truthy(outer_scope_has_numparams)) {
                return self.$diagnostic("error", "numparam_used_in_outer_scope", nil, [nil, location])
              } else {
                return nil
              };
            };}, {$$arity: 1, $$s: self, $$brk: $brk})
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          self.$static_env().$declare(name);
          self.$max_numparam_stack().$register(name['$[]'](1).$to_i());
          return true;
        } else {
          return false
        };
      }, 1);
      clist = ["-320,600,620,-119,1214,-121,-118,-320,-320,-320,221,222,1124,-320,-320", "-624,-320,239,620,-123,620,925,-624,-110,-320,-732,237,428,-124,311", "122,-122,430,429,717,311,-320,-320,620,-320,-320,-320,-320,-320,-116", "-117,-124,620,620,-116,1001,828,718,627,892,925,627,126,240,-732,-123", "833,125,-117,240,240,-320,-320,-320,-320,-320,-320,-320,-320,-320,-320", "-320,-320,-320,-320,-624,-123,-320,-320,-320,-124,687,-320,-119,-110", "-320,-121,-120,-320,1125,240,-720,135,-320,306,-320,-511,-320,-320,240", "-320,-320,-320,-320,-320,-320,-320,-110,-320,-112,-109,310,-320,-320", "-320,126,-120,310,-320,-320,125,-320,-320,-114,-110,-320,-320,-110,-113", "-320,-320,126,-115,126,990,-113,125,-320,125,-110,-122,-320,-320,-122", "-320,-320,-320,-320,-320,-118,126,126,-719,-107,1000,125,125,-116,-117", "-124,126,126,-116,-117,-124,125,125,-108,221,222,218,-320,-320,-320", "-320,-320,-320,-320,-320,-320,-320,-320,-320,-320,-320,221,222,-320", "-320,-320,311,687,-320,-719,-123,-320,-111,661,-320,-123,648,-119,925", "-320,-121,-320,-119,-320,-320,-121,-320,-320,-320,-320,-320,233,-320", "-723,-320,-628,-720,-629,221,222,-723,-723,-723,104,105,-723,-723,-723", "-320,-723,-120,-320,-320,-102,-320,-120,-320,-723,-723,-723,-723,-723", "663,-320,924,-88,-122,219,-112,-723,-723,522,-723,-723,-723,-723,-723", "-122,240,660,650,649,-122,-118,-111,-109,220,-744,-118,311,648,233,223", "310,-116,240,-117,1063,300,-723,-723,-723,-723,-723,-723,-723,-723,-723", "-723,-723,-723,-723,-723,233,682,-723,-723,-723,648,921,-723,106,107", "-723,104,105,-723,-723,662,-723,-124,-723,126,-723,-112,-723,-723,125", "-723,-723,-723,-723,-723,361,-723,-723,-723,-744,683,-719,-111,-109", "648,306,650,649,646,648,362,648,-723,-110,648,-723,-723,-723,-723,240", "-723,-744,-723,800,-320,-119,-112,-723,310,-112,-120,-320,-320,-320", "650,649,-320,-320,-320,892,-320,-112,-111,-109,859,-111,-109,-112,-320", "833,-320,-320,-320,875,106,107,919,-111,-109,-121,-320,-320,431,-320", "-320,-320,-320,-320,650,649,646,949,471,650,649,650,649,655,650,649", "653,920,1035,861,633,1063,233,-732,634,948,-320,-320,-320,-320,-320", "-320,-320,-320,-320,-320,-320,-320,-320,-320,240,-629,-320,-320,-320", "648,922,-320,-118,-635,-320,-119,-625,-320,-320,648,-320,-617,-320,-625", "-320,510,-320,-320,-617,-320,-320,-320,-320,-320,683,-320,682,-320,507", "506,-121,-118,-744,491,648,488,487,486,496,489,521,-320,-108,-623,-320", "-320,-320,-320,499,-320,-623,-320,126,-723,-117,612,-320,125,614,-122", "-723,-723,-723,650,649,651,-723,-723,633,-723,494,-625,960,650,649,664", "-617,-723,-723,504,503,507,506,-121,633,-119,500,523,960,-723,-723,524", "-723,-723,-723,-723,-723,239,650,649,659,491,-321,488,487,486,496,489", "-623,-321,600,491,240,488,487,486,499,489,-321,-723,-723,-723,-723,-723", "-723,-723,-723,-723,-723,-723,-723,-723,-723,558,-628,-723,-723,-723", "494,688,-723,570,126,-723,648,572,-723,125,710,507,506,-723,574,-723", "500,-723,-723,-114,-723,-723,-723,-723,-723,-614,-723,-723,-723,-321", "126,-123,-614,-614,-614,125,135,-614,-614,-614,-614,-614,-723,-107,-87", "-723,-723,-614,-723,-614,-723,-614,-614,-614,931,-116,485,-723,240,927", "-120,-614,-614,928,-614,-614,-614,-614,-614,585,650,649,646,586,-311", "227,-620,-621,227,950,951,-311,304,-620,-621,304,612,593,237,611,-311", "-614,-614,-614,-614,-614,-614,-614,-614,-614,-614,-614,-614,-614,-614", "-614,227,-614,-614,-614,227,-614,-614,592,315,-614,240,1188,-614,-614", "233,-614,590,-614,126,-614,638,-614,-614,125,-614,-614,-614,-614,-614", "-115,-614,-617,-614,-311,228,-620,-621,228,-617,-617,-617,-124,233,-617", "-617,-617,-614,-617,306,-614,-614,-614,-614,597,-614,-617,-614,-617", "-617,-617,612,-614,603,614,-614,228,264,-617,-617,228,-617,-617,-617", "-617,-617,606,227,240,227,615,-356,-619,-622,675,616,636,574,-356,-619", "-622,612,627,673,614,638,420,-356,-617,-617,-617,-617,-617,-617,-617", "-617,-617,-617,-617,-617,-617,-617,631,754,-617,-617,-617,227,-617,-617", "1149,1150,-617,499,630,-617,-617,632,-617,875,-617,640,-617,628,-617", "-617,665,-617,-617,-617,-617,-617,228,-617,228,-617,-356,-619,-622,668", "227,669,954,240,958,957,1197,1188,959,-617,-293,500,-617,-617,-617,-617", "638,-617,671,-617,672,-723,676,1056,-617,240,-109,-617,-723,-723,-723", "496,228,680,-723,-723,-320,-723,-118,956,264,499,681,-320,306,-723,-723", "694,-720,985,892,695,-320,114,113,115,116,-723,-723,240,-723,-723,-723", "-723,-723,228,221,222,697,118,117,119,261,700,507,506,263,262,701,500", "703,264,104,105,221,222,358,-723,-723,-723,-723,-723,-723,-723,-723", "-723,-723,-723,-723,-723,-723,-320,705,-723,-723,-723,-385,688,-723", "227,719,-723,720,261,-723,227,1164,263,262,-723,724,-723,226,-723,-723", "1162,-723,-723,-723,-723,-723,224,-723,-723,-723,726,102,90,93,94,732", "95,97,96,98,754,985,892,-723,91,101,-723,-723,90,-111,499,-723,85,733", "92,106,107,264,-723,264,91,-120,333,81,82,83,11,65,264,228,92,71,72", "264,240,228,75,-723,73,74,76,35,36,79,80,788,240,240,500,240,84,33,32", "114,113,115,116,-102,803,23,1056,240,606,281,282,10,53,335,12,118,117", "119,108,64,110,109,111,814,112,120,121,-320,104,105,49,50,48,-321,-320", "-723,819,-626,240,-720,-321,821,-723,-320,-626,280,279,-719,824,-321", "829,-723,45,-626,830,38,834,858,66,67,227,862,68,863,40,-294,876,602", "52,491,-723,488,487,486,558,489,520,24,558,888,892,910,102,90,93,94", "913,95,97,96,98,914,-320,240,917,91,101,240,-321,926,-723,943,-626,85", "944,92,106,107,945,962,46,47,333,81,82,83,11,65,964,300,970,71,72,972", "974,228,75,-716,73,74,76,35,36,79,80,572,574,496,814,240,84,33,32,114", "113,115,116,499,1159,23,488,487,486,306,489,10,53,335,12,118,117,119", "108,64,110,109,111,306,112,120,121,227,104,105,49,50,48,-627,519,-614", "507,506,814,264,-627,500,-614,520,892,987,988,-716,240,-627,240,-614", "45,998,240,38,-295,240,66,67,1009,1013,68,1159,40,488,487,486,52,489", "-716,-293,491,1017,488,487,486,24,489,700,718,1020,102,90,93,94,1022", "95,97,96,98,1024,228,1026,1026,91,101,240,-627,774,-614,240,240,85,1054", "92,106,107,1057,710,46,47,333,81,82,83,11,65,714,853,854,71,72,855,120", "121,75,-717,73,74,76,35,36,79,80,129,130,131,132,133,84,33,32,114,113", "115,116,925,491,23,488,487,486,972,489,10,53,335,12,118,117,119,108", "64,110,109,111,1069,112,120,121,240,104,105,49,50,48,814,491,-617,488", "487,486,1086,489,710,-617,1088,1093,1094,1099,-717,1100,1101,714,-617", "45,-296,1114,38,1115,1116,66,67,240,240,68,240,40,240,240,240,52,925", "-717,710,491,1123,488,487,486,24,489,240,714,1129,102,90,93,94,1130", "95,97,96,98,1132,700,1135,1138,91,101,1140,1142,240,-617,-385,1154,85", "1165,92,106,107,1166,710,46,47,333,81,82,83,11,65,1026,1026,1026,71", "72,1173,1186,1189,75,1194,73,74,76,35,36,79,80,256,1195,694,1115,1205", "84,33,32,114,113,115,116,1205,700,23,129,130,131,132,133,10,53,335,12", "118,117,119,108,64,110,109,111,1208,112,120,121,1210,104,105,49,50,48", "264,268,269,270,271,281,282,276,277,272,273,1212,257,258,1214,1214,274", "275,240,45,1026,255,38,1205,-720,66,67,-719,1231,68,1214,40,261,1214", "267,52,263,262,1214,259,260,280,279,265,24,266,3,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,129,130,131,132,133,84,33,32", "114,113,115,116,,,23,,,,,677,10,53,335,12,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277", "272,273,,257,258,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263", "262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,278,,-265,,,85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72", ",,,75,,73,74,76,35,36,79,80,129,130,131,132,133,84,33,32,114,113,115", "116,,,23,,,,,889,10,53,335,12,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,257", "258,,,274,275,,45,,,337,,,66,67,,,68,,40,261,,267,52,263,262,,259,260", "280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,278,,,,", "85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35", "36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,677,10,53,335,12,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269", "270,271,281,282,276,277,272,273,,257,258,,,274,275,,45,,,337,,,66,67", ",,68,,40,261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81,82", "83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,918,10,53,335,12,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273", ",257,258,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259", "260,280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,278", ",,,,85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74", "76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12", "118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268", "269,270,271,281,282,276,277,272,273,,257,258,,,274,275,,45,,,38,,,66", "67,,,68,,40,261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81", "82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,257", "258,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260", "280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,278,,,,", "85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35", "36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117", "119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269,270", "271,281,282,276,277,272,273,,257,258,,,274,275,,45,,,38,,,66,67,,,68", ",40,261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,7,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,9,12,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,257,258,,", "274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280,279", "265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,240,278,,,,,85,,92", "106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79", "80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269,270,271", "281,282,276,277,272,273,,257,258,,,274,275,,45,,,38,,,66,67,,,68,,40", "261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,", "104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,257,258", ",,274,275,,45,,,337,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280", "279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,278,,,,,85,", "92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36", "79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269,270,271", "281,282,276,277,272,273,,257,258,,,274,275,,45,,,38,,,66,67,,,68,,40", "261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,", "104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,257,258", ",,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280", "279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,278,,,,,85,", "92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36", "79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269,270,271", "281,282,276,277,272,273,,257,258,,,274,275,,45,,,38,,,66,67,,,68,,40", "261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,278,,,,,85,,92,106,107,,,46,47,333,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,", "104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,-745,-745", ",,274,275,,45,,,38,,,66,67,,264,68,,40,261,,267,52,263,262,,259,260", "280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,261,,91,101,263,262", ",259,260,,85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,", "73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,264,491,23,488,487", "486,,489,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,264,,261,,,,263,262,710,259,260,,,,,,274,275,,45,,,38,", ",66,67,,,68,,40,261,,267,52,263,262,,259,260,,,265,24,266,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,333,81,82", "83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,-745", "-745,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260", "280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85", ",92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36", "79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,268,269,270,271", "281,282,276,277,272,273,,-745,-745,,,274,275,,45,,,38,,,66,67,,,68,", "40,261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,", "95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,333,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,", "104,105,49,50,48,264,,,,,,,,,,,,,,,,274,275,,45,,,38,,,66,67,,,68,,40", "261,,267,52,263,262,,259,260,,,265,24,266,,,,102,90,93,94,,95,97,96", "98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71", "72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,", ",,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,264,268,269,270,271,281,282,276,,272,273,,,,,,274,275,,45,", ",38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280,279,265,24,266", ",,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47", "7,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,23,,,,,,10,53,9,12,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,264,268,269,270,271,281,282,,,272,273", ",,,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260", "280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85", ",92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36", "79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,-745,-745,-745", "-745,281,282,,,-745,-745,,,,,,274,275,,45,,,38,,,66,67,,,68,,40,261", ",267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95,97,96", "98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71", "72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,", ",,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,264,-745,-745,-745,-745,281,282,,,-745,-745,,,,,,274,275,,45", ",,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280,279,265,24,266", ",,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47", "333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,264,-745,-745,-745,-745,281,282,,,-745", "-745,,,,,,274,275,,45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259", "260,280,279,265,24,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,", ",85,,92,106,107,,,46,47,333,81,82,83,11,65,,,,71,72,,,,75,,73,74,76", "35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,264,-745,-745", "-745,-745,281,282,,,-745,-745,,,,,,274,275,,45,,,38,,,66,67,,,68,,40", "261,,267,52,263,262,,259,260,280,279,265,24,266,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,333,81,82,83,11,65", ",,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,", ",23,,,,,,10,53,335,12,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,264,-745,-745,-745,-745,281,282,,,-745,-745,,,,,,274,275", ",45,,,38,,,66,67,,,68,,40,261,,267,52,263,262,,259,260,280,279,265,24", "266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106", "107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113", "115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121", ",104,105,49,50,48,264,-745,-745,-745,-745,281,282,,,-745,-745,,,,,,274", "275,,245,,,253,,,66,67,,,68,,,261,,267,52,263,262,,259,260,280,279,265", "250,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,264,268,269,270,271,281,282,276,277,272,273,,-745", "-745,,,274,275,,245,,,253,,,66,67,,,68,,,261,,267,52,263,262,,259,260", "280,279,265,250,266,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84", "349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,264,,,,,,,,,,,,,,,,274,275,,245,", ",253,,,66,67,,,68,,,261,,267,52,263,262,,259,260,,,,250,,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47", ",75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,", ",,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,264,,,,,,,,,,,,,,,,274,275,,245,,,253,,,66,67,,,68,,,261,,,52,263", "262,,259,260,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84", "349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,264,,,,,,,,,,,,,,,,274,275,,245,", ",253,,,66,67,,,68,,,261,,267,52,263,262,,259,260,,,,250,,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,,12,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38,,,66,67,,,68,,40,,,,52,,,,,", ",,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,", ",,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79", "80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108", "64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98", ",,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,", "53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,", ",,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,", "254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,436,,,,52,,,,,,", ",,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,", ",,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79", "80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,", ",,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35", "36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,,,,85,,92,106,107,-441,,46,47,,,,-441,-441,-441", ",,-441,-441,-441,,-441,,,,,,,,-441,-441,-441,-441,,,,,,,,,-441,-441", ",-441,-441,-441,-441,-441,,,,,,,,,,,,,,,,,,,,,,,-441,-441,-441,-441", "-441,-441,-441,-441,-441,-441,-441,-441,-441,-441,,,-441,-441,-441,", ",-441,,306,-441,,,-441,-441,,-441,,-441,,-441,,-441,-441,,-441,-441", "-441,-441,-441,,-441,-441,-441,,,,,,,,,,,,,,-441,,,-441,-441,,-441,", "-441,81,82,83,,65,,-441,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33", "32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,", "112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,", ",68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,", "81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,", ",84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66", "67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,,118,117", "119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,", ",,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73", "74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,", ",118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,", ",,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,-327,,46,47,,,,-327", "-327,-327,,,-327,-327,-327,,-327,,,,,,,,-327,,-327,-327,,,,,,,,,-327", "-327,,-327,-327,-327,-327,-327,,,,,,,,,,,,,,,,,,,,,,,-327,-327,-327", "-327,-327,-327,-327,-327,-327,-327,-327,-327,-327,-327,,,-327,-327,-327", ",,-327,,315,-327,,,-327,-327,,-327,,-327,,-327,,-327,-327,,-327,-327", "-327,-327,-327,,-327,,-327,,,,,,,,,,,,,,-327,,,-327,-327,,-327,,-327", "81,82,83,,65,,-327,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327", "112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,", ",68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,", "91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355", "79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108", "64,110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,", "245,,,253,,,66,67,,,68,,797,,322,,52,,,328,,,,,,250,,,,,102,325,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,", "53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,", ",,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,81,82", "83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,,10,53,,12,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38,,,66,67,,,68,,40,,", ",52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33", "32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327", "112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,", ",68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,", "91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36", "79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108", "64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98", ",,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,797,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73", "74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,", ",118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,", ",,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,867,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,81,82", "83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,,10,53,,12,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38,,,66,67,,,68,,40,,", ",52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327", "112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,", ",68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,", "91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355", "79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108", "64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98", ",,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35", "36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,", ",,,,245,,,253,,,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,", ",,,53,,,118,117,119,108,64,110,109,111,327,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,324,,322,,52,,,328,,,", ",,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,", ",,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96", "98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76", "354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117", "119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,", ",,,,,245,,,253,,,66,67,,,68,,324,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,", "118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,", ",,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47", ",75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,", ",,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121,,104,105,49", "50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,328,,,,,,250", ",,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121", ",104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,797,,,", "52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33", "32,114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,240,,,81", "82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,", "84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66", "67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,", ",,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,", "118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,", ",,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47", ",75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,", "53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,", ",,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121,,104,105,49", "50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,324,,322,,52,,,328", ",,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106", "107,,,46,47,81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,", ",84,33,32,114,113,115,116,,,23,,,,,,10,53,335,12,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38", ",,66,67,,,68,,40,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,", "91,101,,,,,,420,85,,92,106,107,,,46,47,81,82,83,,65,,,,71,72,,,,75,", "73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53", ",,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,", ",,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,", ",102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116", ",,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121", ",104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,322,", "52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84", "349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,", ",66,67,,,68,,797,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96", "98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76", "354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117", "119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,", ",,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73", "74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,", ",118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,", ",,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,", ",102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,-275,,46", "47,,,,-275,-275,-275,,,-275,-275,-275,491,-275,488,487,486,496,489,", ",-275,-275,-275,,,,499,,,,,,-275,-275,,-275,-275,-275,-275,-275,,491", ",488,487,486,496,489,494,,,,,,,,499,504,503,507,506,,,,500,,491,,488", "487,486,496,489,-275,,,,,494,,-275,499,,,,306,-275,504,503,507,506,", ",,500,,,,,,,,,494,485,,,,-275,-275,,,,,507,506,,,,500,,,,-275,,,-275", ",81,82,83,-275,65,,485,,71,72,-275,,,75,,73,74,76,354,355,79,80,,,,", ",84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79", "80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95", "97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73", "74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,", "53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,", ",,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,", ",,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,", "102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,", "102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,", "102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116", ",,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121", ",104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52", ",,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33", "32,114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84", "349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66", "67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,", ",,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,", ",,,,245,,,253,,,66,67,,,68,,324,,,,52,,,328,,,,,,250,,,,,102,325,93", "94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47,81,82,83,11", "65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,10,53,,12,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38,,,66,67,,,68,,40,,,,52,,,,,", ",,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113", "115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121", ",104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52", ",,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65", "92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,", ",,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66", "67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,", ",,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,", ",,,,245,,,253,,,66,67,,,68,,797,,322,,52,,,328,,,,,,250,,,,,102,325", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "560,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,", ",102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,", ",102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121,,104,105,49", "50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,324,,322,,52,,,328", ",,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65", "92,106,107,71,72,46,560,,75,,73,74,76,354,355,79,80,,,,,,84,349,357", "114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84", "349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109", "111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66", "67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,", ",,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96", "98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76", "35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,", ",,,,245,,,253,,,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325", "93,94,,95,97,96,98,,,,,91,101,240,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,", "254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,", ",,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,", ",,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79", "80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108", "64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245", ",,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98", ",,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,", "53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,", ",,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,", "254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104", "105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,", ",,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92", "106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,", ",,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,,,,,,,85,,92,106,107,,,46,47,81,82,83,11,65,,,,71,72,,,,75,,73,74", "76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,10,53,,12,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,45,,,38,,,66,67,,,68,,40,,,,52,,,,,,,,,24,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75", ",73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,", "118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,", ",,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47", ",75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53", ",,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,", ",,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,", ",,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48", ",,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", "46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,", ",,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,", "102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,", "102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116", ",,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,46,47", "81,82,83,11,65,,,,71,72,,,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114", "113,115,116,,,23,,,,,,10,53,9,12,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,45,,,38,,,66,67,,,68,,40", ",,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,420,85", ",92,106,107,,,46,47,81,82,83,,65,,,,71,72,,,,75,,73,74,76,35,36,79,80", ",,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110", "109,111,327,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253", ",,66,67,,,68,,324,,322,,52,,,328,,,,,,250,,,,,102,325,93,94,,95,97,96", "98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76", "35,36,79,80,,,,,,84,33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118", "117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,", ",,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94", ",95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,-725,,46,47,,,,-725,-725", "-725,,,-725,-725,-725,,-725,,,,,,,,-725,-725,-725,-725,-725,,,,,,,,-725", "-725,,-725,-725,-725,-725,-725,,,,,,,,,,,,,,,,,,,,,,,-725,-725,-725", "-725,-725,-725,-725,-725,-725,-725,-725,-725,-725,-725,,,-725,-725,-725", ",,-725,,,-725,,,-725,-725,,-725,,-725,,-725,,-725,-725,,-725,-725,-725", "-725,-725,,-725,-725,-725,,,,,,,,,,,,,,-725,,,-725,-725,-725,-725,,-725", "-724,-725,,,,,-725,-724,-724,-724,,,-724,-724,-724,,-724,,,,,,,,-724", "-724,-724,-724,-724,,,,114,113,115,116,-724,-724,,-724,-724,-724,-724", "-724,,,,,118,117,119,,,,,,,,,,,104,105,,,358,-724,-724,-724,-724,-724", "-724,-724,-724,-724,-724,-724,-724,-724,-724,,,-724,-724,-724,,,-724", ",,-724,,,-724,-724,,-724,,-724,,-724,,-724,-724,,-724,-724,-724,-724", "-724,,-724,-724,-724,,102,90,93,94,,95,97,96,98,,,,-724,91,101,-724", "-724,-724,-724,,-724,85,-724,92,106,107,-275,-724,81,82,83,11,65,-275", "-275,-275,71,72,-275,-275,-275,75,-275,73,74,76,35,36,79,80,-275,-275", "-275,-275,,84,33,32,114,113,115,116,-275,-275,23,-275,-275,-275,-275", "-275,10,53,9,12,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,-275,-275,-275,-275,-275,-275,-275,-275,-275,-275,-275,-275", "-275,-275,,,-275,-275,-275,45,,-275,38,306,-275,66,67,-275,-275,68,-275", "40,-275,,-275,52,-275,-275,,-275,-275,-275,-275,-275,24,-275,-275,-275", ",102,90,93,94,,95,97,96,98,,,,-275,91,101,-275,-275,,-275,,-275,85,", "92,106,107,,-275,46,47,81,82,83,,65,,,,71,72,,,,75,,73,74,76,35,36,79", "80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,", ",,91,101,126,,,,,125,85,,92,106,107,-312,,46,47,,,,-312,-312,-312,,", "-312,-312,-312,,-312,,,,,,,,-312,,-312,-312,-312,,,,,,,,-312,-312,,-312", "-312,-312,-312,-312,,,,,,,,,,,,,,,,,,,,,,,-312,-312,-312,-312,-312,-312", "-312,-312,-312,-312,-312,-312,-312,-312,,,-312,-312,-312,,,-312,,,-312", ",,-312,-312,,-312,,-312,,-312,,-312,-312,,-312,-312,-312,-312,-312,", "-312,,-312,,,,,,,,,,,,,,-312,,,-312,-312,-312,-312,,-312,,-312,,81,82", "83,-312,65,,,,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,", ",52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,23,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33", "32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,", "112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,", ",68,,436,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,", "253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,", ",,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354", "355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,,,118,117,119", "108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,", ",245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74", "76,35,36,79,80,,,,,,84,33,32,114,113,115,116,,,23,,,,,,,53,,,118,117", "119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,", ",,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,24,,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46,47,,75,,73", "74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254,,,,,,,53,", ",118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50,48,,,,,", ",,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72,46", "47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254", ",,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,49,50", "48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250,,,", ",102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71", "72,46,47,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116", ",,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", "49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,,,,,52,,,,,,,,,250", ",,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107", "71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32,114,113,115,116", ",,254,,,,,,,53,,,118,117,119,108,64,110,109,111,327,112,120,121,,104", "105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68,,324,,322,,52", ",,328,,,,,,250,,,,,102,325,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84,33,32", "114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67,,,68", ",436,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81", "82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,35,36,79,80,,,,,,84", "33,32,114,113,115,116,,,254,,,,,,,53,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,49,50,48,,,,,,,,,,,,,,,,,,,,245,,,253,,,66,67", ",,68,,,,,,52,,,,,,,,,250,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,", ",81,82,83,85,65,92,106,107,71,72,46,47,,75,,73,74,76,354,355,79,80,", ",,,,84,349,357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,1107,,,253", ",,66,67,,,68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,", ",,84,349,357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,1146,,,253,,", "66,67,,,68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,", ",,81,82,83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,", ",84,349,357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,253,,,66", "67,,,68,,,491,,488,487,486,496,489,,,,,,,,,499,,102,90,93,94,,95,97", "96,98,,,,,91,101,,,,588,,494,85,,92,106,107,81,82,83,,65,507,506,,71", "72,500,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116", ",,254,,,,,,,350,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105", ",,358,,,,,,,,,,,,,,,,,,,,346,,,342,,,66,67,,,68,,,,,,,,,,,,,,,,,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106,107,71,72", ",,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115,116,,,254", ",,,,,,350,,,118,117,119,108,64,110,109,111,,112,120,121,,104,105,,,358", ",,,,,,,,,,,,,,,,,,,346,,,253,,,66,67,,,68,,,491,,488,487,486,496,489", ",,,,,,,,499,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,360,,494,85,,92", "106,107,81,82,83,,65,507,506,,71,72,500,,,75,,73,74,76,354,355,79,80", ",,,,,84,349,357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64", "110,109,111,,112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,342", ",,66,67,,,68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101", ",,,81,82,83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,", ",,84,349,357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110", "109,111,,112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,342,,,66", "67,,,68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81", "82,83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,1146,,,253,,,66,67,,", "68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,400,64,110,109,401", ",112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,407,,,402,,,253,,,66,67", ",,68,,,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82", "83,85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349", "357,114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110,109,111", ",112,120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,342,,,66,67,,,68", ",,,,,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83", "85,65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357", "114,113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110,109,111,,112", "120,121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,342,,,66,67,,,68,,,", ",,,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85", "65,92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114", "113,115,116,,,254,,,,,,,350,,,118,117,119,108,64,110,109,111,,112,120", "121,,104,105,,,358,,,,,,,,,,,,,,,,,,,,346,,,342,,,66,67,,,68,,341,,", ",,,,,,,,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65", "92,106,107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113", "115,116,,,254,,,,,,,350,,,118,117,119,108,64,110,109,111,,112,120,121", ",104,105,,,358,,,,,,,,,,,,,,,,,,,,395,,,38,,,66,67,,,68,,40,,,,,,,,", ",,,,,,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,81,82,83,85,65,92,106", "107,71,72,,,,75,,73,74,76,354,355,79,80,,,,,,84,349,357,114,113,115", "116,,,254,,,,,,,350,,,118,117,119,400,64,110,109,401,,112,120,121,,104", "105,,,358,,,,,,,,,,,,,,,,,,,,402,,,253,,,66,67,,,68,,,,,,,,,,,,,,,,", ",,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107,185,196", "186,209,182,202,192,191,212,213,207,190,189,184,210,214,215,194,183", "197,201,203,195,188,,,,204,211,206,205,198,208,193,181,200,199,,,,,", "180,187,178,179,175,176,177,138,140,137,,139,,,,,,,,169,170,,166,148", "149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,,,,,,,,,163,162", ",147,168,165,164,173,160,161,155,153,145,167,146,,,174,102,,,,,,,,,", ",,,,101,185,196,186,209,182,202,192,191,212,213,207,190,189,184,210", "214,215,194,183,197,201,203,195,188,,,,204,211,206,205,198,208,193,181", "200,199,,,,,,180,187,178,179,175,176,177,138,140,,,139,,,,,,,,169,170", ",166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,,,,,", ",,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146,,,174,102", ",,,,,,,,,,,,,101,185,196,186,209,182,202,192,191,212,213,207,190,189", "184,210,214,215,194,183,197,201,203,195,188,,,,204,211,206,205,198,208", "193,181,200,199,,,,,,180,187,178,179,175,176,177,138,140,,,139,,,,,", ",,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159", ",,,,,,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146", ",,174,102,,,,,,,,,,,,,,101,185,196,186,209,182,202,192,191,212,213,207", "190,189,184,210,214,215,194,183,197,201,203,195,188,,,,204,211,206,205", "198,208,193,181,200,199,,,,,,180,187,178,179,175,176,177,138,140,,,139", ",,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172,158", "159,,,,,,,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167", "146,,,174,102,,,,,,,,,,,,,,101,185,196,186,209,182,202,192,191,212,213", "207,190,189,184,210,214,215,194,183,197,201,203,195,188,,,,204,211,206", "294,293,295,292,181,200,199,,,,,,180,187,178,179,289,290,291,287,140", "110,109,288,,112,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152", ",,,171,172,158,159,,,,,,299,,,,,,,,163,162,,147,168,165,164,173,160", "161,155,153,145,167,146,,,174,114,113,115,116,,,,,,491,,488,487,486", "496,489,118,117,119,774,,,,777,499,,,,,104,105,,,358,,,,,,,,,,,,,494", ",,,,,,776,,,747,507,506,,745,,500,746,,,,,,,,,,,,,,,,775,,,,102,90,93", "94,,95,97,96,98,,,,,91,101,114,113,115,116,485,,85,,92,106,107,,,762", "763,,118,117,119,774,,,491,777,488,487,486,496,489,104,105,,,358,,,", "499,,,,,,,,,,,,,,,,776,,,747,,,494,745,,,746,,,,,504,503,507,506,,,", "500,,,,775,,,,102,90,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,", ",85,,92,106,107,,,762,763,,118,117,119,774,,,491,777,488,487,486,496", "489,104,105,,,358,,,,499,,,,,,,,,,,,,,,,776,,,747,,,494,745,,,746,,749", ",,504,503,507,506,,,,500,,,,775,,,,102,90,93,94,,95,97,96,98,,,,,91", "101,114,113,115,116,,,85,,92,106,107,,,762,763,,118,117,119,774,,,,777", "754,,,,,104,105,,,358,499,,,,,,,,,,,,,,,,,,,776,,,747,,,,745,,,746,", "749,,,,,,,500,,,,,,,775,,,,102,755,93,94,,95,97,96,98,,,,,91,101,114", "113,115,116,,,85,,92,106,107,,,762,763,,118,117,119,774,,,491,777,488", "487,486,496,489,104,105,,,358,,,,499,,,,,,,,,,,,,,,,776,,,747,,,494", "745,,,746,,,,,504,503,507,506,,,,500,,,,775,,,,102,90,93,94,,95,97,96", "98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,,762,763,,118,117,119", "774,,,491,777,488,487,486,496,489,104,105,,,358,,,,499,,,,,,,,,,,,,", ",,776,,,747,,,494,745,,,746,,749,,,,,507,506,,,,500,,,,775,,,,102,90", "93,94,,95,97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,,762", "763,,118,117,119,774,,,,777,,,,,,104,105,,,358,,,,,,,,,,,,,,,,,,,,776", ",,747,,,,745,,,746,,749,,,,,,,491,,488,487,486,496,489,775,,,,102,90", "93,94,499,95,97,96,98,,,,,91,101,240,114,113,115,116,,85,,92,106,107", "494,,762,763,,,118,117,119,774,,507,506,777,,,500,,,104,105,,,358,,", ",,,,,,,,,,,,,,,,,776,,,747,,,,745,,,746,,,485,,,,,,,,,,,,,775,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,", "762,763,,118,117,119,774,,,,777,754,,,,,104,105,,,358,499,,,,,,,,,,", ",,,,,,,,776,,,747,,,,745,,,746,,749,,,,,,,500,,,,,,,775,,,,102,755,93", "94,,95,97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,,762,763", ",118,117,119,774,,,,777,754,,,,,104,105,,,358,499,,,,,,,,,,,,,,,,,,", "776,,,747,,,,745,,,746,,749,,,,,,,500,,,,,,,775,,,,102,755,93,94,,95", "97,96,98,,,,,91,101,,,,,,,85,,92,106,107,,,762,763,185,196,186,209,182", "202,192,191,212,213,207,190,189,184,210,214,215,194,183,197,201,203", "195,188,,,,204,211,206,205,198,208,193,181,200,199,,,,,,180,187,178", "179,175,176,177,138,140,,,139,,,,,,,,169,170,,166,148,149,150,157,154", "156,,,151,152,,,,171,172,158,159,,,,,,,,,,,,,,163,162,,147,168,165,164", "173,160,161,155,153,145,167,146,,,174,114,113,115,116,,,491,,488,487", "486,496,489,,,,118,117,119,774,,499,,777,754,,,,,104,105,,,358,499,", ",,,,,,,494,,,,,,,,,,776,507,506,747,,,500,745,,,746,,749,,,,,,,500,", ",,,,,775,,,,102,755,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,,", "85,,92,106,107,,,762,763,,118,117,119,774,,,,777,754,,,,,104,105,,,358", "499,,,,,,,,,,,,,,,,,,,776,,,747,,,,745,,,746,,749,,,,,,,500,,,,,,,775", ",,,102,755,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106", "107,,,762,763,,118,117,119,774,,,,777,,,,,,104,105,,,358,,,,,,,,,,,", ",,,,,,,,776,,,747,,,,745,,,746,,,,,,,,,,,,,,,,775,,,,102,90,93,94,,95", "97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,,762,763,,118", "117,119,774,,,,777,,,,,,104,105,,,358,,,,,,,,,,,,,,,,,,,,776,,,747,", ",,745,,,746,,,,,,,,,,,,,,,,775,,,,102,90,93,94,,95,97,96,98,,,,,91,101", "114,113,115,116,,,85,,92,106,107,,,762,763,,118,117,119,774,,,,777,", ",,,,104,105,,,358,,,,,,,,,,,,,,,,,,,,776,,,747,,,,745,,,746,,,,,,,,", ",,,,,,,775,,,,102,90,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,", ",85,,92,106,107,,,762,763,,118,117,119,774,,,,777,,,,,,104,105,,,358", ",,,,,,,,,,,,,,,,,,,776,,,747,,,,745,,,746,,,,,,,,,,,,,,,,775,,,,102", "90,93,94,,95,97,96,98,,,,,91,101,114,113,115,116,,,85,,92,106,107,,", "762,763,,118,117,119,774,,,,777,,,,,,104,105,,,358,,,,,,,,114,113,115", "116,,,,,,,,,776,,,747,118,117,119,745,,,746,,1053,,,,,104,105,,,358", ",,,,775,,,,102,90,93,94,,95,97,96,98,,,,,91,101,,,,,,,85,,92,106,107", ",,762,763,491,,488,487,486,496,489,,,,,102,90,93,94,499,95,97,96,98", ",,,,91,101,114,113,115,116,,,85,,92,106,107,494,,,,,118,117,119,,504", "503,507,506,,,,500,,104,105,,,358,,,,,,,,,,,,491,,488,487,486,496,489", ",,,,,,,,499,,,,,,491,485,488,487,486,496,489,,,,,,,,,499,494,102,90", "93,94,,95,97,96,98,,507,506,,91,101,500,,,,,494,85,,92,106,107,,,,504", "503,507,506,,,491,500,488,487,486,496,489,,491,,488,487,486,496,489", "499,,,,,485,,,499,,491,,488,487,486,496,489,,,,,,494,644,,499,485,,", ",494,504,503,507,506,,,,500,504,503,507,506,,,,500,494,,,,,,,,,504,503", "507,506,,,491,500,488,487,486,496,489,,,,,,,,,499,485,,,,,,,,485,,,", ",,,,,,,,,494,,,,485,,,,,,,507,506,872,469,,500,871,,,,,,,,169,170,,166", "148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,485", ",,163,162,,147,168,165,164,173,160,161,155,153,145,167,146,842,469,174", ",843,,,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172", "158,159,,,,,,306,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153", "145,167,146,837,462,174,,838,,,,,,,,169,170,,166,148,149,150,157,154", "156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147,168,165", "164,173,160,161,155,153,145,167,146,465,469,174,,464,,,,,,,,169,170", ",166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,", ",,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146,729,469", "174,,730,,,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171", "172,158,159,,,,,,306,,,,,,,,163,162,,147,168,165,164,173,160,161,155", "153,145,167,146,556,462,174,,557,,,,,,,,169,170,,166,148,149,150,157", "154,156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147,168", "165,164,173,160,161,155,153,145,167,146,458,462,174,,459,,,,,,,,169", "170,,166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306", ",,,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146,556", "462,174,,557,,,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,", ",,171,172,158,159,,,,,,,,,,,,,,163,162,,147,168,165,164,173,160,161", "155,153,145,167,146,729,469,174,,730,,,,,,,,169,170,,166,148,149,150", "157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147", "168,165,164,173,160,161,155,153,145,167,146,727,462,174,,728,,,,,,,", "169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,", ",,,306,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146", "807,462,174,,808,,,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152", ",,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147,168,165,164,173,160", "161,155,153,145,167,146,810,469,174,,811,,,,,,,,169,170,,166,148,149", "150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162", ",147,168,165,164,173,160,161,155,153,145,167,146,1200,462,174,,1201", ",,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172,158", "159,,,,,,306,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153,145", "167,146,869,462,174,,870,,,,,,,,169,170,,166,148,149,150,157,154,156", ",,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147,168,165,164", "173,160,161,155,153,145,167,146,1202,469,174,,1203,,,,,,,,169,170,,166", "148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,", ",163,162,,147,168,165,164,173,160,161,155,153,145,167,146,839,469,174", ",840,,,,,,,,169,170,,166,148,149,150,157,154,156,,,151,152,,,,171,172", "158,159,,,,,,306,,,,,,,,163,162,,147,168,165,164,173,160,161,155,153", "145,167,146,1218,469,174,,1217,,,,,,,,169,170,,166,148,149,150,157,154", "156,,,151,152,,,,171,172,158,159,,,,,,306,,,,,,,,163,162,,147,168,165", "164,173,160,161,155,153,145,167,146,727,462,174,,728,,,,,,,,169,170", ",166,148,149,150,157,154,156,,,151,152,,,,171,172,158,159,,,,,,306,", ",,,,,,163,162,,147,168,165,164,173,160,161,155,153,145,167,146,,,174"];
      racc_action_table = (arr = $$$('Array').$new(28717, nil));
      idx = 0;
      $send(clist, 'each', [], function $Ruby31$2(str){
        
        
        if (str == null) str = nil;;
        return $send(str.$split(",", -1), 'each', [], function $$3(i){
          
          
          if (i == null) i = nil;;
          if (!$truthy(i['$empty?']())) {
            arr['$[]='](idx, i.$to_i())
          };
          return (idx = $rb_plus(idx, 1));}, 1);}, 1);
      clist = ["464,521,1016,837,1236,838,992,464,464,464,515,515,1053,464,464,289,464", "23,835,631,1087,1058,289,807,464,927,443,137,396,785,3,840,137,137,501", "31,464,464,1089,464,464,464,464,464,1104,1105,1108,384,385,392,850,622", "501,625,1092,932,1092,331,23,928,521,625,331,393,1058,927,464,464,464", "464,464,464,464,464,464,464,464,464,464,464,289,1165,464,464,464,443", "464,464,1200,807,464,1201,839,464,1053,928,840,9,464,31,464,932,464", "464,515,464,464,464,464,464,871,464,837,464,838,992,785,871,871,871", "1016,1202,31,871,871,1016,871,464,631,807,464,464,807,464,871,464,835", "396,1087,835,840,835,464,1087,807,464,871,871,1203,871,871,871,871,871", "1222,622,1089,839,392,850,622,1089,1104,1105,1108,384,385,1104,1105", "1108,384,385,393,981,981,12,871,871,871,871,871,871,871,871,871,871", "871,871,871,871,553,553,871,871,871,69,871,871,1202,1165,871,839,416", "871,1165,1127,1200,735,871,1201,871,1200,871,871,1201,871,871,871,871", "871,251,871,729,871,243,1203,244,641,641,729,729,729,358,358,729,729", "729,871,729,1202,871,871,802,871,1202,871,729,729,729,729,729,417,871", "735,802,871,14,808,729,729,246,729,729,729,729,729,1203,981,416,1127", "1127,1203,1222,810,979,15,251,1222,351,576,252,17,69,243,553,244,1127", "27,729,729,729,729,729,729,729,729,729,729,729,729,729,729,20,458,729", "729,729,656,729,729,358,358,729,48,48,729,729,417,729,246,729,641,729", "808,729,729,641,729,729,729,729,729,42,729,729,729,252,459,810,810,979", "947,351,576,576,576,658,45,414,729,458,413,729,729,729,729,53,729,20", "729,576,730,458,808,729,351,808,729,730,730,730,656,656,730,730,730", "1220,730,808,810,979,656,810,979,459,730,1220,730,730,730,1006,48,48", "727,810,979,459,730,730,216,730,730,730,730,730,947,947,947,756,229", "658,658,414,414,414,413,413,413,728,923,658,402,947,19,746,402,756,730", "730,730,730,730,730,730,730,730,730,730,730,730,730,746,44,730,730,730", "412,730,730,1006,231,730,727,291,730,730,418,730,288,730,291,730,235", "730,730,288,730,730,730,730,730,870,730,869,730,700,700,728,923,19,972", "415,972,972,972,972,972,245,730,44,290,730,730,730,730,972,730,290,730", "996,872,44,822,730,996,822,730,872,872,872,412,412,412,872,872,776,872", "972,291,776,418,418,418,288,872,872,972,972,972,972,870,931,869,972", "247,931,872,872,248,872,872,872,872,872,254,415,415,415,1022,634,1022", "1022,1022,1022,1022,290,634,362,914,972,914,914,914,1022,914,634,872", "872,872,872,872,872,872,872,872,872,872,872,872,872,305,43,872,872,872", "1022,872,872,319,389,872,411,320,872,389,914,1022,1022,872,323,872,1022", "872,872,362,872,872,872,872,872,108,872,872,872,634,5,362,108,108,108", "5,335,108,108,108,287,108,872,43,336,872,872,287,872,108,872,108,108", "108,744,43,1022,872,338,744,872,108,108,744,108,108,108,108,108,339", "411,411,411,340,347,286,294,295,29,759,759,347,286,294,295,29,376,346", "21,376,347,108,108,108,108,108,108,108,108,108,108,108,108,108,108,287", "345,108,108,108,1187,108,108,345,349,108,350,1187,108,108,352,108,345", "108,509,108,1187,108,108,509,108,108,108,108,108,21,108,111,108,347", "286,294,295,29,111,111,111,21,353,111,111,111,108,111,357,108,108,108", "108,359,108,111,108,111,111,111,377,108,366,377,108,345,368,111,111", "1187,111,111,111,111,111,371,442,374,404,378,54,293,292,442,379,404", "381,54,293,292,380,390,442,380,404,391,54,111,111,111,111,111,111,111", "111,111,111,111,111,111,111,395,939,111,111,111,394,111,111,1090,1090", "111,939,394,111,111,397,111,678,111,406,111,394,111,111,426,111,111", "111,111,111,442,111,404,111,54,293,292,432,1145,434,775,1157,775,775", "1157,1145,775,111,435,939,111,111,111,111,1145,111,437,111,440,465,444", "939,111,454,678,111,465,465,465,1132,394,456,465,465,811,465,678,775", "531,1132,457,811,466,465,465,472,811,823,823,473,811,762,762,762,762", "465,465,476,465,465,465,465,465,1145,383,383,477,762,762,762,531,478", "1132,1132,531,531,481,1132,482,532,762,762,16,16,762,465,465,465,465", "465,465,465,465,465,465,465,465,465,465,811,483,465,465,465,493,465", "465,1106,505,465,508,532,465,18,1106,532,532,465,511,465,18,465,465", "1106,465,465,465,465,465,18,465,465,465,517,762,762,762,762,525,762", "762,762,762,945,1190,1190,465,762,762,465,465,88,465,945,465,762,526", "762,762,762,533,465,534,88,465,387,387,387,387,387,387,535,1106,88,387", "387,536,561,18,387,842,387,387,387,387,387,387,387,562,563,567,945,583", "387,387,387,387,387,387,387,584,587,387,945,589,594,51,51,387,387,387", "387,387,387,387,387,387,387,387,387,598,387,387,387,843,387,387,387", "387,387,593,843,842,607,343,608,843,593,609,842,843,343,51,51,842,619", "593,623,842,387,343,624,387,626,653,387,387,363,661,387,663,387,670", "679,363,387,714,842,714,714,714,684,714,363,387,689,691,693,707,387", "387,387,387,712,387,387,387,387,713,843,715,722,387,387,731,593,740", "842,748,343,387,749,387,387,387,750,779,387,387,841,841,841,841,841", "841,782,784,790,841,841,791,792,363,841,400,841,841,841,841,841,841", "841,794,796,697,804,806,841,841,841,841,841,841,841,697,1099,841,1099", "1099,1099,809,1099,841,841,841,841,841,841,841,841,841,841,841,841,812", "841,841,841,242,841,841,841,841,841,344,242,400,697,697,813,816,344", "697,400,242,825,831,832,400,836,344,845,400,841,849,851,841,866,868", "841,841,877,890,841,1197,841,1197,1197,1197,841,1197,400,893,913,894", "913,913,913,841,913,897,899,902,841,841,841,841,903,841,841,841,841", "905,242,906,908,841,841,912,344,925,400,933,934,841,938,841,841,841", "941,913,841,841,236,236,236,236,236,236,913,649,649,236,236,649,649", "649,236,401,236,236,236,236,236,236,236,8,8,8,8,8,236,236,236,236,236", "236,236,946,494,236,494,494,494,965,494,236,236,236,236,236,236,236", "236,236,236,236,236,968,236,236,236,969,236,236,236,236,236,978,710", "401,710,710,710,983,710,494,401,986,993,995,1002,401,1003,1004,494,401", "236,1005,1031,236,1032,1037,236,236,1042,1043,236,1044,236,1045,1046", "1047,236,1051,401,710,1114,1052,1114,1114,1114,236,1114,1055,710,1059", "236,236,236,236,1066,236,236,236,236,1071,1072,1074,1075,236,236,1076", "1078,1079,401,1080,1096,236,1107,236,236,236,1110,1114,236,236,1103", "1103,1103,1103,1103,1103,1111,1112,1113,1103,1103,1124,1143,1146,1103", "1155,1103,1103,1103,1103,1103,1103,1103,25,1156,1161,1171,1172,1103", "1103,1103,1103,1103,1103,1103,1174,1177,1103,581,581,581,581,581,1103", "1103,1103,1103,1103,1103,1103,1103,1103,1103,1103,1103,1180,1103,1103", "1103,1181,1103,1103,1103,1103,1103,25,25,25,25,25,25,25,25,25,25,25", "1182,25,25,1183,1185,25,25,1199,1103,1204,25,1103,1206,1217,1103,1103", "1218,1224,1103,1225,1103,25,1226,25,1103,25,25,1227,25,25,25,25,25,1103", "25,1,,,1103,1103,1103,1103,,1103,1103,1103,1103,,,,,1103,1103,,25,,", ",,1103,,1103,1103,1103,,,1103,1103,997,997,997,997,997,997,,,,997,997", ",,,997,,997,997,997,997,997,997,997,373,373,373,373,373,997,997,997", "997,997,997,997,,,997,,,,,447,997,997,997,997,997,997,997,997,997,997", "997,997,,997,997,997,,997,997,997,997,997,447,447,447,447,447,447,447", "447,447,447,447,,447,447,,,447,447,,997,,,997,,,997,997,,,997,,997,447", ",447,997,447,447,,447,447,447,447,447,997,447,,,,997,997,997,997,,997", "997,997,997,,,,,997,997,,447,,447,,,997,,997,997,997,,,997,997,337,337", "337,337,337,337,,,,337,337,,,,337,,337,337,337,337,337,337,337,334,334", "334,334,334,337,337,337,337,337,337,337,,,337,,,,,692,337,337,337,337", "337,337,337,337,337,337,337,337,,337,337,337,,337,337,337,337,337,692", "692,692,692,692,692,692,692,692,692,692,,692,692,,,692,692,,337,,,337", ",,337,337,,,337,,337,692,,692,337,692,692,,692,692,692,692,692,337,692", ",,,337,337,337,337,,337,337,337,337,,,,,337,337,,692,,,,,337,,337,337", "337,,,337,337,38,38,38,38,38,38,,,,38,38,,,,38,,38,38,38,38,38,38,38", ",,,,,38,38,38,38,38,38,38,,,38,,,,,453,38,38,38,38,38,38,38,38,38,38", "38,38,,38,38,38,,38,38,38,38,38,453,453,453,453,453,453,453,453,453", "453,453,,453,453,,,453,453,,38,,,38,,,38,38,,,38,,38,453,,453,38,453", "453,,453,453,453,453,453,38,453,,,,38,38,38,38,,38,38,38,38,,,,,38,38", ",453,,,,,38,,38,38,38,,,38,38,642,642,642,642,642,642,,,,642,642,,,", "642,,642,642,642,642,642,642,642,,,,,,642,642,642,642,642,642,642,,", "642,,,,,723,642,642,642,642,642,642,642,642,642,642,642,642,,642,642", "642,,642,642,642,642,642,723,723,723,723,723,723,723,723,723,723,723", ",723,723,,,723,723,,642,,,642,,,642,642,,,642,,642,723,,723,642,723", "723,,723,723,723,723,723,642,723,,,,642,642,642,642,,642,642,642,642", ",,,,642,642,,723,,,,,642,,642,642,642,,,642,642,1068,1068,1068,1068", "1068,1068,,,,1068,1068,,,,1068,,1068,1068,1068,1068,1068,1068,1068,", ",,,,1068,1068,1068,1068,1068,1068,1068,,,1068,,,,,,1068,1068,1068,1068", "1068,1068,1068,1068,1068,1068,1068,1068,,1068,1068,1068,,1068,1068,1068", "1068,1068,817,817,817,817,817,817,817,817,817,817,817,,817,817,,,817", "817,,1068,,,1068,,,1068,1068,,,1068,,1068,817,,817,1068,817,817,,817", "817,817,817,817,1068,817,,,,1068,1068,1068,1068,,1068,1068,1068,1068", ",,,,1068,1068,,817,,,,,1068,,1068,1068,1068,,,1068,1068,372,372,372", "372,372,372,,,,372,372,,,,372,,372,372,372,372,372,372,372,,,,,,372", "372,372,372,372,372,372,,,372,,,,,,372,372,372,372,372,372,372,372,372", "372,372,372,,372,372,372,,372,372,372,372,372,874,874,874,874,874,874", "874,874,874,874,874,,874,874,,,874,874,,372,,,372,,,372,372,,,372,,372", "874,,874,372,874,874,,874,874,874,874,874,372,874,,,,372,372,372,372", ",372,372,372,372,,,,,372,372,,874,,,,,372,,372,372,372,,,372,372,973", "973,973,973,973,973,,,,973,973,,,,973,,973,973,973,973,973,973,973,", ",,,,973,973,973,973,973,973,973,,,973,,,,,,973,973,973,973,973,973,973", "973,973,973,973,973,,973,973,973,,973,973,973,973,973,317,317,317,317", "317,317,317,317,317,317,317,,317,317,,,317,317,,973,,,973,,,973,973", ",,973,,973,317,,317,973,317,317,,317,317,317,317,317,973,317,,,,973", "973,973,973,,973,973,973,973,,,,,973,973,,317,,,,,973,,973,973,973,", ",973,973,2,2,2,2,2,2,,,,2,2,,,,2,,2,2,2,2,2,2,2,,,,,,2,2,2,2,2,2,2,", ",2,,,,,,2,2,2,2,2,2,2,2,2,2,2,2,,2,2,2,,2,2,2,2,2,550,550,550,550,550", "550,550,550,550,550,550,,550,550,,,550,550,,2,,,2,,,2,2,,,2,,2,550,", "550,2,550,550,,550,550,550,550,550,2,550,,,,2,2,2,2,,2,2,2,2,,,,,2,2", "550,550,,,,,2,,2,2,2,,,2,2,230,230,230,230,230,230,,,,230,230,,,,230", ",230,230,230,230,230,230,230,,,,,,230,230,230,230,230,230,230,,,230", ",,,,,230,230,230,230,230,230,230,230,230,230,230,230,,230,230,230,,230", "230,230,230,230,1067,1067,1067,1067,1067,1067,1067,1067,1067,1067,1067", ",1067,1067,,,1067,1067,,230,,,230,,,230,230,,,230,,230,1067,,1067,230", "1067,1067,,1067,1067,1067,1067,1067,230,1067,,,,230,230,230,230,,230", "230,230,230,,,,,230,230,,1067,,,,,230,,230,230,230,,,230,230,342,342", "342,342,342,342,,,,342,342,,,,342,,342,342,342,342,342,342,342,,,,,", "342,342,342,342,342,342,342,,,342,,,,,,342,342,342,342,342,342,342,342", "342,342,342,342,,342,342,342,,342,342,342,342,342,1034,1034,1034,1034", "1034,1034,1034,1034,1034,1034,1034,,1034,1034,,,1034,1034,,342,,,342", ",,342,342,,,342,,342,1034,,1034,342,1034,1034,,1034,1034,1034,1034,1034", "342,1034,,,,342,342,342,342,,342,342,342,342,,,,,342,342,,1034,,,,,342", ",342,342,342,,,342,342,253,253,253,253,253,253,,,,253,253,,,,253,,253", "253,253,253,253,253,253,,,,,,253,253,253,253,253,253,253,,,253,,,,,", "253,253,253,253,253,253,253,253,253,253,253,253,,253,253,253,,253,253", "253,253,253,1033,1033,1033,1033,1033,1033,1033,1033,1033,1033,1033,", "1033,1033,,,1033,1033,,253,,,253,,,253,253,,,253,,253,1033,,1033,253", "1033,1033,,1033,1033,1033,1033,1033,253,1033,,,,253,253,253,253,,253", "253,253,253,,,,,253,253,,1033,,,,,253,,253,253,253,,,253,253,1013,1013", "1013,1013,1013,1013,,,,1013,1013,,,,1013,,1013,1013,1013,1013,1013,1013", "1013,,,,,,1013,1013,1013,1013,1013,1013,1013,,,1013,,,,,,1013,1013,1013", "1013,1013,1013,1013,1013,1013,1013,1013,1013,,1013,1013,1013,,1013,1013", "1013,1013,1013,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011,1011", ",1011,1011,,,1011,1011,,1013,,,1013,,,1013,1013,,,1013,,1013,1011,,1011", "1013,1011,1011,,1011,1011,1011,1011,1011,1013,1011,,,,1013,1013,1013", "1013,,1013,1013,1013,1013,,,,,1013,1013,,1011,,,,,1013,,1013,1013,1013", ",,1013,1013,1098,1098,1098,1098,1098,1098,,,,1098,1098,,,,1098,,1098", "1098,1098,1098,1098,1098,1098,,,,,,1098,1098,1098,1098,1098,1098,1098", ",,1098,,,,,,1098,1098,1098,1098,1098,1098,1098,1098,1098,1098,1098,1098", ",1098,1098,1098,,1098,1098,1098,1098,1098,1010,1010,1010,1010,1010,1010", "1010,1010,1010,1010,1010,,1010,1010,,,1010,1010,,1098,,,1098,,,1098", "1098,,,1098,,1098,1010,,1010,1098,1010,1010,,1010,1010,1010,1010,1010", "1098,1010,,,,1098,1098,1098,1098,,1098,1098,1098,1098,,,,,1098,1098", ",1010,,,,,1098,,1098,1098,1098,,,1098,1098,1097,1097,1097,1097,1097", "1097,,,,1097,1097,,,,1097,,1097,1097,1097,1097,1097,1097,1097,,,,,,1097", "1097,1097,1097,1097,1097,1097,,,1097,,,,,,1097,1097,1097,1097,1097,1097", "1097,1097,1097,1097,1097,1097,,1097,1097,1097,,1097,1097,1097,1097,1097", "529,529,529,529,529,529,529,529,529,529,529,,529,529,,,529,529,,1097", ",,1097,,,1097,1097,,546,1097,,1097,529,,529,1097,529,529,,529,529,529", "529,529,1097,529,,,,1097,1097,1097,1097,,1097,1097,1097,1097,,,546,", "1097,1097,546,546,,546,546,,1097,,1097,1097,1097,,,1097,1097,1147,1147", "1147,1147,1147,1147,,,,1147,1147,,,,1147,,1147,1147,1147,1147,1147,1147", "1147,,,,,,1147,1147,1147,1147,1147,1147,1147,547,1115,1147,1115,1115", "1115,,1115,1147,1147,1147,1147,1147,1147,1147,1147,1147,1147,1147,1147", ",1147,1147,1147,,1147,1147,1147,1147,1147,604,,547,,,,547,547,1115,547", "547,,,,,,604,604,,1147,,,1147,,,1147,1147,,,1147,,1147,604,,604,1147", "604,604,,604,604,,,604,1147,604,,,,1147,1147,1147,1147,,1147,1147,1147", "1147,,,,,1147,1147,,,,,,,1147,,1147,1147,1147,,,1147,1147,621,621,621", "621,621,621,,,,621,621,,,,621,,621,621,621,621,621,621,621,,,,,,621", "621,621,621,621,621,621,,,621,,,,,,621,621,621,621,621,621,621,621,621", "621,621,621,,621,621,621,,621,621,621,621,621,364,364,364,364,364,364", "364,364,364,364,364,,364,364,,,364,364,,621,,,621,,,621,621,,,621,,621", "364,,364,621,364,364,,364,364,364,364,364,621,364,,,,621,621,621,621", ",621,621,621,621,,,,,621,621,,,,,,,621,,621,621,621,,,621,621,892,892", "892,892,892,892,,,,892,892,,,,892,,892,892,892,892,892,892,892,,,,,", "892,892,892,892,892,892,892,,,892,,,,,,892,892,892,892,892,892,892,892", "892,892,892,892,,892,892,892,,892,892,892,892,892,365,365,365,365,365", "365,365,365,365,365,365,,365,365,,,365,365,,892,,,892,,,892,892,,,892", ",892,365,,365,892,365,365,,365,365,365,365,365,892,365,,,,892,892,892", "892,,892,892,892,892,,,,,892,892,,,,,,,892,,892,892,892,,,892,892,618", "618,618,618,618,618,,,,618,618,,,,618,,618,618,618,618,618,618,618,", ",,,,618,618,618,618,618,618,618,,,618,,,,,,618,618,618,618,618,618,618", "618,618,618,618,618,,618,618,618,,618,618,618,618,618,551,,,,,,,,,,", ",,,,,551,551,,618,,,618,,,618,618,,,618,,618,551,,551,618,551,551,,551", "551,,,551,618,551,,,,618,618,618,618,,618,618,618,618,,,,,618,618,,", ",,,,618,,618,618,618,,,618,618,1191,1191,1191,1191,1191,1191,,,,1191", "1191,,,,1191,,1191,1191,1191,1191,1191,1191,1191,,,,,,1191,1191,1191", "1191,1191,1191,1191,,,1191,,,,,,1191,1191,1191,1191,1191,1191,1191,1191", "1191,1191,1191,1191,,1191,1191,1191,,1191,1191,1191,1191,1191,549,549", "549,549,549,549,549,549,,549,549,,,,,,549,549,,1191,,,1191,,,1191,1191", ",,1191,,1191,549,,549,1191,549,549,,549,549,549,549,549,1191,549,,,", "1191,1191,1191,1191,,1191,1191,1191,1191,,,,,1191,1191,,,,,,,1191,,1191", "1191,1191,,,1191,1191,135,135,135,135,135,135,,,,135,135,,,,135,,135", "135,135,135,135,135,135,,,,,,135,135,135,135,135,135,135,,,135,,,,,", "135,135,135,135,135,135,135,135,135,135,135,135,,135,135,135,,135,135", "135,135,135,548,548,548,548,548,548,548,,,548,548,,,,,,548,548,,135", ",,135,,,135,135,,,135,,135,548,,548,135,548,548,,548,548,548,548,548", "135,548,,,,135,135,135,135,,135,135,135,135,,,,,135,135,,,,,,,135,,135", "135,135,,,135,135,218,218,218,218,218,218,,,,218,218,,,,218,,218,218", "218,218,218,218,218,,,,,,218,218,218,218,218,218,218,,,218,,,,,,218", "218,218,218,218,218,218,218,218,218,218,218,,218,218,218,,218,218,218", "218,218,545,545,545,545,545,545,545,,,545,545,,,,,,545,545,,218,,,218", ",,218,218,,,218,,218,545,,545,218,545,545,,545,545,545,545,545,218,545", ",,,218,218,218,218,,218,218,218,218,,,,,218,218,,,,,,,218,,218,218,218", ",,218,218,846,846,846,846,846,846,,,,846,846,,,,846,,846,846,846,846", "846,846,846,,,,,,846,846,846,846,846,846,846,,,846,,,,,,846,846,846", "846,846,846,846,846,846,846,846,846,,846,846,846,,846,846,846,846,846", "544,544,544,544,544,544,544,,,544,544,,,,,,544,544,,846,,,846,,,846", "846,,,846,,846,544,,544,846,544,544,,544,544,544,544,544,846,544,,,", "846,846,846,846,,846,846,846,846,,,,,846,846,,,,,,,846,,846,846,846", ",,846,846,857,857,857,857,857,857,,,,857,857,,,,857,,857,857,857,857", "857,857,857,,,,,,857,857,857,857,857,857,857,,,857,,,,,,857,857,857", "857,857,857,857,857,857,857,857,857,,857,857,857,,857,857,857,857,857", "543,543,543,543,543,543,543,,,543,543,,,,,,543,543,,857,,,857,,,857", "857,,,857,,857,543,,543,857,543,543,,543,543,543,543,543,857,543,,,", "857,857,857,857,,857,857,857,857,,,,,857,857,,,,,,,857,,857,857,857", ",,857,857,388,388,388,388,388,388,,,,388,388,,,,388,,388,388,388,388", "388,388,388,,,,,,388,388,388,388,388,388,388,,,388,,,,,,388,388,388", "388,388,388,388,388,388,388,388,388,,388,388,388,,388,388,388,388,388", "542,542,542,542,542,542,542,,,542,542,,,,,,542,542,,388,,,388,,,388", "388,,,388,,388,542,,542,388,542,542,,542,542,542,542,542,388,542,,,", "388,388,388,388,,388,388,388,388,,,,,388,388,,,,,,,388,,388,388,388", ",,388,388,991,991,991,991,991,991,,,,991,991,,,,991,,991,991,991,991", "991,991,991,,,,,,991,991,991,991,991,991,991,,,991,,,,,,991,991,991", "991,991,991,991,991,991,991,991,991,,991,991,991,,991,991,991,991,991", "541,541,541,541,541,541,541,,,541,541,,,,,,541,541,,991,,,991,,,991", "991,,,991,,991,541,,541,991,541,541,,541,541,541,541,541,991,541,,,", "991,991,991,991,,991,991,991,991,,,,,991,991,,,,920,920,920,991,920", "991,991,991,920,920,991,991,,920,,920,920,920,920,920,920,920,,,,,,920", "920,920,920,920,920,920,,,920,,,,,,,920,,,920,920,920,920,920,920,920", "920,,920,920,920,,920,920,920,920,920,540,540,540,540,540,540,540,,", "540,540,,,,,,540,540,,920,,,920,,,920,920,,,920,,,540,,540,920,540,540", ",540,540,540,540,540,920,540,,,,920,920,920,920,,920,920,920,920,,,", ",920,920,,,,921,921,921,920,921,920,920,920,921,921,920,920,,921,,921", "921,921,921,921,921,921,,,,,,921,921,921,921,921,921,921,,,921,,,,,", ",921,,,921,921,921,921,921,921,921,921,,921,921,921,,921,921,921,921", "921,530,530,530,530,530,530,530,530,530,530,530,,530,530,,,530,530,", "921,,,921,,,921,921,,,921,,,530,,530,921,530,530,,530,530,530,530,530", "921,530,,,,921,921,921,921,,921,921,921,921,,,,,921,921,,,,922,922,922", "921,922,921,921,921,922,922,921,921,,922,,922,922,922,922,922,922,922", ",,,,,922,922,922,922,922,922,922,,,922,,,,,,,922,,,922,922,922,922,922", "922,922,922,,922,922,922,,922,922,922,922,922,538,,,,,,,,,,,,,,,,538", "538,,922,,,922,,,922,922,,,922,,,538,,538,922,538,538,,538,538,,,,922", ",,,,922,922,922,922,,922,922,922,922,,,,,922,922,,,,733,733,733,922", "733,922,922,922,733,733,922,922,,733,,733,733,733,733,733,733,733,,", ",,,733,733,733,733,733,733,733,,,733,,,,,,,733,,,733,733,733,733,733", "733,733,733,,733,733,733,,733,733,733,733,733,539,,,,,,,,,,,,,,,,539", "539,,733,,,733,,,733,733,,,733,,,539,,,733,539,539,,539,539,,,,733,", ",,,733,733,733,733,,733,733,733,733,,,,,733,733,,,,732,732,732,733,732", "733,733,733,732,732,733,733,,732,,732,732,732,732,732,732,732,,,,,,732", "732,732,732,732,732,732,,,732,,,,,,,732,,,732,732,732,732,732,732,732", "732,,732,732,732,,732,732,732,732,732,537,,,,,,,,,,,,,,,,537,537,,732", ",,732,,,732,732,,,732,,,537,,537,732,537,537,,537,537,,,,732,,,,,732", "732,732,732,,732,732,732,732,,,,,732,732,,,,,,,732,,732,732,732,,,732", "732,333,333,333,333,333,,,,333,333,,,,333,,333,333,333,333,333,333,333", ",,,,,333,333,333,333,333,333,333,,,333,,,,,,333,333,,333,333,333,333", "333,333,333,333,333,,333,333,333,,333,333,333,333,333,,,,,,,,,,,,,,", ",,,,,333,,,333,,,333,333,,,333,,333,,,,333,,,,,,,,,333,,,,,333,333,333", "333,,333,333,333,333,,,,,333,333,,,,265,265,265,333,265,333,333,333", "265,265,333,333,,265,,265,265,265,265,265,265,265,,,,,,265,265,265,265", "265,265,265,,,265,,,,,,,265,,,265,265,265,265,265,265,265,265,,265,265", "265,,265,265,265,265,265,,,,,,,,,,,,,,,,,,,,265,,,265,,,265,265,,,265", ",,,,,265,,,,,,,,,265,,,,,265,265,265,265,,265,265,265,265,,,,,265,265", ",,,264,264,264,265,264,265,265,265,264,264,265,265,,264,,264,264,264", "264,264,264,264,,,,,,264,264,264,264,264,264,264,,,264,,,,,,,264,,,264", "264,264,264,264,264,264,264,,264,264,264,,264,264,264,264,264,,,,,,", ",,,,,,,,,,,,,264,,,264,,,264,264,,,264,,,,,,264,,,,,,,,,264,,,,,264", "264,264,264,,264,264,264,264,,,,,264,264,,,,263,263,263,264,263,264", "264,264,263,263,264,264,,263,,263,263,263,263,263,263,263,,,,,,263,263", "263,263,263,263,263,,,263,,,,,,,263,,,263,263,263,263,263,263,263,263", ",263,263,263,,263,263,263,263,263,,,,,,,,,,,,,,,,,,,,263,,,263,,,263", "263,,,263,,,,,,263,,,,,,,,,263,,,,,263,263,263,263,,263,263,263,263", ",,,,263,263,,,,262,262,262,263,262,263,263,263,262,262,263,263,,262", ",262,262,262,262,262,262,262,,,,,,262,262,262,262,262,262,262,,,262", ",,,,,,262,,,262,262,262,262,262,262,262,262,,262,262,262,,262,262,262", "262,262,,,,,,,,,,,,,,,,,,,,262,,,262,,,262,262,,,262,,,,,,262,,,,,,", ",,262,,,,,262,262,262,262,,262,262,262,262,,,,,262,262,,,,261,261,261", "262,261,262,262,262,261,261,262,262,,261,,261,261,261,261,261,261,261", ",,,,,261,261,261,261,261,261,261,,,261,,,,,,,261,,,261,261,261,261,261", "261,261,261,,261,261,261,,261,261,261,261,261,,,,,,,,,,,,,,,,,,,,261", ",,261,,,261,261,,,261,,,,,,261,,,,,,,,,261,,,,,261,261,261,261,,261", "261,261,261,,,,,261,261,,,,708,708,708,261,708,261,261,261,708,708,261", "261,,708,,708,708,708,708,708,708,708,,,,,,708,708,708,708,708,708,708", ",,708,,,,,,,708,,,708,708,708,708,708,708,708,708,,708,708,708,,708", "708,708,708,708,,,,,,,,,,,,,,,,,,,,708,,,708,,,708,708,,,708,,,,,,708", ",,,,,,,,708,,,,,708,708,708,708,,708,708,708,708,,,,,708,708,,,,260", "260,260,708,260,708,708,708,260,260,708,708,,260,,260,260,260,260,260", "260,260,,,,,,260,260,260,260,260,260,260,,,260,,,,,,,260,,,260,260,260", "260,260,260,260,260,,260,260,260,,260,260,260,260,260,,,,,,,,,,,,,,", ",,,,,260,,,260,,,260,260,,,260,,,,,,260,,,,,,,,,260,,,,,260,260,260", "260,,260,260,260,260,,,,,260,260,,,,694,694,694,260,694,260,260,260", "694,694,260,260,,694,,694,694,694,694,694,694,694,,,,,,694,694,694,694", "694,694,694,,,694,,,,,,,694,,,694,694,694,694,694,694,694,694,,694,694", "694,,694,694,694,694,694,,,,,,,,,,,,,,,,,,,,694,,,694,,,694,694,,,694", ",694,,,,694,,,,,,,,,694,,,,,694,694,694,694,,694,694,694,694,,,,,694", "694,,,,259,259,259,694,259,694,694,694,259,259,694,694,,259,,259,259", "259,259,259,259,259,,,,,,259,259,259,259,259,259,259,,,259,,,,,,,259", ",,259,259,259,259,259,259,259,259,,259,259,259,,259,259,259,259,259", ",,,,,,,,,,,,,,,,,,,259,,,259,,,259,259,,,259,,,,,,259,,,,,,,,,259,,", ",,259,259,259,259,,259,259,259,259,,,,,259,259,,,,258,258,258,259,258", "259,259,259,258,258,259,259,,258,,258,258,258,258,258,258,258,,,,,,258", "258,258,258,258,258,258,,,258,,,,,,,258,,,258,258,258,258,258,258,258", "258,,258,258,258,,258,258,258,258,258,,,,,,,,,,,,,,,,,,,,258,,,258,", ",258,258,,,258,,,,,,258,,,,,,,,,258,,,,,258,258,258,258,,258,258,258", "258,,,,,258,258,,,,257,257,257,258,257,258,258,258,257,257,258,258,", "257,,257,257,257,257,257,257,257,,,,,,257,257,257,257,257,257,257,,", "257,,,,,,,257,,,257,257,257,257,257,257,257,257,,257,257,257,,257,257", "257,257,257,,,,,,,,,,,,,,,,,,,,257,,,257,,,257,257,,,257,,,,,,257,,", ",,,,,,257,,,,,257,257,257,257,,257,257,257,257,,,,,257,257,,,,688,688", "688,257,688,257,257,257,688,688,257,257,,688,,688,688,688,688,688,688", "688,,,,,,688,688,688,688,688,688,688,,,688,,,,,,,688,,,688,688,688,688", "688,688,688,688,,688,688,688,,688,688,688,688,688,,,,,,,,,,,,,,,,,,", ",688,,,688,,,688,688,,,688,,,,,,688,,,,,,,,,688,,,,,688,688,688,688", ",688,688,688,688,,,,,688,688,,,,687,687,687,688,687,688,688,688,687", "687,688,688,,687,,687,687,687,687,687,687,687,,,,,,687,687,687,687,687", "687,687,,,687,,,,,,,687,,,687,687,687,687,687,687,687,687,,687,687,687", ",687,687,687,687,687,,,,,,,,,,,,,,,,,,,,687,,,687,,,687,687,,,687,,", ",,,687,,,,,,,,,687,,,,,687,687,687,687,,687,687,687,687,,,,,687,687", ",,,,,,687,,687,687,687,32,,687,687,,,,32,32,32,,,32,32,32,,32,,,,,,", ",32,32,32,32,,,,,,,,,32,32,,32,32,32,32,32,,,,,,,,,,,,,,,,,,,,,,,32", "32,32,32,32,32,32,32,32,32,32,32,32,32,,,32,32,32,,,32,,32,32,,,32,32", ",32,,32,,32,,32,32,,32,32,32,32,32,,32,32,32,,,,,,,,,,,,,,32,,,32,32", ",32,,32,683,683,683,,683,,32,,683,683,,,,683,,683,683,683,683,683,683", "683,,,,,,683,683,683,683,683,683,683,,,683,,,,,,,683,,,683,683,683,683", "683,683,683,683,,683,683,683,,683,683,683,683,683,,,,,,,,,,,,,,,,,,", ",683,,,683,,,683,683,,,683,,,,,,683,,,,,,,,,683,,,,,683,683,683,683", ",683,683,683,683,,,,,683,683,,,,682,682,682,683,682,683,683,683,682", "682,683,683,,682,,682,682,682,682,682,682,682,,,,,,682,682,682,682,682", "682,682,,,682,,,,,,,682,,,682,682,682,682,682,682,682,682,,682,682,682", ",682,682,682,682,682,,,,,,,,,,,,,,,,,,,,682,,,682,,,682,682,,,682,,", ",,,682,,,,,,,,,682,,,,,682,682,682,682,,682,682,682,682,,,,,682,682", ",,,681,681,681,682,681,682,682,682,681,681,682,682,,681,,681,681,681", "681,681,681,681,,,,,,681,681,681,681,681,681,681,,,681,,,,,,,681,,,681", "681,681,681,681,681,681,681,681,681,681,681,,681,681,681,681,681,,,", ",,,,,,,,,,,,,,,,681,,,681,,,681,681,,,681,,,,681,,681,,,681,,,,,,681", ",,,,681,681,681,681,,681,681,681,681,,,,,681,681,,,,956,956,956,681", "956,681,681,681,956,956,681,681,,956,,956,956,956,956,956,956,956,,", ",,,956,956,956,956,956,956,956,,,956,,,,,,,956,,,956,956,956,956,956", "956,956,956,,956,956,956,,956,956,956,956,956,,,,,,,,,,,,,,,,,,,,956", ",,956,,,956,956,,,956,,,,,,956,,,,,,,,,956,,,,,956,956,956,956,,956", "956,956,956,,,,,956,956,,,,962,962,962,956,962,956,956,956,962,962,956", "956,,962,,962,962,962,962,962,962,962,,,,,,962,962,962,962,962,962,962", ",,962,,,,,,,962,,,962,962,962,962,962,962,962,962,,962,962,962,,962", "962,962,962,962,,,,,,,,,,,,,,,,,,,,962,,,962,,,962,962,,,962,,,,,,962", ",,,,,,,,962,,,,,962,962,962,962,,962,962,962,962,,,,,962,962,,,,,,,962", ",962,962,962,33,,962,962,,,,33,33,33,,,33,33,33,,33,,,,,,,,33,,33,33", ",,,,,,,,33,33,,33,33,33,33,33,,,,,,,,,,,,,,,,,,,,,,,33,33,33,33,33,33", "33,33,33,33,33,33,33,33,,,33,33,33,,,33,,33,33,,,33,33,,33,,33,,33,", "33,33,,33,33,33,33,33,,33,,33,,,,,,,,,,,,,,33,,,33,33,,33,,33,34,34", "34,,34,,33,,34,34,,,,34,,34,34,34,34,34,34,34,,,,,,34,34,34,34,34,34", "34,,,34,,,,,,,34,,,34,34,34,34,34,34,34,34,34,34,34,34,,34,34,34,34", "34,,,,,,,,,,,,,,,,,,,,34,,,34,,,34,34,,,34,,34,,34,,34,,,34,,,,,,34", ",,,,34,34,34,34,,34,34,34,34,,,,,34,34,,,,680,680,680,34,680,34,34,34", "680,680,34,34,,680,,680,680,680,680,680,680,680,,,,,,680,680,680,680", "680,680,680,,,680,,,,,,,680,,,680,680,680,680,680,680,680,680,680,680", "680,680,,680,680,680,680,680,,,,,,,,,,,,,,,,,,,,680,,,680,,,680,680", ",,680,,680,,680,,680,,,680,,,,,,680,,,,,680,680,680,680,,680,680,680", "680,,,,,680,680,,,,677,677,677,680,677,680,680,680,677,677,680,680,", "677,,677,677,677,677,677,677,677,,,,,,677,677,677,677,677,677,677,,", "677,,,,,,,677,,,677,677,677,677,677,677,677,677,,677,677,677,,677,677", "677,677,677,,,,,,,,,,,,,,,,,,,,677,,,677,,,677,677,,,677,,,,,,677,,", ",,,,,,677,,,,,677,677,677,677,,677,677,677,677,,,,,677,677,,,,,,,677", ",677,677,677,,,677,677,676,676,676,676,676,,,,676,676,,,,676,,676,676", "676,676,676,676,676,,,,,,676,676,676,676,676,676,676,,,676,,,,,,676", "676,,676,676,676,676,676,676,676,676,676,,676,676,676,,676,676,676,676", "676,,,,,,,,,,,,,,,,,,,,676,,,676,,,676,676,,,676,,676,,,,676,,,,,,,", ",676,,,,,676,676,676,676,,676,676,676,676,,,,,676,676,,,,985,985,985", "676,985,676,676,676,985,985,676,676,,985,,985,985,985,985,985,985,985", ",,,,,985,985,985,985,985,985,985,,,985,,,,,,,985,,,985,985,985,985,985", "985,985,985,,985,985,985,,985,985,985,985,985,,,,,,,,,,,,,,,,,,,,985", ",,985,,,985,985,,,985,,,,,,985,,,,,,,,,985,,,,,985,985,985,985,,985", "985,985,985,,,,,985,985,,,,673,673,673,985,673,985,985,985,673,673,985", "985,,673,,673,673,673,673,673,673,673,,,,,,673,673,673,673,673,673,673", ",,673,,,,,,,673,,,673,673,673,673,673,673,673,673,673,673,673,673,,673", "673,673,673,673,,,,,,,,,,,,,,,,,,,,673,,,673,,,673,673,,,673,,673,,673", ",673,,,673,,,,,,673,,,,,673,673,673,673,,673,673,673,673,,,,,673,673", ",,,672,672,672,673,672,673,673,673,672,672,673,673,,672,,672,672,672", "672,672,672,672,,,,,,672,672,672,672,672,672,672,,,672,,,,,,,672,,,672", "672,672,672,672,672,672,672,,672,672,672,,672,672,672,672,672,,,,,,", ",,,,,,,,,,,,,672,,,672,,,672,672,,,672,,,,,,672,,,,,,,,,672,,,,,672", "672,672,672,,672,672,672,672,,,,,672,672,,,,990,990,990,672,990,672", "672,672,990,990,672,672,,990,,990,990,990,990,990,990,990,,,,,,990,990", "990,990,990,990,990,,,990,,,,,,,990,,,990,990,990,990,990,990,990,990", ",990,990,990,,990,990,990,990,990,,,,,,,,,,,,,,,,,,,,990,,,990,,,990", "990,,,990,,990,,,,990,,,,,,,,,990,,,,,990,990,990,990,,990,990,990,990", ",,,,990,990,,,,671,671,671,990,671,990,990,990,671,671,990,990,,671", ",671,671,671,671,671,671,671,,,,,,671,671,671,671,671,671,671,,,671", ",,,,,,671,,,671,671,671,671,671,671,671,671,,671,671,671,,671,671,671", "671,671,,,,,,,,,,,,,,,,,,,,671,,,671,,,671,671,,,671,,671,,,,671,,,", ",,,,,671,,,,,671,671,671,671,,671,671,671,671,,,,,671,671,,,,,,,671", ",671,671,671,,,671,671,669,669,669,669,669,,,,669,669,,,,669,,669,669", "669,669,669,669,669,,,,,,669,669,669,669,669,669,669,,,669,,,,,,669", "669,,669,669,669,669,669,669,669,669,669,,669,669,669,,669,669,669,669", "669,,,,,,,,,,,,,,,,,,,,669,,,669,,,669,669,,,669,,669,,,,669,,,,,,,", ",669,,,,,669,669,669,669,,669,669,669,669,,,,,669,669,,,,35,35,35,669", "35,669,669,669,35,35,669,669,,35,,35,35,35,35,35,35,35,,,,,,35,35,35", "35,35,35,35,,,35,,,,,,,35,,,35,35,35,35,35,35,35,35,35,35,35,35,,35", "35,35,35,35,,,,,,,,,,,,,,,,,,,,35,,,35,,,35,35,,,35,,35,,35,,35,,,35", ",,,,,35,,,,,35,35,35,35,,35,35,35,35,,,,,35,35,,,,250,250,250,35,250", "35,35,35,250,250,35,35,,250,,250,250,250,250,250,250,250,,,,,,250,250", "250,250,250,250,250,,,250,,,,,,,250,,,250,250,250,250,250,250,250,250", ",250,250,250,,250,250,250,250,250,,,,,,,,,,,,,,,,,,,,250,,,250,,,250", "250,,,250,,,,,,250,,,,,,,,,250,,,,,250,250,250,250,,250,250,250,250", ",,,,250,250,,,,36,36,36,250,36,250,250,250,36,36,250,250,,36,,36,36", "36,36,36,36,36,,,,,,36,36,36,36,36,36,36,,,36,,,,,,,36,,,36,36,36,36", "36,36,36,36,36,36,36,36,,36,36,36,36,36,,,,,,,,,,,,,,,,,,,,36,,,36,", ",36,36,,,36,,36,,36,,36,,,36,,,,,,36,,,,,36,36,36,36,,36,36,36,36,,", ",,36,36,,,,638,638,638,36,638,36,36,36,638,638,36,36,,638,,638,638,638", "638,638,638,638,,,,,,638,638,638,638,638,638,638,,,638,,,,,,,638,,,638", "638,638,638,638,638,638,638,638,638,638,638,,638,638,638,638,638,,,", ",,,,,,,,,,,,,,,,638,,,638,,,638,638,,,638,,638,,638,,638,,,638,,,,,", "638,,,,,638,638,638,638,,638,638,638,638,,,,,638,638,,,,1009,1009,1009", "638,1009,638,638,638,1009,1009,638,638,,1009,,1009,1009,1009,1009,1009", "1009,1009,,,,,,1009,1009,1009,1009,1009,1009,1009,,,1009,,,,,,,1009", ",,1009,1009,1009,1009,1009,1009,1009,1009,1009,1009,1009,1009,,1009", "1009,1009,1009,1009,,,,,,,,,,,,,,,,,,,,1009,,,1009,,,1009,1009,,,1009", ",,,1009,,1009,,,1009,,,,,,1009,,,,,1009,1009,1009,1009,,1009,1009,1009", "1009,,,,,1009,1009,,,,628,628,628,1009,628,1009,1009,1009,628,628,1009", "1009,,628,,628,628,628,628,628,628,628,,,,,,628,628,628,628,628,628", "628,,,628,,,,,,,628,,,628,628,628,628,628,628,628,628,628,628,628,628", ",628,628,628,628,628,,,,,,,,,,,,,,,,,,,,628,,,628,,,628,628,,,628,,628", ",628,,628,,,628,,,,,,628,,,,,628,628,628,628,,628,628,628,628,,,,,628", "628,,,,627,627,627,628,627,628,628,628,627,627,628,628,,627,,627,627", "627,627,627,627,627,,,,,,627,627,627,627,627,627,627,,,627,,,,,,,627", ",,627,627,627,627,627,627,627,627,,627,627,627,,627,627,627,627,627", ",,,,,,,,,,,,,,,,,,,627,,,627,,,627,627,,,627,,627,,,,627,,,,,,,,,627", ",,,,627,627,627,627,,627,627,627,627,,,,,627,627,,,,818,818,818,627", "818,627,627,627,818,818,627,627,,818,,818,818,818,818,818,818,818,,", ",,,818,818,818,818,818,818,818,,,818,,,,,,,818,,,818,818,818,818,818", "818,818,818,,818,818,818,,818,818,818,818,818,,,,,,,,,,,,,,,,,,,,818", ",,818,,,818,818,,,818,,,,,,818,,,,,,,,,818,,,,,818,818,818,818,,818", "818,818,818,,,,,818,818,,,,614,614,614,818,614,818,818,818,614,614,818", "818,,614,,614,614,614,614,614,614,614,,,,,,614,614,614,614,614,614,614", ",,614,,,,,,,614,,,614,614,614,614,614,614,614,614,614,614,614,614,,614", "614,614,614,614,,,,,,,,,,,,,,,,,,,,614,,,614,,,614,614,,,614,,,,,,614", ",,614,,,,,,614,,,,,614,614,614,614,,614,614,614,614,,,,,614,614,,,,611", "611,611,614,611,614,614,614,611,611,614,614,,611,,611,611,611,611,611", "611,611,,,,,,611,611,611,611,611,611,611,,,611,,,,,,,611,,,611,611,611", "611,611,611,611,611,611,611,611,611,,611,611,611,611,611,,,,,,,,,,,", ",,,,,,,,611,,,611,,,611,611,,,611,,611,,,,611,,,611,,,,,,611,,,,,611", "611,611,611,,611,611,611,611,,,,,611,611,,,,239,239,239,611,239,611", "611,611,239,239,611,611,,239,,239,239,239,239,239,239,239,,,,,,239,239", "239,239,239,239,239,,,239,,,,,,,239,,,239,239,239,239,239,239,239,239", ",239,239,239,,239,239,239,239,239,,,,,,,,,,,,,,,,,,,,239,,,239,,,239", "239,,,239,,,,,,239,,,,,,,,,239,,,,,239,239,239,239,,239,239,239,239", ",,,,239,239,239,,,605,605,605,239,605,239,239,239,605,605,239,239,,605", ",605,605,605,605,605,605,605,,,,,,605,605,605,605,605,605,605,,,605", ",,,,,,605,,,605,605,605,605,605,605,605,605,,605,605,605,,605,605,605", "605,605,,,,,,,,,,,,,,,,,,,,605,,,605,,,605,605,,,605,,,,,,605,,,,,,", ",,605,,,,,605,605,605,605,,605,605,605,605,,,,,605,605,,,,1035,1035", "1035,605,1035,605,605,605,1035,1035,605,605,,1035,,1035,1035,1035,1035", "1035,1035,1035,,,,,,1035,1035,1035,1035,1035,1035,1035,,,1035,,,,,,", "1035,,,1035,1035,1035,1035,1035,1035,1035,1035,,1035,1035,1035,,1035", "1035,1035,1035,1035,,,,,,,,,,,,,,,,,,,,1035,,,1035,,,1035,1035,,,1035", ",,,,,1035,,,,,,,,,1035,,,,,1035,1035,1035,1035,,1035,1035,1035,1035", ",,,,1035,1035,,,,603,603,603,1035,603,1035,1035,1035,603,603,1035,1035", ",603,,603,603,603,603,603,603,603,,,,,,603,603,603,603,603,603,603,", ",603,,,,,,,603,,,603,603,603,603,603,603,603,603,,603,603,603,,603,603", "603,603,603,,,,,,,,,,,,,,,,,,,,603,,,603,,,603,603,,,603,,,,,,603,,", ",,,,,,603,,,,,603,603,603,603,,603,603,603,603,,,,,603,603,,,,600,600", "600,603,600,603,603,603,600,600,603,603,,600,,600,600,600,600,600,600", "600,,,,,,600,600,600,600,600,600,600,,,600,,,,,,,600,,,600,600,600,600", "600,600,600,600,,600,600,600,,600,600,600,600,600,,,,,,,,,,,,,,,,,,", ",600,,,600,,,600,600,,,600,,,,,,600,,,,,,,,,600,,,,,600,600,600,600", ",600,600,600,600,,,,,600,600,,,,238,238,238,600,238,600,600,600,238", "238,600,600,,238,,238,238,238,238,238,238,238,,,,,,238,238,238,238,238", "238,238,,,238,,,,,,,238,,,238,238,238,238,238,238,238,238,,238,238,238", ",238,238,238,238,238,,,,,,,,,,,,,,,,,,,,238,,,238,,,238,238,,,238,,", ",,,238,,,,,,,,,238,,,,,238,238,238,238,,238,238,238,238,,,,,238,238", ",,,237,237,237,238,237,238,238,238,237,237,238,238,,237,,237,237,237", "237,237,237,237,,,,,,237,237,237,237,237,237,237,,,237,,,,,,,237,,,237", "237,237,237,237,237,237,237,,237,237,237,,237,237,237,237,237,,,,,,", ",,,,,,,,,,,,,237,,,237,,,237,237,,,237,,,,,,237,,,,,,,,,237,,,,,237", "237,237,237,,237,237,237,237,,,,,237,237,,,,590,590,590,237,590,237", "237,237,590,590,237,237,,590,,590,590,590,590,590,590,590,,,,,,590,590", "590,590,590,590,590,,,590,,,,,,,590,,,590,590,590,590,590,590,590,590", "590,590,590,590,,590,590,590,590,590,,,,,,,,,,,,,,,,,,,,590,,,590,,", "590,590,,,590,,590,,590,,590,,,590,,,,,,590,,,,,590,590,590,590,,590", "590,590,590,,,,,590,590,,,,,,,590,,590,590,590,,,590,590,580,580,580", "580,580,,,,580,580,,,,580,,580,580,580,580,580,580,580,,,,,,580,580", "580,580,580,580,580,,,580,,,,,,580,580,580,580,580,580,580,580,580,580", "580,580,,580,580,580,,580,580,580,580,580,,,,,,,,,,,,,,,,,,,,580,,,580", ",,580,580,,,580,,580,,,,580,,,,,,,,,580,,,,,580,580,580,580,,580,580", "580,580,,,,,580,580,,,,,,580,580,,580,580,580,,,580,580,574,574,574", ",574,,,,574,574,,,,574,,574,574,574,574,574,574,574,,,,,,574,574,574", "574,574,574,574,,,574,,,,,,,574,,,574,574,574,574,574,574,574,574,,574", "574,574,,574,574,574,574,574,,,,,,,,,,,,,,,,,,,,574,,,574,,,574,574", ",,574,,,,,,574,,,,,,,,,574,,,,,574,574,574,574,,574,574,574,574,,,,", "574,574,,,,369,369,369,574,369,574,574,574,369,369,574,574,,369,,369", "369,369,369,369,369,369,,,,,,369,369,369,369,369,369,369,,,369,,,,,", ",369,,,369,369,369,369,369,369,369,369,,369,369,369,,369,369,369,369", "369,,,,,,,,,,,,,,,,,,,,369,,,369,,,369,369,,,369,,,,,,369,,,,,,,,,369", ",,,,369,369,369,369,,369,369,369,369,,,,,369,369,,,,46,46,46,369,46", "369,369,369,46,46,369,369,,46,,46,46,46,46,46,46,46,,,,,,46,46,46,46", "46,46,46,,,46,,,,,,,46,,,46,46,46,46,46,46,46,46,,46,46,46,,46,46,46", "46,46,,,,,,,,,,,,,,,,,,,,46,,,46,,,46,46,,,46,,,,,,46,,,,,,,,,46,,,", ",46,46,46,46,,46,46,46,46,,,,,46,46,,,,572,572,572,46,572,46,46,46,572", "572,46,46,,572,,572,572,572,572,572,572,572,,,,,,572,572,572,572,572", "572,572,,,572,,,,,,,572,,,572,572,572,572,572,572,572,572,572,572,572", "572,,572,572,572,572,572,,,,,,,,,,,,,,,,,,,,572,,,572,,,572,572,,,572", ",,,572,,572,,,572,,,,,,572,,,,,572,572,572,572,,572,572,572,572,,,,", "572,572,,,,570,570,570,572,570,572,572,572,570,570,572,572,,570,,570", "570,570,570,570,570,570,,,,,,570,570,570,570,570,570,570,,,570,,,,,", ",570,,,570,570,570,570,570,570,570,570,570,570,570,570,,570,570,570", "570,570,,,,,,,,,,,,,,,,,,,,570,,,570,,,570,570,,,570,,570,,570,,570", ",,570,,,,,,570,,,,,570,570,570,570,,570,570,570,570,,,,,570,570,,,,47", "47,47,570,47,570,570,570,47,47,570,570,,47,,47,47,47,47,47,47,47,,,", ",,47,47,47,47,47,47,47,,,47,,,,,,,47,,,47,47,47,47,47,47,47,47,,47,47", "47,,47,47,47,47,47,,,,,,,,,,,,,,,,,,,,47,,,47,,,47,47,,,47,,,,,,47,", ",,,,,,,47,,,,,47,47,47,47,,47,47,47,47,,,,,47,47,,,,560,560,560,47,560", "47,47,47,560,560,47,47,,560,,560,560,560,560,560,560,560,,,,,,560,560", "560,560,560,560,560,,,560,,,,,,,560,,,560,560,560,560,560,560,560,560", ",560,560,560,,560,560,560,560,560,,,,,,,,,,,,,,,,,,,,560,,,560,,,560", "560,,,560,,,,,,560,,,,,,,,,560,,,,,560,560,560,560,,560,560,560,560", ",,,,560,560,,,,49,49,49,560,49,560,560,560,49,49,560,560,,49,,49,49", "49,49,49,49,49,,,,,,49,49,49,49,49,49,49,,,49,,,,,,,49,,,49,49,49,49", "49,49,49,49,,49,49,49,,49,49,49,49,49,,,,,,,,,,,,,,,,,,,,49,,,49,,,49", "49,,,49,,,,,,49,,,,,,,,,49,,,,,49,49,49,49,,49,49,49,49,,,,,49,49,,", ",,,,49,,49,49,49,555,,49,49,,,,555,555,555,,,555,555,555,703,555,703", "703,703,703,703,,,555,555,555,,,,703,,,,,,555,555,,555,555,555,555,555", ",701,,701,701,701,701,701,703,,,,,,,,701,703,703,703,703,,,,703,,1140", ",1140,1140,1140,1140,1140,555,,,,,701,,555,1140,,,,555,555,701,701,701", "701,,,,701,,,,,,,,,1140,703,,,,555,555,,,,,1140,1140,,,,1140,,,,555", ",,555,,283,283,283,555,283,,701,,283,283,555,,,283,,283,283,283,283", "283,283,283,,,,,,283,283,283,283,283,283,283,,,283,,,,,,,283,,,283,283", "283,283,283,283,283,283,,283,283,283,,283,283,283,283,283,,,,,,,,,,", ",,,,,,,,,283,,,283,,,283,283,,,283,,,,,,283,,,,,,,,,283,,,,,283,283", "283,283,,283,283,283,283,,,,,283,283,,,,224,224,224,283,224,283,283", "283,224,224,283,283,,224,,224,224,224,224,224,224,224,,,,,,224,224,224", "224,224,224,224,,,224,,,,,,,224,,,224,224,224,224,224,224,224,224,224", "224,224,224,,224,224,224,224,224,,,,,,,,,,,,,,,,,,,,224,,,224,,,224", "224,,,224,,224,,224,,224,,,224,,,,,,224,,,,,224,224,224,224,,224,224", "224,224,,,,,224,224,,,,223,223,223,224,223,224,224,224,223,223,224,224", ",223,,223,223,223,223,223,223,223,,,,,,223,223,223,223,223,223,223,", ",223,,,,,,,223,,,223,223,223,223,223,223,223,223,,223,223,223,,223,223", "223,223,223,,,,,,,,,,,,,,,,,,,,223,,,223,,,223,223,,,223,,,,,,223,,", ",,,,,,223,,,,,223,223,223,223,,223,223,223,223,,,,,223,223,,,,50,50", "50,223,50,223,223,223,50,50,223,223,,50,,50,50,50,50,50,50,50,,,,,,50", "50,50,50,50,50,50,,,50,,,,,,,50,,,50,50,50,50,50,50,50,50,,50,50,50", ",50,50,50,50,50,,,,,,,,,,,,,,,,,,,,50,,,50,,,50,50,,,50,,,,,,50,,,,", ",,,,50,,,,,50,50,50,50,,50,50,50,50,,,,,50,50,,,,222,222,222,50,222", "50,50,50,222,222,50,50,,222,,222,222,222,222,222,222,222,,,,,,222,222", "222,222,222,222,222,,,222,,,,,,,222,,,222,222,222,222,222,222,222,222", ",222,222,222,,222,222,222,222,222,,,,,,,,,,,,,,,,,,,,222,,,222,,,222", "222,,,222,,,,,,222,,,,,,,,,222,,,,,222,222,222,222,,222,222,222,222", ",,,,222,222,,,,72,72,72,222,72,222,222,222,72,72,222,222,,72,,72,72", "72,72,72,72,72,,,,,,72,72,72,72,72,72,72,,,72,,,,,,,72,,,72,72,72,72", "72,72,72,72,,72,72,72,,72,72,72,72,72,,,,,,,,,,,,,,,,,,,,72,,,72,,,72", "72,,,72,,,,,,72,,,,,,,,,72,,,,,72,72,72,72,,72,72,72,72,,,,,72,72,,", ",71,71,71,72,71,72,72,72,71,71,72,72,,71,,71,71,71,71,71,71,71,,,,,", "71,71,71,71,71,71,71,,,71,,,,,,,71,,,71,71,71,71,71,71,71,71,,71,71", "71,,71,71,71,71,71,,,,,,,,,,,,,,,,,,,,71,,,71,,,71,71,,,71,,,,,,71,", ",,,,,,,71,,,,,71,71,71,71,,71,71,71,71,,,,,71,71,,,,436,436,436,71,436", "71,71,71,436,436,71,71,,436,,436,436,436,436,436,436,436,,,,,,436,436", "436,436,436,436,436,,,436,,,,,,,436,,,436,436,436,436,436,436,436,436", ",436,436,436,,436,436,436,436,436,,,,,,,,,,,,,,,,,,,,436,,,436,,,436", "436,,,436,,,,,,436,,,,,,,,,436,,,,,436,436,436,436,,436,436,436,436", ",,,,436,436,,,,68,68,68,436,68,436,436,436,68,68,436,436,,68,,68,68", "68,68,68,68,68,,,,,,68,68,68,68,68,68,68,,,68,,,,,,,68,,,68,68,68,68", "68,68,68,68,68,68,68,68,,68,68,68,68,68,,,,,,,,,,,,,,,,,,,,68,,,68,", ",68,68,,,68,,,,,,68,,,68,,,,,,68,,,,,68,68,68,68,,68,68,68,68,,,,,68", "68,,,,407,407,407,68,407,68,68,68,407,407,68,68,,407,,407,407,407,407", "407,407,407,,,,,,407,407,407,407,407,407,407,,,407,,,,,,,407,,,407,407", "407,407,407,407,407,407,,407,407,407,,407,407,407,407,407,,,,,,,,,,", ",,,,,,,,,407,,,407,,,407,407,,,407,,,,,,407,,,,,,,,,407,,,,,407,407", "407,407,,407,407,407,407,,,,,407,407,,,,847,847,847,407,847,407,407", "407,847,847,407,407,,847,,847,847,847,847,847,847,847,,,,,,847,847,847", "847,847,847,847,,,847,,,,,,,847,,,847,847,847,847,847,847,847,847,,847", "847,847,,847,847,847,847,847,,,,,,,,,,,,,,,,,,,,847,,,847,,,847,847", ",,847,,,,,,847,,,,,,,,,847,,,,,847,847,847,847,,847,847,847,847,,,,", "847,847,,,,276,276,276,847,276,847,847,847,276,276,847,847,,276,,276", "276,276,276,276,276,276,,,,,,276,276,276,276,276,276,276,,,276,,,,,", ",276,,,276,276,276,276,276,276,276,276,,276,276,276,,276,276,276,276", "276,,,,,,,,,,,,,,,,,,,,276,,,276,,,276,276,,,276,,,,,,276,,,,,,,,,276", ",,,,276,276,276,276,,276,276,276,276,,,,,276,276,,,,275,275,275,276", "275,276,276,276,275,275,276,276,,275,,275,275,275,275,275,275,275,,", ",,,275,275,275,275,275,275,275,,,275,,,,,,,275,,,275,275,275,275,275", "275,275,275,,275,275,275,,275,275,275,275,275,,,,,,,,,,,,,,,,,,,,275", ",,275,,,275,275,,,275,,,,,,275,,,,,,,,,275,,,,,275,275,275,275,,275", "275,275,275,,,,,275,275,,,,67,67,67,275,67,275,275,275,67,67,275,275", ",67,,67,67,67,67,67,67,67,,,,,,67,67,67,67,67,67,67,,,67,,,,,,,67,,", "67,67,67,67,67,67,67,67,67,67,67,67,,67,67,67,67,67,,,,,,,,,,,,,,,,", ",,,67,,,67,,,67,67,,,67,,67,,,,67,,,67,,,,,,67,,,,,67,67,67,67,,67,67", "67,67,,,,,67,67,,,,,,,67,,67,67,67,,,67,67,66,66,66,66,66,,,,66,66,", ",,66,,66,66,66,66,66,66,66,,,,,,66,66,66,66,66,66,66,,,66,,,,,,66,66", ",66,66,66,66,66,66,66,66,66,,66,66,66,,66,66,66,66,66,,,,,,,,,,,,,,", ",,,,,66,,,66,,,66,66,,,66,,66,,,,66,,,,,,,,,66,,,,,66,66,66,66,,66,66", "66,66,,,,,66,66,,,,299,299,299,66,299,66,66,66,299,299,66,66,,299,,299", "299,299,299,299,299,299,,,,,,299,299,299,299,299,299,299,,,299,,,,,", ",299,,,299,299,299,299,299,299,299,299,,299,299,299,,299,299,299,299", "299,,,,,,,,,,,,,,,,,,,,299,,,299,,,299,299,,,299,,,,,,299,,,,,,,,,299", ",,,,299,299,299,299,,299,299,299,299,,,,,299,299,,,,274,274,274,299", "274,299,299,299,274,274,299,299,,274,,274,274,274,274,274,274,274,,", ",,,274,274,274,274,274,274,274,,,274,,,,,,,274,,,274,274,274,274,274", "274,274,274,,274,274,274,,274,274,274,274,274,,,,,,,,,,,,,,,,,,,,274", ",,274,,,274,274,,,274,,,,,,274,,,,,,,,,274,,,,,274,274,274,274,,274", "274,274,274,,,,,274,274,,,,867,867,867,274,867,274,274,274,867,867,274", "274,,867,,867,867,867,867,867,867,867,,,,,,867,867,867,867,867,867,867", ",,867,,,,,,,867,,,867,867,867,867,867,867,867,867,,867,867,867,,867", "867,867,867,867,,,,,,,,,,,,,,,,,,,,867,,,867,,,867,867,,,867,,,,,,867", ",,,,,,,,867,,,,,867,867,867,867,,867,867,867,867,,,,,867,867,,,,24,24", "24,867,24,867,867,867,24,24,867,867,,24,,24,24,24,24,24,24,24,,,,,,24", "24,24,24,24,24,24,,,24,,,,,,,24,,,24,24,24,24,24,24,24,24,,24,24,24", ",24,24,24,24,24,,,,,,,,,,,,,,,,,,,,24,,,24,,,24,24,,,24,,,,,,24,,,,", ",,,,24,,,,,24,24,24,24,,24,24,24,24,,,,,24,24,,,,273,273,273,24,273", "24,24,24,273,273,24,24,,273,,273,273,273,273,273,273,273,,,,,,273,273", "273,273,273,273,273,,,273,,,,,,,273,,,273,273,273,273,273,273,273,273", ",273,273,273,,273,273,273,273,273,,,,,,,,,,,,,,,,,,,,273,,,273,,,273", "273,,,273,,,,,,273,,,,,,,,,273,,,,,273,273,273,273,,273,273,273,273", ",,,,273,273,,,,788,788,788,273,788,273,273,273,788,788,273,273,,788", ",788,788,788,788,788,788,788,,,,,,788,788,788,788,788,788,788,,,788", ",,,,,,788,,,788,788,788,788,788,788,788,788,788,788,788,788,,788,788", "788,788,788,,,,,,,,,,,,,,,,,,,,788,,,788,,,788,788,,,788,,788,,788,", "788,,,788,,,,,,788,,,,,788,788,788,788,,788,788,788,788,,,,,788,788", ",,,272,272,272,788,272,788,788,788,272,272,788,788,,272,,272,272,272", "272,272,272,272,,,,,,272,272,272,272,272,272,272,,,272,,,,,,,272,,,272", "272,272,272,272,272,272,272,,272,272,272,,272,272,272,272,272,,,,,,", ",,,,,,,,,,,,,272,,,272,,,272,272,,,272,,,,,,272,,,,,,,,,272,,,,,272", "272,272,272,,272,272,272,272,,,,,272,272,,,,875,875,875,272,875,272", "272,272,875,875,272,272,,875,,875,875,875,875,875,875,875,,,,,,875,875", "875,875,875,875,875,,,875,,,,,,,875,,,875,875,875,875,875,875,875,875", ",875,875,875,,875,875,875,875,875,,,,,,,,,,,,,,,,,,,,875,,,875,,,875", "875,,,875,,,,,,875,,,,,,,,,875,,,,,875,875,875,875,,875,875,875,875", ",,,,875,875,,,,306,306,306,875,306,875,875,875,306,306,875,875,,306", ",306,306,306,306,306,306,306,,,,,,306,306,306,306,306,306,306,,,306", ",,,,,,306,,,306,306,306,306,306,306,306,306,306,306,306,306,,306,306", "306,306,306,,,,,,,,,,,,,,,,,,,,306,,,306,,,306,306,,,306,,306,,306,", "306,,,306,,,,,,306,,,,,306,306,306,306,,306,306,306,306,,,,,306,306", ",,,888,888,888,306,888,306,306,306,888,888,306,306,,888,,888,888,888", "888,888,888,888,,,,,,888,888,888,888,888,888,888,,,888,,,,,,,888,,,888", "888,888,888,888,888,888,888,,888,888,888,,888,888,888,888,888,,,,,,", ",,,,,,,,,,,,,888,,,888,,,888,888,,,888,,,,,,888,,,,,,,,,888,,,,,888", "888,888,888,,888,888,888,888,,,,,888,888,,,,889,889,889,888,889,888", "888,888,889,889,888,888,,889,,889,889,889,889,889,889,889,,,,,,889,889", "889,889,889,889,889,,,889,,,,,,,889,,,889,889,889,889,889,889,889,889", ",889,889,889,,889,889,889,889,889,,,,,,,,,,,,,,,,,,,,889,,,889,,,889", "889,,,889,,,,,,889,,,,,,,,,889,,,,,889,889,889,889,,889,889,889,889", ",,,,889,889,,,,307,307,307,889,307,889,889,889,307,307,889,889,,307", ",307,307,307,307,307,307,307,,,,,,307,307,307,307,307,307,307,,,307", ",,,,,,307,,,307,307,307,307,307,307,307,307,307,307,307,307,,307,307", "307,307,307,,,,,,,,,,,,,,,,,,,,307,,,307,,,307,307,,,307,,307,,307,", "307,,,307,,,,,,307,,,,,307,307,307,307,,307,307,307,307,,,,,307,307", ",,,315,315,315,307,315,307,307,307,315,315,307,307,,315,,315,315,315", "315,315,315,315,,,,,,315,315,315,315,315,315,315,,,315,,,,,,,315,,,315", "315,315,315,315,315,315,315,315,315,315,315,,315,315,315,315,315,,,", ",,,,,,,,,,,,,,,,315,,,315,,,315,315,,,315,,315,,315,,315,,,315,,,,,", "315,,,,,315,315,315,315,,315,315,315,315,,,,,315,315,315,,,271,271,271", "315,271,315,315,315,271,271,315,315,,271,,271,271,271,271,271,271,271", ",,,,,271,271,271,271,271,271,271,,,271,,,,,,,271,,,271,271,271,271,271", "271,271,271,,271,271,271,,271,271,271,271,271,,,,,,,,,,,,,,,,,,,,271", ",,271,,,271,271,,,271,,,,,,271,,,,,,,,,271,,,,,271,271,271,271,,271", "271,271,271,,,,,271,271,,,,270,270,270,271,270,271,271,271,270,270,271", "271,,270,,270,270,270,270,270,270,270,,,,,,270,270,270,270,270,270,270", ",,270,,,,,,,270,,,270,270,270,270,270,270,270,270,,270,270,270,,270", "270,270,270,270,,,,,,,,,,,,,,,,,,,,270,,,270,,,270,270,,,270,,,,,,270", ",,,,,,,,270,,,,,270,270,270,270,,270,270,270,270,,,,,270,270,,,,269", "269,269,270,269,270,270,270,269,269,270,270,,269,,269,269,269,269,269", "269,269,,,,,,269,269,269,269,269,269,269,,,269,,,,,,,269,,,269,269,269", "269,269,269,269,269,,269,269,269,,269,269,269,269,269,,,,,,,,,,,,,,", ",,,,,269,,,269,,,269,269,,,269,,,,,,269,,,,,,,,,269,,,,,269,269,269", "269,,269,269,269,269,,,,,269,269,,,,322,322,322,269,322,269,269,269", "322,322,269,269,,322,,322,322,322,322,322,322,322,,,,,,322,322,322,322", "322,322,322,,,322,,,,,,,322,,,322,322,322,322,322,322,322,322,,322,322", "322,,322,322,322,322,322,,,,,,,,,,,,,,,,,,,,322,,,322,,,322,322,,,322", ",,,,,322,,,,,,,,,322,,,,,322,322,322,322,,322,322,322,322,,,,,322,322", ",,,324,324,324,322,324,322,322,322,324,324,322,322,,324,,324,324,324", "324,324,324,324,,,,,,324,324,324,324,324,324,324,,,324,,,,,,,324,,,324", "324,324,324,324,324,324,324,,324,324,324,,324,324,324,324,324,,,,,,", ",,,,,,,,,,,,,324,,,324,,,324,324,,,324,,,,,,324,,,,,,,,,324,,,,,324", "324,324,324,,324,324,324,324,,,,,324,324,,,,327,327,327,324,327,324", "324,324,327,327,324,324,,327,,327,327,327,327,327,327,327,,,,,,327,327", "327,327,327,327,327,,,327,,,,,,,327,,,327,327,327,327,327,327,327,327", ",327,327,327,,327,327,327,327,327,,,,,,,,,,,,,,,,,,,,327,,,327,,,327", "327,,,327,,,,,,327,,,,,,,,,327,,,,,327,327,327,327,,327,327,327,327", ",,,,327,327,,,,328,328,328,327,328,327,327,327,328,328,327,327,,328", ",328,328,328,328,328,328,328,,,,,,328,328,328,328,328,328,328,,,328", ",,,,,,328,,,328,328,328,328,328,328,328,328,,328,328,328,,328,328,328", "328,328,,,,,,,,,,,,,,,,,,,,328,,,328,,,328,328,,,328,,,,,,328,,,,,,", ",,328,,,,,328,328,328,328,,328,328,328,328,,,,,328,328,,,,268,268,268", "328,268,328,328,328,268,268,328,328,,268,,268,268,268,268,268,268,268", ",,,,,268,268,268,268,268,268,268,,,268,,,,,,,268,,,268,268,268,268,268", "268,268,268,,268,268,268,,268,268,268,268,268,,,,,,,,,,,,,,,,,,,,268", ",,268,,,268,268,,,268,,,,,,268,,,,,,,,,268,,,,,268,268,268,268,,268", "268,268,268,,,,,268,268,,,,267,267,267,268,267,268,268,268,267,267,268", "268,,267,,267,267,267,267,267,267,267,,,,,,267,267,267,267,267,267,267", ",,267,,,,,,,267,,,267,267,267,267,267,267,267,267,,267,267,267,,267", "267,267,267,267,,,,,,,,,,,,,,,,,,,,267,,,267,,,267,267,,,267,,,,,,267", ",,,,,,,,267,,,,,267,267,267,267,,267,267,267,267,,,,,267,267,,,,266", "266,266,267,266,267,267,267,266,266,267,267,,266,,266,266,266,266,266", "266,266,,,,,,266,266,266,266,266,266,266,,,266,,,,,,,266,,,266,266,266", "266,266,266,266,266,,266,266,266,,266,266,266,266,266,,,,,,,,,,,,,,", ",,,,,266,,,266,,,266,266,,,266,,,,,,266,,,,,,,,,266,,,,,266,266,266", "266,,266,266,266,266,,,,,266,266,,,,917,917,917,266,917,266,266,266", "917,917,266,266,,917,,917,917,917,917,917,917,917,,,,,,917,917,917,917", "917,917,917,,,917,,,,,,,917,,,917,917,917,917,917,917,917,917,,917,917", "917,,917,917,917,917,917,,,,,,,,,,,,,,,,,,,,917,,,917,,,917,917,,,917", ",,,,,917,,,,,,,,,917,,,,,917,917,917,917,,917,917,917,917,,,,,917,917", ",,,918,918,918,917,918,917,917,917,918,918,917,917,,918,,918,918,918", "918,918,918,918,,,,,,918,918,918,918,918,918,918,,,918,,,,,,,918,,,918", "918,918,918,918,918,918,918,,918,918,918,,918,918,918,918,918,,,,,,", ",,,,,,,,,,,,,918,,,918,,,918,918,,,918,,,,,,918,,,,,,,,,918,,,,,918", "918,918,918,,918,918,918,918,,,,,918,918,,,,919,919,919,918,919,918", "918,918,919,919,918,918,,919,,919,919,919,919,919,919,919,,,,,,919,919", "919,919,919,919,919,,,919,,,,,,,919,,,919,919,919,919,919,919,919,919", ",919,919,919,,919,919,919,919,919,,,,,,,,,,,,,,,,,,,,919,,,919,,,919", "919,,,919,,,,,,919,,,,,,,,,919,,,,,919,919,919,919,,919,919,919,919", ",,,,919,919,,,,497,497,497,919,497,919,919,919,497,497,919,919,,497", ",497,497,497,497,497,497,497,,,,,,497,497,497,497,497,497,497,,,497", ",,,,,,497,,,497,497,497,497,497,497,497,497,,497,497,497,,497,497,497", "497,497,,,,,,,,,,,,,,,,,,,,497,,,497,,,497,497,,,497,,,,,,497,,,,,,", ",,497,,,,,497,497,497,497,,497,497,497,497,,,,,497,497,,,,,,,497,,497", "497,497,,,497,497,133,133,133,133,133,,,,133,133,,,,133,,133,133,133", "133,133,133,133,,,,,,133,133,133,133,133,133,133,,,133,,,,,,133,133", ",133,133,133,133,133,133,133,133,133,,133,133,133,,133,133,133,133,133", ",,,,,,,,,,,,,,,,,,,133,,,133,,,133,133,,,133,,133,,,,133,,,,,,,,,133", ",,,,133,133,133,133,,133,133,133,133,,,,,133,133,,,,132,132,132,133", "132,133,133,133,132,132,133,133,,132,,132,132,132,132,132,132,132,,", ",,,132,132,132,132,132,132,132,,,132,,,,,,,132,,,132,132,132,132,132", "132,132,132,,132,132,132,,132,132,132,132,132,,,,,,,,,,,,,,,,,,,,132", ",,132,,,132,132,,,132,,,,,,132,,,,,,,,,132,,,,,132,132,132,132,,132", "132,132,132,,,,,132,132,,,,131,131,131,132,131,132,132,132,131,131,132", "132,,131,,131,131,131,131,131,131,131,,,,,,131,131,131,131,131,131,131", ",,131,,,,,,,131,,,131,131,131,131,131,131,131,131,,131,131,131,,131", "131,131,131,131,,,,,,,,,,,,,,,,,,,,131,,,131,,,131,131,,,131,,,,,,131", ",,,,,,,,131,,,,,131,131,131,131,,131,131,131,131,,,,,131,131,,,,130", "130,130,131,130,131,131,131,130,130,131,131,,130,,130,130,130,130,130", "130,130,,,,,,130,130,130,130,130,130,130,,,130,,,,,,,130,,,130,130,130", "130,130,130,130,130,,130,130,130,,130,130,130,130,130,,,,,,,,,,,,,,", ",,,,,130,,,130,,,130,130,,,130,,,,,,130,,,,,,,,,130,,,,,130,130,130", "130,,130,130,130,130,,,,,130,130,,,,1149,1149,1149,130,1149,130,130", "130,1149,1149,130,130,,1149,,1149,1149,1149,1149,1149,1149,1149,,,,", ",1149,1149,1149,1149,1149,1149,1149,,,1149,,,,,,,1149,,,1149,1149,1149", "1149,1149,1149,1149,1149,,1149,1149,1149,,1149,1149,1149,1149,1149,", ",,,,,,,,,,,,,,,,,,1149,,,1149,,,1149,1149,,,1149,,,,,,1149,,,,,,,,,1149", ",,,,1149,1149,1149,1149,,1149,1149,1149,1149,,,,,1149,1149,,,,1150,1150", "1150,1149,1150,1149,1149,1149,1150,1150,1149,1149,,1150,,1150,1150,1150", "1150,1150,1150,1150,,,,,,1150,1150,1150,1150,1150,1150,1150,,,1150,", ",,,,,1150,,,1150,1150,1150,1150,1150,1150,1150,1150,,1150,1150,1150", ",1150,1150,1150,1150,1150,,,,,,,,,,,,,,,,,,,,1150,,,1150,,,1150,1150", ",,1150,,,,,,1150,,,,,,,,,1150,,,,,1150,1150,1150,1150,,1150,1150,1150", "1150,,,,,1150,1150,,,,52,52,52,1150,52,1150,1150,1150,52,52,1150,1150", ",52,,52,52,52,52,52,52,52,,,,,,52,52,52,52,52,52,52,,,52,,,,,,,52,,", "52,52,52,52,52,52,52,52,,52,52,52,,52,52,52,52,52,,,,,,,,,,,,,,,,,,", ",52,,,52,,,52,52,,,52,,,,,,52,,,,,,,,,52,,,,,52,52,52,52,,52,52,52,52", ",,,,52,52,,,,129,129,129,52,129,52,52,52,129,129,52,52,,129,,129,129", "129,129,129,129,129,,,,,,129,129,129,129,129,129,129,,,129,,,,,,,129", ",,129,129,129,129,129,129,129,129,,129,129,129,,129,129,129,129,129", ",,,,,,,,,,,,,,,,,,,129,,,129,,,129,129,,,129,,,,,,129,,,,,,,,,129,,", ",,129,129,129,129,,129,129,129,129,,,,,129,129,,,,,,,129,,129,129,129", ",,129,129,124,124,124,124,124,,,,124,124,,,,124,,124,124,124,124,124", "124,124,,,,,,124,124,124,124,124,124,124,,,124,,,,,,124,124,124,124", "124,124,124,124,124,124,124,124,,124,124,124,,124,124,124,124,124,,", ",,,,,,,,,,,,,,,,,124,,,124,,,124,124,,,124,,124,,,,124,,,,,,,,,124,", ",,,124,124,124,124,,124,124,124,124,,,,,124,124,,,,,,124,124,,124,124", "124,,,124,124,1162,1162,1162,,1162,,,,1162,1162,,,,1162,,1162,1162,1162", "1162,1162,1162,1162,,,,,,1162,1162,1162,1162,1162,1162,1162,,,1162,", ",,,,,1162,,,1162,1162,1162,1162,1162,1162,1162,1162,1162,1162,1162,1162", ",1162,1162,1162,1162,1162,,,,,,,,,,,,,,,,,,,,1162,,,1162,,,1162,1162", ",,1162,,1162,,1162,,1162,,,1162,,,,,,1162,,,,,1162,1162,1162,1162,,1162", "1162,1162,1162,,,,,1162,1162,,,,471,471,471,1162,471,1162,1162,1162", "471,471,1162,1162,,471,,471,471,471,471,471,471,471,,,,,,471,471,471", "471,471,471,471,,,471,,,,,,,471,,,471,471,471,471,471,471,471,471,,471", "471,471,,471,471,471,471,471,,,,,,,,,,,,,,,,,,,,471,,,471,,,471,471", ",,471,,,,,,471,,,,,,,,,471,,,,,471,471,471,471,,471,471,471,471,,,,", "471,471,,,,277,277,277,471,277,471,471,471,277,277,471,471,,277,,277", "277,277,277,277,277,277,,,,,,277,277,277,277,277,277,277,,,277,,,,,", ",277,,,277,277,277,277,277,277,277,277,,277,277,277,,277,277,277,277", "277,,,,,,,,,,,,,,,,,,,,277,,,277,,,277,277,,,277,,,,,,277,,,,,,,,,277", ",,,,277,277,277,277,,277,277,277,277,,,,,277,277,,,,,,,277,,277,277", "277,470,,277,277,,,,470,470,470,,,470,470,470,,470,,,,,,,,470,470,470", "470,470,,,,,,,,470,470,,470,470,470,470,470,,,,,,,,,,,,,,,,,,,,,,,470", "470,470,470,470,470,470,470,470,470,470,470,470,470,,,470,470,470,,", "470,,,470,,,470,470,,470,,470,,470,,470,470,,470,470,470,470,470,,470", "470,470,,,,,,,,,,,,,,470,,,470,470,470,470,,470,469,470,,,,,470,469", "469,469,,,469,469,469,,469,,,,,,,,469,469,469,469,469,,,,951,951,951", "951,469,469,,469,469,469,469,469,,,,,951,951,951,,,,,,,,,,,951,951,", ",951,469,469,469,469,469,469,469,469,469,469,469,469,469,469,,,469,469", "469,,,469,,,469,,,469,469,,469,,469,,469,,469,469,,469,469,469,469,469", ",469,469,469,,951,951,951,951,,951,951,951,951,,,,469,951,951,469,469", "469,469,,469,951,469,951,951,951,460,469,7,7,7,7,7,460,460,460,7,7,460", "460,460,7,460,7,7,7,7,7,7,7,460,460,460,460,,7,7,7,7,7,7,7,460,460,7", "460,460,460,460,460,7,7,7,7,7,7,7,7,7,7,7,7,,7,7,7,,7,7,7,7,7,460,460", "460,460,460,460,460,460,460,460,460,460,460,460,,,460,460,460,7,,460", "7,460,460,7,7,460,460,7,460,7,460,,460,7,460,460,,460,460,460,460,460", "7,460,460,460,,7,7,7,7,,7,7,7,7,,,,460,7,7,460,460,,460,,460,7,,7,7", "7,,460,7,7,75,75,75,,75,,,,75,75,,,,75,,75,75,75,75,75,75,75,,,,,,75", "75,75,75,75,75,75,,,75,,,,,,,75,,,75,75,75,75,75,75,75,75,,75,75,75", ",75,75,75,75,75,,,,,,,,,,,,,,,,,,,,75,,,75,,,75,75,,,75,,,,,,75,,,,", ",,,,75,,,,,75,75,75,75,,75,75,75,75,,,,,75,75,75,,,,,75,75,,75,75,75", "64,,75,75,,,,64,64,64,,,64,64,64,,64,,,,,,,,64,,64,64,64,,,,,,,,64,64", ",64,64,64,64,64,,,,,,,,,,,,,,,,,,,,,,,64,64,64,64,64,64,64,64,64,64", "64,64,64,64,,,64,64,64,,,64,,,64,,,64,64,,64,,64,,64,,64,64,,64,64,64", "64,64,,64,,64,,,,,,,,,,,,,,64,,,64,64,64,64,,64,,64,,278,278,278,64", "278,,,,278,278,,,,278,,278,278,278,278,278,278,278,,,,,,278,278,278", "278,278,278,278,,,278,,,,,,,278,,,278,278,278,278,278,278,278,278,,278", "278,278,,278,278,278,278,278,,,,,,,,,,,,,,,,,,,,278,,,278,,,278,278", ",,278,,,,,,278,,,,,,,,,278,,,,,278,278,278,278,,278,278,278,278,,,,", "278,278,,,,221,221,221,278,221,278,278,278,221,221,278,278,,221,,221", "221,221,221,221,221,221,,,,,,221,221,221,221,221,221,221,,,221,,,,,", ",221,,,221,221,221,221,221,221,221,221,,221,221,221,,221,221,221,221", "221,,,,,,,,,,,,,,,,,,,,221,,,221,,,221,221,,,221,,,,,,221,,,,,,,,,221", ",,,,221,221,221,221,,221,221,221,221,,,,,221,221,,,,220,220,220,221", "220,221,221,221,220,220,221,221,,220,,220,220,220,220,220,220,220,,", ",,,220,220,220,220,220,220,220,,,220,,,,,,,220,,,220,220,220,220,220", "220,220,220,,220,220,220,,220,220,220,220,220,,,,,,,,,,,,,,,,,,,,220", ",,220,,,220,220,,,220,,220,,,,220,,,,,,,,,220,,,,,220,220,220,220,,220", "220,220,220,,,,,220,220,,,,800,800,800,220,800,220,220,220,800,800,220", "220,,800,,800,800,800,800,800,800,800,,,,,,800,800,800,800,800,800,800", ",,800,,,,,,,800,,,800,800,800,800,800,800,800,800,,800,800,800,,800", "800,800,800,800,,,,,,,,,,,,,,,,,,,,800,,,800,,,800,800,,,800,,,,,,800", ",,,,,,,,800,,,,,800,800,800,800,,800,800,800,800,,,,,800,800,,,,797", "797,797,800,797,800,800,800,797,797,800,800,,797,,797,797,797,797,797", "797,797,,,,,,797,797,797,797,797,797,797,,,797,,,,,,,797,,,797,797,797", "797,797,797,797,797,,797,797,797,,797,797,797,797,797,,,,,,,,,,,,,,", ",,,,,797,,,797,,,797,797,,,797,,,,,,797,,,,,,,,,797,,,,,797,797,797", "797,,797,797,797,797,,,,,797,797,,,,386,386,386,797,386,797,797,797", "386,386,797,797,,386,,386,386,386,386,386,386,386,,,,,,386,386,386,386", "386,386,386,,,386,,,,,,,386,,,386,386,386,386,386,386,386,386,,386,386", "386,,386,386,386,386,386,,,,,,,,,,,,,,,,,,,,386,,,386,,,386,386,,,386", ",,,,,386,,,,,,,,,386,,,,,386,386,386,386,,386,386,386,386,,,,,386,386", ",,,524,524,524,386,524,386,386,386,524,524,386,386,,524,,524,524,524", "524,524,524,524,,,,,,524,524,524,524,524,524,524,,,524,,,,,,,524,,,524", "524,524,524,524,524,524,524,,524,524,524,,524,524,524,524,524,,,,,,", ",,,,,,,,,,,,,524,,,524,,,524,524,,,524,,,,,,524,,,,,,,,,524,,,,,524", "524,524,524,,524,524,524,524,,,,,524,524,,,,523,523,523,524,523,524", "524,524,523,523,524,524,,523,,523,523,523,523,523,523,523,,,,,,523,523", "523,523,523,523,523,,,523,,,,,,,523,,,523,523,523,523,523,523,523,523", ",523,523,523,,523,523,523,523,523,,,,,,,,,,,,,,,,,,,,523,,,523,,,523", "523,,,523,,,,,,523,,,,,,,,,523,,,,,523,523,523,523,,523,523,523,523", ",,,,523,523,,,,522,522,522,523,522,523,523,523,522,522,523,523,,522", ",522,522,522,522,522,522,522,,,,,,522,522,522,522,522,522,522,,,522", ",,,,,,522,,,522,522,522,522,522,522,522,522,,522,522,522,,522,522,522", "522,522,,,,,,,,,,,,,,,,,,,,522,,,522,,,522,522,,,522,,,,,,522,,,,,,", ",,522,,,,,522,522,522,522,,522,522,522,522,,,,,522,522,,,,520,520,520", "522,520,522,522,522,520,520,522,522,,520,,520,520,520,520,520,520,520", ",,,,,520,520,520,520,520,520,520,,,520,,,,,,,520,,,520,520,520,520,520", "520,520,520,520,520,520,520,,520,520,520,520,520,,,,,,,,,,,,,,,,,,,", "520,,,520,,,520,520,,,520,,520,,520,,520,,,520,,,,,,520,,,,,520,520", "520,520,,520,520,520,520,,,,,520,520,,,,219,219,219,520,219,520,520", "520,219,219,520,520,,219,,219,219,219,219,219,219,219,,,,,,219,219,219", "219,219,219,219,,,219,,,,,,,219,,,219,219,219,219,219,219,219,219,,219", "219,219,,219,219,219,219,219,,,,,,,,,,,,,,,,,,,,219,,,219,,,219,219", ",,219,,219,,,,219,,,,,,,,,219,,,,,219,219,219,219,,219,219,219,219,", ",,,219,219,,,,510,510,510,219,510,219,219,219,510,510,219,219,,510,", "510,510,510,510,510,510,510,,,,,,510,510,510,510,510,510,510,,,510,", ",,,,,510,,,510,510,510,510,510,510,510,510,,510,510,510,,510,510,510", "510,510,,,,,,,,,,,,,,,,,,,,510,,,510,,,510,510,,,510,,,,,,510,,,,,,", ",,510,,,,,510,510,510,510,,510,510,510,510,,,,,510,510,,,,1017,1017", "1017,510,1017,510,510,510,1017,1017,510,510,,1017,,1017,1017,1017,1017", "1017,1017,1017,,,,,,1017,1017,1017,1017,1017,1017,1017,,,1017,,,,,,", "1017,,,1017,1017,1017,1017,1017,1017,1017,1017,,1017,1017,1017,,1017", "1017,,,1017,,,,,,,,,,,,,,,,,,,,1017,,,1017,,,1017,1017,,,1017,,,,,,", ",,,,,,,,,,,,,1017,1017,1017,1017,,1017,1017,1017,1017,,,,,1017,1017", ",,,1081,1081,1081,1017,1081,1017,1017,1017,1081,1081,,,,1081,,1081,1081", "1081,1081,1081,1081,1081,,,,,,1081,1081,1081,1081,1081,1081,1081,,,1081", ",,,,,,1081,,,1081,1081,1081,1081,1081,1081,1081,1081,,1081,1081,1081", ",1081,1081,,,1081,,,,,,,,,,,,,,,,,,,,1081,,,1081,,,1081,1081,,,1081", ",,,,,,,,,,,,,,,,,,,1081,1081,1081,1081,,1081,1081,1081,1081,,,,,1081", "1081,,,,341,341,341,1081,341,1081,1081,1081,341,341,,,,341,,341,341", "341,341,341,341,341,,,,,,341,341,341,341,341,341,341,,,341,,,,,,,341", ",,341,341,341,341,341,341,341,341,,341,341,341,,341,341,,,341,,,,,,", ",,,,,,,,,,,,,341,,,341,,,341,341,,,341,,,1214,,1214,1214,1214,1214,1214", ",,,,,,,,1214,,341,341,341,341,,341,341,341,341,,,,,341,341,,,,341,,1214", "341,,341,341,341,588,588,588,,588,1214,1214,,588,588,1214,,,588,,588", "588,588,588,588,588,588,,,,,,588,588,588,588,588,588,588,,,588,,,,,", ",588,,,588,588,588,588,588,588,588,588,,588,588,588,,588,588,,,588,", ",,,,,,,,,,,,,,,,,,588,,,588,,,588,588,,,588,,,,,,,,,,,,,,,,,,,,588,588", "588,588,,588,588,588,588,,,,,588,588,,,,40,40,40,588,40,588,588,588", "40,40,,,,40,,40,40,40,40,40,40,40,,,,,,40,40,40,40,40,40,40,,,40,,,", ",,,40,,,40,40,40,40,40,40,40,40,,40,40,40,,40,40,,,40,,,,,,,,,,,,,,", ",,,,,40,,,40,,,40,40,,,40,,,1210,,1210,1210,1210,1210,1210,,,,,,,,,1210", ",40,40,40,40,,40,40,40,40,,,,,40,40,,,,40,,1210,40,,40,40,40,803,803", "803,,803,1210,1210,,803,803,1210,,,803,,803,803,803,803,803,803,803", ",,,,,803,803,803,803,803,803,803,,,803,,,,,,,803,,,803,803,803,803,803", "803,803,803,,803,803,803,,803,803,,,803,,,,,,,,,,,,,,,,,,,,803,,,803", ",,803,803,,,803,,,,,,,,,,,,,,,,,,,,803,803,803,803,,803,803,803,803", ",,,,803,803,,,,360,360,360,803,360,803,803,803,360,360,,,,360,,360,360", "360,360,360,360,360,,,,,,360,360,360,360,360,360,360,,,360,,,,,,,360", ",,360,360,360,360,360,360,360,360,,360,360,360,,360,360,,,360,,,,,,", ",,,,,,,,,,,,,360,,,360,,,360,360,,,360,,,,,,,,,,,,,,,,,,,,360,360,360", "360,,360,360,360,360,,,,,360,360,,,,1144,1144,1144,360,1144,360,360", "360,1144,1144,,,,1144,,1144,1144,1144,1144,1144,1144,1144,,,,,,1144", "1144,1144,1144,1144,1144,1144,,,1144,,,,,,,1144,,,1144,1144,1144,1144", "1144,1144,1144,1144,,1144,1144,1144,,1144,1144,,,1144,,,,,,,,,,,,,,", ",,,,,1144,,,1144,,,1144,1144,,,1144,,,,,,,,,,,,,,,,,,,,1144,1144,1144", "1144,,1144,1144,1144,1144,,,,,1144,1144,,,,77,77,77,1144,77,1144,1144", "1144,77,77,,,,77,,77,77,77,77,77,77,77,,,,,,77,77,77,77,77,77,77,,,77", ",,,,,,77,,,77,77,77,77,77,77,77,77,,77,77,77,,77,77,,,77,,,,,,,,,,,", ",,,,,77,,,77,,,77,,,77,77,,,77,,,,,,,,,,,,,,,,,,,,77,77,77,77,,77,77", "77,77,,,,,77,77,,,,814,814,814,77,814,77,77,77,814,814,,,,814,,814,814", "814,814,814,814,814,,,,,,814,814,814,814,814,814,814,,,814,,,,,,,814", ",,814,814,814,814,814,814,814,814,,814,814,814,,814,814,,,814,,,,,,", ",,,,,,,,,,,,,814,,,814,,,814,814,,,814,,,,,,,,,,,,,,,,,,,,814,814,814", "814,,814,814,814,814,,,,,814,814,,,,597,597,597,814,597,814,814,814", "597,597,,,,597,,597,597,597,597,597,597,597,,,,,,597,597,597,597,597", "597,597,,,597,,,,,,,597,,,597,597,597,597,597,597,597,597,,597,597,597", ",597,597,,,597,,,,,,,,,,,,,,,,,,,,597,,,597,,,597,597,,,597,,,,,,,,", ",,,,,,,,,,,597,597,597,597,,597,597,597,597,,,,,597,597,,,,39,39,39", "597,39,597,597,597,39,39,,,,39,,39,39,39,39,39,39,39,,,,,,39,39,39,39", "39,39,39,,,39,,,,,,,39,,,39,39,39,39,39,39,39,39,,39,39,39,,39,39,,", "39,,,,,,,,,,,,,,,,,,,,39,,,39,,,39,39,,,39,,39,,,,,,,,,,,,,,,,,,39,39", "39,39,,39,39,39,39,,,,,39,39,,,,76,76,76,39,76,39,39,39,76,76,,,,76", ",76,76,76,76,76,76,76,,,,,,76,76,76,76,76,76,76,,,76,,,,,,,76,,,76,76", "76,76,76,76,76,76,,76,76,76,,76,76,,,76,,,,,,,,,,,,,,,,,,,,76,,,76,", ",76,76,,,76,,76,,,,,,,,,,,,,,,,,,76,76,76,76,,76,76,76,76,,,,,76,76", ",,,78,78,78,76,78,76,76,76,78,78,,,,78,,78,78,78,78,78,78,78,,,,,,78", "78,78,78,78,78,78,,,78,,,,,,,78,,,78,78,78,78,78,78,78,78,,78,78,78", ",78,78,,,78,,,,,,,,,,,,,,,,,,,,78,,,78,,,78,78,,,78,,,,,,,,,,,,,,,,", ",,,78,78,78,78,,78,78,78,78,,,,,78,78,,,,,,,78,,78,78,78,10,10,10,10", "10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,,,,10,10", "10,10,10,10,10,10,10,10,,,,,,10,10,10,10,10,10,10,10,10,10,,10,,,,,", ",,10,10,,10,10,10,10,10,10,10,,,10,10,,,,10,10,10,10,,,,,,,,,,,,,,10", "10,,10,10,10,10,10,10,10,10,10,10,10,10,,,10,10,,,,,,,,,,,,,,10,427", "427,427,427,427,427,427,427,427,427,427,427,427,427,427,427,427,427", "427,427,427,427,427,427,,,,427,427,427,427,427,427,427,427,427,427,", ",,,,427,427,427,427,427,427,427,427,427,,,427,,,,,,,,427,427,,427,427", "427,427,427,427,427,,,427,427,,,,427,427,427,427,,,,,,,,,,,,,,427,427", ",427,427,427,427,427,427,427,427,427,427,427,427,,,427,427,,,,,,,,,", ",,,,427,667,667,667,667,667,667,667,667,667,667,667,667,667,667,667", "667,667,667,667,667,667,667,667,667,,,,667,667,667,667,667,667,667,667", "667,667,,,,,,667,667,667,667,667,667,667,667,667,,,667,,,,,,,,667,667", ",667,667,667,667,667,667,667,,,667,667,,,,667,667,667,667,,,,,,,,,,", ",,,667,667,,667,667,667,667,667,667,667,667,667,667,667,667,,,667,667", ",,,,,,,,,,,,,667,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11", "11,11,11,11,11,11,11,,,,11,11,11,11,11,11,11,11,11,11,,,,,,11,11,11", "11,11,11,11,11,11,,,11,,,,,,,,11,11,,11,11,11,11,11,11,11,,,11,11,,", ",11,11,11,11,,,,,,,,,,,,,,11,11,,11,11,11,11,11,11,11,11,11,11,11,11", ",,11,11,,,,,,,,,,,,,,11,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26", "26,26,26,26,26,26,26,26,26,,,,26,26,26,26,26,26,26,26,26,26,,,,,,26", "26,26,26,26,26,26,26,26,26,26,26,,26,,,,,,26,26,,26,26,26,26,26,26,26", ",,26,26,,,,26,26,26,26,,,,,,26,,,,,,,,26,26,,26,26,26,26,26,26,26,26", "26,26,26,26,,,26,753,753,753,753,,,,,,1026,,1026,1026,1026,1026,1026", "753,753,753,753,,,,753,1026,,,,,753,753,,,753,,,,,,,,,,,,,1026,,,,,", ",753,,,753,1026,1026,,753,,1026,753,,,,,,,,,,,,,,,,753,,,,753,753,753", "753,,753,753,753,753,,,,,753,753,1205,1205,1205,1205,1026,,753,,753", "753,753,,,753,753,,1205,1205,1205,1205,,,1208,1205,1208,1208,1208,1208", "1208,1205,1205,,,1205,,,,1208,,,,,,,,,,,,,,,,1205,,,1205,,,1208,1205", ",,1205,,,,,1208,1208,1208,1208,,,,1208,,,,1205,,,,1205,1205,1205,1205", ",1205,1205,1205,1205,,,,,1205,1205,1129,1129,1129,1129,,,1205,,1205", "1205,1205,,,1205,1205,,1129,1129,1129,1129,,,1138,1129,1138,1138,1138", "1138,1138,1129,1129,,,1129,,,,1138,,,,,,,,,,,,,,,,1129,,,1129,,,1138", "1129,,,1129,,1129,,,1138,1138,1138,1138,,,,1138,,,,1129,,,,1129,1129", "1129,1129,,1129,1129,1129,1129,,,,,1129,1129,989,989,989,989,,,1129", ",1129,1129,1129,,,1129,1129,,989,989,989,989,,,,989,989,,,,,989,989", ",,989,989,,,,,,,,,,,,,,,,,,,989,,,989,,,,989,,,989,,989,,,,,,,989,,", ",,,,989,,,,989,989,989,989,,989,989,989,989,,,,,989,989,942,942,942", "942,,,989,,989,989,989,,,989,989,,942,942,942,942,,,1135,942,1135,1135", "1135,1135,1135,942,942,,,942,,,,1135,,,,,,,,,,,,,,,,942,,,942,,,1135", "942,,,942,,,,,1135,1135,1135,1135,,,,1135,,,,942,,,,942,942,942,942", ",942,942,942,942,,,,,942,942,924,924,924,924,,,942,,942,942,942,,,942", "942,,924,924,924,924,,,1231,924,1231,1231,1231,1231,1231,924,924,,,924", ",,,1231,,,,,,,,,,,,,,,,924,,,924,,,1231,924,,,924,,924,,,,,1231,1231", ",,,1231,,,,924,,,,924,924,924,924,,924,924,924,924,,,,,924,924,745,745", "745,745,,,924,,924,924,924,,,924,924,,745,745,745,745,,,,745,,,,,,745", "745,,,745,,,,,,,,,,,,,,,,,,,,745,,,745,,,,745,,,745,,745,,,,,,,1166", ",1166,1166,1166,1166,1166,745,,,,745,745,745,745,1166,745,745,745,745", ",,,,745,745,745,943,943,943,943,,745,,745,745,745,1166,,745,745,,,943", "943,943,943,,1166,1166,943,,,1166,,,943,943,,,943,,,,,,,,,,,,,,,,,,", ",943,,,943,,,,943,,,943,,,1166,,,,,,,,,,,,,943,,,,943,943,943,943,,943", "943,943,943,,,,,943,943,930,930,930,930,,,943,,943,943,943,,,943,943", ",930,930,930,930,,,,930,930,,,,,930,930,,,930,930,,,,,,,,,,,,,,,,,,", "930,,,930,,,,930,,,930,,930,,,,,,,930,,,,,,,930,,,,930,930,930,930,", "930,930,930,930,,,,,930,930,929,929,929,929,,,930,,930,930,930,,,930", "930,,929,929,929,929,,,,929,929,,,,,929,929,,,929,929,,,,,,,,,,,,,,", ",,,,929,,,929,,,,929,,,929,,929,,,,,,,929,,,,,,,929,,,,929,929,929,929", ",929,929,929,929,,,,,929,929,,,,,,,929,,929,929,929,,,929,929,780,780", "780,780,780,780,780,780,780,780,780,780,780,780,780,780,780,780,780", "780,780,780,780,780,,,,780,780,780,780,780,780,780,780,780,780,,,,,", "780,780,780,780,780,780,780,780,780,,,780,,,,,,,,780,780,,780,780,780", "780,780,780,780,,,780,780,,,,780,780,780,780,,,,,,,,,,,,,,780,780,,780", "780,780,780,780,780,780,780,780,780,780,780,,,780,528,528,528,528,,", "1212,,1212,1212,1212,1212,1212,,,,528,528,528,528,,1212,,528,528,,,", ",528,528,,,528,528,,,,,,,,,1212,,,,,,,,,,528,1212,1212,528,,,1212,528", ",,528,,528,,,,,,,528,,,,,,,528,,,,528,528,528,528,,528,528,528,528,", ",,,528,528,527,527,527,527,,,528,,528,528,528,,,528,528,,527,527,527", "527,,,,527,527,,,,,527,527,,,527,527,,,,,,,,,,,,,,,,,,,527,,,527,,,", "527,,,527,,527,,,,,,,527,,,,,,,527,,,,527,527,527,527,,527,527,527,527", ",,,,527,527,1173,1173,1173,1173,,,527,,527,527,527,,,527,527,,1173,1173", "1173,1173,,,,1173,,,,,,1173,1173,,,1173,,,,,,,,,,,,,,,,,,,,1173,,,1173", ",,,1173,,,1173,,,,,,,,,,,,,,,,1173,,,,1173,1173,1173,1173,,1173,1173", "1173,1173,,,,,1173,1173,1116,1116,1116,1116,,,1173,,1173,1173,1173,", ",1173,1173,,1116,1116,1116,1116,,,,1116,,,,,,1116,1116,,,1116,,,,,,", ",,,,,,,,,,,,,1116,,,1116,,,,1116,,,1116,,,,,,,,,,,,,,,,1116,,,,1116", "1116,1116,1116,,1116,1116,1116,1116,,,,,1116,1116,926,926,926,926,,", "1116,,1116,1116,1116,,,1116,1116,,926,926,926,926,,,,926,,,,,,926,926", ",,926,,,,,,,,,,,,,,,,,,,,926,,,926,,,,926,,,926,,,,,,,,,,,,,,,,926,", ",,926,926,926,926,,926,926,926,926,,,,,926,926,1125,1125,1125,1125,", ",926,,926,926,926,,,926,926,,1125,1125,1125,1125,,,,1125,,,,,,1125,1125", ",,1125,,,,,,,,,,,,,,,,,,,,1125,,,1125,,,,1125,,,1125,,,,,,,,,,,,,,,", "1125,,,,1125,1125,1125,1125,,1125,1125,1125,1125,,,,,1125,1125,936,936", "936,936,,,1125,,1125,1125,1125,,,1125,1125,,936,936,936,936,,,,936,", ",,,,936,936,,,936,,,,,,,,763,763,763,763,,,,,,,,,936,,,936,763,763,763", "936,,,936,,936,,,,,763,763,,,763,,,,,936,,,,936,936,936,936,,936,936", "936,936,,,,,936,936,,,,,,,936,,936,936,936,,,936,936,233,,233,233,233", "233,233,,,,,763,763,763,763,233,763,763,763,763,,,,,763,763,950,950", "950,950,,,763,,763,763,763,233,,,,,950,950,950,,233,233,233,233,,,,233", ",950,950,,,950,,,,,,,,,,,,705,,705,705,705,705,705,,,,,,,,,705,,,,,", "234,233,234,234,234,234,234,,,,,,,,,234,705,950,950,950,950,,950,950", "950,950,,705,705,,950,950,705,,,,,234,950,,950,950,950,,,,234,234,234", "234,,,409,234,409,409,409,409,409,,1020,,1020,1020,1020,1020,1020,409", ",,,,705,,,1020,,644,,644,644,644,644,644,,,,,,409,409,,644,234,,,,1020", "409,409,409,409,,,,409,1020,1020,1020,1020,,,,1020,644,,,,,,,,,644,644", "644,644,,,1024,644,1024,1024,1024,1024,1024,,,,,,,,,1024,409,,,,,,,", "1020,,,,,,,,,,,,,1024,,,,644,,,,,,,1024,1024,675,675,,1024,675,,,,,", ",,675,675,,675,675,675,675,675,675,675,,,675,675,,,,675,675,675,675", ",,,,,675,,,,,1024,,,675,675,,675,675,675,675,675,675,675,675,675,675", "675,675,636,636,675,,636,,,,,,,,636,636,,636,636,636,636,636,636,636", ",,636,636,,,,636,636,636,636,,,,,,636,,,,,,,,636,636,,636,636,636,636", "636,636,636,636,636,636,636,636,629,629,636,,629,,,,,,,,629,629,,629", "629,629,629,629,629,629,,,629,629,,,,629,629,629,629,,,,,,629,,,,,,", ",629,629,,629,629,629,629,629,629,629,629,629,629,629,629,226,226,629", ",226,,,,,,,,226,226,,226,226,226,226,226,226,226,,,226,226,,,,226,226", "226,226,,,,,,226,,,,,,,,226,226,,226,226,226,226,226,226,226,226,226", "226,226,226,602,602,226,,602,,,,,,,,602,602,,602,602,602,602,602,602", "602,,,602,602,,,,602,602,602,602,,,,,,602,,,,,,,,602,602,,602,602,602", "602,602,602,602,602,602,602,602,602,637,637,602,,637,,,,,,,,637,637", ",637,637,637,637,637,637,637,,,637,637,,,,637,637,637,637,,,,,,637,", ",,,,,,637,637,,637,637,637,637,637,637,637,637,637,637,637,637,225,225", "637,,225,,,,,,,,225,225,,225,225,225,225,225,225,225,,,225,225,,,,225", "225,225,225,,,,,,225,,,,,,,,225,225,,225,225,225,225,225,225,225,225", "225,225,225,225,302,302,225,,302,,,,,,,,302,302,,302,302,302,302,302", "302,302,,,302,302,,,,302,302,302,302,,,,,,,,,,,,,,302,302,,302,302,302", "302,302,302,302,302,302,302,302,302,519,519,302,,519,,,,,,,,519,519", ",519,519,519,519,519,519,519,,,519,519,,,,519,519,519,519,,,,,,519,", ",,,,,,519,519,,519,519,519,519,519,519,519,519,519,519,519,519,518,518", "519,,518,,,,,,,,518,518,,518,518,518,518,518,518,518,,,518,518,,,,518", "518,518,518,,,,,,518,,,,,,,,518,518,,518,518,518,518,518,518,518,518", "518,518,518,518,591,591,518,,591,,,,,,,,591,591,,591,591,591,591,591", "591,591,,,591,591,,,,591,591,591,591,,,,,,591,,,,,,,,591,591,,591,591", "591,591,591,591,591,591,591,591,591,591,592,592,591,,592,,,,,,,,592", "592,,592,592,592,592,592,592,592,,,592,592,,,,592,592,592,592,,,,,,592", ",,,,,,,592,592,,592,592,592,592,592,592,592,592,592,592,592,592,1163", "1163,592,,1163,,,,,,,,1163,1163,,1163,1163,1163,1163,1163,1163,1163", ",,1163,1163,,,,1163,1163,1163,1163,,,,,,1163,,,,,,,,1163,1163,,1163", "1163,1163,1163,1163,1163,1163,1163,1163,1163,1163,1163,674,674,1163", ",674,,,,,,,,674,674,,674,674,674,674,674,674,674,,,674,674,,,,674,674", "674,674,,,,,,674,,,,,,,,674,674,,674,674,674,674,674,674,674,674,674", "674,674,674,1164,1164,674,,1164,,,,,,,,1164,1164,,1164,1164,1164,1164", "1164,1164,1164,,,1164,1164,,,,1164,1164,1164,1164,,,,,,1164,,,,,,,,1164", "1164,,1164,1164,1164,1164,1164,1164,1164,1164,1164,1164,1164,1164,630", "630,1164,,630,,,,,,,,630,630,,630,630,630,630,630,630,630,,,630,630", ",,,630,630,630,630,,,,,,630,,,,,,,,630,630,,630,630,630,630,630,630", "630,630,630,630,630,630,1188,1188,630,,1188,,,,,,,,1188,1188,,1188,1188", "1188,1188,1188,1188,1188,,,1188,1188,,,,1188,1188,1188,1188,,,,,,1188", ",,,,,,,1188,1188,,1188,1188,1188,1188,1188,1188,1188,1188,1188,1188", "1188,1188,601,601,1188,,601,,,,,,,,601,601,,601,601,601,601,601,601", "601,,,601,601,,,,601,601,601,601,,,,,,601,,,,,,,,601,601,,601,601,601", "601,601,601,601,601,601,601,601,601,,,601"];
      racc_action_check = (arr = $$$('Array').$new(28717, nil));
      idx = 0;
      $send(clist, 'each', [], function $Ruby31$4(str){
        
        
        if (str == null) str = nil;;
        return $send(str.$split(",", -1), 'each', [], function $$5(i){
          
          
          if (i == null) i = nil;;
          if (!$truthy(i['$empty?']())) {
            arr['$[]='](idx, i.$to_i())
          };
          return (idx = $rb_plus(idx, 1));}, 1);}, 1);
      racc_action_pointer = [nil, 1550, 2590, 30, nil, 485, nil, 21057, 1279, -15, 24908, 25292, 63, nil, 111, 130, 888, 195, 878, 334, 213, 587, nil, -72, 16018, 1438, 25420, 260, nil, 586, nil, 10, 7680, 8479, 8613, 9947, 10209, nil, 1870, 24507, 23582, nil, 199, 495, 356, 292, 12722, 13115, 252, 13377, 14041, 977, 19960, 226, 694, nil, nil, nil, nil, nil, nil, nil, nil, nil, 21341, nil, 15494, 15351, 14696, 170, nil, 14434, 14303, nil, nil, 21200, 24638, 24114, 24769, nil, nil, nil, nil, nil, nil, nil, nil, nil, 877, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 610, nil, nil, 722, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 20234, nil, nil, nil, nil, 20091, 19567, 19436, 19305, 19174, nil, 4318, nil, -26, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 266, nil, 4462, 22788, 21740, 21609, 14172, 13910, 13779, 27931, 27748, nil, nil, 264, 2734, 305, nil, 27294, 27386, 317, 1294, 12043, 11912, 11257, nil, nil, 1133, 138, 140, 432, 174, 389, 452, nil, 10078, 131, 191, 3022, 455, nil, nil, 7277, 7146, 7015, 6753, 6491, 6360, 6229, 6098, 5967, 18507, 18376, 18245, 17590, 17459, 17328, 16411, 16149, 15756, 15220, 15089, 20639, 21478, nil, nil, nil, nil, 13648, nil, nil, 583, 548, 381, -62, 413, 376, 696, 695, 584, 585, nil, nil, nil, 15625, nil, nil, 27992, nil, nil, 484, 16673, 17066, nil, nil, nil, nil, nil, nil, nil, 17197, nil, 2446, nil, 455, 459, nil, 17721, 512, 17852, nil, nil, 17983, 18114, nil, nil, -73, nil, 5836, 1711, 509, 484, 1726, 513, 564, 525, 23312, 2878, 999, 1139, 614, 617, 582, nil, 610, 571, 253, 616, 644, nil, nil, nil, 650, 171, 611, 23852, nil, 471, 1022, 3742, 3886, 687, nil, 691, 12591, nil, 677, 2302, 1567, 638, nil, 541, 621, 676, 662, 651, 690, nil, 870, 35, 36, 22133, 1006, 4894, 459, 766, 651, 25, 39, 730, 747, 4, 793, nil, nil, 1141, 1285, 370, nil, 692, nil, 714, 14827, nil, 27438, nil, 531, 386, 291, 288, 421, 142, 191, 396, nil, nil, nil, nil, nil, nil, nil, 713, 25036, nil, nil, nil, nil, 726, nil, 798, 717, 14565, 725, nil, nil, 715, nil, 690, -60, 819, nil, nil, 1582, nil, nil, nil, nil, nil, 1870, 735, nil, 740, 749, 217, 251, 21057, nil, nil, nil, 0, 861, 795, nil, nil, 20916, 20780, 20508, 880, 882, nil, nil, 769, 775, 780, nil, nil, 785, 787, 809, nil, nil, nil, nil, nil, nil, nil, nil, nil, 801, 1280, nil, nil, 19031, nil, nil, nil, 1, nil, nil, nil, 899, nil, nil, 901, 579, 22919, 951, nil, nil, nil, -26, nil, 885, 28114, 28053, 22657, -85, 22526, 22395, 22264, 835, 853, 26710, 26612, 3454, 5300, 814, 855, 936, 938, 947, 952, 5693, 5431, 5562, 5169, 5038, 4894, 4750, 4606, 4462, 3482, 3568, 4318, 4174, 2590, 4030, nil, 154, nil, 13518, nil, nil, nil, nil, 13246, 889, 897, 901, nil, nil, nil, 902, nil, nil, 12984, nil, 12853, nil, 12460, nil, 219, nil, nil, nil, 12317, 1438, nil, 904, 909, nil, nil, 910, 23451, 916, 12174, 28175, 28236, 995, 958, nil, nil, 24376, 929, nil, 11781, 28602, 27809, 11650, 3598, 11388, nil, 1066, 947, 990, nil, 11126, nil, nil, 10995, nil, nil, nil, 4030, 1075, nil, 3742, 25, 1080, 1084, 37, 1086, 10733, 10602, 27687, 28480, -5, nil, nil, 472, nil, 27626, 27870, 10340, nil, nil, 191, 2014, nil, 27463, nil, nil, nil, nil, 1249, nil, nil, nil, 977, nil, nil, 247, nil, 286, nil, nil, 966, nil, 968, nil, nil, nil, 25164, nil, 9816, 971, 9673, 9411, 9280, 28358, 27565, 9018, 8875, 733, 1011, 8744, 8076, 7945, 7814, 1017, nil, nil, 7539, 7408, 1021, nil, 1075, 1726, 1105, 6884, nil, nil, 1120, nil, nil, 376, 13512, nil, 13482, nil, 27365, nil, 975, 6622, nil, 1310, nil, 992, 997, 1057, 1002, nil, nil, nil, nil, nil, nil, 1090, 2014, nil, nil, nil, 307, 332, 222, 361, 1006, 5693, 5562, nil, 120, nil, nil, nil, nil, 1029, nil, nil, nil, 555, 26091, 311, nil, 1007, 1092, 1014, nil, nil, 25503, nil, nil, 375, nil, nil, 586, nil, nil, 861, 27241, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 791, 464, nil, nil, 1016, 26529, nil, 1148, nil, 1131, 4, nil, nil, 16280, nil, 1046, 1053, 1154, nil, 1041, nil, 1088, 22002, nil, nil, 21871, nil, 109, 23721, 1044, nil, 1048, -1, 233, 1103, 249, 799, 1117, 1088, 24245, nil, 1156, 2158, 10864, nil, nil, nil, 372, 876, nil, 1213, nil, nil, nil, nil, nil, 1219, 1220, nil, nil, 6, 1101, -21, -19, 68, 7, 1150, 997, 989, nil, 1103, 4606, 14958, nil, 1227, 22, 1107, nil, nil, nil, nil, nil, 4750, nil, nil, nil, nil, nil, nil, nil, nil, 1106, 15887, 1110, 387, 385, 110, 500, nil, 2302, 16542, nil, 1110, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 16804, 16935, 1236, nil, 3886, 1121, 1169, nil, nil, 1129, nil, 1212, nil, nil, 1131, 1136, nil, 1141, 1143, nil, 1144, nil, nil, nil, 1150, 1204, 507, nil, nil, 18638, 18769, 18900, 5169, 5300, 5431, 333, 25993, 1231, 27004, -65, -35, 26386, 26288, 480, -32, 1154, 1155, nil, 27200, nil, 1154, 747, nil, 1178, 25895, 26190, nil, 929, 1243, 281, nil, nil, 27339, 20916, nil, nil, nil, nil, 8207, nil, nil, nil, nil, nil, 8338, nil, nil, 1227, nil, nil, 1237, 1224, nil, nil, 429, 2446, nil, nil, nil, nil, 1227, 250, nil, 137, nil, 1357, nil, 9149, 1361, nil, nil, 25797, 9542, 5038, -18, 1362, nil, 1363, 369, 1582, nil, nil, nil, nil, 1238, 1285, 1249, 1247, 304, nil, nil, 10471, 3310, 3166, nil, 3166, nil, nil, -10, 23050, nil, nil, 27446, nil, 497, nil, 27515, nil, 25493, nil, nil, nil, nil, 1248, 1250, 3022, 2878, 11519, nil, 1251, nil, nil, nil, nil, 1257, 1258, 1260, 1262, 1263, 1264, nil, nil, nil, 1309, 1267, -39, nil, 1276, nil, nil, -66, 1275, nil, nil, nil, nil, nil, nil, 1323, 2734, 2158, nil, nil, 1285, 1286, nil, 1287, 1288, 1291, nil, 1316, 1296, 1283, 23181, nil, nil, nil, nil, nil, 8, nil, 26, 771, nil, 40, nil, nil, nil, 1420, 3454, 3310, 1136, nil, nil, nil, 1438, 32, 33, 872, 1376, 34, nil, 1302, 1312, 1313, 1314, 1348, 3584, 26906, nil, nil, nil, nil, nil, nil, nil, 1317, 27102, nil, 145, nil, 25699, nil, nil, 815, nil, nil, 25898, nil, nil, 25702, nil, 13537, nil, nil, 1342, 23983, 763, 1397, 3598, nil, 19698, 19829, nil, nil, nil, nil, 1341, 1454, 713, nil, nil, nil, 1457, 20377, 28297, 28419, 69, 26144, nil, nil, nil, nil, 1332, 1333, 26808, 1341, nil, nil, 1342, nil, nil, 1361, 1365, 1382, 1385, nil, 1386, nil, 618, 28541, nil, 973, 4174, nil, nil, nil, nil, nil, 1195, nil, 1392, 76, 79, 109, 136, 1391, 25601, 1394, nil, 25604, nil, 23629, nil, 26599, nil, 23359, nil, nil, 1439, 1442, nil, 362, nil, 142, nil, 1399, 1401, 1404, 1409, nil, nil, nil, 25996, nil, nil, nil, nil, -129, nil];
      racc_action_default = [-1, -745, -4, -745, -2, -730, -5, -745, -8, -745, -745, -745, -745, -31, -745, -745, -36, -745, -745, -639, -639, -311, -52, -732, -745, -61, -745, -69, -70, -71, -75, -287, -287, -287, -324, -352, -353, -87, -13, -91, -99, -101, -745, -626, -627, -745, -745, -745, -745, -745, -745, -239, -745, -732, -258, -302, -303, -304, -305, -306, -307, -308, -309, -310, -718, -313, -317, -744, -707, -333, -335, -745, -745, -63, -63, -730, -745, -745, -745, -354, -355, -357, -358, -359, -360, -419, -563, -564, -565, -566, -587, -569, -570, -589, -591, -574, -579, -583, -585, -601, -602, -603, -587, -605, -607, -608, -609, -610, -716, -615, -616, -717, -618, -619, -620, -621, -622, -623, -624, -625, -630, -631, 1238, -3, -731, -740, -741, -742, -7, -745, -745, -745, -745, -745, -9, -4, -19, -745, -130, -131, -132, -133, -134, -135, -136, -140, -141, -142, -143, -144, -145, -146, -147, -148, -149, -150, -151, -152, -153, -154, -155, -156, -157, -158, -159, -160, -161, -162, -163, -164, -165, -166, -167, -168, -169, -170, -171, -172, -173, -174, -175, -176, -177, -178, -179, -180, -181, -182, -183, -184, -185, -186, -187, -188, -189, -190, -191, -192, -193, -194, -195, -196, -197, -198, -199, -200, -201, -202, -203, -204, -205, -206, -207, -208, -209, -210, -24, -137, -13, -745, -745, -745, -745, -745, -277, -745, -745, -728, -729, -745, -13, -638, -636, -662, -662, -745, -13, -745, -745, -732, -733, -56, -745, -626, -627, -745, -311, -745, -745, -245, -745, -639, -639, -13, -745, -57, -59, -222, -223, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -745, -259, -260, -261, -262, -745, -65, -66, -745, -130, -131, -170, -171, -172, -188, -193, -200, -203, -626, -627, -705, -745, -428, -430, -745, -726, -727, -76, -277, -745, -332, -434, -443, -445, -82, -440, -83, -732, -84, -265, -282, -292, -292, -286, -290, -293, -745, -587, -709, -713, -745, -85, -86, -730, -14, -745, -17, -745, -89, -13, -732, -745, -92, -95, -13, -107, -108, -745, -745, -115, -324, -327, -732, -745, -639, -639, -352, -353, -356, -441, -745, -97, -745, -103, -321, -745, -224, -225, -606, -233, -234, -745, -246, -251, -13, -315, -732, -266, -737, -737, -745, -745, -737, -745, -334, -62, -745, -745, -745, -13, -13, -730, -745, -731, -626, -627, -745, -745, -311, -745, -370, -371, -125, -126, -745, -128, -745, -311, -634, -745, -348, -662, -567, -745, -745, -745, -745, -745, -745, -745, -745, -6, -743, -25, -26, -27, -28, -29, -745, -745, -21, -22, -23, -138, -745, -32, -35, -298, -745, -745, -297, -33, -745, -37, -745, -311, -49, -51, -211, -270, -293, -53, -54, -38, -212, -270, -732, -278, -292, -292, -719, -720, -287, -438, -721, -722, -720, -719, -287, -437, -439, -721, -722, -745, -555, -745, -383, -384, -732, -704, -704, -644, -645, -647, -647, -647, -661, -663, -664, -665, -666, -667, -668, -669, -670, -671, -745, -673, -675, -677, -682, -684, -685, -688, -693, -695, -696, -698, -699, -700, -702, -745, -745, -745, -48, -219, -55, -732, -331, -745, -745, -745, -277, -321, -745, -745, -745, -745, -745, -745, -745, -220, -221, -226, -227, -228, -229, -230, -231, -235, -236, -237, -238, -240, -241, -242, -243, -244, -247, -248, -249, -250, -732, -263, -67, -732, -449, -287, -719, -720, -73, -77, -663, -732, -292, -732, -288, -447, -449, -732, -326, -283, -745, -284, -745, -289, -745, -294, -745, -712, -715, -12, -731, -16, -18, -732, -88, -319, -104, -93, -745, -732, -277, -745, -745, -114, -745, -638, -606, -745, -100, -105, -745, -745, -745, -745, -264, -745, -328, -745, -732, -745, -267, -739, -738, -269, -739, -322, -323, -708, -13, -361, -362, -13, -745, -745, -745, -745, -745, -745, -277, -745, -745, -321, -63, -125, -126, -127, -745, -745, -277, -344, -632, -745, -13, -420, -662, -423, -568, -588, -593, -745, -595, -571, -590, -745, -592, -573, -745, -576, -745, -578, -581, -745, -582, -745, -604, -10, -20, -745, -30, -745, -301, -745, -745, -277, -745, -745, -745, -745, -442, -745, -279, -281, -745, -745, -78, -276, -435, -745, -745, -80, -436, -44, -254, -744, -744, -350, -637, -745, -642, -643, -745, -745, -654, -745, -657, -745, -659, -745, -745, -372, -745, -374, -376, -379, -382, -732, -676, -686, -687, -697, -701, -640, -46, -256, -351, -330, -734, -719, -720, -719, -720, -732, -745, -745, -58, -463, -466, -467, -468, -469, -471, -473, -476, -477, -534, -732, -489, -492, -504, -508, -513, -515, -516, -519, -520, -587, -523, -525, -526, -527, -532, -533, -745, -745, -537, -538, -539, -540, -541, -542, -543, -544, -545, -546, -547, -745, -745, -553, -60, -745, -745, -706, -745, -450, -72, -431, -447, -272, -279, -274, -745, -409, -745, -325, -292, -291, -295, -745, -710, -711, -745, -15, -90, -745, -96, -102, -732, -719, -720, -275, -723, -113, -745, -98, -745, -218, -232, -252, -745, -314, -316, -318, -737, -744, -363, -744, -64, -364, -365, -338, -339, -745, -745, -455, -341, -745, -732, -719, -720, -723, -320, -13, -125, -126, -129, -732, -13, -745, -346, -745, -745, -732, -594, -597, -598, -599, -600, -13, -572, -575, -577, -580, -584, -586, -139, -34, -299, -745, -732, -719, -720, -720, -719, -50, -271, -745, -735, -292, -40, -214, -41, -215, -79, -42, -217, -43, -216, -81, -745, -745, -744, -368, -13, -556, -744, -557, -558, -704, -683, -688, -703, -646, -647, -647, -674, -647, -647, -694, -647, -671, -386, -689, -732, -745, -745, -381, -672, -745, -745, -745, -745, -745, -745, -442, -464, -745, -745, -474, -475, -745, -745, -745, -494, -732, -732, -488, -495, -501, -745, -745, -491, -745, -745, -745, -507, -514, -518, -745, -522, -524, -530, -531, -535, -536, -548, -549, -745, -611, -612, -613, -126, -551, -745, -68, -429, -409, -433, -432, -745, -732, -444, -410, -732, -13, -446, -285, -296, -714, -94, -442, -106, -732, -268, -745, -366, -745, -745, -340, -342, -745, -745, -13, -442, -745, -442, -745, -745, -13, -349, -421, -424, -426, -413, -745, -745, -300, -442, -39, -213, -280, -45, -255, -11, -13, -562, -369, -745, -745, -560, -641, -745, -650, -745, -652, -745, -655, -745, -658, -660, -373, -375, -377, -380, -47, -257, -745, -465, -504, -470, -472, -481, -485, -732, -732, -732, -732, -732, -732, -552, -486, -487, -511, -496, -499, -502, -732, -587, -736, -732, -505, -509, -512, -517, -521, -528, -529, -745, -253, -13, -74, -273, -704, -704, -390, -392, -392, -392, -408, -745, -732, -671, -679, -680, -691, -448, -329, -336, -745, -337, -745, -460, -295, -744, -343, -345, -633, -745, -13, -13, -745, -422, -596, -561, -13, -626, -627, -745, -745, -311, -559, -647, -647, -647, -647, -745, -745, -745, -478, -479, -480, -482, -483, -484, -503, -497, -745, -490, -745, -493, -745, -550, -451, -745, -388, -389, -393, -399, -401, -745, -404, -745, -406, -411, -745, -745, -678, -745, -13, -456, -745, -745, -452, -453, -454, -347, -745, -745, -732, -415, -417, -418, -555, -277, -745, -745, -321, -745, -648, -651, -653, -656, -378, -505, -745, -500, -506, -510, -704, -681, -391, -392, -392, -392, -392, -692, -392, -412, -690, -745, -321, -744, -13, -461, -462, -425, -427, -414, -745, -554, -732, -719, -720, -723, -320, -647, -745, -498, -387, -745, -396, -745, -398, -745, -402, -745, -405, -407, -320, -723, -367, -744, -416, -442, -649, -392, -392, -392, -392, -457, -458, -459, -745, -394, -397, -400, -403, -392, -395];
      clist = ["44,411,301,309,313,44,141,141,318,318,318,340,285,418,454,493,493,284", "382,384,385,473,141,389,297,19,626,511,709,832,19,693,460,466,356,356", "44,344,344,635,127,698,699,571,225,618,621,339,563,702,704,706,144,144", "890,303,708,598,897,241,983,19,352,352,44,134,387,388,366,136,217,356", "356,356,393,297,297,421,422,423,424,798,232,232,305,312,314,907,8,19", "795,445,795,8,445,302,561,678,940,352,352,352,359,734,778,737,737,790", "445,555,127,124,438,439,1003,451,383,383,236,559,383,715,44,798,610", "613,1160,1059,617,512,375,44,904,44,1158,484,484,756,756,123,229,235", "336,1037,4,476,509,19,320,320,320,1030,373,973,1032,1184,19,1075,19", "1016,782,128,2,607,656,658,17,1012,338,1044,1047,17,792,801,383,383", "383,383,216,1055,571,377,380,933,595,595,986,399,516,434,798,493,934", "406,408,427,527,461,318,528,795,795,17,826,952,953,286,780,786,390,8", "667,652,654,657,657,44,369,605,425,378,8,470,785,1160,1184,298,432,44", "379,17,397,1221,639,44,1078,576,372,608,374,818,19,846,19,709,997,19", "642,915,1031,1077,44,1136,19,433,444,1079,1157,444,19,19,831,339,903", "568,905,449,450,518,319,319,319,444,844,643,999,19,426,419,409,318,318", "850,514,515,804,1097,584,17,318,1098,554,565,566,813,965,1151,17,1089", "17,1172,1228,376,989,1191,1038,1039,899,795,1174,731,484,303,929,232", "232,316,329,330,930,1180,645,939,309,942,460,466,1068,968,313,1061,44", "599,1062,622,44,356,912,955,344,44,894,1143,1,553,410,339,412,1175,413", "236,339,552,1030,1171,356,19,1206,344,414,19,415,1036,416,352,19,127", "1042,1045,417,44,591,525,526,923,852,1043,1046,596,857,806,847,17,352", "17,44,44,17,935,601,902,582,1064,1065,17,19,623,624,809,898,17,17,1178", "587,907,,,1126,809,,19,19,,961,,,,17,836,581,629,320,,141,127,696,493", "1219,845,320,,383,685,849,,,809,580,690,,,336,,,809,691,336,709,709", "979,,236,641,1152,437,437,860,904,860,,,1019,,868,725,579,,583,674,144", "1021,1023,589,1025,1027,,1028,,,992,,460,466,493,722,493,666,,994,,461", ",,1177,318,,991,17,882,,978,17,781,887,,,17,238,,,787,1006,789,684,452", "470,793,975,798,689,,,,625,,772,772,685,513,795,969,,802,,1076,,17,371", "805,756,756,562,319,445,721,,484,,,756,319,17,17,445,445,756,851,820", "445,445,599,735,735,461,318,1090,904,737,1048,599,982,1041,,461,878", "880,1049,1050,44,883,885,1229,1110,356,1052,,344,895,470,564,,1060,356", ",,344,,567,470,756,975,461,318,19,,,,,784,461,,352,318,,,,44,,,44,352", ",,,1230,841,470,823,,,825,,470,,,1133,1134,995,,,44,19,,1144,19,904", "461,318,709,709,,,,,,,,827,,,,,,141,916,19,947,44,,,900,470,,900,44", ",848,1103,1167,1168,1169,1170,,,794,,,,1120,1121,1122,,19,,,19,,1181", ",19,1182,,,,,19,19,444,,144,19,19,,,,,,444,444,,1198,,444,444,,822,864", ",1153,,,,,,967,,,,,,,1207,899,772,17,,445,,1147,,1148,772,,,1080,865", ",896,,966,772,772,873,,1060,,963,1007,,,1224,284,1223,1060,,599,141", "1176,,932,,685,17,,690,17,980,946,1096,,,,,,877,996,,,356,,,344,493", ",,,17,,,356,,,344,513,,452,,,,,,1060,,,,,352,,,,,1072,,17,594,,17,352", ",44,17,,1222,,44,,17,17,,,993,17,17,1176,,44,,,609,1131,,1029,835,981", "19,,1004,,,19,,,,,,,1040,,,,19,,,,,,,,,1156,44,815,383,,,,,,19,,,1015", "877,,1066,,,,,,444,,,,,19,,1080,1070,,1080,,772,,772,,,772,772,437,1085", ",,1087,772,,,,679,,772,772,,,,1073,,,772,772,,,1199,1014,,,,1018,932", ",,,,932,932,,,1127,,,809,44,,879,881,,1058,,884,886,,,1084,,,,,772,", "44,1080,1117,1118,1119,1072,44,19,1072,,1072,1092,383,,,,17,,1128,,", "17,44,356,,19,1105,,,,31,19,17,1102,735,31,,,,,,383,1095,,,779,,19,", ",17,352,31,,,,,,,,,,31,31,31,,31,17,,,,,,,,,,44,1072,,1072,,1072,,1072", ",,356,,,297,,,,31,,,,,31,31,1072,19,31,,,44,44,1192,1193,,,44,,,352", "900,1155,,1073,,,1073,1161,1073,772,,906,,908,,19,19,,772,,,19,772,", ",,,1163,,,461,318,17,,356,,31,297,765,765,44,31,31,31,31,31,,31,,,17", "1190,,,,470,17,,,,,1008,352,,,19,772,,,,,,17,,,,1073,,1073,470,1073", ",1073,,44,,,,,383,383,,,,,1220,,1081,772,1073,,,,,,879,881,886,884,19", "679,,,,,,,,,,,,,,679,941,,17,,,31,31,31,31,31,31,31,,,,,,31,,,,,,31", "31,31,31,,,,,17,17,381,18,,,17,,18,31,,,,,,,,,,,,,,,,242,,,,679,,,,", ",242,242,242,,18,345,345,,,,,,,,,17,,,,,31,,,,679,,,31,31,,1008,,18", "679,,,31,242,242,1002,,242,394,404,404,,,1137,1139,1141,,,,,31,,679", ",31,17,,,,31,,765,1081,,,1081,,,1081,765,1081,,,,,,764,764,765,765,", ",,,,1074,18,,,31,,242,242,242,242,18,,18,,,,,,31,31,31,,,,,,,679,,435", "448,,679,679,,,,,,31,,,,,,,,,1111,,1112,,1113,1081,,1081,,1081,,1081", ",,,,1209,1211,1213,1215,,1216,,1002,,,,,1081,,,,,,,,,,,,,,,,,,,18,242", "442,242,242,442,242,,31,,,,18,1232,1233,1234,1235,,18,442,242,242,,", ",1237,,,,,,,,,,18,,573,,575,,,577,578,,,,31,,679,679,679,,,,,,31,,941", "765,,765,,,765,765,,,,,1183,765,1185,,,,,765,765,,242,,1002,,,765,765", "242,242,,,,,,,,242,,1204,,,,,,,,,,,,,,,764,18,,31,,18,,,764,345,18,765", ",31,,,,764,764,,,,,,,,,1225,345,1226,,1227,,20,,,,670,20,,18,31,,,31", ",,1196,,,1236,31,,,242,18,18,,,,,31,,,,31,,,,20,353,353,,,,242,,,,,", ",,,,,,,,679,,,31,,,31,31,20,716,31,,,,,,31,31,353,353,353,31,31,,,,", ",,,,,,,,,,,,,,,,,,,,,,765,242,,,,,,,,765,,,,765,,,,20,,,,,,,,,20,,20", ",,,,796,,381,,799,,,242,764,,764,,,764,764,,,242,,,764,,,,765,,764,764", ",,,,,,764,764,,,,,,796,,,381,,,,,,,,,,,,765,448,,,,,,,,,,,,,31,,,764", ",,,18,20,,20,,,20,,345,,242,,,20,,,31,345,,20,20,31,31,,866,,,,,,,,31", "796,381,,20,,18,,,18,,,,,,893,242,,31,,,,,,,,242,,,911,18,,,,,31,,,", ",,,,,,,,,,,,,,,,,,18,,,442,242,,,18,,,,,,442,442,,,,442,442,,,,,,,,20", ",,,20,,,764,353,20,,,,,,31,764,,,,764,,,,,796,,353,,,,,31,,976,,,977", ",20,,,,,31,,,,,,31,,,,20,20,31,,,,,,,,764,,,,,,,,31,,,,,,,,,,,,,,,,", ",,,,,,,764,,,,,,,,1005,,,345,,,,,15,,,,,15,345,,,,242,,,,,31,,,,,,,", ",,,,,,,,,,18,,,15,,18,242,,,,,31,31,,,,18,31,,,21,,,,,21,,,,,,15,,,442", ",,,,,,398,773,773,,,,,,,,18,,,,,21,347,347,,,31,,31,31,,,,,,,,,,,,31", ",,,,,1091,,21,,,,,15,,,,,396,405,405,,15,,15,381,20,,,31,,,,,353,,,", ",242,,,,353,,,,,,,,,,,,,18,,,,,,,,20,,21,20,242,,,771,771,,18,21,,21", ",,18,,,,,,,,20,,,,,,,,18,,,,1106,,,,,,,15,,440,,,440,,,20,,,20,15,,", "20,,,15,440,,20,20,,,,20,20,,,,,,,,15,,,,,,,,,18,,,,,,,,,21,,443,,1145", "443,,,,,,,21,,,,,,21,443,18,18,,,773,,18,,,,,,773,,,21,,,,,,773,773", ",770,770,,,,,,,,,,,,,,,,,15,,,,15,1187,,,18,15,242,242,,,,,,,,,,,,242", ",,,353,,,,,,,,,,,353,15,,,,,,,,,,,,,18,21,15,15,,21,,,,347,21,,,20,", "771,,,20,,,,,771,,,,,347,20,,,771,771,,,,,,,21,,,,,,,20,43,,,,,43,,21", "21,,,,,,,,20,,,,,,,,296,,,,,,,,,,,,43,343,343,,,773,,773,,,773,773,", ",,,,773,,,,,,773,773,,,,43,,,773,773,,,,,,392,296,296,,,,,,,,,,,,,,", ",,,769,769,,20,,,770,,,,,,773,,770,,,,,,,20,,770,770,,,20,43,,,,,,,", ",43,,43,,,,20,,768,768,353,,,,,771,15,771,,,771,771,,,,,,771,,,,,,771", "771,,,,,,,771,771,,,,,,,,,,,,15,,,15,,,,20,,,,,,,,21,,,,,353,,,347,15", ",771,,,,,43,347,,,,20,20,,,,,20,43,767,767,,,773,43,,15,,21,440,,21", "773,15,,,773,,,440,440,43,,,440,440,,,,,,,21,,,,,,353,856,,20,,,,,,", ",770,,770,,,770,770,,,,21,773,770,443,,,,21,770,770,,,,443,443,,770", "770,443,443,,,,769,,,20,,,,,769,,773,,,,,,,769,769,43,,,,43,,,771,343", "43,,,,770,,,771,,,,771,,,,,,768,343,,,,,,,768,,,,,43,,,,768,768,,,,", ",,,,,43,43,,,,,,,,,771,,,,,,,,,,,,,15,,,,,15,,,,,,,,,,347,15,,,771,", ",,,,,347,,,,,,,,440,,,,,767,,,,,,,,767,,,,15,,21,,,767,767,21,,,,,770", ",,,,,21,,,770,,,,770,,,,,,,769,,769,,443,769,769,,,,,,769,,,,,,769,769", ",21,,,,,769,769,,,,,,,,,,770,,766,766,,,,,768,,768,,15,768,768,,,,,", "768,,,,,,768,768,769,,15,,770,,768,768,15,,,,,,,,,,,,,,43,,15,,,,1109", ",343,,,,,,,21,,343,,,,,,768,,,,,,,,,,21,,,,,43,21,,43,,,,,,,767,,767", ",,767,767,21,,15,,1108,767,,43,,,,767,767,34,,,,,34,767,767,,,,,,,,", ",,15,15,,43,34,,15,,,,43,,,,34,34,34,,34,769,,,,,21,,,767,769,,,,769", ",,,,405,,,,,,,,,34,,,,15,34,34,21,21,34,,,,21,,,,,768,,,,,,,,,768,,", "769,768,,,,,,,766,,,,,,,,766,,15,,,,,,405,766,766,21,34,,,,769,34,34", "34,34,34,,34,,,,,,768,,,,,,,,,,,,,,,,343,,,,,,,,,,21,343,,,,,768,767", ",,,,,,,,767,,,,767,,,,,,,,43,,,,,43,,,,,,,,,,,43,,,,,,,34,34,34,34,34", "34,34,,,,,,34,767,,,,,34,34,34,34,,,,,,,43,,,,,,,34,,,,,,,,,,767,,,", ",,,,,,,,,,,,,,,,766,,766,,,766,766,,,,,,766,,,,34,,766,766,,,,34,34", ",766,766,,,,,34,,,,,,,,,,,,43,,,,,,34,,,,34,,,,,34,,,43,,,766,,,43,", ",,,,,,,,,,,,,,43,,,,1104,34,,,,,,,,,,,,,,34,34,34,,,,,,,,,,,,,,,,,,", "34,,,,,,,,,,,,,,,43,,,,,,,,,,,,,296,,,,,,,,,,,,,,,,43,43,,,,,43,,,,", ",,,,,,249,,,34,,,,766,,,317,317,317,,,,766,,,,766,,364,365,,367,368", ",370,,296,,,43,,,,,,,,,34,317,317,,,,,,,,34,,,,,,,,,,,,766,,,,,,,,,", ",,,43,,,,,,,,,,,,,,,,,,,766,,,,,,,,,,,,,,,,34,,,,,,,,,,34,,,,,,,,,,", ",,,,,,,,,,,,,,,,,34,,,34,,,,,,,34,,,,,,,,,,34,,,,34,,,,,,,,,,,,,,,,", ",,,,317,447,,,453,317,34,,,34,34,,,34,,,,,453,34,34,,,,34,34,,,,,,249", ",,,,,,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544", "545,546,547,548,549,550,,,,,551,,,,,,,,,,,,,,,,,,,,,,,317,317,,,,,,", ",317,,,,,,,317,,317,,,317,317,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,", ",,604,,,,,34,,,,,,,,,,,,,,,,,,,,,,,34,,,,,34,34,,,,,,,,,,34,,,,,,,,", ",,,,,,,,,34,,,,,317,,,,,,,,,,,,34,,,,,,,,,,,,,,,,,,,,,,,692,,,,,,,,", ",,,,,,,,,,,,,,,,,317,,,,,,,,,,,,,723,,34,,,,,,,,317,,453,453,453,,,", ",34,,,,,,,,,,,,34,,,,,,34,,,,,,34,,,,,,,365,,,,,,,,,34,317,,317,,317", ",,,,,,,,,,,,,,,317,,,,,,,,,,453,,,816,,817,,,,,,317,,,317,,,,,,,,,,34", ",,317,317,,,,,,,,,,317,,,,,,,,,,,,,,,34,34,,,,,34,,,,,,,,,,,,317,453", "317,,,,874,,,317,317,453,453,,,,453,453,,,,,,317,,,,,,,,,34,,34,34,", "317,,,,,,,,,,34,,,,,,,,,,,,,,692,723,,,,,,,,,,,,,,34,,,,,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,317,,,,,,,,,317,,,317,,,,,,,,,,,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,317,,,,,,,,453,,,,,,,,", ",,,,1010,1011,,,,,,,,,,,,,,,,,,,,,,,,,,,,1033,1034,453,453,453,453,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1067,,,,,,,,,,,,,,,,,,,,,,,,,", ",,317,,,,,,,,,,,,,,,,,,,317,,,,,,,,,,,,,,,,,,,,,,,,,,453,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,317"];
      racc_goto_table = (arr = $$$('Array').$new(4752, nil));
      idx = 0;
      $send(clist, 'each', [], function $Ruby31$6(str){
        
        
        if (str == null) str = nil;;
        return $send(str.$split(",", -1), 'each', [], function $$7(i){
          
          
          if (i == null) i = nil;;
          if (!$truthy(i['$empty?']())) {
            arr['$[]='](idx, i.$to_i())
          };
          return (idx = $rb_plus(idx, 1));}, 1);}, 1);
      clist = ["72,198,158,91,91,72,75,75,36,36,36,68,46,198,31,230,230,48,107,19,19", "10,75,19,72,34,112,10,128,113,34,12,55,55,82,82,72,72,72,73,117,139", "139,94,33,110,110,11,92,228,228,228,77,77,13,33,135,70,133,22,111,34", "34,34,72,9,44,44,80,17,17,82,82,82,72,72,72,19,19,19,19,239,87,87,56", "56,56,235,8,34,95,20,95,8,20,51,31,32,187,34,34,34,69,41,41,177,177", "58,20,55,117,7,24,24,149,28,26,26,119,57,26,129,72,239,89,89,152,192", "89,28,87,72,231,72,151,225,225,200,200,5,35,35,64,193,2,157,157,34,90", "90,90,127,8,147,130,236,34,145,34,207,161,6,3,10,214,214,29,14,65,178", "178,29,161,16,26,26,26,26,18,178,94,90,90,175,224,224,13,21,66,25,239", "230,176,74,74,27,42,91,36,43,95,95,29,45,202,202,50,52,60,5,8,78,215", "215,215,215,72,83,84,8,86,8,75,93,152,236,105,11,72,106,29,114,151,116", "72,149,198,120,121,122,123,34,124,34,128,125,34,126,128,131,136,72,142", "34,22,22,143,150,22,34,34,112,11,146,66,146,26,26,33,88,88,88,22,73", "153,154,34,2,6,155,36,36,156,26,26,70,159,66,29,36,160,162,164,165,70", "168,169,29,170,29,192,171,88,172,173,180,182,200,95,192,31,225,33,183", "87,87,63,63,63,184,145,157,188,91,189,55,55,147,58,91,195,72,68,196", "19,72,82,129,205,72,72,206,149,1,26,210,11,211,193,212,119,11,51,127", "130,82,34,192,72,213,34,216,175,217,34,34,117,175,175,218,72,33,35,35", "32,219,176,176,80,220,31,223,29,34,29,72,72,29,32,33,229,9,202,202,29", "34,11,11,55,233,29,29,234,69,235,,,187,55,,34,34,,73,,,,29,31,8,33,90", ",75,117,66,230,111,31,90,,26,91,10,,,55,7,91,,,64,,,55,36,64,128,128", "32,,119,26,13,88,88,215,231,215,,,139,,31,66,5,,65,33,77,228,228,65", "228,228,,228,,,32,,55,55,230,36,230,17,,32,,91,,,133,36,,110,29,57,", "70,29,66,57,,,29,40,,,66,32,66,56,79,75,66,94,239,56,,,,5,,72,72,91", "79,95,92,,66,,146,,29,40,66,200,200,88,88,20,117,,225,,,200,88,29,29", "20,20,200,157,66,20,20,68,174,174,91,36,41,231,177,73,68,89,32,,91,28", "28,32,32,72,28,28,13,146,82,191,,72,24,75,63,,191,82,,,72,,63,75,200", "94,91,36,34,,,,,56,91,,34,36,,,,72,,,72,34,,,,113,44,75,11,,,11,,75", ",,139,139,10,,,72,34,,135,34,231,91,36,128,128,,,,,,,,117,,,,,,75,66", "34,198,72,,,140,75,,140,72,,117,110,228,228,228,228,,,90,,,,32,32,32", ",34,,,34,,146,,34,146,,,,,34,34,22,,77,34,34,,,,,,22,22,,12,,22,22,", "90,17,,112,,,,,,107,,,,,,,139,200,72,29,,20,,110,,110,72,,,230,8,,87", ",158,72,72,8,,191,,46,28,,,146,48,228,191,,68,75,191,,174,,91,29,,91", "29,68,174,10,,,,,,90,19,,,82,,,72,230,,,,29,,,82,,,72,79,,79,,,,,,191", ",,,,34,,,,,132,,29,40,,29,34,,72,29,,32,,72,,29,29,,,11,29,29,191,,72", ",,40,10,,66,88,26,34,,11,,,34,,,,,,,66,,,,34,,,,,,,,,10,72,79,26,,,", ",,34,,,11,90,,19,,,,,,22,,,,,34,,230,66,,230,,72,,72,,,72,72,88,66,", ",19,72,,,,40,,72,72,,,,140,,,72,72,,,31,87,,,,87,174,,,,,174,174,,,198", ",,55,72,,79,79,,174,,79,79,,,11,,,,,72,,72,230,66,66,66,132,72,34,132", ",132,11,26,,,,29,,66,,,29,72,82,,34,72,,,,59,34,29,11,174,59,,,,,,26", "117,,,40,,34,,,29,34,59,,,,,,,,,,59,59,59,,59,29,,,,,,,,,,72,132,,132", ",132,,132,,,82,,,72,,,,59,,,,,59,59,132,34,59,,,72,72,19,19,,,72,,,34", "140,11,,140,,,140,11,140,72,,144,,144,,34,34,,72,,,34,72,,,,,33,,,91", "36,29,,82,,59,72,98,98,72,59,59,59,59,59,,59,,,29,11,,,,75,29,,,,,79", "34,,,34,72,,,,,,29,,,,140,,140,75,140,,140,,72,,,,,26,26,,,,,11,,232", "72,140,,,,,,79,79,79,79,34,40,,,,,,,,,,,,,,40,40,,29,,,59,59,59,59,59", "59,59,,,,,,59,,,,,,59,59,59,59,,,,,29,29,85,30,,,29,,30,59,,,,,,,,,", ",,,,,,30,,,,40,,,,,,30,30,30,,30,30,30,,,,,,,,,29,,,,,59,,,,40,,,59", "59,,79,,30,40,,,59,30,30,40,,30,30,30,30,,,141,141,141,,,,,59,,40,,59", "29,,,,59,,98,232,,,232,,,232,98,232,,,,,,97,97,98,98,,,,,,144,30,,,59", ",30,30,30,30,30,,30,,,,,,59,59,59,,,,,,,40,,85,85,,40,40,,,,,,59,,,", ",,,,,144,,144,,144,232,,232,,232,,232,,,,,141,141,141,141,,141,,40,", ",,,232,,,,,,,,,,,,,,,,,,,30,30,30,30,30,30,30,,59,,,,30,141,141,141", "141,,30,30,30,30,,,,141,,,,,,,,,,30,,85,,85,,,85,85,,,,59,,40,40,40", ",,,,,59,,40,98,,98,,,98,98,,,,,144,98,144,,,,,98,98,,30,,40,,,98,98", "30,30,,,,,,,,30,,144,,,,,,,,,,,,,,,97,30,,59,,30,,,97,30,30,98,,59,", ",,97,97,,,,,,,,,144,30,144,,144,,38,,,,85,38,,30,59,,,59,,,40,,,144", "59,,,30,30,30,,,,,59,,,,59,,,,38,38,38,,,,30,,,,,,,,,,,,,,40,,,59,,", "59,59,38,85,59,,,,,,59,59,38,38,38,59,59,,,,,,,,,,,,,,,,,,,,,,,,,,,98", "30,,,,,,,,98,,,,98,,,,38,,,,,,,,,38,,38,,,,,85,,85,,85,,,30,97,,97,", ",97,97,,,30,,,97,,,,98,,97,97,,,,,,,97,97,,,,,,85,,,85,,,,,,,,,,,,98", "85,,,,,,,,,,,,,59,,,97,,,,30,38,,38,,,38,,30,,30,,,38,,,59,30,,38,38", "59,59,,85,,,,,,,,59,85,85,,38,,30,,,30,,,,,,85,30,,59,,,,,,,,30,,,85", "30,,,,,59,,,,,,,,,,,,,,,,,,,,,,30,,,30,30,,,30,,,,,,30,30,,,,30,30,", ",,,,,,38,,,,38,,,97,38,38,,,,,,59,97,,,,97,,,,,85,,38,,,,,59,,85,,,85", ",38,,,,,59,,,,,,59,,,,38,38,59,,,,,,,,97,,,,,,,,59,,,,,,,,,,,,,,,,,", ",,,,,,97,,,,,,,,85,,,30,,,,,23,,,,,23,30,,,,30,,,,,59,,,,,,,,,,,,,,", ",,,30,,,23,,30,30,,,,,59,59,,,,30,59,,,39,,,,,39,,,,,,23,,,30,,,,,,", "23,109,109,,,,,,,,30,,,,,39,39,39,,,59,,59,59,,,,,,,,,,,,59,,,,,,85", ",39,,,,,23,,,,,39,39,39,,23,,23,85,38,,,59,,,,,38,,,,,30,,,,38,,,,,", ",,,,,,,30,,,,,,,,38,,39,38,30,,,104,104,,30,39,,39,,,30,,,,,,,,38,,", ",,,,,30,,,,30,,,,,,,23,,23,,,23,,,38,,,38,23,,,38,,,23,23,,38,38,,,", "38,38,,,,,,,,23,,,,,,,,,30,,,,,,,,,39,,39,,30,39,,,,,,,39,,,,,,39,39", "30,30,,,109,,30,,,,,,109,,,39,,,,,,109,109,,103,103,,,,,,,,,,,,,,,,", "23,,,,23,30,,,30,23,30,30,,,,,,,,,,,,30,,,,38,,,,,,,,,,,38,23,,,,,,", ",,,,,,30,39,23,23,,39,,,,39,39,,,38,,104,,,38,,,,,104,,,,,39,38,,,104", "104,,,,,,,39,,,,,,,38,71,,,,,71,,39,39,,,,,,,,38,,,,,,,,71,,,,,,,,,", ",,71,71,71,,,109,,109,,,109,109,,,,,,109,,,,,,109,109,,,,71,,,109,109", ",,,,,71,71,71,,,,,,,,,,,,,,,,,,102,102,,38,,,103,,,,,,109,,103,,,,,", ",38,,103,103,,,38,71,,,,,,,,,71,,71,,,,38,,101,101,38,,,,,104,23,104", ",,104,104,,,,,,104,,,,,,104,104,,,,,,,104,104,,,,,,,,,,,,23,,,23,,,", "38,,,,,,,,39,,,,,38,,,39,23,,104,,,,,71,39,,,,38,38,,,,,38,71,100,100", ",,109,71,,23,,39,23,,39,109,23,,,109,,,23,23,71,,,23,23,,,,,,,39,,,", ",,38,39,,38,,,,,,,,103,,103,,,103,103,,,,39,109,103,39,,,,39,103,103", ",,,39,39,,103,103,39,39,,,,102,,,38,,,,,102,,109,,,,,,,102,102,71,,", ",71,,,104,71,71,,,,103,,,104,,,,104,,,,,,101,71,,,,,,,101,,,,,71,,,", "101,101,,,,,,,,,,71,71,,,,,,,,,104,,,,,,,,,,,,,23,,,,,23,,,,,,,,,,39", "23,,,104,,,,,,,39,,,,,,,,23,,,,,100,,,,,,,,100,,,,23,,39,,,100,100,39", ",,,,103,,,,,,39,,,103,,,,103,,,,,,,102,,102,,39,102,102,,,,,,102,,,", ",,102,102,,39,,,,,102,102,,,,,,,,,,103,,99,99,,,,,101,,101,,23,101,101", ",,,,,101,,,,,,101,101,102,,23,,103,,101,101,23,,,,,,,,,,,,,,71,,23,", ",,23,,71,,,,,,,39,,71,,,,,,101,,,,,,,,,,39,,,,,71,39,,71,,,,,,,100,", "100,,,100,100,39,,23,,39,100,,71,,,,100,100,62,,,,,62,100,100,,,,,,", ",,,,23,23,,71,62,,23,,,,71,,,,62,62,62,,62,102,,,,,39,,,100,102,,,,102", ",,,,39,,,,,,,,,62,,,,23,62,62,39,39,62,,,,39,,,,,101,,,,,,,,,101,,,102", "101,,,,,,,99,,,,,,,,99,,23,,,,,,39,99,99,39,62,,,,102,62,62,62,62,62", ",62,,,,,,101,,,,,,,,,,,,,,,,71,,,,,,,,,,39,71,,,,,101,100,,,,,,,,,100", ",,,100,,,,,,,,71,,,,,71,,,,,,,,,,,71,,,,,,,62,62,62,62,62,62,62,,,,", ",62,100,,,,,62,62,62,62,,,,,,,71,,,,,,,62,,,,,,,,,,100,,,,,,,,,,,,,", ",,,,,,99,,99,,,99,99,,,,,,99,,,,62,,99,99,,,,62,62,,99,99,,,,,62,,,", ",,,,,,,,71,,,,,,62,,,,62,,,,,62,,,71,,,99,,,71,,,,,,,,,,,,,,,,71,,,", "71,62,,,,,,,,,,,,,,62,62,62,,,,,,,,,,,,,,,,,,,62,,,,,,,,,,,,,,,71,,", ",,,,,,,,,,71,,,,,,,,,,,,,,,,71,71,,,,,71,,,,,,,,,,,37,,,62,,,,99,,,37", "37,37,,,,99,,,,99,,37,37,,37,37,,37,,71,,,71,,,,,,,,,62,37,37,,,,,,", ",62,,,,,,,,,,,,99,,,,,,,,,,,,,71,,,,,,,,,,,,,,,,,,,99,,,,,,,,,,,,,,", ",62,,,,,,,,,,62,,,,,,,,,,,,,,,,,,,,,,,,,,,,62,,,62,,,,,,,62,,,,,,,,", ",62,,,,62,,,,,,,,,,,,,,,,,,,,,37,37,,,37,37,62,,,62,62,,,62,,,,,37,62", "62,,,,62,62,,,,,,37,,,,,,,37,37,37,37,37,37,37,37,37,37,37,37,37,37", "37,37,37,37,37,37,37,37,,,,,37,,,,,,,,,,,,,,,,,,,,,,,37,37,,,,,,,,37", ",,,,,,37,,37,,,37,37,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,37,,,,", "62,,,,,,,,,,,,,,,,,,,,,,,62,,,,,62,62,,,,,,,,,,62,,,,,,,,,,,,,,,,,,62", ",,,,37,,,,,,,,,,,,62,,,,,,,,,,,,,,,,,,,,,,,37,,,,,,,,,,,,,,,,,,,,,,", ",,,37,,,,,,,,,,,,,37,,62,,,,,,,,37,,37,37,37,,,,,62,,,,,,,,,,,,62,,", ",,,62,,,,,,62,,,,,,,37,,,,,,,,,62,37,,37,,37,,,,,,,,,,,,,,,,37,,,,,", ",,,,37,,,37,,37,,,,,,37,,,37,,,,,,,,,,62,,,37,37,,,,,,,,,,37,,,,,,,", ",,,,,,,62,62,,,,,62,,,,,,,,,,,,37,37,37,,,,37,,,37,37,37,37,,,,37,37", ",,,,,37,,,,,,,,,62,,62,62,,37,,,,,,,,,,62,,,,,,,,,,,,,,37,37,,,,,,,", ",,,,,,62,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,37,,,,,,,,,37,,,37", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,37", ",,,,,,,37,,,,,,,,,,,,,37,37,,,,,,,,,,,,,,,,,,,,,,,,,,,,37,37,37,37,37", "37,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,37,,,,,,,,,,,,,,,,,,,,,,,", ",,,,37,,,,,,,,,,,,,,,,,,,37,,,,,,,,,,,,,,,,,,,,,,,,,,37,,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,", ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,37"];
      racc_goto_check = (arr = $$$('Array').$new(4752, nil));
      idx = 0;
      $send(clist, 'each', [], function $Ruby31$8(str){
        
        
        if (str == null) str = nil;;
        return $send(str.$split(",", -1), 'each', [], function $$9(i){
          
          
          if (i == null) i = nil;;
          if (!$truthy(i['$empty?']())) {
            arr['$[]='](idx, i.$to_i())
          };
          return (idx = $rb_plus(idx, 1));}, 1);}, 1);
      racc_goto_pointer = [nil, 343, 142, 162, nil, 134, 154, 106, 86, 56, -209, 9, -441, -639, -723, nil, -407, 59, 167, -52, -129, 111, 35, 2068, -107, -30, 45, 59, -108, 164, 1262, -210, -357, 26, 23, 121, -26, 3589, 1625, 2121, 484, -424, -59, -57, -7, -419, -14, nil, -9, nil, 180, 66, -345, nil, nil, -193, 53, -186, -458, 1017, -350, nil, 3145, 282, 104, 130, -51, nil, -28, 62, -303, 2499, -2, -363, 116, -4, nil, 42, -220, 291, 20, nil, -5, 166, -153, 1195, 153, 63, 235, -252, 114, -28, -258, -332, -277, -480, nil, 849, 616, 2504, 2203, 2113, 2068, 1856, 1723, 200, 161, -51, nil, 1618, -339, -763, -364, -596, 155, nil, -173, 35, nil, 98, 172, -135, 173, -366, -397, -603, -161, -762, -466, -373, -760, -664, -141, -639, nil, -437, -722, nil, nil, -436, -27, 269, -822, -716, 413, -815, -438, -638, nil, -737, -842, -965, -973, -135, -575, 194, -361, -88, -25, -714, -711, -394, -9, nil, -18, -18, nil, nil, -488, -796, -691, -919, -530, -844, 34, -562, -553, -422, -760, nil, -620, nil, -620, -431, -425, nil, nil, -648, -424, -423, nil, -352, -816, -781, nil, -615, -612, nil, -89, nil, -390, nil, -558, nil, nil, -437, -353, -735, nil, nil, 257, 254, 255, 264, -250, -200, 265, 266, 271, -274, -271, nil, nil, -259, -168, -98, nil, nil, -432, -311, -218, -569, 230, -298, -730, -616, -983, nil, nil, -491];
      racc_goto_default = [nil, nil, nil, nil, 5, nil, 6, 391, 334, nil, nil, 472, nil, 984, nil, 331, 332, nil, nil, nil, 13, 14, 22, 247, nil, nil, 16, nil, 441, 248, 363, nil, nil, 637, 251, nil, 27, 25, 252, 246, 517, nil, nil, nil, nil, nil, nil, 386, 143, 26, nil, nil, nil, 28, 29, 812, nil, nil, nil, 351, nil, 30, 348, 455, 37, nil, nil, 39, 42, 41, nil, 243, 244, 403, nil, 463, 142, 87, nil, 446, 103, 51, 54, 283, nil, 323, nil, 891, 456, nil, 457, 468, 480, 686, 569, 321, 307, 55, 56, 57, 58, 59, 60, 61, 62, 63, nil, 308, 69, 70, nil, nil, nil, nil, nil, 77, nil, 619, 78, 230, nil, nil, nil, nil, nil, nil, nil, 711, 492, nil, 712, 713, 478, 474, 475, nil, 1179, 707, 1071, nil, 479, nil, nil, nil, 481, nil, 483, nil, 971, nil, nil, nil, 490, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 467, nil, nil, 791, 783, nil, nil, nil, nil, nil, nil, 1051, nil, 736, 937, 738, 739, 743, 740, 741, nil, nil, 742, 744, nil, nil, nil, 936, 938, nil, 748, 750, 751, 752, 753, nil, 757, 501, 758, 759, 760, 761, nil, nil, nil, 86, 88, 89, nil, nil, nil, nil, 647, nil, nil, nil, nil, nil, 99, 100, nil, 231, 901, 234, 477, nil, 482, 909, 495, 497, 498, 1082, 502, 1083, 505, 508, 326];
      racc_reduce_table = [0, 0, "racc_error", 0, 150, "_reduce_1", 2, 148, "_reduce_2", 2, 149, "_reduce_3", 0, 151, "_reduce_4", 1, 151, "_reduce_5", 3, 151, "_reduce_6", 2, 151, "_reduce_7", 1, 153, "_reduce_none", 2, 153, "_reduce_9", 3, 156, "_reduce_10", 4, 157, "_reduce_11", 2, 158, "_reduce_12", 0, 162, "_reduce_13", 1, 162, "_reduce_14", 3, 162, "_reduce_15", 2, 162, "_reduce_16", 1, 163, "_reduce_none", 2, 163, "_reduce_18", 0, 174, "_reduce_19", 4, 155, "_reduce_20", 3, 155, "_reduce_21", 3, 155, "_reduce_22", 3, 155, "_reduce_23", 2, 155, "_reduce_24", 3, 155, "_reduce_25", 3, 155, "_reduce_26", 3, 155, "_reduce_27", 3, 155, "_reduce_28", 3, 155, "_reduce_29", 4, 155, "_reduce_30", 1, 155, "_reduce_none", 3, 155, "_reduce_32", 3, 155, "_reduce_33", 5, 155, "_reduce_34", 3, 155, "_reduce_35", 1, 155, "_reduce_none", 3, 167, "_reduce_37", 3, 167, "_reduce_38", 6, 167, "_reduce_39", 5, 167, "_reduce_40", 5, 167, "_reduce_41", 5, 167, "_reduce_42", 5, 167, "_reduce_43", 4, 167, "_reduce_44", 6, 167, "_reduce_45", 4, 167, "_reduce_46", 6, 167, "_reduce_47", 3, 167, "_reduce_48", 1, 175, "_reduce_none", 3, 175, "_reduce_50", 1, 175, "_reduce_none", 1, 173, "_reduce_none", 3, 173, "_reduce_53", 3, 173, "_reduce_54", 3, 173, "_reduce_55", 2, 173, "_reduce_56", 0, 189, "_reduce_57", 4, 173, "_reduce_58", 0, 190, "_reduce_59", 4, 173, "_reduce_60", 1, 173, "_reduce_none", 1, 166, "_reduce_none", 0, 194, "_reduce_63", 3, 191, "_reduce_64", 1, 193, "_reduce_65", 2, 181, "_reduce_66", 0, 199, "_reduce_67", 5, 185, "_reduce_68", 1, 169, "_reduce_none", 1, 169, "_reduce_none", 1, 200, "_reduce_none", 4, 200, "_reduce_72", 0, 207, "_reduce_73", 4, 204, "_reduce_74", 1, 206, "_reduce_none", 2, 183, "_reduce_76", 3, 183, "_reduce_77", 4, 183, "_reduce_78", 5, 183, "_reduce_79", 4, 183, "_reduce_80", 5, 183, "_reduce_81", 2, 183, "_reduce_82", 2, 183, "_reduce_83", 2, 183, "_reduce_84", 2, 183, "_reduce_85", 2, 183, "_reduce_86", 1, 168, "_reduce_87", 3, 168, "_reduce_88", 1, 212, "_reduce_89", 3, 212, "_reduce_90", 1, 211, "_reduce_none", 2, 211, "_reduce_92", 3, 211, "_reduce_93", 5, 211, "_reduce_94", 2, 211, "_reduce_95", 4, 211, "_reduce_96", 2, 211, "_reduce_97", 4, 211, "_reduce_98", 1, 211, "_reduce_99", 3, 211, "_reduce_100", 1, 215, "_reduce_none", 3, 215, "_reduce_102", 2, 214, "_reduce_103", 3, 214, "_reduce_104", 1, 217, "_reduce_105", 3, 217, "_reduce_106", 1, 216, "_reduce_107", 1, 216, "_reduce_108", 4, 216, "_reduce_109", 3, 216, "_reduce_110", 3, 216, "_reduce_111", 3, 216, "_reduce_112", 3, 216, "_reduce_113", 2, 216, "_reduce_114", 1, 216, "_reduce_115", 1, 170, "_reduce_116", 1, 170, "_reduce_117", 4, 170, "_reduce_118", 3, 170, "_reduce_119", 3, 170, "_reduce_120", 3, 170, "_reduce_121", 3, 170, "_reduce_122", 2, 170, "_reduce_123", 1, 170, "_reduce_124", 1, 220, "_reduce_125", 1, 220, "_reduce_none", 2, 221, "_reduce_127", 1, 221, "_reduce_128", 3, 221, "_reduce_129", 1, 195, "_reduce_none", 1, 195, "_reduce_none", 1, 195, "_reduce_none", 1, 195, "_reduce_none", 1, 195, "_reduce_none", 1, 164, "_reduce_135", 1, 164, "_reduce_none", 1, 165, "_reduce_137", 0, 225, "_reduce_138", 4, 165, "_reduce_139", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 222, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 1, 223, "_reduce_none", 3, 184, "_reduce_211", 3, 184, "_reduce_212", 6, 184, "_reduce_213", 5, 184, "_reduce_214", 5, 184, "_reduce_215", 5, 184, "_reduce_216", 5, 184, "_reduce_217", 4, 184, "_reduce_218", 3, 184, "_reduce_219", 3, 184, "_reduce_220", 3, 184, "_reduce_221", 2, 184, "_reduce_222", 2, 184, "_reduce_223", 2, 184, "_reduce_224", 2, 184, "_reduce_225", 3, 184, "_reduce_226", 3, 184, "_reduce_227", 3, 184, "_reduce_228", 3, 184, "_reduce_229", 3, 184, "_reduce_230", 3, 184, "_reduce_231", 4, 184, "_reduce_232", 2, 184, "_reduce_233", 2, 184, "_reduce_234", 3, 184, "_reduce_235", 3, 184, "_reduce_236", 3, 184, "_reduce_237", 3, 184, "_reduce_238", 1, 184, "_reduce_none", 3, 184, "_reduce_240", 3, 184, "_reduce_241", 3, 184, "_reduce_242", 3, 184, "_reduce_243", 3, 184, "_reduce_244", 2, 184, "_reduce_245", 2, 184, "_reduce_246", 3, 184, "_reduce_247", 3, 184, "_reduce_248", 3, 184, "_reduce_249", 3, 184, "_reduce_250", 0, 231, "_reduce_251", 4, 184, "_reduce_252", 6, 184, "_reduce_253", 4, 184, "_reduce_254", 6, 184, "_reduce_255", 4, 184, "_reduce_256", 6, 184, "_reduce_257", 1, 184, "_reduce_none", 1, 230, "_reduce_none", 1, 230, "_reduce_none", 1, 230, "_reduce_none", 1, 230, "_reduce_none", 3, 228, "_reduce_263", 3, 228, "_reduce_264", 1, 232, "_reduce_none", 1, 233, "_reduce_none", 2, 233, "_reduce_none", 4, 233, "_reduce_268", 2, 233, "_reduce_269", 1, 226, "_reduce_none", 3, 226, "_reduce_271", 3, 238, "_reduce_272", 5, 238, "_reduce_273", 3, 238, "_reduce_274", 0, 240, "_reduce_275", 1, 240, "_reduce_none", 0, 178, "_reduce_277", 1, 178, "_reduce_none", 2, 178, "_reduce_none", 4, 178, "_reduce_280", 2, 178, "_reduce_281", 1, 210, "_reduce_282", 2, 210, "_reduce_283", 2, 210, "_reduce_284", 4, 210, "_reduce_285", 1, 210, "_reduce_286", 0, 243, "_reduce_287", 2, 203, "_reduce_288", 2, 242, "_reduce_289", 1, 242, "_reduce_290", 2, 241, "_reduce_291", 0, 241, "_reduce_292", 1, 235, "_reduce_293", 2, 235, "_reduce_294", 3, 235, "_reduce_295", 4, 235, "_reduce_296", 1, 172, "_reduce_297", 1, 172, "_reduce_none", 3, 171, "_reduce_299", 4, 171, "_reduce_300", 2, 171, "_reduce_301", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_none", 1, 229, "_reduce_312", 0, 267, "_reduce_313", 4, 229, "_reduce_314", 0, 268, "_reduce_315", 4, 229, "_reduce_316", 0, 269, "_reduce_317", 4, 229, "_reduce_318", 3, 229, "_reduce_319", 3, 229, "_reduce_320", 2, 229, "_reduce_321", 3, 229, "_reduce_322", 3, 229, "_reduce_323", 1, 229, "_reduce_324", 4, 229, "_reduce_325", 3, 229, "_reduce_326", 1, 229, "_reduce_327", 0, 270, "_reduce_328", 6, 229, "_reduce_329", 4, 229, "_reduce_330", 3, 229, "_reduce_331", 2, 229, "_reduce_332", 1, 229, "_reduce_none", 2, 229, "_reduce_334", 1, 229, "_reduce_none", 6, 229, "_reduce_336", 6, 229, "_reduce_337", 4, 229, "_reduce_338", 4, 229, "_reduce_339", 5, 229, "_reduce_340", 4, 229, "_reduce_341", 5, 229, "_reduce_342", 6, 229, "_reduce_343", 0, 271, "_reduce_344", 6, 229, "_reduce_345", 0, 272, "_reduce_346", 7, 229, "_reduce_347", 0, 273, "_reduce_348", 5, 229, "_reduce_349", 4, 229, "_reduce_350", 4, 229, "_reduce_351", 1, 229, "_reduce_352", 1, 229, "_reduce_353", 1, 229, "_reduce_354", 1, 229, "_reduce_355", 1, 177, "_reduce_none", 1, 262, "_reduce_357", 1, 265, "_reduce_358", 1, 196, "_reduce_359", 1, 209, "_reduce_360", 1, 257, "_reduce_none", 1, 257, "_reduce_none", 2, 257, "_reduce_363", 1, 192, "_reduce_none", 1, 192, "_reduce_none", 1, 258, "_reduce_none", 5, 258, "_reduce_367", 1, 160, "_reduce_none", 2, 160, "_reduce_369", 1, 261, "_reduce_none", 1, 261, "_reduce_none", 1, 274, "_reduce_372", 3, 274, "_reduce_373", 1, 277, "_reduce_374", 3, 277, "_reduce_375", 1, 276, "_reduce_none", 3, 276, "_reduce_377", 5, 276, "_reduce_378", 1, 276, "_reduce_379", 3, 276, "_reduce_380", 2, 278, "_reduce_381", 1, 278, "_reduce_382", 1, 279, "_reduce_none", 1, 279, "_reduce_none", 0, 284, "_reduce_385", 2, 282, "_reduce_386", 4, 283, "_reduce_387", 2, 283, "_reduce_388", 2, 283, "_reduce_389", 1, 283, "_reduce_390", 2, 288, "_reduce_391", 0, 288, "_reduce_392", 1, 289, "_reduce_none", 6, 290, "_reduce_394", 8, 290, "_reduce_395", 4, 290, "_reduce_396", 6, 290, "_reduce_397", 4, 290, "_reduce_398", 2, 290, "_reduce_none", 6, 290, "_reduce_400", 2, 290, "_reduce_401", 4, 290, "_reduce_402", 6, 290, "_reduce_403", 2, 290, "_reduce_404", 4, 290, "_reduce_405", 2, 290, "_reduce_406", 4, 290, "_reduce_407", 1, 290, "_reduce_none", 0, 294, "_reduce_409", 1, 294, "_reduce_410", 3, 295, "_reduce_411", 4, 295, "_reduce_412", 1, 296, "_reduce_413", 4, 296, "_reduce_414", 1, 297, "_reduce_415", 3, 297, "_reduce_416", 1, 298, "_reduce_417", 1, 298, "_reduce_none", 0, 302, "_reduce_419", 0, 303, "_reduce_420", 5, 256, "_reduce_421", 4, 300, "_reduce_422", 1, 300, "_reduce_423", 0, 306, "_reduce_424", 4, 301, "_reduce_425", 0, 307, "_reduce_426", 4, 301, "_reduce_427", 0, 309, "_reduce_428", 4, 305, "_reduce_429", 2, 201, "_reduce_430", 4, 201, "_reduce_431", 5, 201, "_reduce_432", 5, 201, "_reduce_433", 2, 255, "_reduce_434", 4, 255, "_reduce_435", 4, 255, "_reduce_436", 3, 255, "_reduce_437", 3, 255, "_reduce_438", 3, 255, "_reduce_439", 2, 255, "_reduce_440", 1, 255, "_reduce_441", 4, 255, "_reduce_442", 0, 311, "_reduce_443", 4, 254, "_reduce_444", 0, 312, "_reduce_445", 4, 254, "_reduce_446", 0, 313, "_reduce_447", 3, 205, "_reduce_448", 0, 314, "_reduce_449", 0, 315, "_reduce_450", 4, 308, "_reduce_451", 5, 259, "_reduce_452", 1, 316, "_reduce_453", 1, 316, "_reduce_none", 0, 319, "_reduce_455", 0, 320, "_reduce_456", 7, 260, "_reduce_457", 1, 318, "_reduce_458", 1, 318, "_reduce_none", 1, 317, "_reduce_460", 3, 317, "_reduce_461", 3, 317, "_reduce_462", 1, 188, "_reduce_none", 2, 188, "_reduce_464", 3, 188, "_reduce_465", 1, 188, "_reduce_466", 1, 188, "_reduce_467", 1, 188, "_reduce_468", 1, 321, "_reduce_none", 3, 326, "_reduce_470", 1, 326, "_reduce_none", 3, 328, "_reduce_472", 1, 328, "_reduce_none", 1, 330, "_reduce_474", 1, 331, "_reduce_475", 1, 329, "_reduce_none", 1, 329, "_reduce_none", 4, 329, "_reduce_478", 4, 329, "_reduce_479", 4, 329, "_reduce_480", 3, 329, "_reduce_481", 4, 329, "_reduce_482", 4, 329, "_reduce_483", 4, 329, "_reduce_484", 3, 329, "_reduce_485", 3, 329, "_reduce_486", 3, 329, "_reduce_487", 2, 329, "_reduce_488", 0, 335, "_reduce_489", 4, 329, "_reduce_490", 2, 329, "_reduce_491", 0, 336, "_reduce_492", 4, 329, "_reduce_493", 1, 322, "_reduce_494", 1, 322, "_reduce_495", 2, 322, "_reduce_496", 3, 322, "_reduce_497", 5, 322, "_reduce_498", 2, 322, "_reduce_499", 4, 322, "_reduce_500", 1, 322, "_reduce_none", 2, 337, "_reduce_502", 3, 337, "_reduce_503", 1, 324, "_reduce_504", 3, 324, "_reduce_505", 5, 323, "_reduce_506", 2, 340, "_reduce_507", 1, 340, "_reduce_508", 1, 339, "_reduce_509", 3, 339, "_reduce_510", 1, 338, "_reduce_none", 3, 325, "_reduce_512", 1, 325, "_reduce_513", 2, 325, "_reduce_514", 1, 325, "_reduce_515", 1, 341, "_reduce_516", 3, 341, "_reduce_517", 2, 343, "_reduce_518", 1, 343, "_reduce_519", 1, 344, "_reduce_520", 3, 344, "_reduce_521", 2, 346, "_reduce_522", 1, 346, "_reduce_523", 2, 348, "_reduce_524", 1, 342, "_reduce_none", 1, 342, "_reduce_none", 1, 332, "_reduce_none", 3, 332, "_reduce_528", 3, 332, "_reduce_529", 2, 332, "_reduce_530", 2, 332, "_reduce_531", 1, 332, "_reduce_none", 1, 332, "_reduce_none", 1, 332, "_reduce_none", 2, 332, "_reduce_535", 2, 332, "_reduce_536", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_none", 1, 349, "_reduce_545", 1, 349, "_reduce_none", 1, 327, "_reduce_547", 2, 350, "_reduce_548", 2, 350, "_reduce_549", 4, 351, "_reduce_550", 2, 333, "_reduce_551", 3, 333, "_reduce_552", 1, 333, "_reduce_553", 6, 159, "_reduce_554", 0, 159, "_reduce_555", 1, 353, "_reduce_556", 1, 353, "_reduce_none", 1, 353, "_reduce_none", 2, 354, "_reduce_559", 1, 354, "_reduce_none", 2, 161, "_reduce_561", 1, 161, "_reduce_none", 1, 244, "_reduce_none", 1, 244, "_reduce_none", 1, 245, "_reduce_565", 1, 356, "_reduce_566", 2, 356, "_reduce_567", 3, 357, "_reduce_568", 1, 357, "_reduce_569", 1, 357, "_reduce_570", 3, 246, "_reduce_571", 4, 247, "_reduce_572", 3, 248, "_reduce_573", 0, 360, "_reduce_574", 3, 360, "_reduce_575", 1, 361, "_reduce_576", 2, 361, "_reduce_577", 3, 250, "_reduce_578", 0, 363, "_reduce_579", 3, 363, "_reduce_580", 3, 249, "_reduce_581", 3, 251, "_reduce_582", 0, 364, "_reduce_583", 3, 364, "_reduce_584", 0, 365, "_reduce_585", 3, 365, "_reduce_586", 0, 345, "_reduce_587", 2, 345, "_reduce_588", 0, 358, "_reduce_589", 2, 358, "_reduce_590", 0, 359, "_reduce_591", 2, 359, "_reduce_592", 1, 362, "_reduce_593", 2, 362, "_reduce_594", 0, 367, "_reduce_595", 4, 362, "_reduce_596", 1, 366, "_reduce_597", 1, 366, "_reduce_598", 1, 366, "_reduce_599", 1, 366, "_reduce_none", 1, 224, "_reduce_none", 1, 224, "_reduce_none", 1, 368, "_reduce_603", 3, 369, "_reduce_604", 1, 355, "_reduce_605", 2, 355, "_reduce_606", 1, 227, "_reduce_607", 1, 227, "_reduce_608", 1, 227, "_reduce_609", 1, 227, "_reduce_610", 1, 352, "_reduce_611", 1, 352, "_reduce_612", 1, 352, "_reduce_613", 1, 218, "_reduce_614", 1, 218, "_reduce_615", 1, 218, "_reduce_616", 1, 218, "_reduce_617", 1, 218, "_reduce_618", 1, 219, "_reduce_619", 1, 219, "_reduce_620", 1, 219, "_reduce_621", 1, 219, "_reduce_622", 1, 219, "_reduce_623", 1, 219, "_reduce_624", 1, 219, "_reduce_625", 1, 252, "_reduce_626", 1, 252, "_reduce_627", 1, 176, "_reduce_628", 1, 176, "_reduce_629", 1, 186, "_reduce_630", 1, 186, "_reduce_631", 0, 370, "_reduce_632", 4, 263, "_reduce_633", 0, 263, "_reduce_634", 1, 182, "_reduce_none", 1, 182, "_reduce_636", 3, 371, "_reduce_637", 1, 266, "_reduce_none", 0, 373, "_reduce_639", 3, 266, "_reduce_640", 4, 372, "_reduce_641", 2, 372, "_reduce_642", 2, 372, "_reduce_643", 1, 372, "_reduce_644", 1, 372, "_reduce_645", 2, 375, "_reduce_646", 0, 375, "_reduce_647", 6, 304, "_reduce_648", 8, 304, "_reduce_649", 4, 304, "_reduce_650", 6, 304, "_reduce_651", 4, 304, "_reduce_652", 6, 304, "_reduce_653", 2, 304, "_reduce_654", 4, 304, "_reduce_655", 6, 304, "_reduce_656", 2, 304, "_reduce_657", 4, 304, "_reduce_658", 2, 304, "_reduce_659", 4, 304, "_reduce_660", 1, 304, "_reduce_661", 0, 304, "_reduce_662", 1, 239, "_reduce_663", 1, 299, "_reduce_664", 1, 299, "_reduce_665", 1, 299, "_reduce_666", 1, 299, "_reduce_667", 1, 275, "_reduce_none", 1, 275, "_reduce_669", 1, 377, "_reduce_670", 1, 378, "_reduce_671", 3, 378, "_reduce_672", 1, 291, "_reduce_673", 3, 291, "_reduce_674", 1, 379, "_reduce_675", 2, 380, "_reduce_676", 1, 380, "_reduce_677", 2, 381, "_reduce_678", 1, 381, "_reduce_679", 1, 285, "_reduce_680", 3, 285, "_reduce_681", 1, 374, "_reduce_682", 3, 374, "_reduce_683", 1, 347, "_reduce_none", 1, 347, "_reduce_none", 2, 281, "_reduce_686", 2, 280, "_reduce_687", 1, 280, "_reduce_688", 3, 382, "_reduce_689", 3, 383, "_reduce_690", 1, 292, "_reduce_691", 3, 292, "_reduce_692", 1, 376, "_reduce_693", 3, 376, "_reduce_694", 1, 384, "_reduce_none", 1, 384, "_reduce_none", 2, 293, "_reduce_697", 1, 293, "_reduce_698", 1, 385, "_reduce_none", 1, 385, "_reduce_none", 2, 287, "_reduce_701", 1, 287, "_reduce_702", 2, 286, "_reduce_703", 0, 286, "_reduce_704", 1, 197, "_reduce_none", 3, 197, "_reduce_706", 0, 253, "_reduce_707", 2, 253, "_reduce_none", 1, 237, "_reduce_709", 3, 237, "_reduce_710", 3, 386, "_reduce_711", 2, 386, "_reduce_712", 1, 386, "_reduce_713", 4, 386, "_reduce_714", 2, 386, "_reduce_715", 1, 208, "_reduce_none", 1, 208, "_reduce_none", 1, 208, "_reduce_none", 1, 202, "_reduce_none", 1, 202, "_reduce_none", 1, 202, "_reduce_none", 1, 202, "_reduce_none", 1, 310, "_reduce_none", 1, 310, "_reduce_none", 1, 310, "_reduce_none", 1, 198, "_reduce_none", 1, 198, "_reduce_none", 1, 180, "_reduce_728", 1, 180, "_reduce_729", 0, 152, "_reduce_none", 1, 152, "_reduce_none", 0, 187, "_reduce_none", 1, 187, "_reduce_none", 2, 213, "_reduce_734", 2, 179, "_reduce_735", 2, 334, "_reduce_736", 0, 236, "_reduce_none", 1, 236, "_reduce_none", 1, 236, "_reduce_none", 1, 264, "_reduce_740", 1, 264, "_reduce_none", 1, 154, "_reduce_none", 2, 154, "_reduce_none", 0, 234, "_reduce_744"];
      racc_reduce_n = 745;
      racc_shift_n = 1238;
      racc_token_table = $hash(false, 0, "error", 1, "kCLASS", 2, "kMODULE", 3, "kDEF", 4, "kUNDEF", 5, "kBEGIN", 6, "kRESCUE", 7, "kENSURE", 8, "kEND", 9, "kIF", 10, "kUNLESS", 11, "kTHEN", 12, "kELSIF", 13, "kELSE", 14, "kCASE", 15, "kWHEN", 16, "kWHILE", 17, "kUNTIL", 18, "kFOR", 19, "kBREAK", 20, "kNEXT", 21, "kREDO", 22, "kRETRY", 23, "kIN", 24, "kDO", 25, "kDO_COND", 26, "kDO_BLOCK", 27, "kDO_LAMBDA", 28, "kRETURN", 29, "kYIELD", 30, "kSUPER", 31, "kSELF", 32, "kNIL", 33, "kTRUE", 34, "kFALSE", 35, "kAND", 36, "kOR", 37, "kNOT", 38, "kIF_MOD", 39, "kUNLESS_MOD", 40, "kWHILE_MOD", 41, "kUNTIL_MOD", 42, "kRESCUE_MOD", 43, "kALIAS", 44, "kDEFINED", 45, "klBEGIN", 46, "klEND", 47, "k__LINE__", 48, "k__FILE__", 49, "k__ENCODING__", 50, "tIDENTIFIER", 51, "tFID", 52, "tGVAR", 53, "tIVAR", 54, "tCONSTANT", 55, "tLABEL", 56, "tCVAR", 57, "tNTH_REF", 58, "tBACK_REF", 59, "tSTRING_CONTENT", 60, "tINTEGER", 61, "tFLOAT", 62, "tUPLUS", 63, "tUMINUS", 64, "tUNARY_NUM", 65, "tPOW", 66, "tCMP", 67, "tEQ", 68, "tEQQ", 69, "tNEQ", 70, "tGEQ", 71, "tLEQ", 72, "tANDOP", 73, "tOROP", 74, "tMATCH", 75, "tNMATCH", 76, "tDOT", 77, "tDOT2", 78, "tDOT3", 79, "tAREF", 80, "tASET", 81, "tLSHFT", 82, "tRSHFT", 83, "tCOLON2", 84, "tCOLON3", 85, "tOP_ASGN", 86, "tASSOC", 87, "tLPAREN", 88, "tLPAREN2", 89, "tRPAREN", 90, "tLPAREN_ARG", 91, "tLBRACK", 92, "tLBRACK2", 93, "tRBRACK", 94, "tLBRACE", 95, "tLBRACE_ARG", 96, "tSTAR", 97, "tSTAR2", 98, "tAMPER", 99, "tAMPER2", 100, "tTILDE", 101, "tPERCENT", 102, "tDIVIDE", 103, "tDSTAR", 104, "tPLUS", 105, "tMINUS", 106, "tLT", 107, "tGT", 108, "tPIPE", 109, "tBANG", 110, "tCARET", 111, "tLCURLY", 112, "tRCURLY", 113, "tBACK_REF2", 114, "tSYMBEG", 115, "tSTRING_BEG", 116, "tXSTRING_BEG", 117, "tREGEXP_BEG", 118, "tREGEXP_OPT", 119, "tWORDS_BEG", 120, "tQWORDS_BEG", 121, "tSYMBOLS_BEG", 122, "tQSYMBOLS_BEG", 123, "tSTRING_DBEG", 124, "tSTRING_DVAR", 125, "tSTRING_END", 126, "tSTRING_DEND", 127, "tSTRING", 128, "tSYMBOL", 129, "tNL", 130, "tEH", 131, "tCOLON", 132, "tCOMMA", 133, "tSPACE", 134, "tSEMI", 135, "tLAMBDA", 136, "tLAMBEG", 137, "tCHARACTER", 138, "tRATIONAL", 139, "tIMAGINARY", 140, "tLABEL_END", 141, "tANDDOT", 142, "tBDOT2", 143, "tBDOT3", 144, "tEQL", 145, "tLOWEST", 146);
      racc_nt_base = 147;
      racc_use_result_var = true;
      $const_set($nesting[0], 'Racc_arg', [racc_action_table, racc_action_check, racc_action_default, racc_action_pointer, racc_goto_table, racc_goto_check, racc_goto_default, racc_goto_pointer, racc_nt_base, racc_reduce_table, racc_token_table, racc_shift_n, racc_reduce_n, racc_use_result_var]);
      $const_set($nesting[0], 'Racc_token_to_s_table', ["$end", "error", "kCLASS", "kMODULE", "kDEF", "kUNDEF", "kBEGIN", "kRESCUE", "kENSURE", "kEND", "kIF", "kUNLESS", "kTHEN", "kELSIF", "kELSE", "kCASE", "kWHEN", "kWHILE", "kUNTIL", "kFOR", "kBREAK", "kNEXT", "kREDO", "kRETRY", "kIN", "kDO", "kDO_COND", "kDO_BLOCK", "kDO_LAMBDA", "kRETURN", "kYIELD", "kSUPER", "kSELF", "kNIL", "kTRUE", "kFALSE", "kAND", "kOR", "kNOT", "kIF_MOD", "kUNLESS_MOD", "kWHILE_MOD", "kUNTIL_MOD", "kRESCUE_MOD", "kALIAS", "kDEFINED", "klBEGIN", "klEND", "k__LINE__", "k__FILE__", "k__ENCODING__", "tIDENTIFIER", "tFID", "tGVAR", "tIVAR", "tCONSTANT", "tLABEL", "tCVAR", "tNTH_REF", "tBACK_REF", "tSTRING_CONTENT", "tINTEGER", "tFLOAT", "tUPLUS", "tUMINUS", "tUNARY_NUM", "tPOW", "tCMP", "tEQ", "tEQQ", "tNEQ", "tGEQ", "tLEQ", "tANDOP", "tOROP", "tMATCH", "tNMATCH", "tDOT", "tDOT2", "tDOT3", "tAREF", "tASET", "tLSHFT", "tRSHFT", "tCOLON2", "tCOLON3", "tOP_ASGN", "tASSOC", "tLPAREN", "tLPAREN2", "tRPAREN", "tLPAREN_ARG", "tLBRACK", "tLBRACK2", "tRBRACK", "tLBRACE", "tLBRACE_ARG", "tSTAR", "tSTAR2", "tAMPER", "tAMPER2", "tTILDE", "tPERCENT", "tDIVIDE", "tDSTAR", "tPLUS", "tMINUS", "tLT", "tGT", "tPIPE", "tBANG", "tCARET", "tLCURLY", "tRCURLY", "tBACK_REF2", "tSYMBEG", "tSTRING_BEG", "tXSTRING_BEG", "tREGEXP_BEG", "tREGEXP_OPT", "tWORDS_BEG", "tQWORDS_BEG", "tSYMBOLS_BEG", "tQSYMBOLS_BEG", "tSTRING_DBEG", "tSTRING_DVAR", "tSTRING_END", "tSTRING_DEND", "tSTRING", "tSYMBOL", "tNL", "tEH", "tCOLON", "tCOMMA", "tSPACE", "tSEMI", "tLAMBDA", "tLAMBEG", "tCHARACTER", "tRATIONAL", "tIMAGINARY", "tLABEL_END", "tANDDOT", "tBDOT2", "tBDOT3", "tEQL", "tLOWEST", "$start", "program", "top_compstmt", "@1", "top_stmts", "opt_terms", "top_stmt", "terms", "stmt", "begin_block", "bodystmt", "compstmt", "opt_rescue", "opt_else", "opt_ensure", "stmts", "stmt_or_begin", "fitem", "undef_list", "expr_value", "command_asgn", "mlhs", "command_call", "lhs", "mrhs", "mrhs_arg", "expr", "@2", "command_rhs", "var_lhs", "primary_value", "opt_call_args", "rbracket", "call_op", "defn_head", "f_opt_paren_args", "command", "arg", "defs_head", "backref", "opt_nl", "p_top_expr_body", "@3", "@4", "expr_value_do", "do", "def_name", "@5", "fname", "k_def", "singleton", "dot_or_colon", "@6", "block_command", "block_call", "operation2", "command_args", "cmd_brace_block", "brace_body", "fcall", "@7", "operation", "k_return", "call_args", "mlhs_basic", "mlhs_inner", "rparen", "mlhs_head", "mlhs_item", "mlhs_node", "mlhs_post", "user_variable", "keyword_variable", "cname", "cpath", "op", "reswords", "symbol", "@8", "arg_rhs", "simple_numeric", "rel_expr", "primary", "relop", "@9", "arg_value", "aref_args", "none", "args", "trailer", "assocs", "paren_args", "args_forward", "opt_paren_args", "opt_block_arg", "block_arg", "@10", "literal", "strings", "xstring", "regexp", "words", "qwords", "symbols", "qsymbols", "var_ref", "assoc_list", "brace_block", "method_call", "lambda", "then", "if_tail", "case_body", "p_case_body", "for_var", "k_class", "superclass", "term", "k_module", "f_arglist", "@11", "@12", "@13", "@14", "@15", "@16", "@17", "f_marg", "f_norm_arg", "f_margs", "f_marg_list", "f_rest_marg", "f_any_kwrest", "f_kwrest", "f_no_kwarg", "f_eq", "block_args_tail", "@18", "f_block_kwarg", "opt_f_block_arg", "f_block_arg", "opt_block_args_tail", "excessed_comma", "block_param", "f_arg", "f_block_optarg", "f_rest_arg", "opt_block_param", "block_param_def", "opt_bv_decl", "bv_decls", "bvar", "f_bad_arg", "f_larglist", "lambda_body", "@19", "@20", "f_args", "do_block", "@21", "@22", "do_body", "@23", "operation3", "@24", "@25", "@26", "@27", "@28", "cases", "p_top_expr", "p_cases", "@29", "@30", "p_expr", "p_args", "p_find", "p_args_tail", "p_kwargs", "p_as", "p_variable", "p_alt", "p_expr_basic", "p_lparen", "p_lbracket", "p_value", "p_const", "rbrace", "@31", "@32", "p_args_head", "p_arg", "p_args_post", "p_rest", "p_kwarg", "p_any_kwrest", "p_kw", "p_kw_label", "string_contents", "p_kwrest", "kwrest_mark", "p_kwnorest", "p_primitive", "p_var_ref", "p_expr_ref", "nonlocal_var", "exc_list", "exc_var", "numeric", "string", "string1", "xstring_contents", "regexp_contents", "word_list", "word", "string_content", "symbol_list", "qword_list", "qsym_list", "string_dvar", "@33", "ssym", "dsym", "@34", "f_paren_args", "args_tail", "@35", "f_kwarg", "opt_args_tail", "f_optarg", "f_arg_asgn", "f_arg_item", "f_label", "f_kw", "f_block_kw", "f_opt", "f_block_opt", "restarg_mark", "blkarg_mark", "assoc"]);
      $const_set($nesting[0], 'Racc_debug_parser', false);
      
      $def(self, '$_reduce_1', function $$_reduce_1(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$push(nil);
        self.max_numparam_stack.$push($hash2(["static"], {"static": true}));
        return result;
      }, 3);
      
      $def(self, '$_reduce_2', function $$_reduce_2(val, _values, result) {
        var self = this;

        
        result = val['$[]'](1);
        self.current_arg_stack.$pop();
        self.max_numparam_stack.$pop();
        return result;
      }, 3);
      
      $def(self, '$_reduce_3', function $$_reduce_3(val, _values, result) {
        var self = this;

        
        result = self.builder.$compstmt(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_4', function $$_reduce_4(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_5', function $$_reduce_5(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_6', function $$_reduce_6(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_7', function $$_reduce_7(val, _values, result) {
        
        
        result = [val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_9', function $$_reduce_9(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'preexe', [val['$[]'](0)].concat($to_a(val['$[]'](1))));
        return result;
      }, 3);
      
      $def(self, '$_reduce_10', function $$_reduce_10(val, _values, result) {
        
        
        result = val;
        return result;
      }, 3);
      
      $def(self, '$_reduce_11', function $$_reduce_11(val, _values, result) {
        var $a, $b, self = this, rescue_bodies = nil, else_t = nil, else_ = nil, ensure_t = nil, ensure_ = nil;

        
        rescue_bodies = val['$[]'](1);
        $b = val['$[]'](2), $a = $to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;
        $b = val['$[]'](3), $a = $to_ary($b), (ensure_t = ($a[0] == null ? nil : $a[0])), (ensure_ = ($a[1] == null ? nil : $a[1])), $b;
        if (($truthy(rescue_bodies['$empty?']()) && ($not(else_t['$nil?']())))) {
          self.$diagnostic("error", "useless_else", nil, else_t)
        };
        result = self.builder.$begin_body(val['$[]'](0), rescue_bodies, else_t, else_, ensure_t, ensure_);
        return result;
      }, 3);
      
      $def(self, '$_reduce_12', function $$_reduce_12(val, _values, result) {
        var self = this;

        
        result = self.builder.$compstmt(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_13', function $$_reduce_13(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_14', function $$_reduce_14(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_15', function $$_reduce_15(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_16', function $$_reduce_16(val, _values, result) {
        
        
        result = [val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_18', function $$_reduce_18(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "begin_in_method", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_19', function $$_reduce_19(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_fname");
        return result;
      }, 3);
      
      $def(self, '$_reduce_20', function $$_reduce_20(val, _values, result) {
        var self = this;

        
        result = self.builder.$alias(val['$[]'](0), val['$[]'](1), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_21', function $$_reduce_21(val, _values, result) {
        var self = this;

        
        result = self.builder.$alias(val['$[]'](0), self.builder.$gvar(val['$[]'](1)), self.builder.$gvar(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_22', function $$_reduce_22(val, _values, result) {
        var self = this;

        
        result = self.builder.$alias(val['$[]'](0), self.builder.$gvar(val['$[]'](1)), self.builder.$back_ref(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_23', function $$_reduce_23(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "nth_ref_alias", nil, val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_24', function $$_reduce_24(val, _values, result) {
        var self = this;

        
        result = self.builder.$undef_method(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_25', function $$_reduce_25(val, _values, result) {
        var self = this;

        
        result = self.builder.$condition_mod(val['$[]'](0), nil, val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_26', function $$_reduce_26(val, _values, result) {
        var self = this;

        
        result = self.builder.$condition_mod(nil, val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_27', function $$_reduce_27(val, _values, result) {
        var self = this;

        
        result = self.builder.$loop_mod("while", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_28', function $$_reduce_28(val, _values, result) {
        var self = this;

        
        result = self.builder.$loop_mod("until", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_29', function $$_reduce_29(val, _values, result) {
        var self = this, rescue_body = nil;

        
        rescue_body = self.builder.$rescue_body(val['$[]'](1), nil, nil, nil, nil, val['$[]'](2));
        result = self.builder.$begin_body(val['$[]'](0), [rescue_body]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_30', function $$_reduce_30(val, _values, result) {
        var self = this;

        
        result = self.builder.$postexe(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_32', function $$_reduce_32(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_33', function $$_reduce_33(val, _values, result) {
        var self = this;

        
        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), self.builder.$array(nil, val['$[]'](2), nil));
        return result;
      }, 3);
      
      $def(self, '$_reduce_34', function $$_reduce_34(val, _values, result) {
        var self = this, rescue_body = nil, begin_body = nil;

        
        rescue_body = self.builder.$rescue_body(val['$[]'](3), nil, nil, nil, nil, val['$[]'](4));
        begin_body = self.builder.$begin_body(val['$[]'](2), [rescue_body]);
        result = self.builder.$multi_assign(val['$[]'](0), val['$[]'](1), begin_body);
        return result;
      }, 3);
      
      $def(self, '$_reduce_35', function $$_reduce_35(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_37', function $$_reduce_37(val, _values, result) {
        var self = this;

        
        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_38', function $$_reduce_38(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_39', function $$_reduce_39(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3)), val['$[]'](4), val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_40', function $$_reduce_40(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_41', function $$_reduce_41(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_42', function $$_reduce_42(val, _values, result) {
        var self = this, const$ = nil;

        
        const$ = self.builder.$const_op_assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));
        result = self.builder.$op_assign(const$, val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_43', function $$_reduce_43(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_44', function $$_reduce_44(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), ($c = $to_ary(($a[1] == null ? nil : $a[1])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        result = self.builder.$def_endless_method(def_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_45', function $$_reduce_45(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, name_t = nil, ctx = nil, rescue_body = nil, method_body = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), ($c = $to_ary(($a[1] == null ? nil : $a[1])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        rescue_body = self.builder.$rescue_body(val['$[]'](4), nil, nil, nil, nil, val['$[]'](5));
        method_body = self.builder.$begin_body(val['$[]'](3), [rescue_body]);
        result = self.builder.$def_endless_method(def_t, name_t, val['$[]'](1), val['$[]'](2), method_body);
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_46', function $$_reduce_46(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, recv = nil, dot_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), (recv = ($a[1] == null ? nil : $a[1])), (dot_t = ($a[2] == null ? nil : $a[2])), ($c = $to_ary(($a[3] == null ? nil : $a[3])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        result = self.builder.$def_endless_singleton(def_t, recv, dot_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_47', function $$_reduce_47(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, recv = nil, dot_t = nil, name_t = nil, ctx = nil, rescue_body = nil, method_body = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), (recv = ($a[1] == null ? nil : $a[1])), (dot_t = ($a[2] == null ? nil : $a[2])), ($c = $to_ary(($a[3] == null ? nil : $a[3])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        rescue_body = self.builder.$rescue_body(val['$[]'](4), nil, nil, nil, nil, val['$[]'](5));
        method_body = self.builder.$begin_body(val['$[]'](3), [rescue_body]);
        result = self.builder.$def_endless_singleton(def_t, recv, dot_t, name_t, val['$[]'](1), val['$[]'](2), method_body);
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_48', function $$_reduce_48(val, _values, result) {
        var self = this;

        
        self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_50', function $$_reduce_50(val, _values, result) {
        var self = this, rescue_body = nil;

        
        rescue_body = self.builder.$rescue_body(val['$[]'](1), nil, nil, nil, nil, val['$[]'](2));
        result = self.builder.$begin_body(val['$[]'](0), [rescue_body]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_53', function $$_reduce_53(val, _values, result) {
        var self = this;

        
        result = self.builder.$logical_op("and", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_54', function $$_reduce_54(val, _values, result) {
        var self = this;

        
        result = self.builder.$logical_op("or", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_55', function $$_reduce_55(val, _values, result) {
        var self = this;

        
        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](2), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_56', function $$_reduce_56(val, _values, result) {
        var self = this;

        
        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_57', function $$_reduce_57(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_beg");
        self.lexer['$command_start='](false);
        self.pattern_variables.$push();
        self.pattern_hash_keys.$push();
        result = self.context.$in_kwarg();
        self.context['$in_kwarg='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_58', function $$_reduce_58(val, _values, result) {
        var self = this;

        
        self.pattern_variables.$pop();
        self.pattern_hash_keys.$pop();
        self.context['$in_kwarg='](val['$[]'](2));
        result = self.builder.$match_pattern(val['$[]'](0), val['$[]'](1), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_59', function $$_reduce_59(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_beg");
        self.lexer['$command_start='](false);
        self.pattern_variables.$push();
        self.pattern_hash_keys.$push();
        result = self.context.$in_kwarg();
        self.context['$in_kwarg='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_60', function $$_reduce_60(val, _values, result) {
        var self = this;

        
        self.pattern_variables.$pop();
        self.pattern_hash_keys.$pop();
        self.context['$in_kwarg='](val['$[]'](2));
        result = self.builder.$match_pattern_p(val['$[]'](0), val['$[]'](1), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_63', function $$_reduce_63(val, _values, result) {
        var self = this;

        
        self.lexer.$cond().$push(true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_64', function $$_reduce_64(val, _values, result) {
        var self = this;

        
        self.lexer.$cond().$pop();
        result = [val['$[]'](1), val['$[]'](2)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_65', function $$_reduce_65(val, _values, result) {
        var self = this;

        
        self.$local_push();
        self.current_arg_stack.$push(nil);
        result = [val['$[]'](0), self.context.$dup()];
        self.context['$in_def='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_66', function $$_reduce_66(val, _values, result) {
        
        
        result = [val['$[]'](0), val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_67', function $$_reduce_67(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_fname");
        self.context['$in_argdef='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_68', function $$_reduce_68(val, _values, result) {
        
        
        result = [val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](4)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_72', function $$_reduce_72(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_73', function $$_reduce_73(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_block='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_74', function $$_reduce_74(val, _values, result) {
        var self = this;

        
        self.context['$in_block='](val['$[]'](1).$in_block());
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](3)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_76', function $$_reduce_76(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(nil, nil, val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_77', function $$_reduce_77(val, _values, result) {
        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        method_call = self.builder.$call_method(nil, nil, val['$[]'](0), nil, val['$[]'](1), nil);
        $b = val['$[]'](2), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_78', function $$_reduce_78(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_79', function $$_reduce_79(val, _values, result) {
        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        $b = val['$[]'](4), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_80', function $$_reduce_80(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_81', function $$_reduce_81(val, _values, result) {
        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        $b = val['$[]'](4), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_82', function $$_reduce_82(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("super", val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_83', function $$_reduce_83(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("yield", val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_84', function $$_reduce_84(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("return", val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_85', function $$_reduce_85(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("break", val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_86', function $$_reduce_86(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("next", val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_87', function $$_reduce_87(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_lhs(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_88', function $$_reduce_88(val, _values, result) {
        var self = this;

        
        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_89', function $$_reduce_89(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_lhs(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_90', function $$_reduce_90(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_92', function $$_reduce_92(val, _values, result) {
        
        
        result = val['$[]'](0).$push(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_93', function $$_reduce_93(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1), val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_94', function $$_reduce_94(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1), val['$[]'](2))).$concat(val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_95', function $$_reduce_95(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_96', function $$_reduce_96(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1))).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_97', function $$_reduce_97(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_98', function $$_reduce_98(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))].concat($to_a(val['$[]'](3)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_99', function $$_reduce_99(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_100', function $$_reduce_100(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0))].concat($to_a(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_102', function $$_reduce_102(val, _values, result) {
        var self = this;

        
        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_103', function $$_reduce_103(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_104', function $$_reduce_104(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_105', function $$_reduce_105(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_106', function $$_reduce_106(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_107', function $$_reduce_107(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_108', function $$_reduce_108(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_109', function $$_reduce_109(val, _values, result) {
        var self = this;

        
        result = self.builder.$index_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_110', function $$_reduce_110(val, _values, result) {
        var self = this;

        
        if ($eqeq(val['$[]'](1)['$[]'](0), "anddot")) {
          self.$diagnostic("error", "csend_in_lhs_of_masgn", nil, val['$[]'](1))
        };
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_111', function $$_reduce_111(val, _values, result) {
        var self = this;

        
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_112', function $$_reduce_112(val, _values, result) {
        var self = this;

        
        if ($eqeq(val['$[]'](1)['$[]'](0), "anddot")) {
          self.$diagnostic("error", "csend_in_lhs_of_masgn", nil, val['$[]'](1))
        };
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_113', function $$_reduce_113(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_114', function $$_reduce_114(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_115', function $$_reduce_115(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_116', function $$_reduce_116(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_117', function $$_reduce_117(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_118', function $$_reduce_118(val, _values, result) {
        var self = this;

        
        result = self.builder.$index_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_119', function $$_reduce_119(val, _values, result) {
        var self = this;

        
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_120', function $$_reduce_120(val, _values, result) {
        var self = this;

        
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_121', function $$_reduce_121(val, _values, result) {
        var self = this;

        
        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_122', function $$_reduce_122(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_123', function $$_reduce_123(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_124', function $$_reduce_124(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_125', function $$_reduce_125(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "module_name_const", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_127', function $$_reduce_127(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_global(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_128', function $$_reduce_128(val, _values, result) {
        var self = this;

        
        result = self.builder.$const(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_129', function $$_reduce_129(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_135', function $$_reduce_135(val, _values, result) {
        var self = this;

        
        result = self.builder.$symbol_internal(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_137', function $$_reduce_137(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_138', function $$_reduce_138(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_fname");
        return result;
      }, 3);
      
      $def(self, '$_reduce_139', function $$_reduce_139(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_211', function $$_reduce_211(val, _values, result) {
        var self = this;

        
        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_212', function $$_reduce_212(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_213', function $$_reduce_213(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3)), val['$[]'](4), val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_214', function $$_reduce_214(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_215', function $$_reduce_215(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_216', function $$_reduce_216(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_217', function $$_reduce_217(val, _values, result) {
        var self = this, const$ = nil;

        
        const$ = self.builder.$const_op_assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));
        result = self.builder.$op_assign(const$, val['$[]'](3), val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_218', function $$_reduce_218(val, _values, result) {
        var self = this, const$ = nil;

        
        const$ = self.builder.$const_op_assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));
        result = self.builder.$op_assign(const$, val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_219', function $$_reduce_219(val, _values, result) {
        var self = this;

        
        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_220', function $$_reduce_220(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_221', function $$_reduce_221(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_222', function $$_reduce_222(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(val['$[]'](0), val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_223', function $$_reduce_223(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(val['$[]'](0), val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_224', function $$_reduce_224(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(nil, val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_225', function $$_reduce_225(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(nil, val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_226', function $$_reduce_226(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_227', function $$_reduce_227(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_228', function $$_reduce_228(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_229', function $$_reduce_229(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_230', function $$_reduce_230(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_231', function $$_reduce_231(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_232', function $$_reduce_232(val, _values, result) {
        var self = this;

        
        result = self.builder.$unary_op(val['$[]'](0), self.builder.$binary_op(val['$[]'](1), val['$[]'](2), val['$[]'](3)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_233', function $$_reduce_233(val, _values, result) {
        var self = this;

        
        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_234', function $$_reduce_234(val, _values, result) {
        var self = this;

        
        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_235', function $$_reduce_235(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_236', function $$_reduce_236(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_237', function $$_reduce_237(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_238', function $$_reduce_238(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_240', function $$_reduce_240(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_241', function $$_reduce_241(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_242', function $$_reduce_242(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_243', function $$_reduce_243(val, _values, result) {
        var self = this;

        
        result = self.builder.$match_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_244', function $$_reduce_244(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_245', function $$_reduce_245(val, _values, result) {
        var self = this;

        
        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_246', function $$_reduce_246(val, _values, result) {
        var self = this;

        
        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_247', function $$_reduce_247(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_248', function $$_reduce_248(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_249', function $$_reduce_249(val, _values, result) {
        var self = this;

        
        result = self.builder.$logical_op("and", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_250', function $$_reduce_250(val, _values, result) {
        var self = this;

        
        result = self.builder.$logical_op("or", val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_251', function $$_reduce_251(val, _values, result) {
        var self = this;

        
        self.context['$in_defined='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_252', function $$_reduce_252(val, _values, result) {
        var self = this;

        
        self.context['$in_defined='](false);
        result = self.builder.$keyword_cmd("defined?", val['$[]'](0), nil, [val['$[]'](3)], nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_253', function $$_reduce_253(val, _values, result) {
        var self = this;

        
        result = self.builder.$ternary(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](4), val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_254', function $$_reduce_254(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), ($c = $to_ary(($a[1] == null ? nil : $a[1])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        result = self.builder.$def_endless_method(def_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_255', function $$_reduce_255(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, name_t = nil, ctx = nil, rescue_body = nil, method_body = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), ($c = $to_ary(($a[1] == null ? nil : $a[1])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        rescue_body = self.builder.$rescue_body(val['$[]'](4), nil, nil, nil, nil, val['$[]'](5));
        method_body = self.builder.$begin_body(val['$[]'](3), [rescue_body]);
        result = self.builder.$def_endless_method(def_t, name_t, val['$[]'](1), val['$[]'](2), method_body);
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_256', function $$_reduce_256(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, recv = nil, dot_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), (recv = ($a[1] == null ? nil : $a[1])), (dot_t = ($a[2] == null ? nil : $a[2])), ($c = $to_ary(($a[3] == null ? nil : $a[3])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        result = self.builder.$def_endless_singleton(def_t, recv, dot_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_257', function $$_reduce_257(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, recv = nil, dot_t = nil, name_t = nil, ctx = nil, rescue_body = nil, method_body = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), (recv = ($a[1] == null ? nil : $a[1])), (dot_t = ($a[2] == null ? nil : $a[2])), ($c = $to_ary(($a[3] == null ? nil : $a[3])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        self.$endless_method_name(name_t);
        rescue_body = self.builder.$rescue_body(val['$[]'](4), nil, nil, nil, nil, val['$[]'](5));
        method_body = self.builder.$begin_body(val['$[]'](3), [rescue_body]);
        result = self.builder.$def_endless_singleton(def_t, recv, dot_t, name_t, val['$[]'](1), val['$[]'](2), method_body);
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_263', function $$_reduce_263(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_264', function $$_reduce_264(val, _values, result) {
        var self = this;

        
        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_268', function $$_reduce_268(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$associate(nil, val['$[]'](2), nil));
        return result;
      }, 3);
      
      $def(self, '$_reduce_269', function $$_reduce_269(val, _values, result) {
        var self = this;

        
        result = [self.builder.$associate(nil, val['$[]'](0), nil)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_271', function $$_reduce_271(val, _values, result) {
        var self = this, rescue_body = nil;

        
        rescue_body = self.builder.$rescue_body(val['$[]'](1), nil, nil, nil, nil, val['$[]'](2));
        result = self.builder.$begin_body(val['$[]'](0), [rescue_body]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_272', function $$_reduce_272(val, _values, result) {
        
        
        result = val;
        return result;
      }, 3);
      
      $def(self, '$_reduce_273', function $$_reduce_273(val, _values, result) {
        var self = this;

        
        if (!$truthy(self.static_env['$declared_forward_args?']())) {
          self.$diagnostic("error", "unexpected_token", $hash2(["token"], {"token": "tBDOT3"}), val['$[]'](3))
        };
        result = [val['$[]'](0), [].concat($to_a(val['$[]'](1))).concat([self.builder.$forwarded_args(val['$[]'](3))]), val['$[]'](4)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_274', function $$_reduce_274(val, _values, result) {
        var self = this;

        
        if (!$truthy(self.static_env['$declared_forward_args?']())) {
          self.$diagnostic("error", "unexpected_token", $hash2(["token"], {"token": "tBDOT3"}), val['$[]'](1))
        };
        result = [val['$[]'](0), [self.builder.$forwarded_args(val['$[]'](1))], val['$[]'](2)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_275', function $$_reduce_275(val, _values, result) {
        
        
        result = [nil, [], nil];
        return result;
      }, 3);
      
      $def(self, '$_reduce_277', function $$_reduce_277(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_280', function $$_reduce_280(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$associate(nil, val['$[]'](2), nil));
        return result;
      }, 3);
      
      $def(self, '$_reduce_281', function $$_reduce_281(val, _values, result) {
        var self = this;

        
        result = [self.builder.$associate(nil, val['$[]'](0), nil)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_282', function $$_reduce_282(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_283', function $$_reduce_283(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_284', function $$_reduce_284(val, _values, result) {
        var self = this;

        
        result = [self.builder.$associate(nil, val['$[]'](0), nil)];
        result.$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_285', function $$_reduce_285(val, _values, result) {
        var self = this, assocs = nil;

        
        assocs = self.builder.$associate(nil, val['$[]'](2), nil);
        result = val['$[]'](0)['$<<'](assocs);
        result.$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_286', function $$_reduce_286(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_287', function $$_reduce_287(val, _values, result) {
        var self = this, last_token = nil, lookahead = nil, $ret_or_1 = nil, top = nil;

        
        last_token = self.last_token['$[]'](0);
        lookahead = ($truthy(($ret_or_1 = last_token['$==']("tLBRACK"))) ? ($ret_or_1) : (last_token['$==']("tLPAREN_ARG")));
        if ($truthy(lookahead)) {
          
          top = self.lexer.$cmdarg().$pop();
          self.lexer.$cmdarg().$push(true);
          self.lexer.$cmdarg().$push(top);
        } else {
          self.lexer.$cmdarg().$push(true)
        };
        return result;
      }, 3);
      
      $def(self, '$_reduce_288', function $$_reduce_288(val, _values, result) {
        var self = this, last_token = nil, lookahead = nil, top = nil;

        
        last_token = self.last_token['$[]'](0);
        lookahead = last_token['$==']("tLBRACE_ARG");
        if ($truthy(lookahead)) {
          
          top = self.lexer.$cmdarg().$pop();
          self.lexer.$cmdarg().$pop();
          self.lexer.$cmdarg().$push(top);
        } else {
          self.lexer.$cmdarg().$pop()
        };
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_289', function $$_reduce_289(val, _values, result) {
        var self = this;

        
        result = self.builder.$block_pass(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_290', function $$_reduce_290(val, _values, result) {
        var self = this;

        
        if ($not(self.static_env['$declared_anonymous_blockarg?']())) {
          self.$diagnostic("error", "no_anonymous_blockarg", nil, val['$[]'](0))
        };
        result = self.builder.$block_pass(val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_291', function $$_reduce_291(val, _values, result) {
        
        
        result = [val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_292', function $$_reduce_292(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_293', function $$_reduce_293(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_294', function $$_reduce_294(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_295', function $$_reduce_295(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_296', function $$_reduce_296(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$splat(val['$[]'](2), val['$[]'](3)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_297', function $$_reduce_297(val, _values, result) {
        var self = this;

        
        result = self.builder.$array(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_299', function $$_reduce_299(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_300', function $$_reduce_300(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$splat(val['$[]'](2), val['$[]'](3)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_301', function $$_reduce_301(val, _values, result) {
        var self = this;

        
        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_312', function $$_reduce_312(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(nil, nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_313', function $$_reduce_313(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$push(false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_314', function $$_reduce_314(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$pop();
        result = self.builder.$begin_keyword(val['$[]'](0), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_315', function $$_reduce_315(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_endarg");
        return result;
      }, 3);
      
      $def(self, '$_reduce_316', function $$_reduce_316(val, _values, result) {
        var self = this;

        
        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_317', function $$_reduce_317(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_endarg");
        return result;
      }, 3);
      
      $def(self, '$_reduce_318', function $$_reduce_318(val, _values, result) {
        var self = this;

        
        result = self.builder.$begin(val['$[]'](0), nil, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_319', function $$_reduce_319(val, _values, result) {
        var self = this;

        
        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_320', function $$_reduce_320(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_321', function $$_reduce_321(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_global(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_322', function $$_reduce_322(val, _values, result) {
        var self = this;

        
        result = self.builder.$array(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_323', function $$_reduce_323(val, _values, result) {
        var self = this;

        
        result = self.builder.$associate(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_324', function $$_reduce_324(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("return", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_325', function $$_reduce_325(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("yield", val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_326', function $$_reduce_326(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("yield", val['$[]'](0), val['$[]'](1), [], val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_327', function $$_reduce_327(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("yield", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_328', function $$_reduce_328(val, _values, result) {
        var self = this;

        
        self.context['$in_defined='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_329', function $$_reduce_329(val, _values, result) {
        var self = this;

        
        self.context['$in_defined='](false);
        result = self.builder.$keyword_cmd("defined?", val['$[]'](0), val['$[]'](2), [val['$[]'](4)], val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_330', function $$_reduce_330(val, _values, result) {
        var self = this;

        
        result = self.builder.$not_op(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_331', function $$_reduce_331(val, _values, result) {
        var self = this;

        
        result = self.builder.$not_op(val['$[]'](0), val['$[]'](1), nil, val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_332', function $$_reduce_332(val, _values, result) {
        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        method_call = self.builder.$call_method(nil, nil, val['$[]'](0));
        $b = val['$[]'](1), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_334', function $$_reduce_334(val, _values, result) {
        var $a, $b, self = this, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        $b = val['$[]'](1), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(val['$[]'](0), begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_336', function $$_reduce_336(val, _values, result) {
        var $a, $b, self = this, else_t = nil, else_ = nil;

        
        $b = val['$[]'](4), $a = $to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;
        result = self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3), else_t, else_, val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_337', function $$_reduce_337(val, _values, result) {
        var $a, $b, self = this, else_t = nil, else_ = nil;

        
        $b = val['$[]'](4), $a = $to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;
        result = self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), else_, else_t, val['$[]'](3), val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_338', function $$_reduce_338(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'loop', ["while", val['$[]'](0)].concat($to_a(val['$[]'](1))).concat([val['$[]'](2), val['$[]'](3)]));
        return result;
      }, 3);
      
      $def(self, '$_reduce_339', function $$_reduce_339(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'loop', ["until", val['$[]'](0)].concat($to_a(val['$[]'](1))).concat([val['$[]'](2), val['$[]'](3)]));
        return result;
      }, 3);
      
      $def(self, '$_reduce_340', function $$_reduce_340(val, _values, result) {
        var $a, $b, $c, self = this, when_bodies = nil, else_t = nil, else_body = nil;

        
        $a = [].concat($to_a(val['$[]'](3))), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_bodies = $slice.call($a, 0, $b)), ($c = $to_ary(($a[$b] == null ? nil : $a[$b])), (else_t = ($c[0] == null ? nil : $c[0])), (else_body = ($c[1] == null ? nil : $c[1]))), $a;
        result = self.builder.$case(val['$[]'](0), val['$[]'](1), when_bodies, else_t, else_body, val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_341', function $$_reduce_341(val, _values, result) {
        var $a, $b, $c, self = this, when_bodies = nil, else_t = nil, else_body = nil;

        
        $a = [].concat($to_a(val['$[]'](2))), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_bodies = $slice.call($a, 0, $b)), ($c = $to_ary(($a[$b] == null ? nil : $a[$b])), (else_t = ($c[0] == null ? nil : $c[0])), (else_body = ($c[1] == null ? nil : $c[1]))), $a;
        result = self.builder.$case(val['$[]'](0), nil, when_bodies, else_t, else_body, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_342', function $$_reduce_342(val, _values, result) {
        var $a, $b, $c, self = this, in_bodies = nil, else_t = nil, else_body = nil;

        
        $a = [].concat($to_a(val['$[]'](3))), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (in_bodies = $slice.call($a, 0, $b)), ($c = $to_ary(($a[$b] == null ? nil : $a[$b])), (else_t = ($c[0] == null ? nil : $c[0])), (else_body = ($c[1] == null ? nil : $c[1]))), $a;
        result = self.builder.$case_match(val['$[]'](0), val['$[]'](1), in_bodies, else_t, else_body, val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_343', function $$_reduce_343(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'for', [val['$[]'](0), val['$[]'](1), val['$[]'](2)].concat($to_a(val['$[]'](3))).concat([val['$[]'](4), val['$[]'](5)]));
        return result;
      }, 3);
      
      $def(self, '$_reduce_344', function $$_reduce_344(val, _values, result) {
        var self = this;

        
        self.context['$in_class='](true);
        self.$local_push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_345', function $$_reduce_345(val, _values, result) {
        var $a, $b, self = this, k_class = nil, ctx = nil, lt_t = nil, superclass = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (k_class = ($a[0] == null ? nil : $a[0])), (ctx = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(self.context.$in_def())) {
          self.$diagnostic("error", "class_in_def", nil, k_class)
        };
        $b = val['$[]'](2), $a = $to_ary($b), (lt_t = ($a[0] == null ? nil : $a[0])), (superclass = ($a[1] == null ? nil : $a[1])), $b;
        result = self.builder.$def_class(k_class, val['$[]'](1), lt_t, superclass, val['$[]'](4), val['$[]'](5));
        self.$local_pop();
        self.context['$in_class='](ctx.$in_class());
        return result;
      }, 3);
      
      $def(self, '$_reduce_346', function $$_reduce_346(val, _values, result) {
        var self = this;

        
        self.context['$in_def='](false);
        self.context['$in_class='](false);
        self.$local_push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_347', function $$_reduce_347(val, _values, result) {
        var $a, $b, self = this, k_class = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (k_class = ($a[0] == null ? nil : $a[0])), (ctx = ($a[1] == null ? nil : $a[1])), $b;
        result = self.builder.$def_sclass(k_class, val['$[]'](1), val['$[]'](2), val['$[]'](5), val['$[]'](6));
        self.$local_pop();
        self.context['$in_def='](ctx.$in_def());
        self.context['$in_class='](ctx.$in_class());
        return result;
      }, 3);
      
      $def(self, '$_reduce_348', function $$_reduce_348(val, _values, result) {
        var self = this;

        
        self.context['$in_class='](true);
        self.$local_push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_349', function $$_reduce_349(val, _values, result) {
        var $a, $b, self = this, k_mod = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (k_mod = ($a[0] == null ? nil : $a[0])), (ctx = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(self.context.$in_def())) {
          self.$diagnostic("error", "module_in_def", nil, k_mod)
        };
        result = self.builder.$def_module(k_mod, val['$[]'](1), val['$[]'](3), val['$[]'](4));
        self.$local_pop();
        self.context['$in_class='](ctx.$in_class());
        return result;
      }, 3);
      
      $def(self, '$_reduce_350', function $$_reduce_350(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), ($c = $to_ary(($a[1] == null ? nil : $a[1])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        result = self.builder.$def_method(def_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_351', function $$_reduce_351(val, _values, result) {
        var $a, $b, $c, self = this, def_t = nil, recv = nil, dot_t = nil, name_t = nil, ctx = nil;

        
        $b = val['$[]'](0), $a = $to_ary($b), (def_t = ($a[0] == null ? nil : $a[0])), (recv = ($a[1] == null ? nil : $a[1])), (dot_t = ($a[2] == null ? nil : $a[2])), ($c = $to_ary(($a[3] == null ? nil : $a[3])), (name_t = ($c[0] == null ? nil : $c[0])), (ctx = ($c[1] == null ? nil : $c[1]))), $b;
        result = self.builder.$def_singleton(def_t, recv, dot_t, name_t, val['$[]'](1), val['$[]'](2), val['$[]'](3));
        self.$local_pop();
        self.current_arg_stack.$pop();
        self.context['$in_def='](ctx.$in_def());
        return result;
      }, 3);
      
      $def(self, '$_reduce_352', function $$_reduce_352(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("break", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_353', function $$_reduce_353(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("next", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_354', function $$_reduce_354(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("redo", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_355', function $$_reduce_355(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("retry", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_357', function $$_reduce_357(val, _values, result) {
        var self = this;

        
        result = [val['$[]'](0), self.context.$dup()];
        return result;
      }, 3);
      
      $def(self, '$_reduce_358', function $$_reduce_358(val, _values, result) {
        var self = this;

        
        result = [val['$[]'](0), self.context.$dup()];
        return result;
      }, 3);
      
      $def(self, '$_reduce_359', function $$_reduce_359(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0);
        self.context['$in_argdef='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_360', function $$_reduce_360(val, _values, result) {
        var self = this, $ret_or_1 = nil;

        
        if ((($truthy(self.context.$in_class()) && ($not(self.context.$in_def()))) && ($not(($truthy(($ret_or_1 = self.$context().$in_block())) ? ($ret_or_1) : (self.$context().$in_lambda())))))) {
          self.$diagnostic("error", "invalid_return", nil, val['$[]'](0))
        };
        return result;
      }, 3);
      
      $def(self, '$_reduce_363', function $$_reduce_363(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_367', function $$_reduce_367(val, _values, result) {
        var $a, $b, self = this, else_t = nil, else_ = nil;

        
        $b = val['$[]'](4), $a = $to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;
        result = [val['$[]'](0), self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3), else_t, else_, nil)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_369', function $$_reduce_369(val, _values, result) {
        
        
        result = val;
        return result;
      }, 3);
      
      $def(self, '$_reduce_372', function $$_reduce_372(val, _values, result) {
        var self = this;

        
        result = self.builder.$arg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_373', function $$_reduce_373(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_374', function $$_reduce_374(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_375', function $$_reduce_375(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_377', function $$_reduce_377(val, _values, result) {
        
        
        result = val['$[]'](0).$push(val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_378', function $$_reduce_378(val, _values, result) {
        
        
        result = val['$[]'](0).$push(val['$[]'](2)).$concat(val['$[]'](4));
        return result;
      }, 3);
      
      $def(self, '$_reduce_379', function $$_reduce_379(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_380', function $$_reduce_380(val, _values, result) {
        
        
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_381', function $$_reduce_381(val, _values, result) {
        var self = this;

        
        result = self.builder.$restarg(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_382', function $$_reduce_382(val, _values, result) {
        var self = this;

        
        result = self.builder.$restarg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_385', function $$_reduce_385(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_386', function $$_reduce_386(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_387', function $$_reduce_387(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_388', function $$_reduce_388(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_389', function $$_reduce_389(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_390', function $$_reduce_390(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_391', function $$_reduce_391(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_392', function $$_reduce_392(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_394', function $$_reduce_394(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_395', function $$_reduce_395(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](6)).$concat(val['$[]'](7));
        return result;
      }, 3);
      
      $def(self, '$_reduce_396', function $$_reduce_396(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_397', function $$_reduce_397(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_398', function $$_reduce_398(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_400', function $$_reduce_400(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_401', function $$_reduce_401(val, _values, result) {
        var self = this;

        
        if (($truthy(val['$[]'](1)['$empty?']()) && ($eqeq(val['$[]'](0).$size(), 1)))) {
          result = [self.builder.$procarg0(val['$[]'](0)['$[]'](0))]
        } else {
          result = val['$[]'](0).$concat(val['$[]'](1))
        };
        return result;
      }, 3);
      
      $def(self, '$_reduce_402', function $$_reduce_402(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_403', function $$_reduce_403(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_404', function $$_reduce_404(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_405', function $$_reduce_405(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_406', function $$_reduce_406(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_407', function $$_reduce_407(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_409', function $$_reduce_409(val, _values, result) {
        var self = this;

        
        result = self.builder.$args(nil, [], nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_410', function $$_reduce_410(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_value");
        return result;
      }, 3);
      
      $def(self, '$_reduce_411', function $$_reduce_411(val, _values, result) {
        var self = this;

        
        self.max_numparam_stack['$has_ordinary_params!']();
        self.current_arg_stack.$set(nil);
        self.context['$in_argdef='](false);
        result = self.builder.$args(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_412', function $$_reduce_412(val, _values, result) {
        var self = this;

        
        self.max_numparam_stack['$has_ordinary_params!']();
        self.current_arg_stack.$set(nil);
        self.context['$in_argdef='](false);
        result = self.builder.$args(val['$[]'](0), val['$[]'](1).$concat(val['$[]'](2)), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_413', function $$_reduce_413(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_414', function $$_reduce_414(val, _values, result) {
        
        
        result = val['$[]'](2);
        return result;
      }, 3);
      
      $def(self, '$_reduce_415', function $$_reduce_415(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_416', function $$_reduce_416(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_417', function $$_reduce_417(val, _values, result) {
        var self = this;

        
        self.static_env.$declare(val['$[]'](0)['$[]'](0));
        result = self.builder.$shadowarg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_419', function $$_reduce_419(val, _values, result) {
        var self = this;

        
        self.static_env.$extend_dynamic();
        self.max_numparam_stack.$push($hash2(["static"], {"static": false}));
        result = self.context.$dup();
        self.context['$in_lambda='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_420', function $$_reduce_420(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$push(false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_421', function $$_reduce_421(val, _values, result) {
        var $a, $b, self = this, lambda_call = nil, args = nil, begin_t = nil, body = nil, end_t = nil;

        
        lambda_call = self.builder.$call_lambda(val['$[]'](0));
        args = ($truthy(self.max_numparam_stack['$has_numparams?']()) ? (self.builder.$numargs(self.max_numparam_stack.$top())) : (val['$[]'](2)));
        $b = val['$[]'](4), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (body = ($a[1] == null ? nil : $a[1])), (end_t = ($a[2] == null ? nil : $a[2])), $b;
        self.max_numparam_stack.$pop();
        self.static_env.$unextend();
        self.lexer.$cmdarg().$pop();
        self.context['$in_lambda='](val['$[]'](1).$in_lambda());
        result = self.builder.$block(lambda_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_422', function $$_reduce_422(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](false);
        self.max_numparam_stack['$has_ordinary_params!']();
        result = self.builder.$args(val['$[]'](0), val['$[]'](1).$concat(val['$[]'](2)), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_423', function $$_reduce_423(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](false);
        if ($truthy(val['$[]'](0)['$any?']())) {
          self.max_numparam_stack['$has_ordinary_params!']()
        };
        result = self.builder.$args(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_424', function $$_reduce_424(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_lambda='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_425', function $$_reduce_425(val, _values, result) {
        var self = this;

        
        self.context['$in_lambda='](val['$[]'](1).$in_lambda());
        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_426', function $$_reduce_426(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_lambda='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_427', function $$_reduce_427(val, _values, result) {
        var self = this;

        
        self.context['$in_lambda='](val['$[]'](1).$in_lambda());
        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_428', function $$_reduce_428(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_block='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_429', function $$_reduce_429(val, _values, result) {
        var self = this;

        
        self.context['$in_block='](val['$[]'](1).$in_block());
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](3)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_430', function $$_reduce_430(val, _values, result) {
        var $a, $b, self = this, begin_t = nil, block_args = nil, body = nil, end_t = nil;

        
        $b = val['$[]'](1), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (block_args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(val['$[]'](0), begin_t, block_args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_431', function $$_reduce_431(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](3), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_432', function $$_reduce_432(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil, method_call = nil, begin_t = nil, body = nil, end_t = nil;

        
        $b = val['$[]'](3), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);
        $b = val['$[]'](4), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_433', function $$_reduce_433(val, _values, result) {
        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;

        
        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);
        $b = val['$[]'](4), $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;
        result = self.builder.$block(method_call, begin_t, args, body, end_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_434', function $$_reduce_434(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](1), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(nil, nil, val['$[]'](0), lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_435', function $$_reduce_435(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](3), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_436', function $$_reduce_436(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](3), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_437', function $$_reduce_437(val, _values, result) {
        var self = this;

        
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_438', function $$_reduce_438(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](2), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), nil, lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_439', function $$_reduce_439(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](2), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), nil, lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_440', function $$_reduce_440(val, _values, result) {
        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;

        
        $b = val['$[]'](1), $a = $to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;
        result = self.builder.$keyword_cmd("super", val['$[]'](0), lparen_t, args, rparen_t);
        return result;
      }, 3);
      
      $def(self, '$_reduce_441', function $$_reduce_441(val, _values, result) {
        var self = this;

        
        result = self.builder.$keyword_cmd("zsuper", val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_442', function $$_reduce_442(val, _values, result) {
        var self = this;

        
        result = self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_443', function $$_reduce_443(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_block='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_444', function $$_reduce_444(val, _values, result) {
        var self = this;

        
        self.context['$in_block='](val['$[]'](1).$in_block());
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](3)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_445', function $$_reduce_445(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_block='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_446', function $$_reduce_446(val, _values, result) {
        var self = this;

        
        self.context['$in_block='](val['$[]'](1).$in_block());
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](3)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_447', function $$_reduce_447(val, _values, result) {
        var self = this;

        
        self.static_env.$extend_dynamic();
        self.max_numparam_stack.$push($hash2(["static"], {"static": false}));
        return result;
      }, 3);
      
      $def(self, '$_reduce_448', function $$_reduce_448(val, _values, result) {
        var self = this, args = nil;

        
        args = ($truthy(self.max_numparam_stack['$has_numparams?']()) ? (self.builder.$numargs(self.max_numparam_stack.$top())) : (val['$[]'](1)));
        result = [args, val['$[]'](2)];
        self.max_numparam_stack.$pop();
        self.static_env.$unextend();
        return result;
      }, 3);
      
      $def(self, '$_reduce_449', function $$_reduce_449(val, _values, result) {
        var self = this;

        
        self.static_env.$extend_dynamic();
        self.max_numparam_stack.$push($hash2(["static"], {"static": false}));
        return result;
      }, 3);
      
      $def(self, '$_reduce_450', function $$_reduce_450(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$push(false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_451', function $$_reduce_451(val, _values, result) {
        var self = this, args = nil;

        
        args = ($truthy(self.max_numparam_stack['$has_numparams?']()) ? (self.builder.$numargs(self.max_numparam_stack.$top())) : (val['$[]'](2)));
        result = [args, val['$[]'](3)];
        self.max_numparam_stack.$pop();
        self.static_env.$unextend();
        self.lexer.$cmdarg().$pop();
        return result;
      }, 3);
      
      $def(self, '$_reduce_452', function $$_reduce_452(val, _values, result) {
        var self = this;

        
        result = [self.builder.$when(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3))].concat($to_a(val['$[]'](4)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_453', function $$_reduce_453(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_455', function $$_reduce_455(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_beg");
        self.lexer['$command_start='](false);
        self.pattern_variables.$push();
        self.pattern_hash_keys.$push();
        result = self.context.$in_kwarg();
        self.context['$in_kwarg='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_456', function $$_reduce_456(val, _values, result) {
        var self = this;

        
        self.pattern_variables.$pop();
        self.pattern_hash_keys.$pop();
        self.context['$in_kwarg='](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_457', function $$_reduce_457(val, _values, result) {
        var self = this;

        
        result = [$send(self.builder, 'in_pattern', [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](3), val['$[]'](5)]))].concat($to_a(val['$[]'](6)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_458', function $$_reduce_458(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_460', function $$_reduce_460(val, _values, result) {
        
        
        result = [val['$[]'](0), nil];
        return result;
      }, 3);
      
      $def(self, '$_reduce_461', function $$_reduce_461(val, _values, result) {
        var self = this;

        
        result = [val['$[]'](0), self.builder.$if_guard(val['$[]'](1), val['$[]'](2))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_462', function $$_reduce_462(val, _values, result) {
        var self = this;

        
        result = [val['$[]'](0), self.builder.$unless_guard(val['$[]'](1), val['$[]'](2))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_464', function $$_reduce_464(val, _values, result) {
        var self = this, item = nil;

        
        item = self.builder.$match_with_trailing_comma(val['$[]'](0), val['$[]'](1));
        result = self.builder.$array_pattern(nil, [item], nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_465', function $$_reduce_465(val, _values, result) {
        var self = this;

        
        result = self.builder.$array_pattern(nil, [val['$[]'](0)].$concat(val['$[]'](2)), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_466', function $$_reduce_466(val, _values, result) {
        var self = this;

        
        result = self.builder.$find_pattern(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_467', function $$_reduce_467(val, _values, result) {
        var self = this;

        
        result = self.builder.$array_pattern(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_468', function $$_reduce_468(val, _values, result) {
        var self = this;

        
        result = self.builder.$hash_pattern(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_470', function $$_reduce_470(val, _values, result) {
        var self = this;

        
        result = self.builder.$match_as(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_472', function $$_reduce_472(val, _values, result) {
        var self = this;

        
        result = self.builder.$match_alt(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_474', function $$_reduce_474(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0);
        self.pattern_hash_keys.$push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_475', function $$_reduce_475(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0);
        self.pattern_hash_keys.$push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_478', function $$_reduce_478(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$array_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_479', function $$_reduce_479(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$find_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_480', function $$_reduce_480(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$hash_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_481', function $$_reduce_481(val, _values, result) {
        var self = this, pattern = nil;

        
        pattern = self.builder.$array_pattern(val['$[]'](1), nil, val['$[]'](2));
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_482', function $$_reduce_482(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$array_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_483', function $$_reduce_483(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$find_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_484', function $$_reduce_484(val, _values, result) {
        var self = this, pattern = nil;

        
        self.pattern_hash_keys.$pop();
        pattern = self.builder.$hash_pattern(nil, val['$[]'](2), nil);
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_485', function $$_reduce_485(val, _values, result) {
        var self = this, pattern = nil;

        
        pattern = self.builder.$array_pattern(val['$[]'](1), nil, val['$[]'](2));
        result = self.builder.$const_pattern(val['$[]'](0), val['$[]'](1), pattern, val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_486', function $$_reduce_486(val, _values, result) {
        var self = this;

        
        result = self.builder.$array_pattern(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_487', function $$_reduce_487(val, _values, result) {
        var self = this;

        
        result = self.builder.$find_pattern(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_488', function $$_reduce_488(val, _values, result) {
        var self = this;

        
        result = self.builder.$array_pattern(val['$[]'](0), [], val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_489', function $$_reduce_489(val, _values, result) {
        var self = this;

        
        self.pattern_hash_keys.$push();
        result = self.context.$in_kwarg();
        self.context['$in_kwarg='](false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_490', function $$_reduce_490(val, _values, result) {
        var self = this;

        
        self.pattern_hash_keys.$pop();
        self.context['$in_kwarg='](val['$[]'](1));
        result = self.builder.$hash_pattern(val['$[]'](0), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_491', function $$_reduce_491(val, _values, result) {
        var self = this;

        
        result = self.builder.$hash_pattern(val['$[]'](0), [], val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_492', function $$_reduce_492(val, _values, result) {
        var self = this;

        
        self.pattern_hash_keys.$push();
        return result;
      }, 3);
      
      $def(self, '$_reduce_493', function $$_reduce_493(val, _values, result) {
        var self = this;

        
        self.pattern_hash_keys.$pop();
        result = self.builder.$begin(val['$[]'](0), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_494', function $$_reduce_494(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_495', function $$_reduce_495(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_496', function $$_reduce_496(val, _values, result) {
        
        
        result = [].concat($to_a(val['$[]'](0))).concat([val['$[]'](1)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_497', function $$_reduce_497(val, _values, result) {
        var self = this, match_rest = nil;

        
        match_rest = self.builder.$match_rest(val['$[]'](1), val['$[]'](2));
        result = [].concat($to_a(val['$[]'](0))).concat([match_rest]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_498', function $$_reduce_498(val, _values, result) {
        var self = this, match_rest = nil;

        
        match_rest = self.builder.$match_rest(val['$[]'](1), val['$[]'](2));
        result = [].concat($to_a(val['$[]'](0))).concat([match_rest]).concat($to_a(val['$[]'](4)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_499', function $$_reduce_499(val, _values, result) {
        var self = this;

        
        result = [].concat($to_a(val['$[]'](0))).concat([self.builder.$match_rest(val['$[]'](1))]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_500', function $$_reduce_500(val, _values, result) {
        var self = this;

        
        result = [].concat($to_a(val['$[]'](0))).concat([self.builder.$match_rest(val['$[]'](1))]).concat($to_a(val['$[]'](3)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_502', function $$_reduce_502(val, _values, result) {
        var self = this, item = nil;

        
        item = self.builder.$match_with_trailing_comma(val['$[]'](0), val['$[]'](1));
        result = [item];
        return result;
      }, 3);
      
      $def(self, '$_reduce_503', function $$_reduce_503(val, _values, result) {
        var self = this, last_item = nil;

        
        last_item = self.builder.$match_with_trailing_comma(val['$[]'](1), val['$[]'](2));
        result = [].concat($to_a(val['$[]'](0))).concat([last_item]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_504', function $$_reduce_504(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_505', function $$_reduce_505(val, _values, result) {
        
        
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_506', function $$_reduce_506(val, _values, result) {
        
        
        result = [val['$[]'](0)].concat($to_a(val['$[]'](2))).concat([val['$[]'](4)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_507', function $$_reduce_507(val, _values, result) {
        var self = this;

        
        result = self.builder.$match_rest(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_508', function $$_reduce_508(val, _values, result) {
        var self = this;

        
        result = self.builder.$match_rest(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_509', function $$_reduce_509(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_510', function $$_reduce_510(val, _values, result) {
        
        
        result = [].concat($to_a(val['$[]'](0))).concat([val['$[]'](2)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_512', function $$_reduce_512(val, _values, result) {
        
        
        result = [].concat($to_a(val['$[]'](0))).concat($to_a(val['$[]'](2)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_513', function $$_reduce_513(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_514', function $$_reduce_514(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_515', function $$_reduce_515(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_516', function $$_reduce_516(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_517', function $$_reduce_517(val, _values, result) {
        
        
        result = [].concat($to_a(val['$[]'](0))).concat([val['$[]'](2)]);
        return result;
      }, 3);
      
      $def(self, '$_reduce_518', function $$_reduce_518(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'match_pair', $to_a(val['$[]'](0)).concat([val['$[]'](1)]));
        return result;
      }, 3);
      
      $def(self, '$_reduce_519', function $$_reduce_519(val, _values, result) {
        var self = this;

        
        result = $send(self.builder, 'match_label', $to_a(val['$[]'](0)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_520', function $$_reduce_520(val, _values, result) {
        
        
        result = ["label", val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_521', function $$_reduce_521(val, _values, result) {
        
        
        result = ["quoted", [val['$[]'](0), val['$[]'](1), val['$[]'](2)]];
        return result;
      }, 3);
      
      $def(self, '$_reduce_522', function $$_reduce_522(val, _values, result) {
        var self = this;

        
        result = [self.builder.$match_rest(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_523', function $$_reduce_523(val, _values, result) {
        var self = this;

        
        result = [self.builder.$match_rest(val['$[]'](0), nil)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_524', function $$_reduce_524(val, _values, result) {
        var self = this;

        
        result = [self.builder.$match_nil_pattern(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_528', function $$_reduce_528(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_529', function $$_reduce_529(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_530', function $$_reduce_530(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(val['$[]'](0), val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_531', function $$_reduce_531(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(val['$[]'](0), val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_535', function $$_reduce_535(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_inclusive(nil, val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_536', function $$_reduce_536(val, _values, result) {
        var self = this;

        
        result = self.builder.$range_exclusive(nil, val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_545', function $$_reduce_545(val, _values, result) {
        var self = this;

        
        result = self.builder.$accessible(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_547', function $$_reduce_547(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(self.builder.$match_var(val['$[]'](0)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_548', function $$_reduce_548(val, _values, result) {
        var self = this, name = nil, lvar = nil;

        
        name = val['$[]'](1)['$[]'](0);
        if (!$truthy(self.$static_env()['$declared?'](name))) {
          self.$diagnostic("error", "undefined_lvar", $hash2(["name"], {"name": name}), val['$[]'](1))
        };
        lvar = self.builder.$accessible(self.builder.$ident(val['$[]'](1)));
        result = self.builder.$pin(val['$[]'](0), lvar);
        return result;
      }, 3);
      
      $def(self, '$_reduce_549', function $$_reduce_549(val, _values, result) {
        var self = this, non_lvar = nil;

        
        non_lvar = self.builder.$accessible(val['$[]'](1));
        result = self.builder.$pin(val['$[]'](0), non_lvar);
        return result;
      }, 3);
      
      $def(self, '$_reduce_550', function $$_reduce_550(val, _values, result) {
        var self = this, expr = nil;

        
        expr = self.builder.$begin(val['$[]'](1), val['$[]'](2), val['$[]'](3));
        result = self.builder.$pin(val['$[]'](0), expr);
        return result;
      }, 3);
      
      $def(self, '$_reduce_551', function $$_reduce_551(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_global(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_552', function $$_reduce_552(val, _values, result) {
        var self = this;

        
        result = self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_553', function $$_reduce_553(val, _values, result) {
        var self = this;

        
        result = self.builder.$const(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_554', function $$_reduce_554(val, _values, result) {
        var $a, $b, self = this, assoc_t = nil, exc_var = nil, exc_list = nil;

        
        $b = val['$[]'](2), $a = $to_ary($b), (assoc_t = ($a[0] == null ? nil : $a[0])), (exc_var = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(val['$[]'](1))) {
          exc_list = self.builder.$array(nil, val['$[]'](1), nil)
        };
        result = [self.builder.$rescue_body(val['$[]'](0), exc_list, assoc_t, exc_var, val['$[]'](3), val['$[]'](4))].concat($to_a(val['$[]'](5)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_555', function $$_reduce_555(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_556', function $$_reduce_556(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_559', function $$_reduce_559(val, _values, result) {
        
        
        result = [val['$[]'](0), val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_561', function $$_reduce_561(val, _values, result) {
        
        
        result = [val['$[]'](0), val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_565', function $$_reduce_565(val, _values, result) {
        var self = this;

        
        result = self.builder.$string_compose(nil, val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_566', function $$_reduce_566(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_567', function $$_reduce_567(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_568', function $$_reduce_568(val, _values, result) {
        var self = this, string = nil;

        
        string = self.builder.$string_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());
        return result;
      }, 3);
      
      $def(self, '$_reduce_569', function $$_reduce_569(val, _values, result) {
        var self = this, string = nil;

        
        string = self.builder.$string(val['$[]'](0));
        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());
        return result;
      }, 3);
      
      $def(self, '$_reduce_570', function $$_reduce_570(val, _values, result) {
        var self = this;

        
        result = self.builder.$character(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_571', function $$_reduce_571(val, _values, result) {
        var self = this, string = nil;

        
        string = self.builder.$xstring_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());
        return result;
      }, 3);
      
      $def(self, '$_reduce_572', function $$_reduce_572(val, _values, result) {
        var self = this, opts = nil;

        
        opts = self.builder.$regexp_options(val['$[]'](3));
        result = self.builder.$regexp_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2), opts);
        return result;
      }, 3);
      
      $def(self, '$_reduce_573', function $$_reduce_573(val, _values, result) {
        var self = this;

        
        result = self.builder.$words_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_574', function $$_reduce_574(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_575', function $$_reduce_575(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$word(val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_576', function $$_reduce_576(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_577', function $$_reduce_577(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_578', function $$_reduce_578(val, _values, result) {
        var self = this;

        
        result = self.builder.$symbols_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_579', function $$_reduce_579(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_580', function $$_reduce_580(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$word(val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_581', function $$_reduce_581(val, _values, result) {
        var self = this;

        
        result = self.builder.$words_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_582', function $$_reduce_582(val, _values, result) {
        var self = this;

        
        result = self.builder.$symbols_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_583', function $$_reduce_583(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_584', function $$_reduce_584(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$string_internal(val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_585', function $$_reduce_585(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_586', function $$_reduce_586(val, _values, result) {
        var self = this;

        
        result = val['$[]'](0)['$<<'](self.builder.$symbol_internal(val['$[]'](1)));
        return result;
      }, 3);
      
      $def(self, '$_reduce_587', function $$_reduce_587(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_588', function $$_reduce_588(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_589', function $$_reduce_589(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_590', function $$_reduce_590(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_591', function $$_reduce_591(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_592', function $$_reduce_592(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_593', function $$_reduce_593(val, _values, result) {
        var self = this;

        
        result = self.builder.$string_internal(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_594', function $$_reduce_594(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_595', function $$_reduce_595(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$push(false);
        self.lexer.$cond().$push(false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_596', function $$_reduce_596(val, _values, result) {
        var self = this;

        
        self.lexer.$cmdarg().$pop();
        self.lexer.$cond().$pop();
        result = self.builder.$begin(val['$[]'](0), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_597', function $$_reduce_597(val, _values, result) {
        var self = this;

        
        result = self.builder.$gvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_598', function $$_reduce_598(val, _values, result) {
        var self = this;

        
        result = self.builder.$ivar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_599', function $$_reduce_599(val, _values, result) {
        var self = this;

        
        result = self.builder.$cvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_603', function $$_reduce_603(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$symbol(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_604', function $$_reduce_604(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$symbol_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_605', function $$_reduce_605(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_606', function $$_reduce_606(val, _values, result) {
        var self = this;

        
        if ($truthy(self.builder['$respond_to?']("negate"))) {
          result = self.builder.$negate(val['$[]'](0), val['$[]'](1))
        } else {
          result = self.builder.$unary_num(val['$[]'](0), val['$[]'](1))
        };
        return result;
      }, 3);
      
      $def(self, '$_reduce_607', function $$_reduce_607(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$integer(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_608', function $$_reduce_608(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$float(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_609', function $$_reduce_609(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$rational(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_610', function $$_reduce_610(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_end");
        result = self.builder.$complex(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_611', function $$_reduce_611(val, _values, result) {
        var self = this;

        
        result = self.builder.$ivar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_612', function $$_reduce_612(val, _values, result) {
        var self = this;

        
        result = self.builder.$gvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_613', function $$_reduce_613(val, _values, result) {
        var self = this;

        
        result = self.builder.$cvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_614', function $$_reduce_614(val, _values, result) {
        var self = this;

        
        result = self.builder.$ident(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_615', function $$_reduce_615(val, _values, result) {
        var self = this;

        
        result = self.builder.$ivar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_616', function $$_reduce_616(val, _values, result) {
        var self = this;

        
        result = self.builder.$gvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_617', function $$_reduce_617(val, _values, result) {
        var self = this;

        
        result = self.builder.$const(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_618', function $$_reduce_618(val, _values, result) {
        var self = this;

        
        result = self.builder.$cvar(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_619', function $$_reduce_619(val, _values, result) {
        var self = this;

        
        result = self.builder.$nil(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_620', function $$_reduce_620(val, _values, result) {
        var self = this;

        
        result = self.builder.$self(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_621', function $$_reduce_621(val, _values, result) {
        var self = this;

        
        result = self.builder.$true(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_622', function $$_reduce_622(val, _values, result) {
        var self = this;

        
        result = self.builder.$false(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_623', function $$_reduce_623(val, _values, result) {
        var self = this;

        
        result = self.builder.$__FILE__(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_624', function $$_reduce_624(val, _values, result) {
        var self = this;

        
        result = self.builder.$__LINE__(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_625', function $$_reduce_625(val, _values, result) {
        var self = this;

        
        result = self.builder.$__ENCODING__(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_626', function $$_reduce_626(val, _values, result) {
        var self = this;

        
        result = self.builder.$accessible(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_627', function $$_reduce_627(val, _values, result) {
        var self = this;

        
        result = self.builder.$accessible(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_628', function $$_reduce_628(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_629', function $$_reduce_629(val, _values, result) {
        var self = this;

        
        result = self.builder.$assignable(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_630', function $$_reduce_630(val, _values, result) {
        var self = this;

        
        result = self.builder.$nth_ref(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_631', function $$_reduce_631(val, _values, result) {
        var self = this;

        
        result = self.builder.$back_ref(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_632', function $$_reduce_632(val, _values, result) {
        var self = this;

        
        self.lexer['$state=']("expr_value");
        return result;
      }, 3);
      
      $def(self, '$_reduce_633', function $$_reduce_633(val, _values, result) {
        
        
        result = [val['$[]'](0), val['$[]'](2)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_634', function $$_reduce_634(val, _values, result) {
        
        
        result = nil;
        return result;
      }, 3);
      
      $def(self, '$_reduce_636', function $$_reduce_636(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](false);
        result = self.builder.$args(nil, [], nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_637', function $$_reduce_637(val, _values, result) {
        var self = this;

        
        result = self.builder.$args(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        self.lexer['$state=']("expr_value");
        self.context['$in_argdef='](false);
        return result;
      }, 3);
      
      $def(self, '$_reduce_639', function $$_reduce_639(val, _values, result) {
        var self = this;

        
        result = self.context.$dup();
        self.context['$in_kwarg='](true);
        self.context['$in_argdef='](true);
        return result;
      }, 3);
      
      $def(self, '$_reduce_640', function $$_reduce_640(val, _values, result) {
        var self = this;

        
        self.context['$in_kwarg='](val['$[]'](0).$in_kwarg());
        self.context['$in_argdef='](false);
        result = self.builder.$args(nil, val['$[]'](1), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_641', function $$_reduce_641(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_642', function $$_reduce_642(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_643', function $$_reduce_643(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_644', function $$_reduce_644(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_645', function $$_reduce_645(val, _values, result) {
        var self = this;

        
        self.static_env.$declare_forward_args();
        result = [self.builder.$forward_arg(val['$[]'](0))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_646', function $$_reduce_646(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_647', function $$_reduce_647(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_648', function $$_reduce_648(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_649', function $$_reduce_649(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](6)).$concat(val['$[]'](7));
        return result;
      }, 3);
      
      $def(self, '$_reduce_650', function $$_reduce_650(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_651', function $$_reduce_651(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_652', function $$_reduce_652(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_653', function $$_reduce_653(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_654', function $$_reduce_654(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_655', function $$_reduce_655(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_656', function $$_reduce_656(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));
        return result;
      }, 3);
      
      $def(self, '$_reduce_657', function $$_reduce_657(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_658', function $$_reduce_658(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_659', function $$_reduce_659(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_660', function $$_reduce_660(val, _values, result) {
        
        
        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_661', function $$_reduce_661(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_662', function $$_reduce_662(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_663', function $$_reduce_663(val, _values, result) {
        
        
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_664', function $$_reduce_664(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "argument_const", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_665', function $$_reduce_665(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "argument_ivar", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_666', function $$_reduce_666(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "argument_gvar", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_667', function $$_reduce_667(val, _values, result) {
        var self = this;

        
        self.$diagnostic("error", "argument_cvar", nil, val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_669', function $$_reduce_669(val, _values, result) {
        var self = this;

        
        self.static_env.$declare(val['$[]'](0)['$[]'](0));
        self.max_numparam_stack['$has_ordinary_params!']();
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_670', function $$_reduce_670(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(val['$[]'](0)['$[]'](0));
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_671', function $$_reduce_671(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(0);
        result = self.builder.$arg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_672', function $$_reduce_672(val, _values, result) {
        var self = this;

        
        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_673', function $$_reduce_673(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_674', function $$_reduce_674(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_675', function $$_reduce_675(val, _values, result) {
        var self = this;

        
        self.$check_kwarg_name(val['$[]'](0));
        self.static_env.$declare(val['$[]'](0)['$[]'](0));
        self.max_numparam_stack['$has_ordinary_params!']();
        self.current_arg_stack.$set(val['$[]'](0)['$[]'](0));
        self.context['$in_argdef='](false);
        result = val['$[]'](0);
        return result;
      }, 3);
      
      $def(self, '$_reduce_676', function $$_reduce_676(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(nil);
        self.context['$in_argdef='](true);
        result = self.builder.$kwoptarg(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_677', function $$_reduce_677(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(nil);
        self.context['$in_argdef='](true);
        result = self.builder.$kwarg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_678', function $$_reduce_678(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](true);
        result = self.builder.$kwoptarg(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_679', function $$_reduce_679(val, _values, result) {
        var self = this;

        
        self.context['$in_argdef='](true);
        result = self.builder.$kwarg(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_680', function $$_reduce_680(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_681', function $$_reduce_681(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_682', function $$_reduce_682(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_683', function $$_reduce_683(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_686', function $$_reduce_686(val, _values, result) {
        var self = this;

        
        result = [self.builder.$kwnilarg(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_687', function $$_reduce_687(val, _values, result) {
        var self = this;

        
        self.static_env.$declare(val['$[]'](1)['$[]'](0));
        result = [self.builder.$kwrestarg(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_688', function $$_reduce_688(val, _values, result) {
        var self = this;

        
        result = [self.builder.$kwrestarg(val['$[]'](0))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_689', function $$_reduce_689(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(0);
        self.context['$in_argdef='](true);
        result = self.builder.$optarg(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_690', function $$_reduce_690(val, _values, result) {
        var self = this;

        
        self.current_arg_stack.$set(0);
        self.context['$in_argdef='](true);
        result = self.builder.$optarg(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_691', function $$_reduce_691(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_692', function $$_reduce_692(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_693', function $$_reduce_693(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_694', function $$_reduce_694(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_697', function $$_reduce_697(val, _values, result) {
        var self = this;

        
        self.static_env.$declare(val['$[]'](1)['$[]'](0));
        result = [self.builder.$restarg(val['$[]'](0), val['$[]'](1))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_698', function $$_reduce_698(val, _values, result) {
        var self = this;

        
        result = [self.builder.$restarg(val['$[]'](0))];
        return result;
      }, 3);
      
      $def(self, '$_reduce_701', function $$_reduce_701(val, _values, result) {
        var self = this;

        
        self.static_env.$declare(val['$[]'](1)['$[]'](0));
        result = self.builder.$blockarg(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_702', function $$_reduce_702(val, _values, result) {
        var self = this;

        
        self.static_env.$declare_anonymous_blockarg();
        result = self.builder.$blockarg(val['$[]'](0), nil);
        return result;
      }, 3);
      
      $def(self, '$_reduce_703', function $$_reduce_703(val, _values, result) {
        
        
        result = [val['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_704', function $$_reduce_704(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_706', function $$_reduce_706(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_707', function $$_reduce_707(val, _values, result) {
        
        
        result = [];
        return result;
      }, 3);
      
      $def(self, '$_reduce_709', function $$_reduce_709(val, _values, result) {
        
        
        result = [val['$[]'](0)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_710', function $$_reduce_710(val, _values, result) {
        
        
        result = val['$[]'](0)['$<<'](val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_711', function $$_reduce_711(val, _values, result) {
        var self = this;

        
        result = self.builder.$pair(val['$[]'](0), val['$[]'](1), val['$[]'](2));
        return result;
      }, 3);
      
      $def(self, '$_reduce_712', function $$_reduce_712(val, _values, result) {
        var self = this;

        
        result = self.builder.$pair_keyword(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_713', function $$_reduce_713(val, _values, result) {
        var self = this;

        
        result = self.builder.$pair_label(val['$[]'](0));
        return result;
      }, 3);
      
      $def(self, '$_reduce_714', function $$_reduce_714(val, _values, result) {
        var self = this;

        
        result = self.builder.$pair_quoted(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));
        return result;
      }, 3);
      
      $def(self, '$_reduce_715', function $$_reduce_715(val, _values, result) {
        var self = this;

        
        result = self.builder.$kwsplat(val['$[]'](0), val['$[]'](1));
        return result;
      }, 3);
      
      $def(self, '$_reduce_728', function $$_reduce_728(val, _values, result) {
        
        
        result = ["dot", val['$[]'](0)['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_729', function $$_reduce_729(val, _values, result) {
        
        
        result = ["anddot", val['$[]'](0)['$[]'](1)];
        return result;
      }, 3);
      
      $def(self, '$_reduce_734', function $$_reduce_734(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_735', function $$_reduce_735(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_736', function $$_reduce_736(val, _values, result) {
        
        
        result = val['$[]'](1);
        return result;
      }, 3);
      
      $def(self, '$_reduce_740', function $$_reduce_740(val, _values, result) {
        var self = this;

        
        self.$yyerrok();
        return result;
      }, 3);
      
      $def(self, '$_reduce_744', function $$_reduce_744(val, _values, result) {
        
        
        result = nil;
        return result;
      }, 3);
      return $def(self, '$_reduce_none', function $$_reduce_none(val, _values, result) {
        
        return val['$[]'](0)
      }, 3);
    })($nesting[0], $$$($$('Parser'), 'Base'), $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/ast/builder"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $Opal = Opal.Opal, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('require,emit_lambda=,new');
  
  self.$require("opal/ast/node");
  self.$require("parser/ruby31");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Builder');

        
        
        self['$emit_lambda='](true);
        return $def(self, '$n', function $$n(type, children, location) {
          
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, $hash2(["location"], {"location": location}))
        }, 3);
      })($nesting[0], $$$($$$($$$('Parser'), 'Builders'), 'Default'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $return_self = Opal.return_self, $return_val = Opal.return_val, $const_set = Opal.const_set, $truthy = Opal.truthy, $Opal = Opal.Opal, $hash2 = Opal.hash2, $defs = Opal.defs, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $send = Opal.send, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('require,new,current_node,loc,process_regular_node,on_send,+,stmts_of,begin_with_stmts,nil?,include?,type,children,length,[],s,attr_accessor,current_node=,location=,raise,[]=,meta');
  
  self.$require("parser");
  self.$require("opal/ast/node");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.dynamic_cache_result = nil;
        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'DummyLocation');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          
          $def(self, '$node=', function $DummyLocation_node$eq$1($a) {
            var $post_args, $rest_arg;

            
            
            $post_args = Opal.slice.call(arguments);
            
            $rest_arg = $post_args;;
            return nil;
          }, -1);
          
          $def(self, '$expression', $return_self, 0);
          
          $def(self, '$begin_pos', $return_val(0), 0);
          
          $def(self, '$end_pos', $return_val(0), 0);
          
          $def(self, '$source', $return_val(""), 0);
          
          $def(self, '$line', $return_val(0), 0);
          
          $def(self, '$column', $return_val(0), 0);
          return $def(self, '$last_line', function $$last_line() {
            
            return $$$($$('Float'), 'INFINITY')
          }, 0);
        })($nesting[0], null, $nesting);
        $const_set($nesting[0], 'DUMMY_LOCATION', $$('DummyLocation').$new());
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children, self = this, loc = nil;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          children = $post_args;;
          loc = ($truthy(self.$current_node()) ? (self.$current_node().$loc()) : ($$('DUMMY_LOCATION')));
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, $hash2(["location"], {"location": loc}));
        }, -2);
        $defs(self, '$s', function $$s(type, $a) {
          var $post_args, children;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          children = $post_args;;
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, $hash2(["location"], {"location": $$('DUMMY_LOCATION')}));
        }, -2);
        $alias(self, "on_iter", "process_regular_node");
        $alias(self, "on_zsuper", "process_regular_node");
        $alias(self, "on_jscall", "on_send");
        $alias(self, "on_jsattr", "process_regular_node");
        $alias(self, "on_jsattrasgn", "process_regular_node");
        $alias(self, "on_kwsplat", "process_regular_node");
        
        $def(self, '$prepend_to_body', function $$prepend_to_body(body, node) {
          var self = this, stmts = nil;

          
          stmts = $rb_plus(self.$stmts_of(node), self.$stmts_of(body));
          return self.$begin_with_stmts(stmts);
        }, 2);
        
        $def(self, '$append_to_body', function $$append_to_body(body, node) {
          var self = this, stmts = nil;

          
          stmts = $rb_plus(self.$stmts_of(body), self.$stmts_of(node));
          return self.$begin_with_stmts(stmts);
        }, 2);
        
        $def(self, '$stmts_of', function $$stmts_of(node) {
          
          if ($truthy(node['$nil?']())) {
            return []
          } else if ($truthy(["begin", "kwbegin"]['$include?'](node.$type()))) {
            return node.$children()
          } else {
            return [node]
          }
        }, 1);
        
        $def(self, '$begin_with_stmts', function $$begin_with_stmts(stmts) {
          var self = this;

          
          switch (stmts.$length()) {
            case 0:
              return nil
            case 1:
              return stmts['$[]'](0)
            default:
              return $send(self, 's', ["begin"].concat($to_a(stmts)))
          }
        }, 1);
        self.$attr_accessor("current_node");
        
        $def(self, '$process', function $$process(node) {
          var $a, $yield = $$process.$$p || nil, self = this;

          delete $$process.$$p;
          return (function() { try {
          
          self['$current_node='](node);
          return $send2(self, $find_super(self, 'process', $$process, false, true), 'process', [node], $yield);
          } finally {
            ($a = [nil], $send(self, 'current_node=', $a), $a[$a.length - 1])
          }; })()
        }, 1);
        
        $def(self, '$error', function $$error(msg) {
          var self = this, error = nil;

          
          error = $$$($Opal, 'RewritingError').$new(msg);
          if ($truthy(self.$current_node())) {
            error['$location='](self.$current_node().$loc())
          };
          return self.$raise(error);
        }, 1);
        
        $def(self, '$on_top', function $$on_top(node) {
          var self = this;

          
          node = self.$process_regular_node(node);
          if ($truthy(self.dynamic_cache_result)) {
            node.$meta()['$[]=']("dynamic_cache_result", true)
          };
          return node;
        }, 1);
        return $def(self, '$dynamic!', $assign_ivar_val("dynamic_cache_result", true), 0);
      })($nesting[0], $$$($$$($$$('Parser'), 'AST'), 'Processor'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/opal_engine_check"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_a = Opal.to_a, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $const_set = Opal.const_set;

  Opal.add_stubs('require,children,skip_check_present?,process,s,skip_check_present_not?,==');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'OpalEngineCheck');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$on_if', function $$on_if(node) {
          var $a, $yield = $$on_if.$$p || nil, self = this, test = nil, true_body = nil, false_body = nil, $ret_or_1 = nil;

          delete $$on_if.$$p;
          
          $a = [].concat($to_a(node.$children())), (test = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
          if ($truthy(self['$skip_check_present?'](test))) {
            return self.$process(($truthy(($ret_or_1 = true_body)) ? ($ret_or_1) : (self.$s("nil"))))
          } else if ($truthy(self['$skip_check_present_not?'](test))) {
            return self.$process(($truthy(($ret_or_1 = false_body)) ? ($ret_or_1) : (self.$s("nil"))))
          } else {
            return $send2(self, $find_super(self, 'on_if', $$on_if, false, true), 'on_if', [node], $yield)
          };
        }, 1);
        
        $def(self, '$skip_check_present?', function $OpalEngineCheck_skip_check_present$ques$1(test) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = test['$==']($$('RUBY_ENGINE_CHECK'))))) {
            return $ret_or_1
          } else {
            return test['$==']($$('RUBY_PLATFORM_CHECK'))
          }
        }, 1);
        
        $def(self, '$skip_check_present_not?', function $OpalEngineCheck_skip_check_present_not$ques$2(test) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = test['$==']($$('RUBY_ENGINE_CHECK_NOT'))))) {
            return $ret_or_1
          } else {
            return test['$==']($$('RUBY_PLATFORM_CHECK_NOT'))
          }
        }, 1);
        $const_set($nesting[0], 'RUBY_ENGINE_CHECK', self.$s("send", self.$s("const", nil, "RUBY_ENGINE"), "==", self.$s("str", "opal")));
        $const_set($nesting[0], 'RUBY_ENGINE_CHECK_NOT', self.$s("send", self.$s("const", nil, "RUBY_ENGINE"), "!=", self.$s("str", "opal")));
        $const_set($nesting[0], 'RUBY_PLATFORM_CHECK', self.$s("send", self.$s("const", nil, "RUBY_PLATFORM"), "==", self.$s("str", "opal")));
        return $const_set($nesting[0], 'RUBY_PLATFORM_CHECK_NOT', self.$s("send", self.$s("const", nil, "RUBY_PLATFORM"), "!=", self.$s("str", "opal")));
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/for_rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $assign_ivar_val = Opal.assign_ivar_val, $defs = Opal.defs, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs('require,+,find,map,s,next_tmp,class,===,type,updated,<<,prepend_to_body,process,attr_reader,new,to_a,result');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ForRewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', $assign_ivar_val("counter", 0), 0);
        $defs(self, '$next_tmp', function $$next_tmp() {
          var self = this, $ret_or_1 = nil;
          if (self.counter == null) self.counter = nil;

          
          self.counter = ($truthy(($ret_or_1 = self.counter)) ? ($ret_or_1) : (0));
          self.counter = $rb_plus(self.counter, 1);
          return "$for_tmp" + (self.counter);
        }, 0);
        
        $def(self, '$on_for', function $$on_for(node) {
          var $a, self = this, loop_variable = nil, iterating_value = nil, loop_body = nil, iterating_lvars = nil, lvars_declared_in_body = nil, outer_assigns = nil, tmp_loop_variable = nil, get_tmp_loop_variable = nil, loop_variable_assignment = nil, $ret_or_1 = nil;

          
          $a = [].concat($to_a(node)), (loop_variable = ($a[0] == null ? nil : $a[0])), (iterating_value = ($a[1] == null ? nil : $a[1])), (loop_body = ($a[2] == null ? nil : $a[2])), $a;
          iterating_lvars = $$('LocalVariableAssigns').$find(loop_variable);
          lvars_declared_in_body = $$('LocalVariableAssigns').$find(loop_body);
          outer_assigns = $send($rb_plus(iterating_lvars, lvars_declared_in_body), 'map', [], function $$1(lvar_name){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (lvar_name == null) lvar_name = nil;;
            return self.$s("lvdeclare", lvar_name);}, {$$arity: 1, $$s: self});
          tmp_loop_variable = self.$class().$next_tmp();
          get_tmp_loop_variable = self.$s("js_tmp", tmp_loop_variable);
          loop_variable_assignment = ($eqeqeq("mlhs", ($ret_or_1 = loop_variable.$type())) ? (loop_variable.$updated("masgn", [loop_variable, get_tmp_loop_variable])) : (loop_variable['$<<'](get_tmp_loop_variable)));
          loop_body = self.$prepend_to_body(loop_body, loop_variable_assignment);
          node = node.$updated("send", [iterating_value, "each", node.$updated("iter", [self.$s("args", self.$s("arg", tmp_loop_variable)), self.$process(loop_body)])]);
          return node.$updated("begin", [].concat($to_a(outer_assigns)).concat([node]));
        }, 1);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'LocalVariableAssigns');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          self.$attr_reader("result");
          $defs(self, '$find', function $$find(node) {
            var self = this, processor = nil;

            
            processor = self.$new();
            processor.$process(node);
            return processor.$result().$to_a();
          }, 1);
          
          $def(self, '$initialize', function $$initialize() {
            var self = this;

            return (self.result = $$('Set').$new())
          }, 0);
          return $def(self, '$on_lvasgn', function $$on_lvasgn(node) {
            var $a, $yield = $$on_lvasgn.$$p || nil, self = this, name = nil, _ = nil;

            delete $$on_lvasgn.$$p;
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
            self.$result()['$<<'](name);
            return $send2(self, $find_super(self, 'on_lvasgn', $$on_lvasgn, false, true), 'on_lvasgn', [node], $yield);
          }, 1);
        })($nesting[0], $$('Base'), $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/js_reserved_words"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $range = Opal.range, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $hash2 = Opal.hash2, $alias = Opal.alias;

  Opal.add_stubs('require,freeze,=~,!,valid_name?,class,to_sym,valid_ivar_name?,[],to_s,updated,fix_var_name,fix_ivar_name,on_restarg');
  
  self.$require("opal/rewriters/base");
  self.$require("opal/regexp_anchors");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'JsReservedWords');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'ES51_RESERVED_WORD', $regexp([$$('REGEXP_START'), "(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'ES3_RESERVED_WORD_EXCLUSIVE', $regexp([$$('REGEXP_START'), "(?:int|byte|char|goto|long|final|float|short|double|native|throws|boolean|abstract|volatile|transient|synchronized)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'PROTO_SPECIAL_PROPS', $regexp([$$('REGEXP_START'), "(?:constructor|displayName|__proto__|__parent__|__noSuchMethod__|__count__)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'PROTO_SPECIAL_METHODS', $regexp([$$('REGEXP_START'), "(?:hasOwnProperty|valueOf)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'IMMUTABLE_PROPS', $regexp([$$('REGEXP_START'), "(?:NaN|Infinity|undefined)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'BASIC_IDENTIFIER_RULES', $regexp([$$('REGEXP_START'), "[$_a-z][$_a-z\\d]*", $$('REGEXP_END')], 'i').$freeze());
        $const_set($nesting[0], 'RESERVED_FUNCTION_NAMES', $regexp([$$('REGEXP_START'), "(?:Array)", $$('REGEXP_END')]).$freeze());
        $defs(self, '$valid_name?', function $JsReservedWords_valid_name$ques$1(name) {
          var $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = $$('BASIC_IDENTIFIER_RULES')['$=~'](name)))) {
            return ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = $$('ES51_RESERVED_WORD')['$=~'](name))) ? ($ret_or_3) : ($$('ES3_RESERVED_WORD_EXCLUSIVE')['$=~'](name))))) ? ($ret_or_2) : ($$('IMMUTABLE_PROPS')['$=~'](name)))['$!']()
          } else {
            return $ret_or_1
          }
        }, 1);
        $defs(self, '$valid_ivar_name?', function $JsReservedWords_valid_ivar_name$ques$2(name) {
          var $ret_or_1 = nil;

          return ($truthy(($ret_or_1 = $$('PROTO_SPECIAL_PROPS')['$=~'](name))) ? ($ret_or_1) : ($$('PROTO_SPECIAL_METHODS')['$=~'](name)))['$!']()
        }, 1);
        
        $def(self, '$fix_var_name', function $$fix_var_name(name) {
          var self = this;

          if ($truthy(self.$class()['$valid_name?'](name))) {
            return name
          } else {
            return (("" + (name)) + "$").$to_sym()
          }
        }, 1);
        
        $def(self, '$fix_ivar_name', function $$fix_ivar_name(name) {
          var self = this;

          if ($truthy(self.$class()['$valid_ivar_name?'](name.$to_s()['$[]']($range(1, -1, false))))) {
            return name
          } else {
            return (("" + (name)) + "$").$to_sym()
          }
        }, 1);
        
        $def(self, '$on_lvar', function $$on_lvar(node) {
          var $a, $yield = $$on_lvar.$$p || nil, self = this, name = nil, _ = nil;

          delete $$on_lvar.$$p;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          node = node.$updated(nil, [self.$fix_var_name(name)]);
          return $send2(self, $find_super(self, 'on_lvar', $$on_lvar, false, true), 'on_lvar', [node], null);
        }, 1);
        
        $def(self, '$on_lvasgn', function $$on_lvasgn(node) {
          var $a, $yield = $$on_lvasgn.$$p || nil, self = this, name = nil, value = nil;

          delete $$on_lvasgn.$$p;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          node = ($truthy(value) ? (node.$updated(nil, [self.$fix_var_name(name), value])) : (node.$updated(nil, [self.$fix_var_name(name)])));
          return $send2(self, $find_super(self, 'on_lvasgn', $$on_lvasgn, false, true), 'on_lvasgn', [node], null);
        }, 1);
        
        $def(self, '$on_ivar', function $$on_ivar(node) {
          var $a, $yield = $$on_ivar.$$p || nil, self = this, name = nil, _ = nil;

          delete $$on_ivar.$$p;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          node = node.$updated(nil, [self.$fix_ivar_name(name)]);
          return $send2(self, $find_super(self, 'on_ivar', $$on_ivar, false, true), 'on_ivar', [node], null);
        }, 1);
        
        $def(self, '$on_ivasgn', function $$on_ivasgn(node) {
          var $a, $yield = $$on_ivasgn.$$p || nil, self = this, name = nil, value = nil;

          delete $$on_ivasgn.$$p;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          node = ($truthy(value) ? (node.$updated(nil, [self.$fix_ivar_name(name), value])) : (node.$updated(nil, [self.$fix_ivar_name(name)])));
          return $send2(self, $find_super(self, 'on_ivasgn', $$on_ivasgn, false, true), 'on_ivasgn', [node], null);
        }, 1);
        
        $def(self, '$on_restarg', function $$on_restarg(node) {
          var $a, self = this, name = nil, _ = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(name)) {
            node = node.$updated(nil, [self.$fix_var_name(name)], $hash2(["meta"], {"meta": $hash2(["arg_name"], {"arg_name": name})}))
          };
          return node;
        }, 1);
        $alias(self, "on_kwrestarg", "on_restarg");
        return $def(self, '$on_argument', function $$on_argument(node) {
          var $a, $yield = $$on_argument.$$p || nil, self = this, name = nil, value = nil, fixed_name = nil, new_children = nil;

          delete $$on_argument.$$p;
          
          node = $send2(self, $find_super(self, 'on_argument', $$on_argument, false, true), 'on_argument', [node], null);
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          fixed_name = self.$fix_var_name(name);
          new_children = ($truthy(value) ? ([fixed_name, value]) : ([fixed_name]));
          return node.$updated(nil, new_children, $hash2(["meta"], {"meta": $hash2(["arg_name"], {"arg_name": name})}));
        }, 1);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/block_to_iter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $def = Opal.def;

  Opal.add_stubs('require,s,process,updated,+,children');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'BlockToIter');

        
        return $def(self, '$on_block', function $$on_block(node) {
          var $a, self = this, recvr = nil, args = nil, body = nil, iter_node = nil;

          
          $a = [].concat($to_a(node)), (recvr = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          iter_node = self.$s("iter", args, body);
          return self.$process(recvr.$updated(nil, $rb_plus(recvr.$children(), [iter_node])));
        }, 1)
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/dot_js_syntax"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send;

  Opal.add_stubs('require,==,type,!=,size,error,first,to_js_attr_call,to_js_attr_assign_call,to_native_js_call,s');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DotJsSyntax');

        
        
        
        $def(self, '$on_send', function $$on_send(node) {
          var $a, $yield = $$on_send.$$p || nil, self = this, recv = nil, meth = nil, args = nil, recv_of_recv = nil, meth_of_recv = nil, _ = nil, property = nil, value = nil;

          delete $$on_send.$$p;
          
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
          if (($truthy(recv) && ($eqeq(recv.$type(), "send")))) {
            
            $a = [].concat($to_a(recv)), (recv_of_recv = ($a[0] == null ? nil : $a[0])), (meth_of_recv = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $a;
            if ($eqeq(meth_of_recv, "JS")) {
              
              
              switch (meth) {
                case "[]":
                  
                  if ($neqeq(args.$size(), 1)) {
                    self.$error(".JS[:property] syntax supports only one argument")
                  };
                  property = args.$first();
                  node = self.$to_js_attr_call(recv_of_recv, property);
                  break;
                case "[]=":
                  
                  if ($neqeq(args.$size(), 2)) {
                    self.$error(".JS[:property]= syntax supports only two arguments")
                  };
                  $a = [].concat($to_a(args)), (property = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
                  node = self.$to_js_attr_assign_call(recv_of_recv, property, value);
                  break;
                default:
                  node = self.$to_native_js_call(recv_of_recv, meth, args)
              };
              return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], null);
            } else {
              return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
            };
          } else {
            return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
          };
        }, 1);
        
        $def(self, '$to_native_js_call', function $$to_native_js_call(recv, meth, args) {
          var self = this;

          return $send(self, 's', ["jscall", recv, meth].concat($to_a(args)))
        }, 3);
        
        $def(self, '$to_js_attr_call', function $$to_js_attr_call(recv, property) {
          var self = this;

          return self.$s("jsattr", recv, property)
        }, 2);
        return $def(self, '$to_js_attr_assign_call', function $$to_js_attr_assign_call(recv, property, value) {
          var self = this;

          return self.$s("jsattrasgn", recv, property, value)
        }, 3);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/pattern_matching"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $eqeqeq = Opal.eqeqeq, $Opal = Opal.Opal;

  Opal.add_stubs('require,s,convert_full_pattern,raise_no_matching_pattern_error,+,process,single_case_match,private,shift,type,!,empty?,!=,==,class,new,run!,variables,pattern,map,<<,array,on_literal,first,children,to_proc,method,each,to_ast,on_array_pattern,compact,[],===');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PatternMatching');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.depth = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          self.depth = 0;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], $yield);
        }, 0);
        
        $def(self, '$on_match_pattern', function $$on_match_pattern(node) {
          var $a, self = this, from = nil, pat = nil;

          
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), (pat = ($a[1] == null ? nil : $a[1])), $a;
          return self.$s("begin", self.$s("lvasgn", "$pmvar", from), self.$s("if", self.$convert_full_pattern(from, pat), nil, self.$raise_no_matching_pattern_error("$pmvar")));
        }, 1);
        
        $def(self, '$on_match_pattern_p', function $$on_match_pattern_p(node) {
          var $a, self = this, from = nil, pat = nil;

          
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), (pat = ($a[1] == null ? nil : $a[1])), $a;
          return self.$s("if", self.$convert_full_pattern(from, pat), self.$s("true"), self.$s("false"));
        }, 1);
        
        $def(self, '$on_case_match', function $$on_case_match(node) {
          var $a, $b, self = this, cmvar = nil, from = nil, cases = nil, els = nil;

          
          self.depth = $rb_plus(self.depth, 1);
          cmvar = "$cmvar" + (self.depth);
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (cases = $slice.call($a, 1, $b)), (els = ($a[$b] == null ? nil : $a[$b])), $a;
          if ($truthy(els)) {
            self.$process(els)
          } else {
            els = self.$raise_no_matching_pattern_error(cmvar)
          };
          return self.$s("begin", self.$s("lvasgn", cmvar, from), $send(self, 'single_case_match', [cmvar].concat($to_a(cases)).concat([els])));
        }, 1);
        self.$private();
        
        $def(self, '$raise_no_matching_pattern_error', function $$raise_no_matching_pattern_error(from) {
          var self = this;

          return self.$s("send", nil, "raise", self.$s("const", self.$s("cbase"), "NoMatchingPatternError"), self.$s("lvar", from))
        }, 1);
        
        $def(self, '$single_case_match', function $$single_case_match(from, $a, $b) {
          var $post_args, cases, els, $c, self = this, cas = nil, pat = nil, if_guard = nil, body = nil, guard = nil;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          cases = $post_args.splice(0, $post_args.length - 1);;
          
          els = $post_args.shift();
          if (els == null) els = nil;;
          cas = cases.$shift();
          $c = [].concat($to_a(cas)), (pat = ($c[0] == null ? nil : $c[0])), (if_guard = ($c[1] == null ? nil : $c[1])), (body = ($c[2] == null ? nil : $c[2])), $c;
          pat = self.$convert_full_pattern(from, pat);
          if ($truthy(if_guard)) {
            
            $c = [].concat($to_a(if_guard)), (guard = ($c[0] == null ? nil : $c[0])), $c;
            
            switch (if_guard.$type()) {
              case "if_guard":
                pat = self.$s("and", pat, guard)
                break;
              case "unless_guard":
                pat = self.$s("and", pat, self.$s("send", guard, "!"))
                break;
              default:
                nil
            };
          };
          return self.$s("if", pat, self.$process(body), ($not(cases['$empty?']()) ? ($send(self, 'single_case_match', [from].concat($to_a(cases)).concat([els]))) : ($neqeq(els, self.$s("empty_else")) ? (els) : nil)));
        }, -3);
        
        $def(self, '$convert_full_pattern', function $$convert_full_pattern(from, pat) {
          var self = this, converter = nil;

          
          if ($eqeq(from.$class(), $$('Symbol'))) {
            from = self.$s("lvar", from)
          };
          converter = $$('PatternConverter').$new(pat);
          converter['$run!']();
          return self.$s("masgn", $send(self, 's', ["mlhs"].concat($to_a(converter.$variables()))), self.$s("send", self.$s("const", self.$s("cbase"), "PatternMatching"), "call", from, converter.$pattern()));
        }, 2);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'PatternConverter');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.pat = $proto.variables = nil;
          
          
          $def(self, '$initialize', function $$initialize(pat) {
            var self = this;

            
            self.pat = pat;
            return (self.variables = []);
          }, 1);
          
          $def(self, '$run!', function $PatternConverter_run$excl$1() {
            var self = this;

            return (self.outpat = self.$process(self.pat))
          }, 0);
          
          $def(self, '$pattern', $return_ivar("outpat"), 0);
          
          $def(self, '$variables', function $$variables() {
            var self = this;

            return $send(self.variables, 'map', [], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

              
              
              if (i == null) i = nil;;
              return self.$s("lvasgn", i);}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$on_match_var', function $$on_match_var(node) {
            var $a, self = this, var$ = nil;

            
            $a = [].concat($to_a(node)), (var$ = ($a[0] == null ? nil : $a[0])), $a;
            self.variables['$<<'](var$);
            return self.$s("sym", "var");
          }, 1);
          
          $def(self, '$on_match_as', function $$on_match_as(node) {
            var $a, self = this, pat = nil, save = nil;

            
            $a = [].concat($to_a(node)), (pat = ($a[0] == null ? nil : $a[0])), (save = ($a[1] == null ? nil : $a[1])), $a;
            self.$process(save);
            return self.$array(self.$s("sym", "save"), self.$process(pat));
          }, 1);
          
          $def(self, '$on_literal', function $$on_literal(node) {
            var self = this;

            return self.$array(self.$s("sym", "lit"), node)
          }, 1);
          $alias(self, "on_int", "on_literal");
          $alias(self, "on_float", "on_literal");
          $alias(self, "on_complex", "on_literal");
          $alias(self, "on_rational", "on_literal");
          $alias(self, "on_array", "on_literal");
          $alias(self, "on_str", "on_literal");
          $alias(self, "on_dstr", "on_literal");
          $alias(self, "on_xstr", "on_literal");
          $alias(self, "on_sym", "on_literal");
          $alias(self, "on_irange", "on_literal");
          $alias(self, "on_erange", "on_literal");
          $alias(self, "on_const", "on_literal");
          $alias(self, "on_regexp", "on_literal");
          $alias(self, "on_lambda", "on_literal");
          $alias(self, "on_begin", "on_literal");
          
          $def(self, '$on_pin', function $$on_pin(node) {
            var self = this;

            return self.$on_literal(node.$children().$first())
          }, 1);
          
          $def(self, '$on_match_rest', function $$on_match_rest(node) {
            var self = this;

            if ($truthy(node.$children()['$empty?']())) {
              return self.$array(self.$s("sym", "rest"))
            } else {
              return self.$array(self.$s("sym", "rest"), self.$process(node.$children().$first()))
            }
          }, 1);
          
          $def(self, '$on_match_alt', function $$on_match_alt(node) {
            var self = this;

            return $send(self, 'array', [self.$s("sym", "any")].concat($to_a($send(node.$children(), 'map', [], self.$method("process").$to_proc()))))
          }, 1);
          
          $def(self, '$on_const_pattern', function $$on_const_pattern(node) {
            var self = this;

            return $send(self, 'array', [self.$s("sym", "all")].concat($to_a($send(node.$children(), 'map', [], self.$method("process").$to_proc()))))
          }, 1);
          
          $def(self, '$on_array_pattern', function $$on_array_pattern(node, tail) {
            var self = this, children = nil, fixed_size = nil, array_size = nil;

            
            
            if (tail == null) tail = false;;
            children = [].concat($to_a(node));
            if ($truthy(tail)) {
              children['$<<'](self.$s("match_rest"))
            };
            fixed_size = true;
            array_size = 0;
            children = $send(children, 'each', [], function $$3(i){
              
              
              if (i == null) i = nil;;
              
              switch (i.$type()) {
                case "match_rest":
                  return (fixed_size = false)
                default:
                  return (array_size = $rb_plus(array_size, 1))
              };}, 1);
            return self.$array(self.$s("sym", "array"), self.$to_ast(fixed_size), self.$to_ast(array_size), self.$to_ast($send(children, 'map', [], self.$method("process").$to_proc())));
          }, -2);
          
          $def(self, '$on_array_pattern_with_tail', function $$on_array_pattern_with_tail(node) {
            var self = this;

            return self.$on_array_pattern(node, true)
          }, 1);
          
          $def(self, '$on_hash_pattern', function $$on_hash_pattern(node) {
            var self = this, children = nil, any_size = nil;

            
            children = [].concat($to_a(node));
            any_size = ($truthy(children['$empty?']()) ? (self.$to_ast(false)) : (self.$to_ast(true)));
            children = $send(children, 'map', [], function $$4(i){var self = $$4.$$s == null ? this : $$4.$$s;

              
              
              if (i == null) i = nil;;
              
              switch (i.$type()) {
                case "pair":
                  return self.$array(i.$children()['$[]'](0), self.$process(i.$children()['$[]'](1)))
                case "match_var":
                  return self.$array(self.$s("sym", i.$children()['$[]'](0)), self.$process(i))
                case "match_nil_pattern":
                  
                  any_size = self.$to_ast(false);
                  return nil;
                case "match_rest":
                  
                  if ($truthy(i.$children().$first())) {
                    any_size = self.$process(i.$children().$first())
                  } else {
                    any_size = self.$to_ast(true)
                  };
                  return nil;
                default:
                  return nil
              };}, {$$arity: 1, $$s: self}).$compact();
            return self.$array(self.$s("sym", "hash"), any_size, $send(self, 'array', $to_a(children)));
          }, 1);
          
          $def(self, '$on_find_pattern', function $$on_find_pattern(node) {
            var self = this, children = nil;

            
            children = [].concat($to_a(node));
            children = $send(children, 'map', [], self.$method("process").$to_proc());
            return self.$array(self.$s("sym", "find"), $send(self, 'array', $to_a(children)));
          }, 1);
          self.$private();
          
          $def(self, '$array', function $$array($a) {
            var $post_args, args, self = this;

            
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            return self.$to_ast(args);
          }, -1);
          return $def(self, '$to_ast', function $$to_ast(val) {
            var self = this, $ret_or_1 = nil;

            if ($eqeqeq($$('Array'), ($ret_or_1 = val))) {
              return $send(self, 's', ["array"].concat($to_a(val)))
            } else if ($eqeqeq($$('Integer'), $ret_or_1)) {
              return self.$s("int", val)
            } else if ($eqeqeq(true, $ret_or_1)) {
              return self.$s("true")
            } else if ($eqeqeq(false, $ret_or_1)) {
              return self.$s("false")
            } else if ($eqeqeq(nil, $ret_or_1)) {
              return self.$s("nil")
            } else {
              return nil
            }
          }, 1);
        })($nesting[0], $$$($$$($Opal, 'Rewriters'), 'Base'), $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/logical_operator_assignment"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $defs = Opal.defs, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $lambda = Opal.lambda, $eqeq = Opal.eqeq, $to_a = Opal.to_a, $slice = Opal.slice, $hash2 = Opal.hash2, $send = Opal.send, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs('require,+,updated,s,==,include?,[],type,new_temp,freeze,call,fetch,error,process');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'LogicalOperatorAssignment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', function $LogicalOperatorAssignment_reset_tmp_counter$excl$1() {
          
          return $class_variable_set($nesting[0], '@@counter', 0)
        }, 0);
        $defs(self, '$new_temp', function $$new_temp() {
          var $a, $ret_or_1 = nil;

          
          $class_variable_set($nesting[0], '@@counter', ($truthy((($a = $nesting[0].$$cvars['@@counter'], $a != null) ? 'class variable' : nil)) ? (($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@counter', false))) ? ($ret_or_1) : (0))) : (0)));
          $class_variable_set($nesting[0], '@@counter', $rb_plus($class_variable_get($nesting[0], '@@counter', false), 1));
          return "$logical_op_recvr_tmp_" + ($class_variable_get($nesting[0], '@@counter', false));
        }, 0);
        $const_set($nesting[0], 'GET_SET', $lambda(function $LogicalOperatorAssignment$2(get_type, set_type){var self = $LogicalOperatorAssignment$2.$$s == null ? this : $LogicalOperatorAssignment$2.$$s;

          
          
          if (get_type == null) get_type = nil;;
          
          if (set_type == null) set_type = nil;;
          return $lambda(function $$3(lhs, rhs, root_type){var self = $$3.$$s == null ? this : $$3.$$s, get_node = nil, condition_node = nil, defined_node = nil;

            
            
            if (lhs == null) lhs = nil;;
            
            if (rhs == null) rhs = nil;;
            
            if (root_type == null) root_type = nil;;
            get_node = lhs.$updated(get_type);
            condition_node = self.$s(root_type, get_node, rhs);
            if (($truthy(["const", "cvar"]['$include?'](get_type)) && ($eqeq(root_type, "or")))) {
              
              defined_node = self.$s("defined?", get_node);
              condition_node = self.$s("if", defined_node, self.$s("begin", condition_node), rhs);
            };
            return lhs.$updated(set_type, [].concat($to_a(lhs)).concat([condition_node]));}, {$$arity: 3, $$s: self});}, {$$arity: 2, $$s: self}));
        $const_set($nesting[0], 'LocalVariableHandler', $$('GET_SET')['$[]']("lvar", "lvasgn"));
        $const_set($nesting[0], 'InstanceVariableHandler', $$('GET_SET')['$[]']("ivar", "ivasgn"));
        $const_set($nesting[0], 'ConstantHandler', $$('GET_SET')['$[]']("const", "casgn"));
        $const_set($nesting[0], 'GlobalVariableHandler', $$('GET_SET')['$[]']("gvar", "gvasgn"));
        $const_set($nesting[0], 'ClassVariableHandler', $$('GET_SET')['$[]']("cvar", "cvasgn"));
        (function($base, $super) {
          var self = $klass($base, $super, 'SendHandler');

          
          return $defs(self, '$call', function $$call(lhs, rhs, root_type) {
            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_writer = nil, get_or_set = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
            if (($truthy(recvr) && ($eqeq(recvr.$type(), "send")))) {
              
              recvr_tmp = self.$new_temp();
              cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
              recvr = self.$s("js_tmp", recvr_tmp);
            };
            writer_method = "" + (reader_method) + "=";
            call_reader = lhs.$updated("send", [recvr, reader_method].concat($to_a(args)));
            call_writer = lhs.$updated("send", [recvr, writer_method].concat($to_a(args)).concat([rhs]));
            get_or_set = self.$s(root_type, call_reader, call_writer);
            if ($truthy(cache_recvr)) {
              return self.$s("begin", cache_recvr, get_or_set)
            } else {
              return get_or_set
            };
          }, 3)
        })($nesting[0], self);
        (function($base, $super) {
          var self = $klass($base, $super, 'ConditionalSendHandler');

          
          return $defs(self, '$call', function $$call(lhs, rhs, root_type) {
            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_or_asgn = nil;

            
            root_type = "" + (root_type) + "_asgn";
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
            recvr_tmp = self.$new_temp();
            cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
            recvr = self.$s("js_tmp", recvr_tmp);
            recvr_is_nil = self.$s("send", recvr, "nil?");
            plain_send = lhs.$updated("send", [recvr, meth].concat($to_a(args)));
            plain_or_asgn = self.$s(root_type, plain_send, rhs);
            return self.$s("begin", cache_recvr, self.$s("if", recvr_is_nil, self.$s("nil"), plain_or_asgn));
          }, 3)
        })($nesting[0], self);
        $const_set($nesting[0], 'HANDLERS', $hash2(["lvasgn", "ivasgn", "casgn", "gvasgn", "cvasgn", "send", "csend"], {"lvasgn": $$('LocalVariableHandler'), "ivasgn": $$('InstanceVariableHandler'), "casgn": $$('ConstantHandler'), "gvasgn": $$('GlobalVariableHandler'), "cvasgn": $$('ClassVariableHandler'), "send": $$('SendHandler'), "csend": $$('ConditionalSendHandler')}).$freeze());
        
        $def(self, '$on_or_asgn', function $$on_or_asgn(node) {
          var $a, self = this, lhs = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$arity: 0, $$s: self}).$call(lhs, rhs, "or");
          return self.$process(result);
        }, 1);
        
        $def(self, '$on_and_asgn', function $$on_and_asgn(node) {
          var $a, self = this, lhs = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$arity: 0, $$s: self}).$call(lhs, rhs, "and");
          return self.$process(result);
        }, 1);
        $const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s("str", "assignment"));
        return $def(self, '$on_defined?', function $LogicalOperatorAssignment_on_defined$ques$6(node) {
          var $a, $yield = $LogicalOperatorAssignment_on_defined$ques$6.$$p || nil, self = this, inner = nil, _ = nil;

          delete $LogicalOperatorAssignment_on_defined$ques$6.$$p;
          
          $a = [].concat($to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(["or_asgn", "and_asgn"]['$include?'](inner.$type()))) {
            return $$('ASSIGNMENT_STRING_NODE')
          } else {
            return $send2(self, $find_super(self, 'on_defined?', $LogicalOperatorAssignment_on_defined$ques$6, false, true), 'on_defined?', [node], null)
          };
        }, 1);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/binary_operator_assignment"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $defs = Opal.defs, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $lambda = Opal.lambda, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $send = Opal.send, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs('require,+,updated,[],==,type,new_temp,s,freeze,call,fetch,error,process');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BinaryOperatorAssignment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', function $BinaryOperatorAssignment_reset_tmp_counter$excl$1() {
          
          return $class_variable_set($nesting[0], '@@counter', 0)
        }, 0);
        $defs(self, '$new_temp', function $$new_temp() {
          var $a, $ret_or_1 = nil;

          
          $class_variable_set($nesting[0], '@@counter', ($truthy((($a = $nesting[0].$$cvars['@@counter'], $a != null) ? 'class variable' : nil)) ? (($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@counter', false))) ? ($ret_or_1) : (0))) : (0)));
          $class_variable_set($nesting[0], '@@counter', $rb_plus($class_variable_get($nesting[0], '@@counter', false), 1));
          return "$binary_op_recvr_tmp_" + ($class_variable_get($nesting[0], '@@counter', false));
        }, 0);
        $const_set($nesting[0], 'GET_SET', $lambda(function $BinaryOperatorAssignment$2(get_type, set_type){
          
          
          if (get_type == null) get_type = nil;;
          
          if (set_type == null) set_type = nil;;
          return $lambda(function $$3(node, lhs, operation, rhs){var get_node = nil, set_node = nil;

            
            
            if (node == null) node = nil;;
            
            if (lhs == null) lhs = nil;;
            
            if (operation == null) operation = nil;;
            
            if (rhs == null) rhs = nil;;
            get_node = lhs.$updated(get_type);
            set_node = node.$updated("send", [get_node, operation, rhs]);
            return lhs.$updated(set_type, [].concat($to_a(lhs)).concat([set_node]));}, 4);}, 2));
        $const_set($nesting[0], 'LocalVariableHandler', $$('GET_SET')['$[]']("lvar", "lvasgn"));
        $const_set($nesting[0], 'InstanceVariableHandler', $$('GET_SET')['$[]']("ivar", "ivasgn"));
        $const_set($nesting[0], 'ConstantHandler', $$('GET_SET')['$[]']("const", "casgn"));
        $const_set($nesting[0], 'GlobalVariableHandler', $$('GET_SET')['$[]']("gvar", "gvasgn"));
        $const_set($nesting[0], 'ClassVariableHandler', $$('GET_SET')['$[]']("cvar", "cvasgn"));
        (function($base, $super) {
          var self = $klass($base, $super, 'SendHandler');

          
          return $defs(self, '$call', function $$call(node, lhs, operation, rhs) {
            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_op = nil, call_writer = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
            if (($truthy(recvr) && ($eqeq(recvr.$type(), "send")))) {
              
              recvr_tmp = self.$new_temp();
              cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
              recvr = self.$s("js_tmp", recvr_tmp);
            };
            writer_method = "" + (reader_method) + "=";
            call_reader = lhs.$updated("send", [recvr, reader_method].concat($to_a(args)));
            call_op = node.$updated("send", [call_reader, operation, rhs]);
            call_writer = lhs.$updated("send", [recvr, writer_method].concat($to_a(args)).concat([call_op]));
            if ($truthy(cache_recvr)) {
              return node.$updated("begin", [cache_recvr, call_writer])
            } else {
              return call_writer
            };
          }, 4)
        })($nesting[0], self);
        (function($base, $super) {
          var self = $klass($base, $super, 'ConditionalSendHandler');

          
          return $defs(self, '$call', function $$call(node, lhs, operation, rhs) {
            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_op_asgn = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
            recvr_tmp = self.$new_temp();
            cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
            recvr = self.$s("js_tmp", recvr_tmp);
            recvr_is_nil = self.$s("send", recvr, "nil?");
            plain_send = lhs.$updated("send", [recvr, meth].concat($to_a(args)));
            plain_op_asgn = node.$updated("op_asgn", [plain_send, operation, rhs]);
            return self.$s("begin", cache_recvr, self.$s("if", recvr_is_nil, self.$s("nil"), plain_op_asgn));
          }, 4)
        })($nesting[0], self);
        $const_set($nesting[0], 'HANDLERS', $hash2(["lvasgn", "ivasgn", "casgn", "gvasgn", "cvasgn", "send", "csend"], {"lvasgn": $$('LocalVariableHandler'), "ivasgn": $$('InstanceVariableHandler'), "casgn": $$('ConstantHandler'), "gvasgn": $$('GlobalVariableHandler'), "cvasgn": $$('ClassVariableHandler'), "send": $$('SendHandler'), "csend": $$('ConditionalSendHandler')}).$freeze());
        
        $def(self, '$on_op_asgn', function $$on_op_asgn(node) {
          var $a, self = this, lhs = nil, op = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (op = ($a[1] == null ? nil : $a[1])), (rhs = ($a[2] == null ? nil : $a[2])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$arity: 0, $$s: self}).$call(node, lhs, op, rhs);
          return self.$process(result);
        }, 1);
        $const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s("str", "assignment"));
        return $def(self, '$on_defined?', function $BinaryOperatorAssignment_on_defined$ques$5(node) {
          var $a, $yield = $BinaryOperatorAssignment_on_defined$ques$5.$$p || nil, self = this, inner = nil, _ = nil;

          delete $BinaryOperatorAssignment_on_defined$ques$5.$$p;
          
          $a = [].concat($to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($eqeq(inner.$type(), "op_asgn")) {
            return $$('ASSIGNMENT_STRING_NODE')
          } else {
            return $send2(self, $find_super(self, 'on_defined?', $BinaryOperatorAssignment_on_defined$ques$5, false, true), 'on_defined?', [node], null)
          };
        }, 1);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/hashes/key_duplicates_rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal;

  Opal.add_stubs('require,new,include?,type,<<,==,process_regular_node,updated,inspect,warn');
  
  self.$require("opal/rewriters/base");
  self.$require("set");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Hashes');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'KeyDuplicatesRewriter');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.keys = nil;
          
          
          $def(self, '$initialize', function $$initialize() {
            var self = this;

            return (self.keys = $$('UniqKeysSet').$new())
          }, 0);
          
          $def(self, '$on_hash', function $$on_hash(node) {
            var $a, $yield = $$on_hash.$$p || nil, self = this, previous_keys = nil;

            delete $$on_hash.$$p;
            return (function() { try {
            
            $a = [self.keys, $$('UniqKeysSet').$new()], (previous_keys = $a[0]), (self.keys = $a[1]), $a;
            return $send2(self, $find_super(self, 'on_hash', $$on_hash, false, true), 'on_hash', [node], null);
            } finally {
              (self.keys = previous_keys)
            }; })()
          }, 1);
          
          $def(self, '$on_pair', function $$on_pair(node) {
            var $a, $yield = $$on_pair.$$p || nil, self = this, key = nil, _value = nil;

            delete $$on_pair.$$p;
            
            $a = [].concat($to_a(node)), (key = ($a[0] == null ? nil : $a[0])), (_value = ($a[1] == null ? nil : $a[1])), $a;
            if ($truthy(["str", "sym"]['$include?'](key.$type()))) {
              self.keys['$<<'](key)
            };
            return $send2(self, $find_super(self, 'on_pair', $$on_pair, false, true), 'on_pair', [node], null);
          }, 1);
          
          $def(self, '$on_kwsplat', function $$on_kwsplat(node) {
            var $a, self = this, hash = nil, _ = nil;

            
            $a = [].concat($to_a(node)), (hash = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
            if ($eqeq(hash.$type(), "hash")) {
              hash = self.$process_regular_node(hash)
            };
            return node.$updated(nil, [hash]);
          }, 1);
          return (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'UniqKeysSet');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto.set = nil;
            
            
            $def(self, '$initialize', function $$initialize() {
              var self = this;

              return (self.set = $$('Set').$new())
            }, 0);
            return $def(self, '$<<', function $UniqKeysSet_$lt$lt$1(element) {
              var $a, self = this, key = nil, _ = nil;

              if ($truthy(self.set['$include?'](element))) {
                
                $a = [].concat($to_a(element)), (key = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
                key = ($eqeq(element.$type(), "str") ? (key.$inspect()) : (":" + (key)));
                return $$('Kernel').$warn("warning: key " + (key) + " is duplicated and overwritten");
              } else {
                return self.set['$<<'](element)
              }
            }, 1);
          })($nesting[0], null, $nesting);
        })($nesting[0], $$$($$$($Opal, 'Rewriters'), 'Base'), $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/dump_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $hash2 = Opal.hash2, $def = Opal.def;

  Opal.add_stubs('require,updated');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DumpArgs');

        
        
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, $yield = $$on_def.$$p || nil, self = this, _mid = nil, args = nil, _body = nil;

          delete $$on_def.$$p;
          
          node = $send2(self, $find_super(self, 'on_def', $$on_def, false, true), 'on_def', [node], null);
          $a = [].concat($to_a(node)), (_mid = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (_body = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, nil, $hash2(["meta"], {"meta": $hash2(["original_args"], {"original_args": args})}));
        }, 1);
        
        $def(self, '$on_defs', function $$on_defs(node) {
          var $a, $yield = $$on_defs.$$p || nil, self = this, _recv = nil, _mid = nil, args = nil, _body = nil;

          delete $$on_defs.$$p;
          
          node = $send2(self, $find_super(self, 'on_defs', $$on_defs, false, true), 'on_defs', [node], null);
          $a = [].concat($to_a(node)), (_recv = ($a[0] == null ? nil : $a[0])), (_mid = ($a[1] == null ? nil : $a[1])), (args = ($a[2] == null ? nil : $a[2])), (_body = ($a[3] == null ? nil : $a[3])), $a;
          return node.$updated(nil, nil, $hash2(["meta"], {"meta": $hash2(["original_args"], {"original_args": args})}));
        }, 1);
        return $def(self, '$on_iter', function $$on_iter(node) {
          var $a, $yield = $$on_iter.$$p || nil, self = this, args = nil, _body = nil;

          delete $$on_iter.$$p;
          
          node = $send2(self, $find_super(self, 'on_iter', $$on_iter, false, true), 'on_iter', [node], null);
          $a = [].concat($to_a(node)), (args = ($a[0] == null ? nil : $a[0])), (_body = ($a[1] == null ? nil : $a[1])), $a;
          return node.$updated(nil, nil, $hash2(["meta"], {"meta": $hash2(["original_args"], {"original_args": args})}));
        }, 1);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/mlhs_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $def = Opal.def, $assign_ivar_val = Opal.assign_ivar_val, $rb_plus = Opal.rb_plus, $send = Opal.send, $eqeq = Opal.eqeq, $hash2 = Opal.hash2;

  Opal.add_stubs('require,new,updated,rewritten,initialization,s,prepend_to_body,attr_reader,split!,+,each,children,==,type,new_mlhs_tmp,process,<<,length,[],empty?');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MlhsArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, $yield = $$on_def.$$p || nil, self = this, mid = nil, args = nil, body = nil, arguments$ = nil, $ret_or_1 = nil;

          delete $$on_def.$$p;
          
          node = $send2(self, $find_super(self, 'on_def', $$on_def, false, true), 'on_def', [node], null);
          $a = [].concat($to_a(node)), (mid = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          arguments$ = $$('Arguments').$new(args);
          args = args.$updated(nil, arguments$.$rewritten());
          if ($truthy(arguments$.$initialization())) {
            
            body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
            body = self.$prepend_to_body(body, arguments$.$initialization());
          };
          return node.$updated(nil, [mid, args, body]);
        }, 1);
        
        $def(self, '$on_defs', function $$on_defs(node) {
          var $a, $yield = $$on_defs.$$p || nil, self = this, recv = nil, mid = nil, args = nil, body = nil, arguments$ = nil, $ret_or_1 = nil;

          delete $$on_defs.$$p;
          
          node = $send2(self, $find_super(self, 'on_defs', $$on_defs, false, true), 'on_defs', [node], null);
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (mid = ($a[1] == null ? nil : $a[1])), (args = ($a[2] == null ? nil : $a[2])), (body = ($a[3] == null ? nil : $a[3])), $a;
          arguments$ = $$('Arguments').$new(args);
          args = args.$updated(nil, arguments$.$rewritten());
          if ($truthy(arguments$.$initialization())) {
            
            body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
            body = self.$prepend_to_body(body, arguments$.$initialization());
          };
          return node.$updated(nil, [recv, mid, args, body]);
        }, 1);
        
        $def(self, '$on_iter', function $$on_iter(node) {
          var $a, $yield = $$on_iter.$$p || nil, self = this, args = nil, body = nil, arguments$ = nil, $ret_or_1 = nil;

          delete $$on_iter.$$p;
          
          node = $send2(self, $find_super(self, 'on_iter', $$on_iter, false, true), 'on_iter', [node], null);
          $a = [].concat($to_a(node)), (args = ($a[0] == null ? nil : $a[0])), (body = ($a[1] == null ? nil : $a[1])), $a;
          arguments$ = $$('Arguments').$new(args);
          args = args.$updated(nil, arguments$.$rewritten());
          if ($truthy(arguments$.$initialization())) {
            
            body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
            body = self.$prepend_to_body(body, arguments$.$initialization());
          };
          return node.$updated(nil, [args, body]);
        }, 1);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Arguments');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.counter = $proto.args = $proto.initialization = nil;
          
          self.$attr_reader("rewritten", "initialization");
          
          $def(self, '$initialize', function $$initialize(args) {
            var self = this;

            
            self.args = args;
            self.rewritten = [];
            self.initialization = [];
            self.rewriter = $$('MlhsRewriter').$new();
            return self['$split!']();
          }, 1);
          
          $def(self, '$reset_tmp_counter!', $assign_ivar_val("counter", 0), 0);
          
          $def(self, '$new_mlhs_tmp', function $$new_mlhs_tmp() {
            var self = this, $ret_or_1 = nil;

            
            self.counter = ($truthy(($ret_or_1 = self.counter)) ? ($ret_or_1) : (0));
            self.counter = $rb_plus(self.counter, 1);
            return "$mlhs_tmp" + (self.counter);
          }, 0);
          return $def(self, '$split!', function $Arguments_split$excl$1() {
            var self = this;

            
            $send(self.args.$children(), 'each', [], function $$2(arg){var self = $$2.$$s == null ? this : $$2.$$s, var_name = nil, rhs = nil, mlhs = nil;
              if (self.rewriter == null) self.rewriter = nil;
              if (self.initialization == null) self.initialization = nil;
              if (self.rewritten == null) self.rewritten = nil;

              
              
              if (arg == null) arg = nil;;
              if ($eqeq(arg.$type(), "mlhs")) {
                
                var_name = self.$new_mlhs_tmp();
                rhs = self.$s("lvar", var_name);
                mlhs = self.rewriter.$process(arg);
                self.initialization['$<<'](self.$s("masgn", mlhs, rhs));
                return self.rewritten['$<<'](self.$s("arg", var_name).$updated(nil, nil, $hash2(["meta"], {"meta": $hash2(["arg_name"], {"arg_name": var_name})})));
              } else {
                return self.rewritten['$<<'](arg)
              };}, {$$arity: 1, $$s: self});
            if ($eqeq(self.initialization.$length(), 1)) {
              return (self.initialization = self.initialization['$[]'](0))
            } else if ($truthy(self.initialization['$empty?']())) {
              return (self.initialization = nil)
            } else {
              return (self.initialization = $send(self, 's', ["begin"].concat($to_a(self.initialization))))
            };
          }, 0);
        })($nesting[0], $$('Base'), $nesting);
        return (function($base, $super) {
          var self = $klass($base, $super, 'MlhsRewriter');

          
          
          
          $def(self, '$on_arg', function $$on_arg(node) {
            
            return node.$updated("lvasgn")
          }, 1);
          return $def(self, '$on_restarg', function $$on_restarg(node) {
            var self = this, name = nil;

            
            name = node.$children()['$[]'](0);
            if ($truthy(name)) {
              return self.$s("splat", node.$updated("lvasgn"))
            } else {
              return self.$s("splat")
            };
          }, 1);
        })($nesting[0], $$('Base'));
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/arguments"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('attr_reader,each,type,<<,any?,raise,!,nil?,has_any_kwargs?,can_inline_kwargs?,empty?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Arguments');

        var $proto = self.$$prototype;

        $proto.restarg = $proto.postargs = $proto.kwargs = $proto.kwoptargs = $proto.kwrestarg = $proto.optargs = nil;
        
        self.$attr_reader("args", "optargs", "restarg", "postargs", "kwargs", "kwoptargs", "kwrestarg", "kwnilarg", "shadowargs", "blockarg");
        
        $def(self, '$initialize', function $$initialize(args) {
          var self = this;

          
          self.args = [];
          self.optargs = [];
          self.restarg = nil;
          self.postargs = [];
          self.kwargs = [];
          self.kwoptargs = [];
          self.kwrestarg = nil;
          self.kwnilarg = false;
          self.shadowargs = [];
          self.blockarg = nil;
          return $send(args, 'each', [], function $$1(arg){var self = $$1.$$s == null ? this : $$1.$$s;
            if (self.optargs == null) self.optargs = nil;
            if (self.restarg == null) self.restarg = nil;
            if (self.postargs == null) self.postargs = nil;
            if (self.args == null) self.args = nil;
            if (self.kwargs == null) self.kwargs = nil;
            if (self.kwoptargs == null) self.kwoptargs = nil;
            if (self.shadowargs == null) self.shadowargs = nil;

            
            
            if (arg == null) arg = nil;;
            
            switch (arg.$type()) {
              case "arg":
              case "mlhs":
                return (($truthy(self.restarg) || ($truthy(self.optargs['$any?']()))) ? (self.postargs) : (self.args))['$<<'](arg)
              case "optarg":
                return self.optargs['$<<'](arg)
              case "restarg":
                return (self.restarg = arg)
              case "kwarg":
                return self.kwargs['$<<'](arg)
              case "kwoptarg":
                return self.kwoptargs['$<<'](arg)
              case "kwnilarg":
                return (self.kwnilarg = true)
              case "kwrestarg":
                return (self.kwrestarg = arg)
              case "shadowarg":
                return self.shadowargs['$<<'](arg)
              case "blockarg":
                return (self.blockarg = arg)
              default:
                return self.$raise("Unsupported arg type " + (arg.$type()))
            };}, {$$arity: 1, $$s: self});
        }, 1);
        
        $def(self, '$has_post_args?', function $Arguments_has_post_args$ques$2() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.restarg['$nil?']()['$!']())) ? ($ret_or_2) : (self.postargs['$any?']()))))) {
            return $ret_or_1
          } else {
            
            if ($truthy(($ret_or_2 = self['$has_any_kwargs?']()))) {
              return self['$can_inline_kwargs?']()['$!']()
            } else {
              return $ret_or_2
            };
          }
        }, 0);
        
        $def(self, '$has_any_kwargs?', function $Arguments_has_any_kwargs$ques$3() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.kwargs['$any?']())) ? ($ret_or_2) : (self.kwoptargs['$any?']()))))) {
            return $ret_or_1
          } else {
            return self.kwrestarg['$nil?']()['$!']()
          }
        }, 0);
        return $def(self, '$can_inline_kwargs?', function $Arguments_can_inline_kwargs$ques$4() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.optargs['$empty?']())) ? (self.restarg['$nil?']()) : ($ret_or_2))))) {
            return self.postargs['$empty?']()
          } else {
            return $ret_or_1
          }
        }, 0);
      })($nesting[0], null)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/rewriters/inline_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $hash2 = Opal.hash2, $def = Opal.def, $const_set = Opal.const_set, $send = Opal.send, $eqeq = Opal.eqeq, $Opal = Opal.Opal;

  Opal.add_stubs('require,s,new,updated,inline,prepend_to_body,initialization,attr_reader,freeze,children,each,send,any?,blockarg,<<,shadowargs,args,==,[],has_post_args?,length,has_any_kwargs?,can_inline_kwargs?,kwargs,kwoptargs,kwrestarg,postargs,optargs,args_to_keep,restarg');
  
  self.$require("opal/rewriters/base");
  self.$require("opal/rewriters/arguments");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'InlineArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, $yield = $$on_def.$$p || nil, self = this, mid = nil, args = nil, body = nil, $ret_or_1 = nil, initializer = nil, inline_args = nil;

          delete $$on_def.$$p;
          
          node = $send2(self, $find_super(self, 'on_def', $$on_def, false, true), 'on_def', [node], null);
          $a = [].concat($to_a(node)), (mid = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
          initializer = $$('Initializer').$new(args, $hash2(["type"], {"type": "def"}));
          inline_args = args.$updated(nil, initializer.$inline());
          body = self.$prepend_to_body(body, initializer.$initialization());
          return node.$updated(nil, [mid, inline_args, body]);
        }, 1);
        
        $def(self, '$on_defs', function $$on_defs(node) {
          var $a, $yield = $$on_defs.$$p || nil, self = this, recv = nil, mid = nil, args = nil, body = nil, $ret_or_1 = nil, initializer = nil, inline_args = nil;

          delete $$on_defs.$$p;
          
          node = $send2(self, $find_super(self, 'on_defs', $$on_defs, false, true), 'on_defs', [node], null);
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (mid = ($a[1] == null ? nil : $a[1])), (args = ($a[2] == null ? nil : $a[2])), (body = ($a[3] == null ? nil : $a[3])), $a;
          body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
          initializer = $$('Initializer').$new(args, $hash2(["type"], {"type": "defs"}));
          inline_args = args.$updated(nil, initializer.$inline());
          body = self.$prepend_to_body(body, initializer.$initialization());
          return node.$updated(nil, [recv, mid, inline_args, body]);
        }, 1);
        
        $def(self, '$on_iter', function $$on_iter(node) {
          var $a, $yield = $$on_iter.$$p || nil, self = this, args = nil, body = nil, $ret_or_1 = nil, initializer = nil, inline_args = nil;

          delete $$on_iter.$$p;
          
          node = $send2(self, $find_super(self, 'on_iter', $$on_iter, false, true), 'on_iter', [node], null);
          $a = [].concat($to_a(node)), (args = ($a[0] == null ? nil : $a[0])), (body = ($a[1] == null ? nil : $a[1])), $a;
          body = ($truthy(($ret_or_1 = body)) ? ($ret_or_1) : (self.$s("nil")));
          initializer = $$('Initializer').$new(args, $hash2(["type"], {"type": "iter"}));
          inline_args = args.$updated(nil, initializer.$inline());
          body = self.$prepend_to_body(body, initializer.$initialization());
          return node.$updated(nil, [inline_args, body]);
        }, 1);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Initializer');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.initialization = $proto.args = $proto.inline = nil;
          
          self.$attr_reader("inline", "initialization");
          $const_set($nesting[0], 'STEPS', ["extract_blockarg", "initialize_shadowargs", "extract_args", "prepare_post_args", "prepare_kwargs", "extract_optargs", "extract_restarg", "extract_post_args", "extract_kwargs", "extract_kwoptargs", "extract_kwrestarg"].$freeze());
          
          $def(self, '$initialize', function $$initialize(args, $kwargs) {
            var type, self = this;

            
            
            if ($kwargs == null) {
              $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
              throw Opal.ArgumentError.$new('expected kwargs');
            };
            
            if (!Opal.hasOwnProperty.call($kwargs.$$smap, 'type')) {
              throw Opal.ArgumentError.$new('missing keyword: type');
            }
            type = $kwargs.$$smap["type"];;
            self.args = $$('Arguments').$new(args.$children());
            self.inline = [];
            self.initialization = [];
            self.type = type;
            self.underscore_found = false;
            $send($$('STEPS'), 'each', [], function $$1(step){var self = $$1.$$s == null ? this : $$1.$$s;

              
              
              if (step == null) step = nil;;
              return self.$send(step);}, {$$arity: 1, $$s: self});
            if ($truthy(self.initialization['$any?']())) {
              return (self.initialization = $send(self, 's', ["begin"].concat($to_a(self.initialization))))
            } else {
              return (self.initialization = nil)
            };
          }, 2);
          
          $def(self, '$extract_blockarg', function $$extract_blockarg() {
            var self = this, arg = nil;

            if ($truthy((arg = self.args.$blockarg()))) {
              return self.initialization['$<<'](arg.$updated("extract_blockarg"))
            } else {
              return nil
            }
          }, 0);
          
          $def(self, '$initialize_shadowargs', function $$initialize_shadowargs() {
            var self = this;

            return $send(self.args.$shadowargs(), 'each', [], function $$2(arg){var self = $$2.$$s == null ? this : $$2.$$s;
              if (self.initialization == null) self.initialization = nil;

              
              
              if (arg == null) arg = nil;;
              return self.initialization['$<<'](arg.$updated("initialize_shadowarg"));}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$extract_args', function $$extract_args() {
            var self = this;

            return $send(self.args.$args(), 'each', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.type == null) self.type = nil;
              if (self.initialization == null) self.initialization = nil;
              if (self.underscore_found == null) self.underscore_found = nil;
              if (self.inline == null) self.inline = nil;

              
              
              if (arg == null) arg = nil;;
              if ($eqeq(self.type, "iter")) {
                
                self.initialization['$<<'](arg.$updated("initialize_iter_arg"));
                if ($eqeq(arg.$children()['$[]'](0), "_")) {
                  
                  if ($truthy(self.underscore_found)) {
                    arg = self.$s("fake_arg")
                  };
                  self.underscore_found = true;
                };
              };
              return self.inline['$<<'](arg);}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$prepare_post_args', function $$prepare_post_args() {
            var self = this;

            if ($truthy(self.args['$has_post_args?']())) {
              return self.initialization['$<<'](self.$s("prepare_post_args", self.args.$args().$length()))
            } else {
              return nil
            }
          }, 0);
          
          $def(self, '$prepare_kwargs', function $$prepare_kwargs() {
            var self = this;

            
            if (!$truthy(self.args['$has_any_kwargs?']())) {
              return nil
            };
            if ($truthy(self.args['$can_inline_kwargs?']())) {
              self.inline['$<<'](self.$s("arg", "$kwargs"))
            } else {
              
              self.initialization['$<<'](self.$s("extract_kwargs"));
              self.inline['$<<'](self.$s("fake_arg"));
            };
            return self.initialization['$<<'](self.$s("ensure_kwargs_are_kwargs"));
          }, 0);
          
          $def(self, '$extract_kwargs', function $$extract_kwargs() {
            var self = this;

            return $send(self.args.$kwargs(), 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;
              if (self.initialization == null) self.initialization = nil;

              
              
              if (arg == null) arg = nil;;
              return self.initialization['$<<'](arg.$updated("extract_kwarg"));}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$extract_kwoptargs', function $$extract_kwoptargs() {
            var self = this;

            return $send(self.args.$kwoptargs(), 'each', [], function $$5(arg){var self = $$5.$$s == null ? this : $$5.$$s;
              if (self.initialization == null) self.initialization = nil;

              
              
              if (arg == null) arg = nil;;
              return self.initialization['$<<'](arg.$updated("extract_kwoptarg"));}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$extract_kwrestarg', function $$extract_kwrestarg() {
            var self = this, arg = nil;

            if ($truthy((arg = self.args.$kwrestarg()))) {
              return self.initialization['$<<'](arg.$updated("extract_kwrestarg"))
            } else {
              return nil
            }
          }, 0);
          
          $def(self, '$extract_post_args', function $$extract_post_args() {
            var self = this;

            return $send(self.args.$postargs(), 'each', [], function $$6(arg){var self = $$6.$$s == null ? this : $$6.$$s;
              if (self.initialization == null) self.initialization = nil;
              if (self.inline == null) self.inline = nil;

              
              
              if (arg == null) arg = nil;;
              self.initialization['$<<'](arg.$updated("extract_post_arg"));
              return self.inline['$<<'](self.$s("fake_arg"));}, {$$arity: 1, $$s: self})
          }, 0);
          
          $def(self, '$extract_optargs', function $$extract_optargs() {
            var self = this, has_post_args = nil;

            
            has_post_args = self.args['$has_post_args?']();
            return $send(self.args.$optargs(), 'each', [], function $$7(arg){var $a, self = $$7.$$s == null ? this : $$7.$$s, arg_name = nil, default_value = nil;
              if (self.initialization == null) self.initialization = nil;
              if (self.inline == null) self.inline = nil;

              
              
              if (arg == null) arg = nil;;
              if ($truthy(has_post_args)) {
                
                $a = [].concat($to_a(arg)), (arg_name = ($a[0] == null ? nil : $a[0])), (default_value = ($a[1] == null ? nil : $a[1])), $a;
                self.initialization['$<<'](arg.$updated("extract_post_optarg", [arg_name, default_value, self.$args_to_keep()]));
                return self.inline['$<<'](self.$s("fake_arg"));
              } else {
                
                self.inline['$<<'](arg.$updated("arg"));
                return self.initialization['$<<'](arg.$updated("extract_optarg"));
              };}, {$$arity: 1, $$s: self});
          }, 0);
          
          $def(self, '$extract_restarg', function $$extract_restarg() {
            var self = this, arg = nil, arg_name = nil;

            if ($truthy((arg = self.args.$restarg()))) {
              
              arg_name = arg.$children()['$[]'](0);
              self.initialization['$<<'](arg.$updated("extract_restarg", [arg_name, self.$args_to_keep()]));
              return self.inline['$<<'](self.$s("fake_arg"));
            } else {
              return nil
            }
          }, 0);
          return $def(self, '$args_to_keep', function $$args_to_keep() {
            var self = this;

            return self.args.$postargs().$length()
          }, 0);
        })($nesting[0], $$$($$$($Opal, 'Rewriters'), 'Base'), $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/numblocks"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_ary = Opal.to_ary, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def;

  Opal.add_stubs('require,children,s,gen_args,map');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Numblocks');

        
        
        
        $def(self, '$on_numblock', function $$on_numblock(node) {
          var $a, $b, self = this, left = nil, arg_count = nil, right = nil;

          
          $b = node.$children(), $a = $to_ary($b), (left = ($a[0] == null ? nil : $a[0])), (arg_count = ($a[1] == null ? nil : $a[1])), (right = ($a[2] == null ? nil : $a[2])), $b;
          return self.$s("block", left, $send(self, 's', ["args"].concat($to_a(self.$gen_args(arg_count)))), right);
        }, 1);
        return $def(self, '$gen_args', function $$gen_args(arg_count) {
          var self = this;

          return $send(Opal.Range.$new(1, arg_count, false), 'map', [], function $$1(i){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (i == null) i = nil;;
            return self.$s("arg", "_" + (i));}, {$$arity: 1, $$s: self})
        }, 1);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/returnable_logic"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $def = Opal.def, $rb_minus = Opal.rb_minus, $assign_ivar_val = Opal.assign_ivar_val, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $slice = Opal.slice, $send = Opal.send, $eqeq = Opal.eqeq;

  Opal.add_stubs('require,+,-,children,[]=,meta,s,next_tmp,build_if_from_when,free_tmp,[],process,updated,==,count,first,delete,private,build_rule_from_parts,empty?,type');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ReturnableLogic');

        var $proto = self.$$prototype;

        $proto.counter = nil;
        
        
        $def(self, '$next_tmp', function $$next_tmp() {
          var self = this, $ret_or_1 = nil;

          
          self.counter = ($truthy(($ret_or_1 = self.counter)) ? ($ret_or_1) : (0));
          self.counter = $rb_plus(self.counter, 1);
          return "$ret_or_" + (self.counter);
        }, 0);
        
        $def(self, '$free_tmp', function $$free_tmp() {
          var self = this;

          return (self.counter = $rb_minus(self.counter, 1))
        }, 0);
        
        $def(self, '$reset_tmp_counter!', $assign_ivar_val("counter", nil), 0);
        
        $def(self, '$on_if', function $$on_if(node) {
          var $a, $yield = $$on_if.$$p || nil, self = this, test = nil;

          delete $$on_if.$$p;
          
          $a = [].concat($to_a(node.$children())), (test = ($a[0] == null ? nil : $a[0])), $a;
          if ($truthy(test)) {
            test.$meta()['$[]=']("if_test", true)
          };
          return $send2(self, $find_super(self, 'on_if', $$on_if, false, true), 'on_if', [node], $yield);
        }, 1);
        
        $def(self, '$on_case', function $$on_case(node) {
          var $a, $b, self = this, lhs = nil, whens = nil, els = nil, $ret_or_1 = nil, lhs_tmp = nil, out = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (whens = $slice.call($a, 1, $b)), (els = ($a[$b] == null ? nil : $a[$b])), $a;
          els = ($truthy(($ret_or_1 = els)) ? ($ret_or_1) : (self.$s("nil")));
          if ($truthy(lhs)) {
            lhs_tmp = self.$next_tmp()
          };
          out = self.$build_if_from_when(node, lhs, lhs_tmp, whens, els);
          if ($truthy(lhs)) {
            self.$free_tmp()
          };
          return out;
        }, 1);
        
        $def(self, '$on_or', function $$on_or(node) {
          var $a, self = this, lhs = nil, rhs = nil, out = nil, lhs_tmp = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(node.$meta()['$[]']("if_test"))) {
            
            lhs.$meta()['$[]=']("if_test", ($a = ["if_test", true], $send(rhs.$meta(), '[]=', $a), $a[$a.length - 1]));
            out = self.$process(node.$updated("if", [lhs, self.$s("true"), rhs]));
          } else {
            
            lhs_tmp = self.$next_tmp();
            out = self.$process(node.$updated("if", [self.$s("lvasgn", lhs_tmp, lhs), self.$s("js_tmp", lhs_tmp), rhs]));
            self.$free_tmp();
          };
          return out;
        }, 1);
        
        $def(self, '$on_and', function $$on_and(node) {
          var $a, self = this, lhs = nil, rhs = nil, out = nil, lhs_tmp = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(node.$meta()['$[]']("if_test"))) {
            
            lhs.$meta()['$[]=']("if_test", ($a = ["if_test", true], $send(rhs.$meta(), '[]=', $a), $a[$a.length - 1]));
            out = self.$process(node.$updated("if", [lhs, rhs, self.$s("false")]));
          } else {
            
            lhs_tmp = self.$next_tmp();
            out = self.$process(node.$updated("if", [self.$s("lvasgn", lhs_tmp, lhs), rhs, self.$s("js_tmp", lhs_tmp)]));
            self.$free_tmp();
          };
          return out;
        }, 1);
        
        $def(self, '$on_begin', function $$on_begin(node) {
          var $yield = $$on_begin.$$p || nil, self = this;

          delete $$on_begin.$$p;
          
          if (($truthy(node.$meta()['$[]']("if_test")) && ($eqeq(node.$children().$count(), 1)))) {
            node.$children().$first().$meta()['$[]=']("if_test", true)
          };
          node.$meta().$delete("if_test");
          return $send2(self, $find_super(self, 'on_begin', $$on_begin, false, true), 'on_begin', [node], $yield);
        }, 1);
        self.$private();
        
        $def(self, '$build_if_from_when', function $$build_if_from_when(node, lhs, lhs_tmp, whens, els) {
          var $a, $b, self = this, first_when = nil, next_whens = nil, parts = nil, expr = nil, rule = nil;

          
          $a = [].concat($to_a(whens)), (first_when = ($a[0] == null ? nil : $a[0])), (next_whens = $slice.call($a, 1)), $a;
          $a = [].concat($to_a(first_when.$children())), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (parts = $slice.call($a, 0, $b)), (expr = ($a[$b] == null ? nil : $a[$b])), $a;
          rule = self.$build_rule_from_parts(node, lhs, lhs_tmp, parts);
          return first_when.$updated("if", [rule, self.$process(expr), ($truthy(next_whens['$empty?']()) ? (self.$process(els)) : (self.$build_if_from_when(nil, nil, lhs_tmp, next_whens, els)))]);
        }, 5);
        return $def(self, '$build_rule_from_parts', function $$build_rule_from_parts(node, lhs, lhs_tmp, parts) {
          var $a, self = this, first_part = nil, next_parts = nil, subrule = nil, splat_on = nil, iter_val = nil, block = nil;

          
          lhs = (($truthy(node) && ($truthy(lhs_tmp))) ? (node.$updated("lvasgn", [lhs_tmp, self.$process(lhs)])) : (self.$s("js_tmp", lhs_tmp)));
          $a = [].concat($to_a(parts)), (first_part = ($a[0] == null ? nil : $a[0])), (next_parts = $slice.call($a, 1)), $a;
          subrule = ($eqeq(first_part.$type(), "splat") ? (((splat_on = first_part.$children().$first()), (iter_val = self.$next_tmp()), (block = self.$s("send", self.$process(splat_on), "any?", self.$s("iter", self.$s("args", self.$s("arg", iter_val)), self.$build_rule_from_parts(nil, nil, lhs_tmp, [self.$s("lvar", iter_val)])))), (($truthy(node) && ($truthy(lhs_tmp))) ? (self.$s("begin", lhs, block)) : (block)))) : ($truthy(lhs_tmp) ? (self.$s("send", self.$process(first_part), "===", lhs)) : (self.$process(first_part))));
          if ($truthy(next_parts['$empty?']())) {
            return subrule
          } else {
            return self.$s("if", subrule, self.$s("true"), self.$build_rule_from_parts(nil, nil, lhs_tmp, next_parts))
          };
        }, 4);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/forward_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $range = Opal.range, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $neqeq = Opal.neqeq;

  Opal.add_stubs('require,process,s,==,type,last,children,[],updated,!=,class');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ForwardArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$on_forward_args', function $$on_forward_args(_node) {
          var self = this;

          return self.$process(self.$s("args", self.$s("forward_arg", "$")))
        }, 1);
        
        $def(self, '$on_args', function $$on_args(node) {
          var $yield = $$on_args.$$p || nil, self = this, prev_children = nil;

          delete $$on_args.$$p;
          if (($truthy(node.$children().$last()) && ($eqeq(node.$children().$last().$type(), "forward_arg")))) {
            
            prev_children = node.$children()['$[]']($range(0, -2, false));
            return node.$updated(nil, [].concat($to_a(prev_children)).concat([self.$s("restarg", "$fwd_rest"), self.$s("blockarg", "$fwd_block")]));
          } else {
            return $send2(self, $find_super(self, 'on_args', $$on_args, false, true), 'on_args', [node], $yield)
          }
        }, 1);
        return $def(self, '$on_send', function $$on_send(node) {
          var $yield = $$on_send.$$p || nil, self = this, prev_children = nil;

          delete $$on_send.$$p;
          if ((($truthy(node.$children().$last()) && ($neqeq(node.$children().$last().$class(), $$('Symbol')))) && ($eqeq(node.$children().$last().$type(), "forwarded_args")))) {
            
            prev_children = node.$children()['$[]']($range(0, -2, false));
            return node.$updated(nil, [].concat($to_a(prev_children)).concat([self.$s("splat", self.$s("lvar", "$fwd_rest")), self.$s("block_pass", self.$s("lvar", "$fwd_block"))]));
          } else {
            return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
          }
        }, 1);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $assign_ivar = Opal.assign_ivar, $send = Opal.send;

  Opal.add_stubs('require,<<,list,delete,==,!=,use,disabled?,class,each,rewritter_disabled?,new,process');
  
  self.$require("opal/rewriters/opal_engine_check");
  self.$require("opal/rewriters/for_rewriter");
  self.$require("opal/rewriters/js_reserved_words");
  self.$require("opal/rewriters/block_to_iter");
  self.$require("opal/rewriters/dot_js_syntax");
  self.$require("opal/rewriters/pattern_matching");
  self.$require("opal/rewriters/logical_operator_assignment");
  self.$require("opal/rewriters/binary_operator_assignment");
  self.$require("opal/rewriters/hashes/key_duplicates_rewriter");
  self.$require("opal/rewriters/dump_args");
  self.$require("opal/rewriters/mlhs_args");
  self.$require("opal/rewriters/inline_args");
  self.$require("opal/rewriters/numblocks");
  self.$require("opal/rewriters/returnable_logic");
  self.$require("opal/rewriters/forward_args");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Rewriter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.sexp = nil;
      
      self.disabled = false;
      (function(self, $parent_nesting) {
        
        
        
        $def(self, '$list', function $$list() {
          var self = this, $ret_or_1 = nil;
          if (self.list == null) self.list = nil;

          return (self.list = ($truthy(($ret_or_1 = self.list)) ? ($ret_or_1) : ([])))
        }, 0);
        
        $def(self, '$use', function $$use(rewriter) {
          var self = this;

          return self.$list()['$<<'](rewriter)
        }, 1);
        
        $def(self, '$delete', function $delete$1(rewriter) {
          var self = this;

          return self.$list().$delete(rewriter)
        }, 1);
        
        $def(self, '$disable', function $$disable($kwargs) {
          var except, $yield = $$disable.$$p || nil, self = this, old_disabled = nil, $ret_or_1 = nil;
          if (self.disabled == null) self.disabled = nil;

          delete $$disable.$$p;
          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          except = $kwargs.$$smap["except"];
          if (except == null) except = nil;
          return (function() { try {
          
          old_disabled = self.disabled;
          self.disabled = ($truthy(($ret_or_1 = except)) ? ($ret_or_1) : (true));
          return Opal.yieldX($yield, []);;
          } finally {
            (self.disabled = old_disabled)
          }; })();
        }, -1);
        
        $def(self, '$disabled?', function $disabled$ques$2() {
          var self = this;
          if (self.disabled == null) self.disabled = nil;

          return self.disabled['$=='](true)
        }, 0);
        return $def(self, '$rewritter_disabled?', function $rewritter_disabled$ques$3(rewriter) {
          var self = this;
          if (self.disabled == null) self.disabled = nil;

          
          if ($eqeq(self.disabled, false)) {
            return false
          };
          return self.disabled['$!='](rewriter);
        }, 1);
      })(Opal.get_singleton_class(self), $nesting);
      self.$use($$$($$('Rewriters'), 'OpalEngineCheck'));
      self.$use($$$($$('Rewriters'), 'ForRewriter'));
      self.$use($$$($$('Rewriters'), 'Numblocks'));
      self.$use($$$($$('Rewriters'), 'ForwardArgs'));
      self.$use($$$($$('Rewriters'), 'BlockToIter'));
      self.$use($$$($$('Rewriters'), 'DotJsSyntax'));
      self.$use($$$($$('Rewriters'), 'PatternMatching'));
      self.$use($$$($$('Rewriters'), 'JsReservedWords'));
      self.$use($$$($$('Rewriters'), 'LogicalOperatorAssignment'));
      self.$use($$$($$('Rewriters'), 'BinaryOperatorAssignment'));
      self.$use($$$($$$($$('Rewriters'), 'Hashes'), 'KeyDuplicatesRewriter'));
      self.$use($$$($$('Rewriters'), 'ReturnableLogic'));
      self.$use($$$($$('Rewriters'), 'DumpArgs'));
      self.$use($$$($$('Rewriters'), 'MlhsArgs'));
      self.$use($$$($$('Rewriters'), 'InlineArgs'));
      
      $def(self, '$initialize', $assign_ivar("sexp"), 0);
      return $def(self, '$process', function $$process() {
        var self = this;

        
        if ($truthy(self.$class()['$disabled?']())) {
          return self.sexp
        };
        $send(self.$class().$list(), 'each', [], function $$4(rewriter_class){var self = $$4.$$s == null ? this : $$4.$$s, rewriter = nil;
          if (self.sexp == null) self.sexp = nil;

          
          
          if (rewriter_class == null) rewriter_class = nil;;
          if ($truthy(self.$class()['$rewritter_disabled?'](rewriter_class))) {
            return nil;
          };
          rewriter = rewriter_class.$new();
          return (self.sexp = rewriter.$process(self.sexp));}, {$$arity: 1, $$s: self});
        return self.sexp;
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/parser/source_buffer"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Parser');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SourceBuffer');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $defs(self, '$recognize_encoding', function $$recognize_encoding(string) {
          var $yield = $$recognize_encoding.$$p || nil, self = this, $ret_or_1 = nil;

          delete $$recognize_encoding.$$p;
          if ($truthy(($ret_or_1 = $send2(self, $find_super(self, 'recognize_encoding', $$recognize_encoding, false, true), 'recognize_encoding', [string], $yield)))) {
            return $ret_or_1
          } else {
            return $$$($$('Encoding'), 'UTF_8')
          }
        }, 1)
      })($nesting[0], $$$($$$($$$('Parser'), 'Source'), 'Buffer'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/parser/default_config"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $lambda = Opal.lambda, $send = Opal.send, $defs = Opal.defs, $truthy = Opal.truthy, $Opal = Opal.Opal;

  Opal.add_stubs('attr_accessor,all_errors_are_fatal=,diagnostics,ignore_warnings=,consumer=,diagnostics_consumer,extend,diagnostics_consumer=,new,rewrite,process,default_parser,default_parser_class');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Parser');

      var $nesting = [self].concat($parent_nesting);

      
      (function($base, $parent_nesting) {
        var self = $module($base, 'DefaultConfig');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base) {
          var self = $module($base, 'ClassMethods');

          
          
          self.$attr_accessor("diagnostics_consumer");
          return $def(self, '$default_parser', function $$default_parser() {
            var $yield = $$default_parser.$$p || nil, self = this, parser = nil;

            delete $$default_parser.$$p;
            
            parser = $send2(self, $find_super(self, 'default_parser', $$default_parser, false, true), 'default_parser', [], $yield);
            parser.$diagnostics()['$all_errors_are_fatal='](true);
            parser.$diagnostics()['$ignore_warnings='](false);
            parser.$diagnostics()['$consumer='](self.$diagnostics_consumer());
            return parser;
          }, 0);
        })($nesting[0]);
        $defs(self, '$included', function $$included(klass) {
          var $a;

          
          klass.$extend($$('ClassMethods'));
          return ($a = [$lambda(function $$1(diagnostic){
            
            
            if (diagnostic == null) diagnostic = nil;;
            return nil;}, 1)], $send(klass, 'diagnostics_consumer=', $a), $a[$a.length - 1]);
        }, 1);
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [$$$($$$($$('Opal'), 'AST'), 'Builder').$new()], null);
        }, -1);
        
        $def(self, '$parse', function $$parse(source_buffer) {
          var $yield = $$parse.$$p || nil, self = this, parsed = nil, $ret_or_1 = nil, wrapped = nil, rewriten = nil;

          delete $$parse.$$p;
          
          parsed = ($truthy(($ret_or_1 = $send2(self, $find_super(self, 'parse', $$parse, false, true), 'parse', [source_buffer], $yield))) ? ($ret_or_1) : ($$$($$$($Opal, 'AST'), 'Node').$new("nil")));
          wrapped = $$$($$$($Opal, 'AST'), 'Node').$new("top", [parsed]);
          rewriten = self.$rewrite(wrapped);
          return rewriten;
        }, 1);
        return $def(self, '$rewrite', function $$rewrite(node) {
          
          return $$$($$('Opal'), 'Rewriter').$new(node).$process()
        }, 1);
      })($nesting[0], $nesting);
      return (function(self, $parent_nesting) {
        
        
        self.$attr_accessor("default_parser_class");
        return $def(self, '$default_parser', function $$default_parser() {
          var self = this;

          return self.$default_parser_class().$default_parser()
        }, 0);
      })(Opal.get_singleton_class(self), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/parser/with_ruby_lexer"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs('include,default_parser_class=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'WithRubyLexer');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$($$$($$('Opal'), 'Parser'), 'DefaultConfig'));
    return ($a = [self], $send($$$($$('Opal'), 'Parser'), 'default_parser_class=', $a), $a[$a.length - 1]);
  })($$$($$('Opal'), 'Parser'), $$$($$('Parser'), 'Ruby31'), $nesting)
};

Opal.modules["opal/parser/patch"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $rb_plus = Opal.rb_plus, $send = Opal.send, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $not = Opal.not, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $module = Opal.module;

  Opal.add_stubs('source,unpack,+,to_a,lines,end_with?,<<,map,chomp,=~,diagnostic,nil?,new,type,updated,dedent,first,children,==,empty?,interrupt,compact,encoding,split,force_encoding,length,map!,each_with_index,!,each_char,<=,===,-,>,*,/,[]=,[],join,respond_to?,send,value');
  
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Lexer');

    var $proto = self.$$prototype;

    $proto.source_buffer = nil;
    return $def(self, '$source_buffer=', function $Lexer_source_buffer$eq$1(source_buffer) {
      var self = this, source = nil;

      
      self.source_buffer = source_buffer;
      if ($truthy(self.source_buffer)) {
        
        source = self.source_buffer.$source();
        return (self.source_pts = source.$unpack("U*"));
      } else {
        return (self.source_pts = nil)
      };
    }, 1)
  })($$('Parser'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Literal');

    var $proto = self.$$prototype;

    $proto.buffer_s = $proto.buffer = nil;
    
    
    Opal.udef(self, '$' + "extend_string");;
    return $def(self, '$extend_string', function $$extend_string(string, ts, te) {
      var self = this, $ret_or_1 = nil;

      
      self.buffer_s = ($truthy(($ret_or_1 = self.buffer_s)) ? ($ret_or_1) : (ts));
      self.buffer_e = te;
      return (self.buffer = $rb_plus(self.buffer, string));
    }, 3);
  })($$$($$('Parser'), 'Lexer'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Buffer');

    var $proto = self.$$prototype;

    $proto.lines = $proto.source = nil;
    return $def(self, '$source_lines', function $$source_lines() {
      var self = this, $ret_or_1 = nil, lines = nil;

      return (self.lines = ($truthy(($ret_or_1 = self.lines)) ? ($ret_or_1) : (((lines = self.source.$lines().$to_a()), ($truthy(self.source['$end_with?']("\n")) ? (lines['$<<']("")) : nil), $send(lines, 'map', [], function $$2(line){
        
        
        if (line == null) line = nil;;
        return line.$chomp("\n");}, 1)))))
    }, 0)
  })($$$($$('Parser'), 'Source'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Default');

    
    
    
    $def(self, '$check_lvar_name', function $$check_lvar_name(name, loc) {
      var self = this;

      if ($truthy(name['$=~'](new RegExp('^[\\p{Ll}|_][\\p{L}\\p{Nl}\\p{Nd}_]*$', 'u')))) {
        return nil
      } else {
        return self.$diagnostic("error", "lvar_name", $hash2(["name"], {"name": name}), loc)
      }
    }, 2);
    return $def(self, '$dedent_string', function $$dedent_string(node, dedent_level) {
      var dedenter = nil, children = nil;

      
      if (!$truthy(dedent_level['$nil?']())) {
        
        dedenter = $$$($$$($$$('Parser'), 'Lexer'), 'Dedenter').$new(dedent_level);
        
        switch (node.$type()) {
          case "str":
            node = node.$updated(nil, [dedenter.$dedent(node.$children().$first())])
            break;
          case "dstr":
          case "xstr":
            
            children = $send(node.$children(), 'map', [], function $$3(str_node){
              
              
              if (str_node == null) str_node = nil;;
              if ($eqeq(str_node.$type(), "str")) {
                
                str_node = str_node.$updated(nil, [dedenter.$dedent(str_node.$children().$first())]);
                if ($truthy(str_node.$children().$first()['$empty?']())) {
                  return nil;
                };
              } else {
                dedenter.$interrupt()
              };
              return str_node;}, 1);
            node = node.$updated(nil, children.$compact());
            break;
          default:
            nil
        };
      };
      return node;
    }, 2);
  })($$$($$('Parser'), 'Builders'), null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dedenter');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$dedent', function $$dedent(string) {
      var self = this, original_encoding = nil, lines = nil;

      
      original_encoding = string.$encoding();
      lines = string.$force_encoding($$$($$('Encoding'), 'BINARY')).$split("\\\n");
      if ($eqeq(lines.$length(), 1)) {
        lines = [string.$force_encoding(original_encoding)]
      } else {
        $send(lines, 'map!', [], function $$4(s){
          
          
          if (s == null) s = nil;;
          return s.$force_encoding(original_encoding);}, 1)
      };
      (function(){var $brk = Opal.new_brk(); try {return $send(lines, 'each_with_index', [], function $$5(line, index){var $a, self = $$5.$$s == null ? this : $$5.$$s, left_to_remove = nil, remove = nil;
        if (self.at_line_begin == null) self.at_line_begin = nil;
        if (self.dedent_level == null) self.dedent_level = nil;

        
        
        if (line == null) line = nil;;
        
        if (index == null) index = nil;;
        if (($eqeq(index, 0) && ($not(self.at_line_begin)))) {
          return nil;
        };
        left_to_remove = self.dedent_level;
        remove = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_char', [], function $$6(char$){var self = $$6.$$s == null ? this : $$6.$$s, $ret_or_1 = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          
          if (char$ == null) char$ = nil;;
          if ($truthy($rb_le(left_to_remove, 0))) {
            
            Opal.brk(nil, $brk)
          };
          if ($eqeqeq(" ", ($ret_or_1 = char$))) {
            
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, 1));
          } else if ($eqeqeq("\t", $ret_or_1)) {
            
            if ($truthy($rb_gt($rb_times($$('TAB_WIDTH'), $rb_plus($rb_divide(remove, $$('TAB_WIDTH')), 1)), self.dedent_level))) {
              
              Opal.brk(nil, $brk)
            };
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, $$('TAB_WIDTH')));
          } else {
            
            Opal.brk(nil, $brk)
          };}, {$$arity: 1, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        return ($a = [index, line['$[]'](Opal.Range.$new(remove, -1, false))], $send(lines, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self, $$brk: $brk})
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      string = lines.$join();
      self.at_line_begin = string['$end_with?']("\n");
      return string;
    }, 1)
  })($$$($$('Parser'), 'Lexer'), null, $nesting);;
  (function($base) {
    var self = $module($base, 'Mixin');

    
    
    
    Opal.udef(self, '$' + "process");;
    return $def(self, '$process', function $$process(node) {
      var $a, self = this, $ret_or_1 = nil, type = nil, on_handler = nil, handler = nil;
      if (self._on_handler_cache == null) self._on_handler_cache = nil;

      
      if ($truthy(node['$nil?']())) {
        return nil
      };
      self._on_handler_cache = ($truthy(($ret_or_1 = self._on_handler_cache)) ? ($ret_or_1) : ($hash2([], {})));
      type = node.$type();
      on_handler = ($truthy(($ret_or_1 = self._on_handler_cache['$[]'](type))) ? ($ret_or_1) : (($a = [type, ((handler = "on_" + (type)), ($truthy(self['$respond_to?'](handler)) ? (nil) : ((handler = "handler_missing"))), handler)], $send(self._on_handler_cache, '[]=', $a), $a[$a.length - 1])));
      if ($truthy(($ret_or_1 = self.$send(on_handler, node)))) {
        return $ret_or_1
      } else {
        return node
      };
    }, 1);
  })($$$($$('AST'), 'Processor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'Default');

    
    
    
    Opal.udef(self, '$' + "string_value");;
    return $def(self, '$string_value', function $$string_value(token) {
      var self = this;

      return self.$value(token)
    }, 1);
  })($$$($$('Parser'), 'Builders'), null);
};

Opal.modules["opal/parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("opal/ast/builder");
  self.$require("opal/rewriter");
  self.$require("opal/parser/source_buffer");
  self.$require("opal/parser/default_config");
  self.$require("opal/parser/with_ruby_lexer");
  return self.$require("opal/parser/patch");
};

Opal.modules["opal/fragment"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $not = Opal.not;

  Opal.add_stubs('attr_reader,to_s,inspect,type,[],meta,source_map_name_for,sexp,==,class,+,parent,>,!,first,children,loc,respond_to?,dot,selector,operator,begin,line,location,column');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Fragment');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.code = $proto.scope = $proto.sexp = nil;
      
      self.$attr_reader("code");
      
      $def(self, '$initialize', function $$initialize(code, scope, sexp) {
        var self = this;

        
        
        if (sexp == null) sexp = nil;;
        self.code = code.$to_s();
        self.sexp = sexp;
        return (self.scope = scope);
      }, -3);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "f(" + (self.code.$inspect()) + ")"
      }, 0);
      
      $def(self, '$source_map_name_for', function $$source_map_name_for(sexp) {
        var $a, self = this, scope = nil, iters = nil, level = nil, const$ = nil, name = nil;

        
        switch (sexp.$type()) {
          case "top":
            
            switch (sexp.$meta()['$[]']("kind")) {
              case "require":
                return "<top (required)>"
              case "eval":
                return "(eval)"
              case "main":
                return "<main>"
              default:
                return nil
            }
            break;
          case "begin":
          case "newline":
          case "js_return":
            if ($truthy(self.scope)) {
              return self.$source_map_name_for(self.scope.$sexp())
            } else {
              return nil
            }
            break;
          case "iter":
            
            scope = self.scope;
            iters = 1;
            while ($truthy(scope)) {
              if ($eqeq(scope.$class(), $$$($$('Nodes'), 'IterNode'))) {
                
                iters = $rb_plus(iters, 1);
                scope = scope.$parent();
              } else {
                break;
              }
            };
            if ($truthy($rb_gt(iters, 1))) {
              level = " (" + (iters) + " levels)"
            };
            return "block" + (level) + " in " + (self.$source_map_name_for(scope.$sexp()));
          case "self":
            return "self"
          case "module":
            
            $a = [].concat($to_a(sexp)), (const$ = ($a[0] == null ? nil : $a[0])), $a;
            return "<module:" + (self.$source_map_name_for(const$)) + ">";
          case "class":
            
            $a = [].concat($to_a(sexp)), (const$ = ($a[0] == null ? nil : $a[0])), $a;
            return "<class:" + (self.$source_map_name_for(const$)) + ">";
          case "const":
            
            $a = [].concat($to_a(sexp)), (scope = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $a;
            if (($not(scope) || ($eqeq(scope.$type(), "cbase")))) {
              return name.$to_s()
            } else {
              return "" + (self.$source_map_name_for(scope)) + "::" + (name)
            };
            break;
          case "int":
            return sexp.$children().$first()
          case "def":
            return sexp.$children().$first()
          case "defs":
            return sexp.$children()['$[]'](1)
          case "send":
            return sexp.$children()['$[]'](1)
          case "lvar":
          case "lvasgn":
          case "lvdeclare":
          case "ivar":
          case "ivasgn":
          case "gvar":
          case "cvar":
          case "cvasgn":
          case "gvars":
          case "gvasgn":
          case "arg":
            return sexp.$children().$first()
          case "str":
          case "xstr":
            return self.$source_map_name_for(self.scope.$sexp())
          default:
            return nil
        }
      }, 1);
      
      $def(self, '$source_map_name', function $$source_map_name() {
        var self = this;

        
        if (!$truthy(self.sexp)) {
          return nil
        };
        return self.$source_map_name_for(self.sexp);
      }, 0);
      
      $def(self, '$location', function $$location() {
        var self = this, loc = nil, $ret_or_1 = nil;

        if ($not(self.sexp)) {
          return nil
        } else if ($eqeq(self.sexp.$type(), "send")) {
          
          loc = self.sexp.$loc();
          if ($truthy(loc['$respond_to?']("dot"))) {
            if ($truthy(($ret_or_1 = loc.$dot()))) {
              return $ret_or_1
            } else {
              return loc.$selector()
            }
          } else if ($truthy(loc['$respond_to?']("operator"))) {
            return loc.$operator()
          } else {
            return self.sexp
          };
        } else if ($eqeq(self.sexp.$type(), "iter")) {
          if ($truthy(loc['$respond_to?']("begin"))) {
            return self.sexp.$loc().$begin()
          } else {
            return self.sexp
          }
        } else {
          return self.sexp
        }
      }, 0);
      
      $def(self, '$line', function $$line() {
        var $a, self = this;

        return ($a = self.$location(), ($a === nil || $a == null) ? nil : self.$location().$line())
      }, 0);
      
      $def(self, '$column', function $$column() {
        var $a, self = this;

        return ($a = self.$location(), ($a === nil || $a == null) ? nil : self.$location().$column())
      }, 0);
      return $def(self, '$skip_source_map?', function $Fragment_skip_source_map$ques$1() {
        var self = this;

        return self.sexp['$=='](false)
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/nodes/helpers"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $rb_plus = Opal.rb_plus, $send = Opal.send, $hash2 = Opal.hash2, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq;

  Opal.add_stubs('require,valid_name?,inspect,=~,to_s,+,indent,compiler,to_proc,parser_indent,push,fragment,current_indent,js_truthy_optimize,helper,expr,type,[],handlers,include?,truthy_optimize?,==,count,record_method_call,first,children,s,[]=,meta');
  
  self.$require("opal/regexp_anchors");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Helpers');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$property', function $$property(name) {
          var self = this;

          if ($truthy(self['$valid_name?'](name))) {
            return "." + (name)
          } else {
            return "[" + (name.$inspect()) + "]"
          }
        }, 1);
        
        $def(self, '$valid_name?', function $Helpers_valid_name$ques$1(name) {
          
          return $$$($$$($$('Opal'), 'Rewriters'), 'JsReservedWords')['$valid_name?'](name)
        }, 1);
        
        $def(self, '$mid_to_jsid', function $$mid_to_jsid(mid) {
          
          if ($truthy(/\=|\+|\-|\*|\/|\!|\?|<|\>|\&|\||\^|\%|\~|\[|`/['$=~'](mid.$to_s()))) {
            return "['$" + (mid) + "']"
          } else {
            return $rb_plus(".$", mid)
          }
        }, 1);
        
        $def(self, '$indent', function $$indent() {
          var block = $$indent.$$p || nil, self = this;

          delete $$indent.$$p;
          
          ;
          return $send(self.$compiler(), 'indent', [], block.$to_proc());
        }, 0);
        
        $def(self, '$current_indent', function $$current_indent() {
          var self = this;

          return self.$compiler().$parser_indent()
        }, 0);
        
        $def(self, '$line', function $$line($a) {
          var $post_args, strs, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          strs = $post_args;;
          self.$push(self.$fragment("\n" + (self.$current_indent()), $hash2(["loc"], {"loc": false})));
          return $send(self, 'push', $to_a(strs));
        }, -1);
        
        $def(self, '$empty_line', function $$empty_line() {
          var self = this;

          return self.$push(self.$fragment("\n", $hash2(["loc"], {"loc": false})))
        }, 0);
        
        $def(self, '$js_truthy', function $$js_truthy(sexp) {
          var self = this, optimize = nil;

          
          if ($truthy((optimize = self.$js_truthy_optimize(sexp)))) {
            return optimize
          };
          self.$helper("truthy");
          return [self.$fragment("$truthy("), self.$expr(sexp), self.$fragment(")")];
        }, 1);
        return $def(self, '$js_truthy_optimize', function $$js_truthy_optimize(sexp) {
          var $a, self = this, receiver = nil, mid = nil, args = nil, receiver_handler_class = nil, $ret_or_2 = nil, allow_optimization_on_type = nil, $ret_or_3 = nil, _test = nil, true_body = nil, false_body = nil;

          
          switch (sexp.$type()) {
            case "send":
              
              $a = [].concat($to_a(sexp)), (receiver = ($a[0] == null ? nil : $a[0])), (mid = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
              receiver_handler_class = ($truthy(($ret_or_2 = receiver)) ? (self.$compiler().$handlers()['$[]'](receiver.$type())) : ($ret_or_2));
              allow_optimization_on_type = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = $$$($$('Compiler'), 'COMPARE')['$include?'](mid.$to_s()))) ? (receiver_handler_class) : ($ret_or_3)))) ? (receiver_handler_class['$truthy_optimize?']()) : ($ret_or_2));
              if (($truthy(allow_optimization_on_type) || ($eqeq(mid, "block_given?")))) {
                return self.$expr(sexp)
              } else if ($eqeq(args.$count(), 1)) {
                
                switch (mid) {
                  case "==":
                    
                    self.$helper("eqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$eqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  case "===":
                    
                    self.$helper("eqeqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$eqeqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  case "!=":
                    
                    self.$helper("neqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$neqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  default:
                    return nil
                }
              } else if ($eqeq(args.$count(), 0)) {
                
                switch (mid) {
                  case "!":
                    
                    self.$helper("not");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$not("), self.$expr(receiver), self.$fragment(")")];
                  default:
                    return nil
                }
              } else {
                return nil
              };
              break;
            case "begin":
              if ($eqeq(sexp.$children().$count(), 1)) {
                return self.$js_truthy_optimize(sexp.$children().$first())
              } else {
                return nil
              }
              break;
            case "if":
              
              $a = [].concat($to_a(sexp)), (_test = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
              if ($eqeq(true_body, self.$s("true"))) {
                
                sexp.$meta()['$[]=']("do_js_truthy_on_false_body", true);
                return self.$expr(sexp);
              } else if ($eqeq(false_body, self.$s("false"))) {
                
                sexp.$meta()['$[]=']("do_js_truthy_on_true_body", true);
                return self.$expr(sexp);
              } else {
                return nil
              };
              break;
            default:
              return nil
          }
        }, 1);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $defs = Opal.defs, $send = Opal.send, $return_val = Opal.return_val, $def = Opal.def, $Opal = Opal.Opal, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('require,include,each,[]=,handlers,each_with_index,define_method,[],children,attr_reader,type,top_scope,top_scope=,compile,raise,is_a?,fragment,<<,reverse_each,unshift,push,new,scope,error,loc,==,process,expr,add_scope_local,to_sym,add_scope_ivar,add_scope_gvar,add_scope_temp,helper,with_temp,to_proc,in_while?,instance_variable_get,has_rescue_else?,in_ensure,in_ensure?,in_resbody,in_resbody?,in_rescue,!,class_scope?,sclass?,+,parent,nesting,class_variable_owner_nesting_level,comments,compiler,name,source_buffer,expression,start_with?,end_with?,line');
  
  self.$require("opal/nodes/helpers");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.compiler = $proto.sexp = $proto.fragments = $proto.level = nil;
        
        self.$include($$('Helpers'));
        $defs(self, '$handlers', function $$handlers() {
          var self = this, $ret_or_1 = nil;
          if (self.handlers == null) self.handlers = nil;

          return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ($hash2([], {}))))
        }, 0);
        $defs(self, '$handle', function $$handle($a) {
          var $post_args, types, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          types = $post_args;;
          return $send(types, 'each', [], function $$1(type){var $b, self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (type == null) type = nil;;
            return ($b = [type, self], $send($$('Base').$handlers(), '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
        }, -1);
        $defs(self, '$children', function $$children($a) {
          var $post_args, names, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          names = $post_args;;
          return $send(names, 'each_with_index', [], function $$2(name, idx){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (name == null) name = nil;;
            
            if (idx == null) idx = nil;;
            return $send(self, 'define_method', [name], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.sexp == null) self.sexp = nil;

              return self.sexp.$children()['$[]'](idx)}, {$$arity: 0, $$s: self});}, {$$arity: 2, $$s: self});
        }, -1);
        $defs(self, '$truthy_optimize?', $return_val(false), 0);
        self.$attr_reader("compiler", "type", "sexp");
        
        $def(self, '$initialize', function $$initialize(sexp, level, compiler) {
          var $a, self = this, $ret_or_1 = nil;

          
          self.sexp = sexp;
          self.type = sexp.$type();
          self.level = level;
          self.compiler = compiler;
          if ($truthy(($ret_or_1 = self.compiler.$top_scope()))) {
            return $ret_or_1
          } else {
            return ($a = [self], $send(self.compiler, 'top_scope=', $a), $a[$a.length - 1])
          };
        }, 3);
        
        $def(self, '$children', function $$children() {
          var self = this;

          return self.sexp.$children()
        }, 0);
        
        $def(self, '$compile_to_fragments', function $$compile_to_fragments() {
          var $a, self = this;

          
          if ($truthy((($a = self['fragments'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
            return self.fragments
          };
          self.fragments = [];
          self.$compile();
          return self.fragments;
        }, 0);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$raise("Not Implemented")
        }, 0);
        
        $def(self, '$push', function $$push($a) {
          var $post_args, strs, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          strs = $post_args;;
          return $send(strs, 'each', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.fragments == null) self.fragments = nil;

            
            
            if (str == null) str = nil;;
            if ($truthy(str['$is_a?']($$('String')))) {
              str = self.$fragment(str)
            };
            return self.fragments['$<<'](str);}, {$$arity: 1, $$s: self});
        }, -1);
        
        $def(self, '$unshift', function $$unshift($a) {
          var $post_args, strs, self = this;

          
          
          $post_args = Opal.slice.call(arguments);
          
          strs = $post_args;;
          return $send(strs, 'reverse_each', [], function $$5(str){var self = $$5.$$s == null ? this : $$5.$$s;
            if (self.fragments == null) self.fragments = nil;

            
            
            if (str == null) str = nil;;
            if ($truthy(str['$is_a?']($$('String')))) {
              str = self.$fragment(str)
            };
            return self.fragments.$unshift(str);}, {$$arity: 1, $$s: self});
        }, -1);
        
        $def(self, '$wrap', function $$wrap(pre, post) {
          var self = this;

          
          self.$unshift(pre);
          return self.$push(post);
        }, 2);
        
        $def(self, '$fragment', function $$fragment(str, $kwargs) {
          var loc, self = this, $ret_or_1 = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          loc = $kwargs.$$smap["loc"];
          if (loc == null) loc = true;
          return $$$($$('Opal'), 'Fragment').$new(str, self.$scope(), ($truthy(($ret_or_1 = loc)) ? (self.sexp) : ($ret_or_1)));
        }, -2);
        
        $def(self, '$error', function $$error(msg) {
          var self = this;

          return self.compiler.$error(msg)
        }, 1);
        
        $def(self, '$scope', function $$scope() {
          var self = this;

          return self.compiler.$scope()
        }, 0);
        
        $def(self, '$top_scope', function $$top_scope() {
          var self = this;

          return self.compiler.$top_scope()
        }, 0);
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          children = $post_args;;
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, $hash2(["location"], {"location": self.sexp.$loc()}));
        }, -2);
        
        $def(self, '$expr?', function $Base_expr$ques$6() {
          var self = this;

          return self.level['$==']("expr")
        }, 0);
        
        $def(self, '$recv?', function $Base_recv$ques$7() {
          var self = this;

          return self.level['$==']("recv")
        }, 0);
        
        $def(self, '$stmt?', function $Base_stmt$ques$8() {
          var self = this;

          return self.level['$==']("stmt")
        }, 0);
        
        $def(self, '$process', function $$process(sexp, level) {
          var self = this;

          
          
          if (level == null) level = "expr";;
          return self.compiler.$process(sexp, level);
        }, -2);
        
        $def(self, '$expr', function $$expr(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "expr")
        }, 1);
        
        $def(self, '$recv', function $$recv(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "recv")
        }, 1);
        
        $def(self, '$stmt', function $$stmt(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "stmt")
        }, 1);
        
        $def(self, '$expr_or_nil', function $$expr_or_nil(sexp) {
          var self = this;

          if ($truthy(sexp)) {
            return self.$expr(sexp)
          } else {
            return "nil"
          }
        }, 1);
        
        $def(self, '$add_local', function $$add_local(name) {
          var self = this;

          return self.$scope().$add_scope_local(name.$to_sym())
        }, 1);
        
        $def(self, '$add_ivar', function $$add_ivar(name) {
          var self = this;

          return self.$scope().$add_scope_ivar(name)
        }, 1);
        
        $def(self, '$add_gvar', function $$add_gvar(name) {
          var self = this;

          return self.$scope().$add_scope_gvar(name)
        }, 1);
        
        $def(self, '$add_temp', function $$add_temp(temp) {
          var self = this;

          return self.$scope().$add_scope_temp(temp)
        }, 1);
        
        $def(self, '$helper', function $$helper(name) {
          var self = this;

          return self.compiler.$helper(name)
        }, 1);
        
        $def(self, '$with_temp', function $$with_temp() {
          var block = $$with_temp.$$p || nil, self = this;

          delete $$with_temp.$$p;
          
          ;
          return $send(self.compiler, 'with_temp', [], block.$to_proc());
        }, 0);
        
        $def(self, '$in_while?', function $Base_in_while$ques$9() {
          var self = this;

          return self.compiler['$in_while?']()
        }, 0);
        
        $def(self, '$while_loop', function $$while_loop() {
          var self = this;

          return self.compiler.$instance_variable_get("@while_loop")
        }, 0);
        
        $def(self, '$has_rescue_else?', function $Base_has_rescue_else$ques$10() {
          var self = this;

          return self.$scope()['$has_rescue_else?']()
        }, 0);
        
        $def(self, '$in_ensure', function $$in_ensure() {
          var block = $$in_ensure.$$p || nil, self = this;

          delete $$in_ensure.$$p;
          
          ;
          return $send(self.$scope(), 'in_ensure', [], block.$to_proc());
        }, 0);
        
        $def(self, '$in_ensure?', function $Base_in_ensure$ques$11() {
          var self = this;

          return self.$scope()['$in_ensure?']()
        }, 0);
        
        $def(self, '$in_resbody', function $$in_resbody() {
          var block = $$in_resbody.$$p || nil, self = this;

          delete $$in_resbody.$$p;
          
          ;
          return $send(self.$scope(), 'in_resbody', [], block.$to_proc());
        }, 0);
        
        $def(self, '$in_resbody?', function $Base_in_resbody$ques$12() {
          var self = this;

          return self.$scope()['$in_resbody?']()
        }, 0);
        
        $def(self, '$in_rescue', function $$in_rescue(node) {
          var block = $$in_rescue.$$p || nil, self = this;

          delete $$in_rescue.$$p;
          
          ;
          return $send(self.$scope(), 'in_rescue', [node], block.$to_proc());
        }, 1);
        
        $def(self, '$class_variable_owner_nesting_level', function $$class_variable_owner_nesting_level() {
          var $a, self = this, cvar_scope = nil, nesting_level = nil, $ret_or_1 = nil;

          
          cvar_scope = self.$scope();
          nesting_level = 0;
          while ($truthy(($truthy(($ret_or_1 = cvar_scope)) ? (cvar_scope['$class_scope?']()['$!']()) : ($ret_or_1)))) {
            
            if ($truthy(cvar_scope['$sclass?']())) {
              nesting_level = $rb_plus(nesting_level, 1)
            };
            cvar_scope = cvar_scope.$parent();
          };
          return nesting_level;
        }, 0);
        
        $def(self, '$class_variable_owner', function $$class_variable_owner() {
          var self = this;

          if ($truthy(self.$scope())) {
            return "" + (self.$scope().$nesting()) + "[" + (self.$class_variable_owner_nesting_level()) + "]"
          } else {
            return "Opal.Object"
          }
        }, 0);
        
        $def(self, '$comments', function $$comments() {
          var self = this;

          return self.$compiler().$comments()['$[]'](self.sexp.$loc())
        }, 0);
        return $def(self, '$source_location', function $$source_location() {
          var self = this, file = nil, line = nil;

          
          file = self.sexp.$loc().$expression().$source_buffer().$name();
          if ($truthy(file['$start_with?']("corelib/"))) {
            file = "<internal:" + (file) + ">"
          };
          if ($truthy(file['$end_with?'](".js"))) {
            file = "<js:" + (file) + ">"
          };
          line = self.sexp.$loc().$line();
          return "['" + (file) + "', " + (line) + "]";
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/literal"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def, $return_val = Opal.return_val, $defs = Opal.defs, $truthy = Opal.truthy, $const_set = Opal.const_set, $hash2 = Opal.hash2, $regexp = Opal.regexp, $send = Opal.send, $rb_plus = Opal.rb_plus, $lambda = Opal.lambda, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $slice = Opal.slice, $Opal = Opal.Opal, $rb_gt = Opal.rb_gt;

  Opal.add_stubs('require,handle,==,type,push,self,scope,to_s,children,value,recv?,wrap,freeze,join,keys,gsub,even?,length,last_match,+,chop,[],inspect,to_i,to_utf16,translate_escape_chars,valid_encoding?,helper,upcase,<=,call,-,>>,&,attr_accessor,extract_flags_and_value,select!,flags,=~,warning,compiler,compile_static_regexp,compile_dynamic_regexp,each_with_index,zero?,expr,any?,new,flags=,map,to_proc,value=,empty?,s,single_line?,include?,is_a?,updated,delete,source,expression,loc,private,>,!=,!,regexp,first,each,compile_inline?,compile_inline,compile_range_initialize,start,finish,raise,expr_or_nil,absolute_const,top_scope,numerator,denominator,real,imag');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'ValueNode');

        
        
        self.$handle("true", "false", "self", "nil");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($eqeq(self.$type(), "self")) {
            return self.$push(self.$scope().$self())
          } else {
            return self.$push(self.$type().$to_s())
          }
        }, 0);
        return $defs(self, '$truthy_optimize?', $return_val(true), 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'NumericNode');

        
        
        self.$handle("int", "float");
        self.$children("value");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push(self.$value().$to_s());
          if ($truthy(self['$recv?']())) {
            return self.$wrap("(", ")")
          } else {
            return nil
          };
        }, 0);
        return $defs(self, '$truthy_optimize?', $return_val(true), 0);
      })($nesting[0], $$('Base'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StringNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("str");
        self.$children("value");
        $const_set($nesting[0], 'ESCAPE_CHARS', $hash2(["a", "e"], {"a": "\\u0007", "e": "\\u001b"}).$freeze());
        $const_set($nesting[0], 'ESCAPE_REGEX', $regexp(["(\\\\+)([", $$('ESCAPE_CHARS').$keys().$join(""), "])"]).$freeze());
        
        $def(self, '$translate_escape_chars', function $$translate_escape_chars(inspect_string) {
          
          return $send(inspect_string, 'gsub', [$$('ESCAPE_REGEX')], function $$1(original){
            
            
            if (original == null) original = nil;;
            if ($truthy($$('Regexp').$last_match(1).$length()['$even?']())) {
              return original
            } else {
              return $rb_plus($$('Regexp').$last_match(1).$chop(), $$('ESCAPE_CHARS')['$[]']($$('Regexp').$last_match(2)))
            };}, 1)
        }, 1);
        
        $def(self, '$compile', function $$compile() {
          var self = this, string_value = nil, sanitized_value = nil;

          
          string_value = self.$value();
          sanitized_value = $send(string_value.$inspect(), 'gsub', [/\\u\{([0-9a-f]+)\}/], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s, code_point = nil;

            
            code_point = $$('Regexp').$last_match(1).$to_i(16);
            return self.$to_utf16(code_point);}, {$$arity: 0, $$s: self});
          self.$push(self.$translate_escape_chars(sanitized_value));
          nil;
          if ($truthy(self.$value()['$valid_encoding?']())) {
            return nil
          } else {
            
            self.$helper("binary");
            return self.$wrap("$binary(", ")");
          };
        }, 0);
        return $def(self, '$to_utf16', function $$to_utf16(code_point) {
          var ten_bits = nil, u = nil, lead_surrogate = nil, tail_surrogate = nil;

          
          ten_bits = 1023;
          u = $lambda(function $$3(code_unit){
            
            
            if (code_unit == null) code_unit = nil;;
            return $rb_plus("\\u", code_unit.$to_s(16).$upcase());}, 1);
          if ($truthy($rb_le(code_point, 65535))) {
            return u.$call(code_point)
          };
          code_point = $rb_minus(code_point, 65536);
          lead_surrogate = $rb_plus(55296, code_point['$>>'](10));
          tail_surrogate = $rb_plus(56320, code_point['$&'](ten_bits));
          return $rb_plus(u.$call(lead_surrogate), u.$call(tail_surrogate));
        }, 1);
      })($nesting[0], $$('Base'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'SymbolNode');

        
        
        self.$handle("sym");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$value().$to_s().$inspect())
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RegexpNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.sexp = nil;
        
        self.$handle("regexp");
        self.$attr_accessor("value", "flags");
        $const_set($nesting[0], 'SUPPORTED_FLAGS', /[gimuy]/.$freeze());
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          return self.$extract_flags_and_value();
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          $send(self.$flags(), 'select!', [], function $$4(flag){var self = $$4.$$s == null ? this : $$4.$$s;

            
            
            if (flag == null) flag = nil;;
            if ($truthy($$('SUPPORTED_FLAGS')['$=~'](flag))) {
              return true
            } else {
              
              self.$compiler().$warning("Skipping the '" + (flag) + "' Regexp flag as it's not widely supported by JavaScript vendors.");
              return false;
            };}, {$$arity: 1, $$s: self});
          if ($eqeq(self.$value().$type(), "str")) {
            return self.$compile_static_regexp()
          } else {
            return self.$compile_dynamic_regexp()
          };
        }, 0);
        
        $def(self, '$compile_dynamic_regexp', function $$compile_dynamic_regexp() {
          var self = this;

          
          self.$helper("regexp");
          self.$push("$regexp([");
          $send(self.$value().$children(), 'each_with_index', [], function $$5(v, index){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (v == null) v = nil;;
            
            if (index == null) index = nil;;
            if (!$truthy(index['$zero?']())) {
              self.$push(", ")
            };
            return self.$push(self.$expr(v));}, {$$arity: 2, $$s: self});
          self.$push("]");
          if ($truthy(self.$flags()['$any?']())) {
            self.$push(", '" + (self.$flags().$join()) + "'")
          };
          return self.$push(")");
        }, 0);
        
        $def(self, '$compile_static_regexp', function $$compile_static_regexp() {
          var self = this, value = nil;

          
          value = self.$value().$children()['$[]'](0);
          
          switch (value) {
            case "":
              return self.$push("/(?:)/")
            default:
              return self.$push("" + ($$('Regexp').$new(value).$inspect()) + (self.$flags().$join()))
          };
        }, 0);
        
        $def(self, '$extract_flags_and_value', function $$extract_flags_and_value() {
          var $a, $b, self = this, values = nil, flags_sexp = nil, parts = nil;

          
          $a = [].concat($to_a(self.$children())), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (values = $slice.call($a, 0, $b)), (flags_sexp = ($a[$b] == null ? nil : $a[$b])), $a;
          self['$flags=']($send(flags_sexp.$children(), 'map', [], "to_s".$to_proc()));
          self['$value='](($truthy(values['$empty?']()) ? (self.$s("str", "")) : ($truthy(self['$single_line?'](values)) ? (values['$[]'](0)) : ($send(self, 's', ["dstr"].concat($to_a(values)))))));
          if ($truthy(self.$flags()['$include?']("x"))) {
            
            parts = $send(self.$value().$children(), 'map', [], function $$6(part){var self = $$6.$$s == null ? this : $$6.$$s, trimmed_value = nil;

              
              
              if (part == null) part = nil;;
              if (($truthy(part['$is_a?']($$$($$$($Opal, 'AST'), 'Node'))) && ($eqeq(part.$type(), "str")))) {
                
                trimmed_value = part.$children()['$[]'](0).$gsub(/^\s*\#.*/, "").$gsub(/\s/, "");
                return self.$s("str", trimmed_value);
              } else {
                return part
              };}, {$$arity: 1, $$s: self});
            self['$value='](self.$value().$updated(nil, parts));
            self.$flags().$delete("x");
          };
          if ($eqeq(self.$value().$type(), "str")) {
            return ($a = [self.$s("str", self.$value().$children()['$[]'](0).$gsub("\\A", "^").$gsub("\\z", "$"))], $send(self, 'value=', $a), $a[$a.length - 1])
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$raw_value', function $$raw_value() {
          var $a, self = this;

          return ($a = [self.sexp.$loc().$expression().$source()], $send(self, 'value=', $a), $a[$a.length - 1])
        }, 0);
        self.$private();
        return $def(self, '$single_line?', function $RegexpNode_single_line$ques$7(values) {
          var value = nil, $ret_or_1 = nil;

          
          if ($truthy($rb_gt(values.$length(), 1))) {
            return false
          };
          value = values['$[]'](0);
          if ($truthy(($ret_or_1 = value.$type()['$!=']("str")))) {
            return $ret_or_1
          } else {
            return value.$children()['$[]'](0)['$include?']("\n")['$!']()
          };
        }, 1);
      })($nesting[0], $$('Base'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'MatchCurrentLineNode');

        
        
        self.$handle("match_current_line");
        self.$children("regexp");
        return $def(self, '$compile', function $$compile() {
          var self = this, gvar_sexp = nil, send_node = nil;

          
          gvar_sexp = self.$s("gvar", "$_");
          send_node = self.$s("send", gvar_sexp, "=~", self.$regexp());
          return self.$push(self.$expr(send_node));
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'DynamicStringNode');

        
        
        self.$handle("dstr");
        return $def(self, '$compile', function $$compile() {
          var self = this, skip_empty = nil;

          
          if (($truthy($rb_gt(self.$children().$length(), 1)) && ($eqeq(self.$children().$first().$type(), "str")))) {
            skip_empty = true
          } else {
            self.$push("\"\"")
          };
          return $send(self.$children(), 'each', [], function $$8(part){var self = $$8.$$s == null ? this : $$8.$$s;

            
            
            if (part == null) part = nil;;
            if ($truthy(skip_empty)) {
              skip_empty = false
            } else {
              self.$push(" + ")
            };
            if ($eqeq(part.$type(), "str")) {
              self.$push(self.$expr(part))
            } else {
              self.$push("(", self.$expr(part), ")")
            };
            if ($truthy(self['$recv?']())) {
              return self.$wrap("(", ")")
            } else {
              return nil
            };}, {$$arity: 1, $$s: self});
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'DynamicSymbolNode');

        
        return self.$handle("dsym")
      })($nesting[0], $$('DynamicStringNode'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RangeNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$children("start", "finish");
        $const_set($nesting[0], 'SIMPLE_CHILDREN_TYPES', ["int", "float", "str", "sym"].$freeze());
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$compile_inline?']())) {
            
            self.$helper("range");
            return self.$compile_inline();
          } else {
            return self.$compile_range_initialize()
          }
        }, 0);
        
        $def(self, '$compile_inline?', function $RangeNode_compile_inline$ques$9() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$start()['$!']())) ? ($ret_or_2) : (($truthy(($ret_or_3 = self.$start().$type())) ? ($$('SIMPLE_CHILDREN_TYPES')['$include?'](self.$start().$type())) : ($ret_or_3))))))) {
            
            if ($truthy(($ret_or_2 = self.$finish()['$!']()))) {
              return $ret_or_2
            } else {
              
              if ($truthy(($ret_or_3 = self.$finish().$type()))) {
                return $$('SIMPLE_CHILDREN_TYPES')['$include?'](self.$finish().$type())
              } else {
                return $ret_or_3
              };
            };
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$compile_inline', function $$compile_inline() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        }, 0);
        return $def(self, '$compile_range_initialize', function $$compile_range_initialize() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        }, 0);
      })($nesting[0], $$('Base'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'InclusiveRangeNode');

        
        
        self.$handle("irange");
        
        $def(self, '$compile_inline', function $$compile_inline() {
          var self = this;

          return self.$push("$range(", self.$expr_or_nil(self.$start()), ", ", self.$expr_or_nil(self.$finish()), ", false)")
        }, 0);
        return $def(self, '$compile_range_initialize', function $$compile_range_initialize() {
          var self = this;

          return self.$push("Opal.Range.$new(", self.$expr_or_nil(self.$start()), ", ", self.$expr_or_nil(self.$finish()), ", false)")
        }, 0);
      })($nesting[0], $$('RangeNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'ExclusiveRangeNode');

        
        
        self.$handle("erange");
        
        $def(self, '$compile_inline', function $$compile_inline() {
          var self = this;

          return self.$push("$range(", self.$expr_or_nil(self.$start()), ", ", self.$expr_or_nil(self.$finish()), ", true)")
        }, 0);
        return $def(self, '$compile_range_initialize', function $$compile_range_initialize() {
          var self = this;

          return self.$push("Opal.Range.$new(", self.$expr_or_nil(self.$start()), ",", self.$expr_or_nil(self.$finish()), ", true)")
        }, 0);
      })($nesting[0], $$('RangeNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'RationalNode');

        
        
        self.$handle("rational");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push("" + (self.$top_scope().$absolute_const()) + "('Rational').$new(" + (self.$value().$numerator()) + ", " + (self.$value().$denominator()) + ")")
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ComplexNode');

        
        
        self.$handle("complex");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push("" + (self.$top_scope().$absolute_const()) + "('Complex').$new(" + (self.$value().$real()) + ", " + (self.$value().$imag()) + ")")
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/variables"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs('require,handle,children,irb?,compiler,top?,scope,using_irb?,push,to_s,var_name,with_temp,property,wrap,add_local,expr,value,expr?,recv?,[],name,add_ivar,self,helper,add_gvar,handle_global_match,handle_post_match,handle_pre_match,raise,index,stmt?,class_variable_owner,inspect');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'LocalVariableNode');

        
        
        self.$handle("lvar");
        self.$children("var_name");
        
        $def(self, '$using_irb?', function $LocalVariableNode_using_irb$ques$1() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$compiler()['$irb?']()))) {
            return self.$scope()['$top?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          if (!$truthy(self['$using_irb?']())) {
            return self.$push(self.$var_name().$to_s())
          };
          return $send(self, 'with_temp', [], function $$2(tmp){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (tmp == null) tmp = nil;;
            self.$push(self.$property(self.$var_name().$to_s()));
            return self.$wrap("((" + (tmp) + " = Opal.irb_vars", ") == null ? nil : " + (tmp) + ")");}, {$$arity: 1, $$s: self});
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'LocalAssignNode');

        
        
        self.$handle("lvasgn");
        self.$children("var_name", "value");
        
        $def(self, '$using_irb?', function $LocalAssignNode_using_irb$ques$3() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$compiler()['$irb?']()))) {
            return self.$scope()['$top?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          if ($truthy(self['$using_irb?']())) {
            self.$push("Opal.irb_vars" + (self.$property(self.$var_name().$to_s())) + " = ")
          } else {
            
            self.$add_local(self.$var_name().$to_s());
            self.$push("" + (self.$var_name()) + " = ");
          };
          self.$push(self.$expr(self.$value()));
          if ((($truthy(self['$recv?']()) || ($truthy(self['$expr?']()))) && ($truthy(self.$value())))) {
            return self.$wrap("(", ")")
          } else {
            return nil
          };
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'LocalDeclareNode');

        
        
        self.$handle("lvdeclare");
        self.$children("var_name");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$add_local(self.$var_name().$to_s());
          return nil;
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'InstanceVariableNode');

        
        
        self.$handle("ivar");
        self.$children("name");
        
        $def(self, '$var_name', function $$var_name() {
          var self = this;

          return self.$name().$to_s()['$[]']($range(1, -1, false))
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, name = nil;

          
          name = self.$property(self.$var_name());
          self.$add_ivar(name);
          return self.$push("" + (self.$scope().$self()) + (name));
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'InstanceAssignNode');

        
        
        self.$handle("ivasgn");
        self.$children("name", "value");
        
        $def(self, '$var_name', function $$var_name() {
          var self = this;

          return self.$name().$to_s()['$[]']($range(1, -1, false))
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, name = nil;

          
          name = self.$property(self.$var_name());
          self.$push("" + (self.$scope().$self()) + (name) + " = ");
          self.$push(self.$expr(self.$value()));
          if ((($truthy(self['$recv?']()) || ($truthy(self['$expr?']()))) && ($truthy(self.$value())))) {
            return self.$wrap("(", ")")
          } else {
            return nil
          };
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'GlobalVariableNode');

        
        
        self.$handle("gvar");
        self.$children("name");
        
        $def(self, '$var_name', function $$var_name() {
          var self = this;

          return self.$name().$to_s()['$[]']($range(1, -1, false))
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, name = nil;

          
          self.$helper("gvars");
          name = self.$property(self.$var_name());
          self.$add_gvar(name);
          return self.$push("$gvars" + (name));
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BackRefNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("back_ref");
        
        $def(self, '$compile', function $$compile() {
          var $yield = $$compile.$$p || nil, self = this;

          delete $$compile.$$p;
          
          self.$helper("gvars");
          
          switch (self.$var_name()) {
            case "&":
              return self.$handle_global_match()
            case "'":
              return self.$handle_post_match()
            case "`":
              return self.$handle_pre_match()
            case "+":
              return $send2(self, $find_super(self, 'compile', $$compile, false, true), 'compile', [], $yield)
            default:
              return self.$raise($$('NotImplementedError'))
          };
        }, 0);
        
        $def(self, '$handle_global_match', function $$handle_global_match() {
          var self = this;

          return $send(self, 'with_temp', [], function $$4(tmp){var self = $$4.$$s == null ? this : $$4.$$s;

            
            
            if (tmp == null) tmp = nil;;
            return self.$push("((" + (tmp) + " = $gvars['~']) === nil ? nil : " + (tmp) + "['$[]'](0))");}, {$$arity: 1, $$s: self})
        }, 0);
        
        $def(self, '$handle_pre_match', function $$handle_pre_match() {
          var self = this;

          return $send(self, 'with_temp', [], function $$5(tmp){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (tmp == null) tmp = nil;;
            return self.$push("((" + (tmp) + " = $gvars['~']) === nil ? nil : " + (tmp) + ".$pre_match())");}, {$$arity: 1, $$s: self})
        }, 0);
        return $def(self, '$handle_post_match', function $$handle_post_match() {
          var self = this;

          return $send(self, 'with_temp', [], function $$6(tmp){var self = $$6.$$s == null ? this : $$6.$$s;

            
            
            if (tmp == null) tmp = nil;;
            return self.$push("((" + (tmp) + " = $gvars['~']) === nil ? nil : " + (tmp) + ".$post_match())");}, {$$arity: 1, $$s: self})
        }, 0);
      })($nesting[0], $$('GlobalVariableNode'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'GlobalAssignNode');

        
        
        self.$handle("gvasgn");
        self.$children("name", "value");
        
        $def(self, '$var_name', function $$var_name() {
          var self = this;

          return self.$name().$to_s()['$[]']($range(1, -1, false))
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, name = nil;

          
          self.$helper("gvars");
          name = self.$property(self.$var_name());
          self.$push("$gvars" + (name) + " = ");
          self.$push(self.$expr(self.$value()));
          if ((($truthy(self['$recv?']()) || ($truthy(self['$expr?']()))) && ($truthy(self.$value())))) {
            return self.$wrap("(", ")")
          } else {
            return nil
          };
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'NthrefNode');

        
        
        self.$handle("nth_ref");
        self.$children("index");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$helper("gvars");
          return $send(self, 'with_temp', [], function $$7(tmp){var self = $$7.$$s == null ? this : $$7.$$s;

            
            
            if (tmp == null) tmp = nil;;
            return self.$push("((" + (tmp) + " = $gvars['~']) === nil ? nil : " + (tmp) + "['$[]'](" + (self.$index()) + "))");}, {$$arity: 1, $$s: self});
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'ClassVariableNode');

        
        
        self.$handle("cvar");
        self.$children("name");
        return $def(self, '$compile', function $$compile() {
          var self = this, tolerant = nil;

          
          self.$helper("class_variable_get");
          tolerant = false;
          if ($truthy(self['$stmt?']())) {
            tolerant = true
          };
          return self.$push("$class_variable_get(" + (self.$class_variable_owner()) + ", '" + (self.$name()) + "', " + (tolerant.$inspect()) + ")");
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ClassVarAssignNode');

        
        
        self.$handle("cvasgn");
        self.$children("name", "value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$helper("class_variable_set");
          return self.$push("$class_variable_set(" + (self.$class_variable_owner()) + ", '" + (self.$name()) + "', ", self.$expr(self.$value()), ")");
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/constants"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $const_set = Opal.const_set;

  Opal.add_stubs('require,handle,children,magical_data_const?,push,optimized_access?,helper,name,==,const_scope,s,absolute_const,top_scope,recv,eval?,compiler,relative_access,scope,nil?,eof_content,freeze,include?,base,expr,value,nesting');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ConstNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("const");
        self.$children("const_scope", "name");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$magical_data_const?']())) {
            return self.$push("$__END__")
          } else if ($truthy(self['$optimized_access?']())) {
            
            self.$helper("" + (self.$name()));
            return self.$push("$" + (self.$name()));
          } else if ($eqeq(self.$const_scope(), self.$s("cbase"))) {
            return self.$push("" + (self.$top_scope().$absolute_const()) + "('" + (self.$name()) + "')")
          } else if ($truthy(self.$const_scope())) {
            return self.$push("" + (self.$top_scope().$absolute_const()) + "(", self.$recv(self.$const_scope()), ", '" + (self.$name()) + "')")
          } else if ($truthy(self.$compiler()['$eval?']())) {
            return self.$push("" + (self.$scope().$relative_access()) + "('" + (self.$name()) + "')")
          } else {
            return self.$push("" + (self.$scope().$relative_access()) + "('" + (self.$name()) + "')")
          }
        }, 0);
        
        $def(self, '$magical_data_const?', function $ConstNode_magical_data_const$ques$1() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$const_scope()['$nil?']())) ? (self.$name()['$==']("DATA")) : ($ret_or_2))))) {
            return self.$compiler().$eof_content()
          } else {
            return $ret_or_1
          }
        }, 0);
        $const_set($nesting[0], 'OPTIMIZED_ACCESS_CONSTS', ["BasicObject", "Object", "Module", "Class", "Opal", "Kernel", "NilClass"].$freeze());
        return $def(self, '$optimized_access?', function $ConstNode_optimized_access$ques$2() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$const_scope()['$=='](self.$s("cbase"))))) {
            return $$('OPTIMIZED_ACCESS_CONSTS')['$include?'](self.$name())
          } else {
            return $ret_or_1
          }
        }, 0);
      })($nesting[0], $$('Base'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'CbaseNode');

        
        
        self.$handle("cbase");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push("'::'")
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ConstAssignNode');

        
        
        self.$handle("casgn");
        self.$children("base", "name", "value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$helper("const_set");
          if ($truthy(self.$base())) {
            return self.$push("$const_set(", self.$expr(self.$base()), ", '" + (self.$name()) + "', ", self.$expr(self.$value()), ")")
          } else {
            return self.$push("$const_set(" + (self.$scope().$nesting()) + "[0], '" + (self.$name()) + "', ", self.$expr(self.$value()), ")")
          };
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/rewriters/break_finder"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $assign_ivar_val = Opal.assign_ivar_val, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $alias = Opal.alias;

  Opal.add_stubs('require,stop_lookup');
  
  self.$require("opal/rewriter");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'BreakFinder');

        
        
        
        $def(self, '$initialize', $assign_ivar_val("found_break", false), 0);
        
        $def(self, '$found_break?', $return_ivar("found_break"), 0);
        
        $def(self, '$on_break', function $$on_break(node) {
          var self = this;

          
          self.found_break = true;
          return node;
        }, 1);
        
        $def(self, '$stop_lookup', $return_val(nil), 0);
        $alias(self, "on_for", "stop_lookup");
        $alias(self, "on_while", "stop_lookup");
        $alias(self, "on_while_post", "stop_lookup");
        $alias(self, "on_until", "stop_lookup");
        $alias(self, "on_until_post", "stop_lookup");
        return $alias(self, "on_block", "stop_lookup");
      })($nesting[0], $$$($$$($$('Opal'), 'Rewriters'), 'Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/call"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $send = Opal.send, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $slice = Opal.slice, $truthy = Opal.truthy, $def = Opal.def, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $not = Opal.not, $neqeq = Opal.neqeq, $to_ary = Opal.to_ary, $Opal = Opal.Opal, $range = Opal.range;

  Opal.add_stubs('require,handle,attr_reader,freeze,[]=,define_method,to_proc,include?,type,s,handle_special,record_method_call,compiler,meth,with_wrapper,using_eval?,compile_eval_var,using_irb?,compile_irb_var,default_compile,private,iter,new,process,found_break?,splat?,call_is_writer_that_needs_handling?,!,empty?,collect_refinements_temps,scope,==,auto_await?,push,await_encountered=,invoke_using_refinement?,compile_using_refined_send,invoke_using_send?,compile_using_send,compile_simple_call_chain,compile_break_catcher,helper,compile_receiver,compile_method_name,compile_arguments,compile_block_pass,compile_refinements,recv,receiver_sexp,expr,arglist,children,map,iter_has_break?,unshift,line,method_jsid,any?,recvr,mid_to_jsid,to_s,with_temp,intern,irb?,top?,variable_like?,eval?,scope_variables,nil?,updated,async_await,!=,match?,method,arity,[],each,add_special,to_sym,call,inline_operators?,fragment,resolve,<<,requires,file,dirname,cleanpath,join,Pathname,self,inspect,length,warning,autoloads,required_trees,force_encoding,encoding,+,handle_block_given_call,def?,mid,module_name,count,accepts_using?,using_refinement,first,refinements_temp,arity_check?,defines_lambda,push_nesting?,nesting,new_temp,scope_locals,source_location,size,last,csend?,handle_conditional_send,handle_writer,expr?,recv?,=~,wrap,dynamic_require_severity,handle_part,is_a?,expand_path,split,error,each_with_object,pop');
  
  self.$require("set");
  self.$require("pathname");
  self.$require("opal/nodes/base");
  self.$require("opal/rewriters/break_finder");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CallNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.sexp = $proto.conditional_recvr = $proto.with_writer_temp = $proto.compiler = nil;
        
        self.$handle("send", "csend");
        self.$attr_reader("recvr", "meth", "arglist", "iter");
        $const_set($nesting[0], 'SPECIALS', $hash2([], {}));
        $const_set($nesting[0], 'OPERATORS', $hash2(["+", "-", "*", "/", "<", "<=", ">", ">="], {"+": "plus", "-": "minus", "*": "times", "/": "divide", "<": "lt", "<=": "le", ">": "gt", ">=": "ge"}).$freeze());
        $defs(self, '$add_special', function $$add_special(name, options) {
          var handler = $$add_special.$$p || nil, self = this;

          delete $$add_special.$$p;
          
          ;
          
          if (options == null) options = $hash2([], {});;
          $$('SPECIALS')['$[]='](name, options);
          return $send(self, 'define_method', ["handle_" + (name)], handler.$to_proc());
        }, -2);
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $b, $c, $yield = $$initialize.$$p || nil, self = this, args = nil, rest = nil, last_arg = nil;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          $b = [].concat($to_a(self.sexp)), (self.recvr = ($b[0] == null ? nil : $b[0])), (self.meth = ($b[1] == null ? nil : $b[1])), (args = $slice.call($b, 2)), $b;
          $b = [].concat($to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_arg = ($b[$c] == null ? nil : $b[$c])), $b;
          if (($truthy(last_arg) && ($truthy(["iter", "block_pass"]['$include?'](last_arg.$type()))))) {
            
            self.iter = last_arg;
            args = rest;
          } else {
            self.iter = nil
          };
          return (self.arglist = $send(self, 's', ["arglist"].concat($to_a(args))));
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return $send(self, 'handle_special', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            
            self.$compiler().$record_method_call(self.$meth());
            return $send(self, 'with_wrapper', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

              if ($truthy(self['$using_eval?']())) {
                return self.$compile_eval_var()
              } else if ($truthy(self['$using_irb?']())) {
                return self.$compile_irb_var()
              } else {
                return self.$default_compile()
              }}, {$$arity: 0, $$s: self});}, {$$arity: 0, $$s: self})
        }, 0);
        self.$private();
        
        $def(self, '$iter_has_break?', function $CallNode_iter_has_break$ques$3() {
          var self = this, finder = nil;

          
          if (!$truthy(self.$iter())) {
            return false
          };
          finder = $$$($$$($$('Opal'), 'Rewriters'), 'BreakFinder').$new();
          finder.$process(self.$iter());
          return finder['$found_break?']();
        }, 0);
        
        $def(self, '$invoke_using_send?', function $CallNode_invoke_using_send$ques$4() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$iter())) ? ($ret_or_2) : (self['$splat?']()))))) {
            return $ret_or_1
          } else {
            return self['$call_is_writer_that_needs_handling?']()
          }
        }, 0);
        
        $def(self, '$invoke_using_refinement?', function $CallNode_invoke_using_refinement$ques$5() {
          var self = this;

          return self.$scope().$scope().$collect_refinements_temps()['$empty?']()['$!']()
        }, 0);
        
        $def(self, '$csend?', function $CallNode_csend$ques$6() {
          var self = this;

          return self.sexp.$type()['$==']("csend")
        }, 0);
        
        $def(self, '$default_compile', function $$default_compile() {
          var self = this;

          
          if ($truthy(self['$auto_await?']())) {
            
            self.$push("await ");
            self.$scope()['$await_encountered='](true);
          };
          if ($truthy(self['$invoke_using_refinement?']())) {
            self.$compile_using_refined_send()
          } else if ($truthy(self['$invoke_using_send?']())) {
            self.$compile_using_send()
          } else {
            self.$compile_simple_call_chain()
          };
          return self.$compile_break_catcher();
        }, 0);
        
        $def(self, '$compile_using_send', function $$compile_using_send() {
          var self = this;

          
          self.$helper("send");
          self.$push("$send(");
          self.$compile_receiver();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        }, 0);
        
        $def(self, '$compile_using_refined_send', function $$compile_using_refined_send() {
          var self = this;

          
          self.$helper("refined_send");
          self.$push("$refined_send(");
          self.$compile_refinements();
          self.$compile_receiver();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        }, 0);
        
        $def(self, '$compile_receiver', function $$compile_receiver() {
          var self = this, $ret_or_1 = nil;

          return self.$push(($truthy(($ret_or_1 = self.conditional_recvr)) ? ($ret_or_1) : (self.$recv(self.$receiver_sexp()))))
        }, 0);
        
        $def(self, '$compile_method_name', function $$compile_method_name() {
          var self = this;

          return self.$push(", '" + (self.$meth()) + "'")
        }, 0);
        
        $def(self, '$compile_arguments', function $$compile_arguments(skip_comma) {
          var self = this;

          
          
          if (skip_comma == null) skip_comma = false;;
          if (!$truthy(skip_comma)) {
            self.$push(", ")
          };
          if ($truthy(self.with_writer_temp)) {
            return self.$push(self.with_writer_temp)
          } else if ($truthy(self['$splat?']())) {
            return self.$push(self.$expr(self.$arglist()))
          } else if ($truthy(self.$arglist().$children()['$empty?']())) {
            return self.$push("[]")
          } else {
            return self.$push("[", self.$expr(self.$arglist()), "]")
          };
        }, -1);
        
        $def(self, '$compile_block_pass', function $$compile_block_pass() {
          var self = this;

          if ($truthy(self.$iter())) {
            return self.$push(", ", self.$expr(self.$iter()))
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$compile_refinements', function $$compile_refinements() {
          var self = this, refinements = nil;

          
          refinements = $send(self.$scope().$collect_refinements_temps(), 'map', [], function $$7(i){var self = $$7.$$s == null ? this : $$7.$$s;

            
            
            if (i == null) i = nil;;
            return self.$s("js_tmp", i);}, {$$arity: 1, $$s: self});
          return self.$push(self.$expr($send(self, 's', ["array"].concat($to_a(refinements)))), ", ");
        }, 0);
        
        $def(self, '$compile_break_catcher', function $$compile_break_catcher() {
          var self = this;

          if ($truthy(self['$iter_has_break?']())) {
            
            self.$unshift("return ");
            self.$unshift("(function(){var $brk = Opal.new_brk(); try {");
            return self.$line("} catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()");
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$compile_simple_call_chain', function $$compile_simple_call_chain() {
          var self = this;

          return self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), "(", self.$expr(self.$arglist()), ")")
        }, 0);
        
        $def(self, '$splat?', function $CallNode_splat$ques$8() {
          var self = this;

          return $send(self.$arglist().$children(), 'any?', [], function $$9(a){
            
            
            if (a == null) a = nil;;
            return a.$type()['$==']("splat");}, 1)
        }, 0);
        
        $def(self, '$receiver_sexp', function $$receiver_sexp() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$recvr()))) {
            return $ret_or_1
          } else {
            return self.$s("self")
          }
        }, 0);
        
        $def(self, '$method_jsid', function $$method_jsid() {
          var self = this;

          return self.$mid_to_jsid(self.$meth().$to_s())
        }, 0);
        
        $def(self, '$compile_irb_var', function $$compile_irb_var() {
          var self = this;

          return $send(self, 'with_temp', [], function $$10(tmp){var self = $$10.$$s == null ? this : $$10.$$s, lvar = nil, call = nil, ref = nil;

            
            
            if (tmp == null) tmp = nil;;
            lvar = self.$meth();
            call = self.$s("send", self.$s("self"), self.$meth().$intern(), self.$s("arglist"));
            ref = "(typeof " + (lvar) + " !== 'undefined') ? " + (lvar) + " : ";
            return self.$push("((" + (tmp) + " = Opal.irb_vars." + (lvar) + ") == null ? ", ref, self.$expr(call), " : " + (tmp) + ")");}, {$$arity: 1, $$s: self})
        }, 0);
        
        $def(self, '$compile_eval_var', function $$compile_eval_var() {
          var self = this;

          return self.$push(self.$meth().$to_s())
        }, 0);
        
        $def(self, '$using_irb?', function $CallNode_using_irb$ques$11() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.compiler['$irb?']())) ? (self.$scope()['$top?']()) : ($ret_or_2))))) {
            return self['$variable_like?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$using_eval?', function $CallNode_using_eval$ques$12() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.compiler['$eval?']())) ? (self.$scope()['$top?']()) : ($ret_or_2))))) {
            return self.compiler.$scope_variables()['$include?'](self.$meth())
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$variable_like?', function $CallNode_variable_like$ques$13() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$arglist()['$=='](self.$s("arglist")))) ? (self.$recvr()['$nil?']()) : ($ret_or_2))))) {
            return self.$iter()['$nil?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$sexp_with_arglist', function $$sexp_with_arglist() {
          var self = this;

          return self.sexp.$updated(nil, [self.$recvr(), self.$meth(), self.$arglist()])
        }, 0);
        
        $def(self, '$auto_await?', function $CallNode_auto_await$ques$14() {
          var self = this, awaited_set = nil, $ret_or_1 = nil, $ret_or_2 = nil;

          
          awaited_set = self.$compiler().$async_await();
          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = awaited_set)) ? (awaited_set['$!='](true)) : ($ret_or_2))))) {
            return awaited_set['$match?'](self.$meth().$to_s())
          } else {
            return $ret_or_1
          };
        }, 0);
        
        $def(self, '$handle_special', function $$handle_special() {
          var compile_default = $$handle_special.$$p || nil, self = this, method = nil;

          delete $$handle_special.$$p;
          
          ;
          if ($truthy($$('SPECIALS')['$include?'](self.$meth()))) {
            
            method = self.$method("handle_" + (self.$meth()));
            if ($eqeq(method.$arity(), 1)) {
              return method['$[]'](compile_default)
            } else {
              return method['$[]']()
            };
          } else {
            return Opal.yieldX(compile_default, []);
          };
        }, 0);
        $send($$('OPERATORS'), 'each', [], function $CallNode$15(operator, name){var self = $CallNode$15.$$s == null ? this : $CallNode$15.$$s;

          
          
          if (operator == null) operator = nil;;
          
          if (name == null) name = nil;;
          return $send(self, 'add_special', [operator.$to_sym()], function $$16(compile_default){var $a, self = $$16.$$s == null ? this : $$16.$$s, lhs = nil, rhs = nil;

            
            
            if (compile_default == null) compile_default = nil;;
            if ($truthy(self['$invoke_using_refinement?']())) {
              return compile_default.$call()
            } else if ($truthy(self.$compiler()['$inline_operators?']())) {
              
              self.$compiler().$record_method_call(operator);
              self.$helper("rb_" + (name));
              $a = [self.$expr(self.$recvr()), self.$expr(self.$arglist())], (lhs = $a[0]), (rhs = $a[1]), $a;
              self.$push(self.$fragment("$rb_" + (name) + "("));
              self.$push(lhs);
              self.$push(self.$fragment(", "));
              self.$push(rhs);
              return self.$push(self.$fragment(")"));
            } else {
              return compile_default.$call()
            };}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
        $send(self, 'add_special', ["require"], function $CallNode$17(compile_default){var self = $CallNode$17.$$s == null ? this : $CallNode$17.$$s, str = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          str = $$('DependencyResolver').$new(self.$compiler(), self.$arglist().$children()['$[]'](0)).$resolve();
          if (!$truthy(str['$nil?']())) {
            self.$compiler().$requires()['$<<'](str)
          };
          return compile_default.$call();}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["require_relative"], function $CallNode$18(){var self = $CallNode$18.$$s == null ? this : $CallNode$18.$$s, arg = nil, file = nil, dir = nil;

          
          arg = self.$arglist().$children()['$[]'](0);
          file = self.$compiler().$file();
          if ($eqeq(arg.$type(), "str")) {
            
            dir = $$('File').$dirname(file);
            self.$compiler().$requires()['$<<'](self.$Pathname(dir).$join(arg.$children()['$[]'](0)).$cleanpath().$to_s());
          };
          self.$push(self.$fragment("" + (self.$scope().$self()) + ".$require(" + (file.$inspect()) + "+ '/../' + "));
          self.$push(self.$process(self.$arglist()));
          return self.$push(self.$fragment(")"));}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["autoload"], function $CallNode$19(compile_default){var self = $CallNode$19.$$s == null ? this : $CallNode$19.$$s, args = nil, str = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          args = self.$arglist().$children();
          if (($eqeq(args.$length(), 2) && ($eqeq(args['$[]'](0).$type(), "sym")))) {
            
            str = $$('DependencyResolver').$new(self.$compiler(), args['$[]'](1), "ignore").$resolve();
            if ($truthy(str['$nil?']())) {
              self.$compiler().$warning("File for autoload of constant '" + (args['$[]'](0).$children()['$[]'](0)) + "' could not be bundled!")
            } else {
              
              self.$compiler().$requires()['$<<'](str);
              self.$compiler().$autoloads()['$<<'](str);
            };
          };
          return compile_default.$call();}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["require_tree"], function $CallNode$20(compile_default){var $a, self = $CallNode$20.$$s == null ? this : $CallNode$20.$$s, first_arg = nil, rest = nil, relative_path = nil, dir = nil, full_path = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          $a = [].concat($to_a(self.$arglist().$children())), (first_arg = ($a[0] == null ? nil : $a[0])), (rest = $slice.call($a, 1)), $a;
          if ($eqeq(first_arg.$type(), "str")) {
            
            relative_path = first_arg.$children()['$[]'](0);
            self.$compiler().$required_trees()['$<<'](relative_path);
            dir = $$('File').$dirname(self.$compiler().$file());
            full_path = self.$Pathname(dir).$join(relative_path).$cleanpath().$to_s();
            full_path.$force_encoding(relative_path.$encoding());
            first_arg = first_arg.$updated(nil, [full_path]);
          };
          self.arglist = self.$arglist().$updated(nil, $rb_plus([first_arg], rest));
          return compile_default.$call();}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["block_given?"], function $CallNode$21(){var self = $CallNode$21.$$s == null ? this : $CallNode$21.$$s;
          if (self.sexp == null) self.sexp = nil;

          return self.$push(self.$compiler().$handle_block_given_call(self.sexp))}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["__callee__"], function $CallNode$22(){var self = $CallNode$22.$$s == null ? this : $CallNode$22.$$s;

          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))
          } else {
            return self.$push(self.$fragment("nil"))
          }}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["__method__"], function $CallNode$23(){var self = $CallNode$23.$$s == null ? this : $CallNode$23.$$s;

          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))
          } else {
            return self.$push(self.$fragment("nil"))
          }}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["__dir__"], function $CallNode$24(){var self = $CallNode$24.$$s == null ? this : $CallNode$24.$$s;

          return self.$push($$('File').$dirname($$$($$('Opal'), 'Compiler').$module_name(self.$compiler().$file())).$inspect())}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["using"], function $CallNode$25(compile_default){var self = $CallNode$25.$$s == null ? this : $CallNode$25.$$s;

          
          
          if (compile_default == null) compile_default = nil;;
          if (($truthy(self.$scope()['$accepts_using?']()) && ($eqeq(self.$arglist().$children().$count(), 1)))) {
            return self.$using_refinement(self.$arglist().$children().$first())
          } else {
            return compile_default.$call()
          };}, {$$arity: 1, $$s: self});
        
        $def(self, '$using_refinement', function $$using_refinement(arg) {
          var $a, self = this, prev = nil, curr = nil;

          
          $a = [].concat($to_a(self.$scope().$refinements_temp())), (prev = ($a[0] == null ? nil : $a[0])), (curr = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(prev)) {
            return self.$push("(" + (curr) + " = " + (prev) + ".slice(), " + (curr) + ".push(", self.$expr(arg), "), " + (self.$scope().$self()) + ")")
          } else {
            return self.$push("(" + (curr) + " = [", self.$expr(arg), "], " + (self.$scope().$self()) + ")")
          };
        }, 1);
        $send(self, 'add_special', ["debugger"], function $CallNode$26(){var self = $CallNode$26.$$s == null ? this : $CallNode$26.$$s;

          return self.$push(self.$fragment("debugger"))}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["__OPAL_COMPILER_CONFIG__"], function $CallNode$27(){var self = $CallNode$27.$$s == null ? this : $CallNode$27.$$s;

          return self.$push(self.$fragment("Opal.hash({ arity_check: " + (self.$compiler()['$arity_check?']()) + " })"))}, {$$arity: 0, $$s: self});
        $send(self, 'add_special', ["lambda"], function $CallNode$28(compile_default){var self = $CallNode$28.$$s == null ? this : $CallNode$28.$$s;

          
          
          if (compile_default == null) compile_default = nil;;
          return $send(self.$scope(), 'defines_lambda', [], function $$29(){
            return compile_default.$call()}, 0);}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["nesting"], function $CallNode$30(compile_default){var self = $CallNode$30.$$s == null ? this : $CallNode$30.$$s, push_nesting = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          push_nesting = self['$push_nesting?']();
          if ($truthy(push_nesting)) {
            self.$push("(Opal.Module.$$nesting = " + (self.$scope().$nesting()) + ", ")
          };
          compile_default.$call();
          if ($truthy(push_nesting)) {
            return self.$push(")")
          } else {
            return nil
          };}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["constants"], function $CallNode$31(compile_default){var self = $CallNode$31.$$s == null ? this : $CallNode$31.$$s, push_nesting = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          push_nesting = self['$push_nesting?']();
          if ($truthy(push_nesting)) {
            self.$push("(Opal.Module.$$nesting = " + (self.$scope().$nesting()) + ", ")
          };
          compile_default.$call();
          if ($truthy(push_nesting)) {
            return self.$push(")")
          } else {
            return nil
          };}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["eval"], function $CallNode$32(compile_default){var self = $CallNode$32.$$s == null ? this : $CallNode$32.$$s, temp = nil, scope_variables = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          if (($neqeq(self.$arglist().$children().$length(), 1) || ($not([self.$s("self"), nil]['$include?'](self.$recvr()))))) {
            return compile_default.$call();
          };
          self.$scope().$nesting();
          temp = self.$scope().$new_temp();
          scope_variables = $send(self.$scope().$scope_locals(), 'map', [], "to_s".$to_proc()).$inspect();
          self.$push("(" + (temp) + " = ", self.$expr(self.$arglist()));
          self.$push(", typeof Opal.compile === 'function' ? eval(Opal.compile(" + (temp));
          self.$push(", {scope_variables: ", scope_variables);
          self.$push(", arity_check: " + (self.$compiler()['$arity_check?']()) + ", file: '(eval)', eval: true})) : ");
          return self.$push("" + (self.$scope().$self()) + ".$eval(" + (temp) + "))");}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["local_variables"], function $CallNode$33(compile_default){var self = $CallNode$33.$$s == null ? this : $CallNode$33.$$s, scope_variables = nil;

          
          
          if (compile_default == null) compile_default = nil;;
          if (!$truthy([self.$s("self"), nil]['$include?'](self.$recvr()))) {
            return compile_default.$call();
          };
          scope_variables = $send(self.$scope().$scope_locals(), 'map', [], "to_s".$to_proc()).$inspect();
          return self.$push(scope_variables);}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["binding"], function $CallNode$34(compile_default){var self = $CallNode$34.$$s == null ? this : $CallNode$34.$$s;

          
          
          if (compile_default == null) compile_default = nil;;
          if (!$truthy(self.$recvr()['$nil?']())) {
            return compile_default.$call();
          };
          self.$scope().$nesting();
          self.$push("Opal.Binding.$new(");
          self.$push("  function($code) {");
          self.$push("    return eval($code);");
          self.$push("  },");
          self.$push("  ", $send(self.$scope().$scope_locals(), 'map', [], "to_s".$to_proc()).$inspect(), ",");
          self.$push("  ", self.$scope().$self(), ",");
          self.$push("  ", self.$source_location());
          return self.$push(")");}, {$$arity: 1, $$s: self});
        $send(self, 'add_special', ["__await__"], function $CallNode$35(compile_default){var $a, self = $CallNode$35.$$s == null ? this : $CallNode$35.$$s;

          
          
          if (compile_default == null) compile_default = nil;;
          if ($truthy(self.$compiler().$async_await())) {
            
            self.$push(self.$fragment("(await ("));
            self.$push(self.$process(self.$recvr()));
            self.$push(self.$fragment("))"));
            return ($a = [true], $send(self.$scope(), 'await_encountered=', $a), $a[$a.length - 1]);
          } else {
            return compile_default.$call()
          };}, {$$arity: 1, $$s: self});
        
        $def(self, '$push_nesting?', function $CallNode_push_nesting$ques$36() {
          var self = this, recv = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          
          recv = self.$children().$first();
          if ($truthy(($ret_or_1 = self.$children().$size()['$=='](2)))) {
            
            if ($truthy(($ret_or_2 = recv['$nil?']()))) {
              return $ret_or_2
            } else {
              
              if ($truthy(($ret_or_3 = recv.$type()['$==']("const")))) {
                return recv.$children().$last()['$==']("Module")
              } else {
                return $ret_or_3
              };
            };
          } else {
            return $ret_or_1
          };
        }, 0);
        
        $def(self, '$with_wrapper', function $$with_wrapper() {
          var block = $$with_wrapper.$$p || nil, self = this;

          delete $$with_wrapper.$$p;
          
          ;
          if (($truthy(self['$csend?']()) && ($not(self.conditional_recvr)))) {
            return $send(self, 'handle_conditional_send', [], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

              return $send(self, 'with_wrapper', [], block.$to_proc())}, {$$arity: 0, $$s: self})
          } else if ($truthy(self['$call_is_writer_that_needs_handling?']())) {
            return $send(self, 'handle_writer', [], block.$to_proc())
          } else {
            return Opal.yieldX(block, []);
          };
        }, 0);
        
        $def(self, '$call_is_writer_that_needs_handling?', function $CallNode_call_is_writer_that_needs_handling$ques$38() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self['$expr?']())) ? ($ret_or_2) : (self['$recv?']()))))) {
            
            if ($truthy(($ret_or_2 = self.$meth().$to_s()['$=~'](/^\w+=$/)))) {
              return $ret_or_2
            } else {
              return self.$meth()['$==']("[]=")
            };
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$handle_conditional_send', function $$handle_conditional_send() {
          var $yield = $$handle_conditional_send.$$p || nil, self = this, receiver_temp = nil;

          delete $$handle_conditional_send.$$p;
          
          receiver_temp = self.$scope().$new_temp();
          self.$push("" + (receiver_temp) + " = ", self.$expr(self.$recvr()));
          self.$push(", (" + (receiver_temp) + " === nil || " + (receiver_temp) + " == null) ? nil : ");
          self.conditional_recvr = receiver_temp;
          Opal.yieldX($yield, []);
          return self.$wrap("(", ")");
        }, 0);
        
        $def(self, '$handle_writer', function $$handle_writer() {
          var $yield = $$handle_writer.$$p || nil, self = this;

          delete $$handle_writer.$$p;
          return $send(self, 'with_temp', [], function $$39(temp){var self = $$39.$$s == null ? this : $$39.$$s;

            
            
            if (temp == null) temp = nil;;
            self.$push("(" + (temp) + " = ");
            self.$compile_arguments(true);
            self.$push(", ");
            self.with_writer_temp = temp;
            Opal.yieldX($yield, []);
            self.with_writer_temp = false;
            self.$push(", ");
            return self.$push("" + (temp) + "[" + (temp) + ".length - 1])");}, {$$arity: 1, $$s: self})
        }, 0);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'DependencyResolver');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.compiler = $proto.sexp = $proto.missing_dynamic_require = nil;
          
          
          $def(self, '$initialize', function $$initialize(compiler, sexp, missing_dynamic_require) {
            var self = this, $ret_or_1 = nil;

            
            
            if (missing_dynamic_require == null) missing_dynamic_require = nil;;
            self.compiler = compiler;
            self.sexp = sexp;
            return (self.missing_dynamic_require = ($truthy(($ret_or_1 = missing_dynamic_require)) ? ($ret_or_1) : (self.compiler.$dynamic_require_severity())));
          }, -3);
          
          $def(self, '$resolve', function $$resolve() {
            var self = this;

            return self.$handle_part(self.sexp)
          }, 0);
          
          $def(self, '$handle_part', function $$handle_part(sexp, missing_dynamic_require) {
            var $a, $b, self = this, recv = nil, meth = nil, args = nil, parts = nil;

            
            
            if (missing_dynamic_require == null) missing_dynamic_require = self.missing_dynamic_require;;
            if ($truthy(sexp)) {
              
              switch (sexp.$type()) {
                case "str":
                  return sexp.$children()['$[]'](0)
                case "dstr":
                  return $send(sexp.$children(), 'map', [], function $$40(i){var self = $$40.$$s == null ? this : $$40.$$s;

                    
                    
                    if (i == null) i = nil;;
                    return self.$handle_part(i);}, {$$arity: 1, $$s: self}).$join()
                case "begin":
                  if ($eqeq(sexp.$children().$length(), 1)) {
                    return self.$handle_part(sexp.$children()['$[]'](0))
                  }
                  break;
                case "send":
                  
                  $b = sexp.$children(), $a = $to_ary($b), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $b;
                  parts = $send(args, 'map', [], function $$41(s){var self = $$41.$$s == null ? this : $$41.$$s;

                    
                    
                    if (s == null) s = nil;;
                    return self.$handle_part(s, "ignore");}, {$$arity: 1, $$s: self});
                  if ($truthy(parts['$include?'](nil))) {
                    return nil
                  };
                  if ((($truthy(recv['$is_a?']($$$($$$($Opal, 'AST'), 'Node'))) && ($eqeq(recv.$type(), "const"))) && ($eqeq(recv.$children().$last(), "File")))) {
                    if ($eqeq(meth, "expand_path")) {
                      return $send(self, 'expand_path', $to_a(parts))
                    } else if ($eqeq(meth, "join")) {
                      return self.$expand_path(parts.$join("/"))
                    } else if ($eqeq(meth, "dirname")) {
                      return self.$expand_path(parts['$[]'](0).$split("/")['$[]']($range(0, -1, true)).$join("/"))
                    }
                  } else if ($eqeq(meth, "__dir__")) {
                    return $$('File').$dirname($$$($$('Opal'), 'Compiler').$module_name(self.compiler.$file()))
                  };
                  break;
                default:
                  nil
              }
            };
            
            switch (missing_dynamic_require) {
              case "error":
                return self.compiler.$error("Cannot handle dynamic require", self.sexp.$line())
              case "warning":
                return self.compiler.$warning("Cannot handle dynamic require", self.sexp.$line())
              default:
                return nil
            };
          }, -2);
          return $def(self, '$expand_path', function $$expand_path(path, base) {
            
            
            
            if (base == null) base = "";;
            return $send(((("" + (base)) + "/") + (path)).$split("/"), 'each_with_object', [[]], function $$42(part, p){
              
              
              if (part == null) part = nil;;
              
              if (p == null) p = nil;;
              if ($eqeq(part, "")) {
                return nil
              } else if ($eqeq(part, "..")) {
                return p.$pop()
              } else {
                return p['$<<'](part)
              };}, 2).$join("/");
          }, -2);
        })($nesting[0], null, $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/call_special"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send;

  Opal.add_stubs('require,handle,children,push,recv,recvr,expr,property,value,<<,default_compile,meth,receiver_sexp,method_jsid,compile_arguments,iter,s,lhs,rhs,==,type,first,map,flatten,scan,to_proc,empty?,stmt?,process');
  
  self.$require("opal/nodes/base");
  self.$require("opal/nodes/call");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'JsAttrNode');

        
        
        self.$handle("jsattr");
        self.$children("recvr", "property");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$recv(self.$recvr()), "[", self.$expr(self.$property()), "]")
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JsAttrAsgnNode');

        
        
        self.$handle("jsattrasgn");
        self.$children("recvr", "property", "value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$recv(self.$recvr()), "[", self.$expr(self.$property()), "] = ", self.$expr(self.$value()))
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JsCallNode');

        var $proto = self.$$prototype;

        $proto.iter = $proto.arglist = nil;
        
        self.$handle("jscall");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          if ($truthy(self.iter)) {
            self.arglist = self.arglist['$<<'](self.iter)
          };
          return (self.iter = nil);
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$default_compile()
        }, 0);
        
        $def(self, '$method_jsid', function $$method_jsid() {
          var self = this;

          return "." + (self.$meth())
        }, 0);
        return $def(self, '$compile_using_send', function $$compile_using_send() {
          var self = this;

          
          self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), ".apply(null");
          self.$compile_arguments();
          if ($truthy(self.$iter())) {
            self.$push(".concat(", self.$expr(self.$iter()), ")")
          };
          return self.$push(")");
        }, 0);
      })($nesting[0], $$('CallNode'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'Match3Node');

        var $proto = self.$$prototype;

        $proto.level = nil;
        
        self.$handle("match_with_lvasgn");
        self.$children("lhs", "rhs");
        return $def(self, '$compile', function $$compile() {
          var self = this, sexp = nil, re = nil, names = nil, names_def = nil;

          
          sexp = self.$s("send", self.$lhs(), "=~", self.$rhs());
          if (($eqeq(self.$lhs().$type(), "regexp") && ($eqeq(self.$lhs().$children().$first().$type(), "str")))) {
            
            re = self.$lhs().$children().$first().$children().$first();
            names = $send(re.$scan(/\(\?<([^>]*)>/).$flatten(), 'map', [], "to_sym".$to_proc());
            if (!$truthy(names['$empty?']())) {
              
              names_def = self.$s("lvasgn", "$m3names", self.$s("if", self.$s("gvar", "$~"), self.$s("send", self.$s("gvar", "$~"), "named_captures"), self.$s("hash")));
              names = $send(names, 'map', [], function $$1(name){var self = $$1.$$s == null ? this : $$1.$$s;

                
                
                if (name == null) name = nil;;
                return self.$s("lvasgn", name, self.$s("send", self.$s("lvar", "$m3names"), "[]", self.$s("sym", name)));}, {$$arity: 1, $$s: self});
              if ($truthy(self['$stmt?']())) {
                sexp = $send(self, 's', ["begin", sexp, names_def].concat($to_a(names)))
              } else {
                sexp = $send(self, 's', ["begin", self.$s("lvasgn", "$m3tmp", sexp), names_def].concat($to_a(names)).concat([self.$s("lvar", "$m3tmp")]))
              };
            };
          };
          return self.$push(self.$process(sexp, self.level));
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/scope"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $assign_ivar_val = Opal.assign_ivar_val, $return_ivar = Opal.return_ivar, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2;

  Opal.add_stubs('require,attr_accessor,attr_reader,indent,scope,compiler,scope=,==,iter?,!,class?,dup,push,map,ivars,gvars,empty?,<<,parser_indent,join,+,fragment,def_in_class?,add_proto_ivar,include?,has_local?,|,scope_locals,reject,start_with?,to_s,has_temp?,pop,next_temp,loop,succ,uses_block!,identify!,valid_name?,mid,compact,parent,name,scope_name,unique_temp,lambda?,def?,type,nil?,rescue_else_sexp,last,class,collect_refinements_temps,add_scope_local,new_refinements_temp,identity,block_name=,add_temp,block_name,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ScopeNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.type = $proto.is_lambda = $proto.defs = $proto.parent = $proto.temps = $proto.locals = $proto.proto_ivars = $proto.compiler = $proto.ivars = $proto.gvars = $proto.args = $proto.queue = $proto.while_stack = $proto.identity = $proto.rescues = $proto.next_retry_id = $proto.refinements_temp = $proto.block_prepared = nil;
        
        self.$attr_accessor("parent");
        self.$attr_accessor("name");
        self.$attr_accessor("block_name");
        self.$attr_reader("scope_name");
        self.$attr_reader("locals");
        self.$attr_reader("ivars");
        self.$attr_reader("gvars");
        self.$attr_accessor("mid");
        self.$attr_accessor("defs");
        self.$attr_reader("methods");
        self.$attr_accessor("catch_return", "has_break", "has_retry");
        self.$attr_accessor("rescue_else_sexp");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          self.locals = [];
          self.temps = [];
          self.args = [];
          self.ivars = [];
          self.gvars = [];
          self.parent = nil;
          self.queue = [];
          self.unique = "a";
          self.while_stack = [];
          self.identity = nil;
          self.defs = nil;
          self.methods = [];
          self.uses_block = false;
          self.in_ensure = false;
          return (self.proto_ivars = []);
        }, -1);
        
        $def(self, '$in_scope', function $$in_scope() {
          var $yield = $$in_scope.$$p || nil, self = this;

          delete $$in_scope.$$p;
          return $send(self, 'indent', [], function $$1(){var $a, self = $$1.$$s == null ? this : $$1.$$s;
            if (self.parent == null) self.parent = nil;

            
            self.parent = self.$compiler().$scope();
            self.$compiler()['$scope='](self);
            Opal.yield1($yield, self);
            return ($a = [self.parent], $send(self.$compiler(), 'scope=', $a), $a[$a.length - 1]);}, {$$arity: 0, $$s: self})
        }, 0);
        
        $def(self, '$class_scope?', function $ScopeNode_class_scope$ques$2() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.type['$==']("class")))) {
            return $ret_or_1
          } else {
            return self.type['$==']("module")
          }
        }, 0);
        
        $def(self, '$class?', function $ScopeNode_class$ques$3() {
          var self = this;

          return self.type['$==']("class")
        }, 0);
        
        $def(self, '$module?', function $ScopeNode_module$ques$4() {
          var self = this;

          return self.type['$==']("module")
        }, 0);
        
        $def(self, '$sclass?', function $ScopeNode_sclass$ques$5() {
          var self = this;

          return self.type['$==']("sclass")
        }, 0);
        
        $def(self, '$top?', function $ScopeNode_top$ques$6() {
          var self = this;

          return self.type['$==']("top")
        }, 0);
        
        $def(self, '$iter?', function $ScopeNode_iter$ques$7() {
          var self = this;

          return self.type['$==']("iter")
        }, 0);
        
        $def(self, '$def?', function $ScopeNode_def$ques$8() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.type['$==']("def")))) {
            return $ret_or_1
          } else {
            return self.type['$==']("defs")
          }
        }, 0);
        
        $def(self, '$lambda?', function $ScopeNode_lambda$ques$9() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$iter?']()))) {
            return self.is_lambda
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$is_lambda!', $assign_ivar_val("is_lambda", true), 0);
        
        $def(self, '$defines_lambda', function $$defines_lambda() {
          var $yield = $$defines_lambda.$$p || nil, self = this;

          delete $$defines_lambda.$$p;
          
          self.lambda_definition = true;
          Opal.yieldX($yield, []);
          return (self.lambda_definition = false);
        }, 0);
        
        $def(self, '$lambda_definition?', $return_ivar("lambda_definition"), 0);
        
        $def(self, '$def_in_class?', function $ScopeNode_def_in_class$ques$10() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.defs['$!']())) ? (self.type['$==']("def")) : ($ret_or_3)))) ? (self.parent) : ($ret_or_2))))) {
            return self.parent['$class?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$to_vars', function $$to_vars() {
          var self = this, vars = nil, iv = nil, gv = nil, indent = nil, str = nil, pvars = nil;

          
          vars = self.temps.$dup();
          $send(vars, 'push', $to_a($send(self.locals, 'map', [], function $$11(l){
            
            
            if (l == null) l = nil;;
            return "" + (l) + " = nil";}, 1)));
          iv = $send(self.$ivars(), 'map', [], function $$12(ivar){
            
            
            if (ivar == null) ivar = nil;;
            return "if (self" + (ivar) + " == null) self" + (ivar) + " = nil;\n";}, 1);
          gv = $send(self.$gvars(), 'map', [], function $$13(gvar){
            
            
            if (gvar == null) gvar = nil;;
            return "if ($gvars" + (gvar) + " == null) $gvars" + (gvar) + " = nil;\n";}, 1);
          if (($truthy(self['$class?']()) && ($not(self.proto_ivars['$empty?']())))) {
            vars['$<<']("$proto = self.$$prototype")
          };
          indent = self.compiler.$parser_indent();
          str = ($truthy(vars['$empty?']()) ? ("") : ("var " + (vars.$join(", ")) + ";\n"));
          if (!$truthy(self.$ivars()['$empty?']())) {
            str = $rb_plus(str, "" + (indent) + (iv.$join(indent)))
          };
          if (!$truthy(self.$gvars()['$empty?']())) {
            str = $rb_plus(str, "" + (indent) + (gv.$join(indent)))
          };
          if (($truthy(self['$class?']()) && ($not(self.proto_ivars['$empty?']())))) {
            
            pvars = $send(self.proto_ivars, 'map', [], function $$14(i){
              
              
              if (i == null) i = nil;;
              return "$proto" + (i);}, 1).$join(" = ");
            str = "" + (str) + "\n" + (indent) + (pvars) + " = nil;";
          };
          return self.$fragment(str);
        }, 0);
        
        $def(self, '$add_scope_ivar', function $$add_scope_ivar(ivar) {
          var self = this;

          if ($truthy(self['$def_in_class?']())) {
            return self.parent.$add_proto_ivar(ivar)
          } else if ($truthy(self.ivars['$include?'](ivar))) {
            return nil
          } else {
            return self.ivars['$<<'](ivar)
          }
        }, 1);
        
        $def(self, '$add_scope_gvar', function $$add_scope_gvar(gvar) {
          var self = this;

          if ($truthy(self.gvars['$include?'](gvar))) {
            return nil
          } else {
            return self.gvars['$<<'](gvar)
          }
        }, 1);
        
        $def(self, '$add_proto_ivar', function $$add_proto_ivar(ivar) {
          var self = this;

          if ($truthy(self.proto_ivars['$include?'](ivar))) {
            return nil
          } else {
            return self.proto_ivars['$<<'](ivar)
          }
        }, 1);
        
        $def(self, '$add_arg', function $$add_arg(arg) {
          var self = this;

          
          if (!$truthy(self.args['$include?'](arg))) {
            self.args['$<<'](arg)
          };
          return arg;
        }, 1);
        
        $def(self, '$add_scope_local', function $$add_scope_local(local) {
          var self = this;

          
          if ($truthy(self['$has_local?'](local))) {
            return nil
          };
          return self.locals['$<<'](local);
        }, 1);
        
        $def(self, '$has_local?', function $ScopeNode_has_local$ques$15(local) {
          var self = this;

          
          if ((($truthy(self.locals['$include?'](local)) || ($truthy(self.args['$include?'](local)))) || ($truthy(self.temps['$include?'](local))))) {
            return true
          };
          if (($truthy(self.parent) && ($eqeq(self.type, "iter")))) {
            return self.parent['$has_local?'](local)
          };
          return false;
        }, 1);
        
        $def(self, '$scope_locals', function $$scope_locals() {
          var self = this, locals = nil;

          
          locals = self.locals['$|'](self.args)['$|']((($truthy(self.parent) && ($eqeq(self.type, "iter"))) ? (self.parent.$scope_locals()) : ([])));
          return $send(locals, 'reject', [], function $$16(i){
            
            
            if (i == null) i = nil;;
            return i.$to_s()['$start_with?']("$");}, 1);
        }, 0);
        
        $def(self, '$add_scope_temp', function $$add_scope_temp(tmp) {
          var self = this;

          
          if ($truthy(self['$has_temp?'](tmp))) {
            return nil
          };
          return self.temps.$push(tmp);
        }, 1);
        
        $def(self, '$has_temp?', function $ScopeNode_has_temp$ques$17(tmp) {
          var self = this;

          return self.temps['$include?'](tmp)
        }, 1);
        
        $def(self, '$new_temp', function $$new_temp() {
          var self = this, tmp = nil;

          
          if (!$truthy(self.queue['$empty?']())) {
            return self.queue.$pop()
          };
          tmp = self.$next_temp();
          self.temps['$<<'](tmp);
          return tmp;
        }, 0);
        
        $def(self, '$next_temp', function $$next_temp() {
          var self = this, tmp = nil;

          
          tmp = nil;
          (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;
            if (self.unique == null) self.unique = nil;

            
            tmp = "$" + (self.unique);
            self.unique = self.unique.$succ();
            if ($truthy(self['$has_local?'](tmp))) {
              return nil
            } else {
              
              Opal.brk(nil, $brk)
            };}, {$$arity: 0, $$s: self, $$brk: $brk})
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return tmp;
        }, 0);
        
        $def(self, '$queue_temp', function $$queue_temp(name) {
          var self = this;

          return self.queue['$<<'](name)
        }, 1);
        
        $def(self, '$push_while', function $$push_while() {
          var self = this, info = nil;

          
          info = $hash2([], {});
          self.while_stack.$push(info);
          return info;
        }, 0);
        
        $def(self, '$pop_while', function $$pop_while() {
          var self = this;

          return self.while_stack.$pop()
        }, 0);
        
        $def(self, '$in_while?', function $ScopeNode_in_while$ques$19() {
          var self = this;

          return self.while_stack['$empty?']()['$!']()
        }, 0);
        
        $def(self, '$uses_block!', function $ScopeNode_uses_block$excl$20() {
          var self = this;

          if (($eqeq(self.type, "iter") && ($truthy(self.parent)))) {
            return self.parent['$uses_block!']()
          } else {
            
            self.uses_block = true;
            return self['$identify!']();
          }
        }, 0);
        
        $def(self, '$identify!', function $ScopeNode_identify$excl$21(name) {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          
          
          if (name == null) name = nil;;
          if ($truthy(self.identity)) {
            return self.identity
          };
          if ($truthy(self['$valid_name?'](self.$mid()))) {
            self.identity = "$$" + (self.$mid())
          } else {
            
            name = ($truthy(($ret_or_1 = name)) ? ($ret_or_1) : ([($truthy(($ret_or_2 = self.$parent())) ? (($truthy(($ret_or_3 = self.$parent().$name())) ? ($ret_or_3) : (self.$parent().$scope_name()))) : ($ret_or_2)), self.$mid()].$compact().$join("_")));
            self.identity = self.compiler.$unique_temp(name);
          };
          return self.identity;
        }, -1);
        self.$attr_reader("identity");
        
        $def(self, '$find_parent_def', function $$find_parent_def() {
          var $a, self = this, scope = nil;

          
          scope = self;
          while ($truthy((scope = scope.$parent()))) {
            if (($truthy(scope['$def?']()) || ($truthy(scope['$lambda?']())))) {
              return scope
            }
          };
          return nil;
        }, 0);
        
        $def(self, '$super_chain', function $$super_chain() {
          var $a, self = this, chain = nil, scope = nil, defn = nil, mid = nil;

          
          $a = [[], self, "null", "null"], (chain = $a[0]), (scope = $a[1]), (defn = $a[2]), (mid = $a[3]), $a;
          while ($truthy(scope)) {
            if ($eqeq(scope.$type(), "iter")) {
              
              chain['$<<'](scope['$identify!']());
              if ($truthy(scope.$parent())) {
                scope = scope.$parent()
              };
            } else if ($truthy(["def", "defs"]['$include?'](scope.$type()))) {
              
              defn = scope['$identify!']();
              mid = "'" + (scope.$mid()) + "'";
              break;;
            } else {
              break;
            }
          };
          return [chain, defn, mid];
        }, 0);
        
        $def(self, '$uses_block?', $return_ivar("uses_block"), 0);
        
        $def(self, '$has_rescue_else?', function $ScopeNode_has_rescue_else$ques$22() {
          var self = this;

          return self.$rescue_else_sexp()['$nil?']()['$!']()
        }, 0);
        
        $def(self, '$in_rescue', function $$in_rescue(node) {
          var $yield = $$in_rescue.$$p || nil, self = this, $ret_or_1 = nil, result = nil;

          delete $$in_rescue.$$p;
          
          self.rescues = ($truthy(($ret_or_1 = self.rescues)) ? ($ret_or_1) : ([]));
          self.rescues.$push(node);
          result = Opal.yieldX($yield, []);
          self.rescues.$pop();
          return result;
        }, 1);
        
        $def(self, '$current_rescue', function $$current_rescue() {
          var self = this;

          return self.rescues.$last()
        }, 0);
        
        $def(self, '$in_resbody', function $$in_resbody() {
          var $yield = $$in_resbody.$$p || nil, self = this, result = nil;

          delete $$in_resbody.$$p;
          
          if (!($yield !== nil)) {
            return nil
          };
          self.in_resbody = true;
          result = Opal.yieldX($yield, []);
          self.in_resbody = false;
          return result;
        }, 0);
        
        $def(self, '$in_resbody?', $return_ivar("in_resbody"), 0);
        
        $def(self, '$in_ensure', function $$in_ensure() {
          var $yield = $$in_ensure.$$p || nil, self = this, result = nil;

          delete $$in_ensure.$$p;
          
          if (!($yield !== nil)) {
            return nil
          };
          self.in_ensure = true;
          result = Opal.yieldX($yield, []);
          self.in_ensure = false;
          return result;
        }, 0);
        
        $def(self, '$in_ensure?', $return_ivar("in_ensure"), 0);
        
        $def(self, '$gen_retry_id', function $$gen_retry_id() {
          var self = this, $ret_or_1 = nil;

          
          self.next_retry_id = ($truthy(($ret_or_1 = self.next_retry_id)) ? ($ret_or_1) : ("retry_0"));
          return (self.next_retry_id = self.next_retry_id.$succ());
        }, 0);
        
        $def(self, '$accepts_using?', function $ScopeNode_accepts_using$ques$23() {
          var self = this;

          return [$$('TopNode'), $$('ModuleNode'), $$('ClassNode'), $$('IterNode')]['$include?'](self.$class())
        }, 0);
        
        $def(self, '$collect_refinements_temps', function $$collect_refinements_temps(temps) {
          var self = this;

          
          
          if (temps == null) temps = [];;
          if ($truthy(self.refinements_temp)) {
            temps['$<<'](self.refinements_temp)
          };
          if ($truthy(self.$parent())) {
            return self.$parent().$collect_refinements_temps(temps)
          };
          return temps;
        }, -1);
        
        $def(self, '$new_refinements_temp', function $$new_refinements_temp() {
          var self = this, var$ = nil;

          
          var$ = self.$compiler().$unique_temp("$refn");
          self.$add_scope_local(var$);
          return var$;
        }, 0);
        
        $def(self, '$refinements_temp', function $$refinements_temp() {
          var $a, self = this, prev = nil, curr = nil;

          
          $a = [self.refinements_temp, self.$new_refinements_temp()], (prev = $a[0]), (curr = $a[1]), $a;
          self.refinements_temp = curr;
          return [prev, curr];
        }, 0);
        
        $def(self, '$self', function $$self() {
          var self = this;

          
          self.define_self = true;
          return "self";
        }, 0);
        
        $def(self, '$nesting', function $$nesting() {
          var self = this;

          
          self.define_nesting = true;
          return "$nesting";
        }, 0);
        
        $def(self, '$relative_access', function $$relative_access() {
          var self = this;

          
          self.define_relative_access = (self.define_nesting = true);
          return "$$";
        }, 0);
        
        $def(self, '$prepare_block', function $$prepare_block(block_name) {
          var self = this, scope_name = nil;

          
          
          if (block_name == null) block_name = nil;;
          scope_name = self.$scope().$identity();
          if ($truthy(block_name)) {
            self['$block_name='](block_name)
          };
          self.$add_temp("" + (self.$block_name()) + " = " + (scope_name) + ".$$p || nil");
          if ($truthy(self.block_prepared)) {
            return nil
          } else {
            
            self.$line("delete " + (scope_name) + ".$$p;");
            return (self.block_prepared = true);
          };
        }, -1);
        return self.$attr_accessor("await_encountered");
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/module"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $send = Opal.send, $rb_plus = Opal.rb_plus, $def = Opal.def;

  Opal.add_stubs('require,handle,children,name_and_base,helper,nil?,body,stmt?,unshift,line,in_scope,name=,scope,compile_body,await_encountered,await_encountered=,parent,+,nesting,private,cid,expr,stmt,returns,compiler,empty_line,add_temp,to_vars');
  
  self.$require("opal/nodes/scope");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ModuleNode');

        var $proto = self.$$prototype;

        $proto.define_nesting = $proto.define_relative_access = nil;
        
        self.$handle("module");
        self.$children("cid", "body");
        
        $def(self, '$compile', function $$compile() {
          var $a, $b, self = this, name = nil, base = nil, await_begin = nil, await_end = nil, async = nil;

          
          $b = self.$name_and_base(), $a = $to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (base = ($a[1] == null ? nil : $a[1])), $b;
          self.$helper("module");
          if ($truthy(self.$body()['$nil?']())) {
            if ($truthy(self['$stmt?']())) {
              return self.$unshift("$module(", base, ", '" + (name) + "')")
            } else {
              return self.$unshift("($module(", base, ", '" + (name) + "'), nil)")
            }
          } else {
            
            self.$line("  var self = $module($base, '" + (name) + "');");
            $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

              
              self.$scope()['$name='](name);
              return self.$compile_body();}, {$$arity: 0, $$s: self});
            if ($truthy(self.$await_encountered())) {
              
              await_begin = "(await ";
              await_end = ")";
              async = "async ";
              self.$parent()['$await_encountered='](true);
            } else {
              $a = ["", "", ""], (await_begin = $a[0]), (await_end = $a[1]), (async = $a[2]), $a
            };
            self.$unshift("" + (await_begin) + "(" + (async) + "function($base" + (($truthy(self.define_nesting) ? (", $parent_nesting") : nil)) + ") {");
            return self.$line("})(", base, "" + (($truthy(self.define_nesting) ? ($rb_plus(", ", self.$scope().$nesting())) : nil)) + ")" + (await_end));
          };
        }, 0);
        self.$private();
        
        $def(self, '$name_and_base', function $$name_and_base() {
          var $a, $b, self = this, base = nil, name = nil;

          
          $b = self.$cid().$children(), $a = $to_ary($b), (base = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy(base['$nil?']())) {
            return [name, "" + (self.$scope().$nesting()) + "[0]"]
          } else {
            return [name, self.$expr(base)]
          };
        }, 0);
        return $def(self, '$compile_body', function $$compile_body() {
          var self = this, body_code = nil;

          
          body_code = self.$stmt(self.$compiler().$returns(self.$body()));
          self.$empty_line();
          if ($truthy(self.define_nesting)) {
            self.$add_temp("$nesting = [self].concat($parent_nesting)")
          };
          if ($truthy(self.define_relative_access)) {
            self.$add_temp("$$ = Opal.$r($nesting)")
          };
          self.$line(self.$scope().$to_vars());
          return self.$line(body_code);
        }, 0);
      })($nesting[0], $$('ScopeNode'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/class"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $send = Opal.send, $rb_plus = Opal.rb_plus, $def = Opal.def;

  Opal.add_stubs('require,handle,children,name_and_base,helper,nil?,body,stmt?,unshift,super_code,line,in_scope,name=,scope,compile_body,await_encountered,await_encountered=,parent,+,nesting,sup,expr');
  
  self.$require("opal/nodes/module");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ClassNode');

        var $proto = self.$$prototype;

        $proto.define_nesting = nil;
        
        self.$handle("class");
        self.$children("cid", "sup", "body");
        
        $def(self, '$compile', function $$compile() {
          var $a, $b, self = this, name = nil, base = nil, await_begin = nil, await_end = nil, async = nil;

          
          $b = self.$name_and_base(), $a = $to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (base = ($a[1] == null ? nil : $a[1])), $b;
          self.$helper("klass");
          if ($truthy(self.$body()['$nil?']())) {
            if ($truthy(self['$stmt?']())) {
              return self.$unshift("$klass(", base, ", ", self.$super_code(), ", '" + (name) + "')")
            } else {
              return self.$unshift("($klass(", base, ", ", self.$super_code(), ", '" + (name) + "'), nil)")
            }
          } else {
            
            self.$line("  var self = $klass($base, $super, '" + (name) + "');");
            $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

              
              self.$scope()['$name='](name);
              return self.$compile_body();}, {$$arity: 0, $$s: self});
            if ($truthy(self.$await_encountered())) {
              
              await_begin = "(await ";
              await_end = ")";
              async = "async ";
              self.$parent()['$await_encountered='](true);
            } else {
              $a = ["", "", ""], (await_begin = $a[0]), (await_end = $a[1]), (async = $a[2]), $a
            };
            self.$unshift("" + (await_begin) + "(" + (async) + "function($base, $super" + (($truthy(self.define_nesting) ? (", $parent_nesting") : nil)) + ") {");
            return self.$line("})(", base, ", ", self.$super_code(), "" + (($truthy(self.define_nesting) ? ($rb_plus(", ", self.$scope().$nesting())) : nil)) + ")" + (await_end));
          };
        }, 0);
        return $def(self, '$super_code', function $$super_code() {
          var self = this;

          if ($truthy(self.$sup())) {
            return self.$expr(self.$sup())
          } else {
            return "null"
          }
        }, 0);
      })($nesting[0], $$('ModuleNode'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/singleton_class"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $def = Opal.def;

  Opal.add_stubs('require,handle,children,push,in_scope,stmt,returns,compiler,body,add_temp,line,to_vars,scope,recv,object,nesting');
  
  self.$require("opal/nodes/scope");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'SingletonClassNode');

        
        
        self.$handle("sclass");
        self.$children("object", "body");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push("(function(self, $parent_nesting) {");
          $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s, body_stmt = nil;
            if (self.define_nesting == null) self.define_nesting = nil;
            if (self.define_relative_access == null) self.define_relative_access = nil;

            
            body_stmt = self.$stmt(self.$compiler().$returns(self.$body()));
            if ($truthy(self.define_nesting)) {
              self.$add_temp("$nesting = [self].concat($parent_nesting)")
            };
            if ($truthy(self.define_relative_access)) {
              self.$add_temp("$$ = Opal.$r($nesting)")
            };
            self.$line(self.$scope().$to_vars());
            return self.$line(body_stmt);}, {$$arity: 0, $$s: self});
          return self.$line("})(Opal.get_singleton_class(", self.$recv(self.$object()), "), " + (self.$scope().$nesting()) + ")");
        }, 0);
      })($nesting[0], $$('ScopeNode'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/arg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,add_arg,scope,name,push,to_s');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ArgNode');

          
          
          self.$handle("arg");
          self.$children("name");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$scope().$add_arg(self.$name());
            return self.$push(self.$name().$to_s());
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/arity_check"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $rb_minus = Opal.rb_minus, $not = Opal.not, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $send = Opal.send;

  Opal.add_stubs('require,handle,children,new,args_node,args,optargs,restarg,postargs,kwargs,kwoptargs,kwrestarg,kwnilarg,arity=,scope,arity,arity_check?,compiler,empty?,arity_checks,helper,inspect,to_s,mid,line,push,join,compact,size,all_args,-,!,-@,<,+,>,<<,has_only_optional_kwargs?,any?,negative_arity,positive_arity,select,include?,type,has_required_kwargs?,all?,==,def?,class_scope?,top?,parent,class?,name,module?,identity');
  
  self.$require("opal/nodes/base");
  self.$require("opal/rewriters/arguments");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ArityCheckNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.kwargs = $proto.kwoptargs = $proto.kwrestarg = $proto.all_args = $proto.args = $proto.optargs = $proto.restarg = $proto.postargs = $proto.arity_checks = nil;
        
        self.$handle("arity_check");
        self.$children("args_node");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this, arguments$ = nil;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          arguments$ = $$$($$('Rewriters'), 'Arguments').$new(self.$args_node().$children());
          self.args = arguments$.$args();
          self.optargs = arguments$.$optargs();
          self.restarg = arguments$.$restarg();
          self.postargs = arguments$.$postargs();
          self.kwargs = arguments$.$kwargs();
          self.kwoptargs = arguments$.$kwoptargs();
          self.kwrestarg = arguments$.$kwrestarg();
          return (self.kwnilarg = arguments$.$kwnilarg());
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this, meth = nil;

          
          self.$scope()['$arity='](self.$arity());
          if (!$truthy(self.$compiler()['$arity_check?']())) {
            return nil
          };
          if ($truthy(self.$arity_checks()['$empty?']())) {
            return nil
          } else {
            
            self.$helper("ac");
            meth = self.$scope().$mid().$to_s().$inspect();
            self.$line("var $arity = arguments.length;");
            return self.$push(" if (" + (self.$arity_checks().$join(" || ")) + ") { $ac($arity, " + (self.$arity()) + ", this, " + (meth) + "); }");
          };
        }, 0);
        
        $def(self, '$kwargs', function $$kwargs() {
          var self = this;

          return [].concat($to_a(self.kwargs)).concat($to_a(self.kwoptargs)).concat([self.kwrestarg]).$compact()
        }, 0);
        
        $def(self, '$all_args', function $$all_args() {
          var self = this, $ret_or_1 = nil;

          return (self.all_args = ($truthy(($ret_or_1 = self.all_args)) ? ($ret_or_1) : ([].concat($to_a(self.args)).concat($to_a(self.optargs)).concat([self.restarg]).concat($to_a(self.postargs)).concat($to_a(self.$kwargs())).$compact())))
        }, 0);
        
        $def(self, '$arity_checks', function $$arity_checks() {
          var $a, self = this, arity = nil, min_arity = nil, max_arity = nil;

          
          if ($truthy((($a = self['arity_checks'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
            return self.arity_checks
          };
          arity = self.$all_args().$size();
          arity = $rb_minus(arity, self.optargs.$size());
          if ($truthy(self.restarg)) {
            arity = $rb_minus(arity, 1)
          };
          arity = $rb_minus(arity, self.$kwargs().$size());
          if ((($not(self.optargs['$empty?']()) || ($not(self.$kwargs()['$empty?']()))) || ($truthy(self.restarg)))) {
            arity = $rb_minus(arity['$-@'](), 1)
          };
          self.arity_checks = [];
          if ($truthy($rb_lt(arity, 0))) {
            
            min_arity = $rb_plus(arity, 1)['$-@']();
            max_arity = self.$all_args().$size();
            if ($truthy($rb_gt(min_arity, 0))) {
              self.arity_checks['$<<']("$arity < " + (min_arity))
            };
            if (!$truthy(self.restarg)) {
              self.arity_checks['$<<']("$arity > " + (max_arity))
            };
          } else {
            self.arity_checks['$<<']("$arity !== " + (arity))
          };
          return self.arity_checks;
        }, 0);
        
        $def(self, '$arity', function $$arity() {
          var self = this;

          if ((($truthy(self.restarg) || ($truthy(self.optargs['$any?']()))) || ($truthy(self['$has_only_optional_kwargs?']())))) {
            return self.$negative_arity()
          } else {
            return self.$positive_arity()
          }
        }, 0);
        
        $def(self, '$negative_arity', function $$negative_arity() {
          var self = this, required_plain_args = nil, result = nil;

          
          required_plain_args = $send(self.$all_args(), 'select', [], function $$1(arg){
            
            
            if (arg == null) arg = nil;;
            return ["arg", "mlhs"]['$include?'](arg.$type());}, 1);
          result = required_plain_args.$size();
          if ($truthy(self['$has_required_kwargs?']())) {
            result = $rb_plus(result, 1)
          };
          result = $rb_minus(result['$-@'](), 1);
          return result;
        }, 0);
        
        $def(self, '$positive_arity', function $$positive_arity() {
          var self = this, result = nil;

          
          result = self.$all_args().$size();
          result = $rb_minus(result, self.$kwargs().$size());
          if ($truthy(self.$kwargs()['$any?']())) {
            result = $rb_plus(result, 1)
          };
          return result;
        }, 0);
        
        $def(self, '$has_only_optional_kwargs?', function $ArityCheckNode_has_only_optional_kwargs$ques$2() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$kwargs()['$any?']()))) {
            return $send(self.$kwargs(), 'all?', [], function $$3(arg){
              
              
              if (arg == null) arg = nil;;
              return ["kwoptarg", "kwrestarg"]['$include?'](arg.$type());}, 1)
          } else {
            return $ret_or_1
          }
        }, 0);
        return $def(self, '$has_required_kwargs?', function $ArityCheckNode_has_required_kwargs$ques$4() {
          var self = this;

          return $send(self.$kwargs(), 'any?', [], function $$5(arg){
            
            
            if (arg == null) arg = nil;;
            return arg.$type()['$==']("kwarg");}, 1)
        }, 0);
      })($nesting[0], $$('Base'), $nesting);
      return (function($base, $super) {
        var self = $klass($base, $super, 'IterArityCheckNode');

        
        
        self.$handle("iter_arity_check");
        return $def(self, '$compile', function $$compile() {
          var $a, self = this, parent_scope = nil, $ret_or_1 = nil, $ret_or_2 = nil, context = nil, identity = nil;

          
          self.$scope()['$arity='](self.$arity());
          if (!$truthy(self.$compiler()['$arity_check?']())) {
            return nil
          };
          if ($truthy(self.$arity_checks()['$empty?']())) {
            return nil
          } else {
            
            parent_scope = self.$scope();
            while (!($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = parent_scope['$def?']())) ? ($ret_or_2) : (parent_scope['$class_scope?']())))) ? ($ret_or_1) : (parent_scope['$top?']()))))) {
              parent_scope = parent_scope.$parent()
            };
            context = ($truthy(parent_scope['$top?']()) ? ("'<main>'") : ($truthy(parent_scope['$def?']()) ? ("'" + (parent_scope.$mid()) + "'") : ($truthy(parent_scope['$class?']()) ? ("'<class:" + (parent_scope.$name()) + ">'") : ($truthy(parent_scope['$module?']()) ? ("'<module:" + (parent_scope.$name()) + ">'") : nil))));
            identity = self.$scope().$identity();
            self.$line("if (" + (identity) + ".$$is_lambda || " + (identity) + ".$$define_meth) {");
            self.$line("  var $arity = arguments.length;");
            self.$line("  if (" + (self.$arity_checks().$join(" || ")) + ") { Opal.block_ac($arity, " + (self.$arity()) + ", " + (context) + "); }");
            return self.$line("}");
          };
        }, 0);
      })($nesting[0], $$('ArityCheckNode'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/ensure_kwargs_are_kwargs"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,helper,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'EnsureKwargsAreKwargs');

          
          
          self.$handle("ensure_kwargs_are_kwargs");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$helper("hash2");
            self.$line("if ($kwargs == null) {");
            self.$line("  $kwargs = $hash2([], {});");
            self.$line("} else if (!$kwargs.$$is_hash) {");
            self.$line("  throw Opal.ArgumentError.$new('expected kwargs');");
            return self.$line("}");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_block_arg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,uses_block!,scope,add_arg,name,prepare_block');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractBlockarg');

          
          
          self.$handle("extract_blockarg");
          self.$children("name");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$scope()['$uses_block!']();
            self.$scope().$add_arg(self.$name());
            return self.$scope().$prepare_block(self.$name());
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_kwarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,[],meta,<<,used_kwargs,scope,add_temp,lvar_name,line,inspect,to_s');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractKwarg');

          var $proto = self.$$prototype;

          $proto.sexp = nil;
          
          self.$handle("extract_kwarg");
          self.$children("lvar_name");
          return $def(self, '$compile', function $$compile() {
            var self = this, key_name = nil;

            
            key_name = self.sexp.$meta()['$[]']("arg_name");
            self.$scope().$used_kwargs()['$<<'](key_name);
            self.$add_temp(self.$lvar_name());
            self.$line("if (!Opal.hasOwnProperty.call($kwargs.$$smap, '" + (key_name) + "')) {");
            self.$line("  throw Opal.ArgumentError.$new('missing keyword: " + (key_name) + "');");
            self.$line("}");
            return self.$line("" + (self.$lvar_name()) + " = $kwargs.$$smap[" + (key_name.$to_s().$inspect()) + "];");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_kwargs"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,add_temp,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractKwargs');

          
          
          self.$handle("extract_kwargs");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$add_temp("$kwargs");
            return self.$line("$kwargs = Opal.extract_kwargs($post_args)");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_kwoptarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,children,[],meta,<<,used_kwargs,scope,add_temp,lvar_name,line,inspect,to_s,==,default_value,expr');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractKwoptarg');

          var $proto = self.$$prototype;

          $proto.sexp = nil;
          
          self.$handle("extract_kwoptarg");
          self.$children("lvar_name", "default_value");
          return $def(self, '$compile', function $$compile() {
            var self = this, key_name = nil;

            
            key_name = self.sexp.$meta()['$[]']("arg_name");
            self.$scope().$used_kwargs()['$<<'](key_name);
            self.$add_temp(self.$lvar_name());
            self.$line("" + (self.$lvar_name()) + " = $kwargs.$$smap[" + (key_name.$to_s().$inspect()) + "];");
            if ($eqeq(self.$default_value().$children()['$[]'](1), "undefined")) {
              return nil
            };
            return self.$line("if (" + (self.$lvar_name()) + " == null) " + (self.$lvar_name()) + " = ", self.$expr(self.$default_value()));
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_kwrestarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send;

  Opal.add_stubs('require,handle,children,name,add_temp,line,used_kwargs,map,scope,join');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractKwrestarg');

          
          
          self.$handle("extract_kwrestarg");
          self.$children("name");
          
          $def(self, '$compile', function $$compile() {
            var self = this, name = nil, $ret_or_1 = nil;

            
            name = ($truthy(($ret_or_1 = self.$name())) ? ($ret_or_1) : ("$kw_rest_arg"));
            self.$add_temp(name);
            return self.$line("" + (name) + " = Opal.kwrestargs($kwargs, " + (self.$used_kwargs()) + ");");
          }, 0);
          return $def(self, '$used_kwargs', function $$used_kwargs() {
            var self = this, args = nil;

            
            args = $send(self.$scope().$used_kwargs(), 'map', [], function $$1(arg_name){
              
              
              if (arg_name == null) arg_name = nil;;
              return "'" + (arg_name) + "': true";}, 1);
            return "{" + (args.$join(",")) + "}";
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_optarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,children,==,[],default_value,line,name,expr');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractOptargNode');

          
          
          self.$handle("extract_optarg");
          self.$children("name", "default_value");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            if ($eqeq(self.$default_value().$children()['$[]'](1), "undefined")) {
              return nil
            };
            return self.$line("if (" + (self.$name()) + " == null) " + (self.$name()) + " = ", self.$expr(self.$default_value()), ";");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_post_arg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,add_temp,name,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractPostArg');

          
          
          self.$handle("extract_post_arg");
          self.$children("name");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$add_temp(self.$name());
            self.$line("" + (self.$name()) + " = $post_args.shift();");
            return self.$line("if (" + (self.$name()) + " == null) " + (self.$name()) + " = nil;");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_post_optarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,children,add_temp,name,line,args_to_keep,==,[],default_value,expr');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractPostOptarg');

          
          
          self.$handle("extract_post_optarg");
          self.$children("name", "default_value", "args_to_keep");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$add_temp(self.$name());
            self.$line("if ($post_args.length > " + (self.$args_to_keep()) + ") " + (self.$name()) + " = $post_args.shift();");
            if ($eqeq(self.$default_value().$children()['$[]'](1), "undefined")) {
              return nil
            };
            return self.$line("if (" + (self.$name()) + " == null) " + (self.$name()) + " = ", self.$expr(self.$default_value()), ";");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/extract_restarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,children,name,add_temp,==,args_to_keep,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'ExtractRestarg');

          
          
          self.$handle("extract_restarg");
          self.$children("name", "args_to_keep");
          return $def(self, '$compile', function $$compile() {
            var self = this, name = nil, $ret_or_1 = nil;

            
            name = ($truthy(($ret_or_1 = self.$name())) ? ($ret_or_1) : ("$rest_arg"));
            self.$add_temp(name);
            if ($eqeq(self.$args_to_keep(), 0)) {
              return self.$line("" + (name) + " = $post_args;")
            } else {
              return self.$line("" + (name) + " = $post_args.splice(0, $post_args.length - " + (self.$args_to_keep()) + ");")
            };
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/fake_arg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,next_temp,scope,add_arg,push');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'FakeArgNode');

          
          
          self.$handle("fake_arg");
          return $def(self, '$compile', function $$compile() {
            var self = this, name = nil;

            
            name = self.$scope().$next_temp();
            self.$scope().$add_arg(name);
            return self.$push(name);
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/initialize_iterarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,line,name');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'InitializeIterarg');

          
          
          self.$handle("initialize_iter_arg");
          self.$children("name");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            return self.$line("if (" + (self.$name()) + " == null) " + (self.$name()) + " = nil;")
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/initialize_shadowarg"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,<<,locals,scope,name,add_arg,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'InitializeShadowarg');

          
          
          self.$handle("initialize_shadowarg");
          self.$children("name");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$scope().$locals()['$<<'](self.$name());
            self.$scope().$add_arg(self.$name());
            return self.$line("" + (self.$name()) + " = nil;");
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args/parameters"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $return_val = Opal.return_val;

  Opal.add_stubs('children,map,public_send,type,join,compact,==');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Parameters');

          var $proto = self.$$prototype;

          $proto.args = nil;
          
          
          $def(self, '$initialize', function $$initialize(args) {
            var self = this;

            return (self.args = args.$children())
          }, 1);
          
          $def(self, '$to_code', function $$to_code() {
            var self = this, stringified_parameters = nil;

            
            stringified_parameters = $send(self.args, 'map', [], function $$1(arg){var self = $$1.$$s == null ? this : $$1.$$s;

              
              
              if (arg == null) arg = nil;;
              return $send(self, 'public_send', ["on_" + (arg.$type())].concat($to_a(arg)));}, {$$arity: 1, $$s: self});
            return "[" + (stringified_parameters.$compact().$join(", ")) + "]";
          }, 0);
          
          $def(self, '$on_arg', function $$on_arg(arg_name) {
            
            return "['req', '" + (arg_name) + "']"
          }, 1);
          
          $def(self, '$on_mlhs', function $$on_mlhs($a) {
            var $post_args, $rest_arg;

            
            
            $post_args = Opal.slice.call(arguments);
            
            $rest_arg = $post_args;;
            return "['req']";
          }, -1);
          
          $def(self, '$on_optarg', function $$on_optarg(arg_name, _default_value) {
            
            return "['opt', '" + (arg_name) + "']"
          }, 2);
          
          $def(self, '$on_restarg', function $$on_restarg(arg_name) {
            
            
            
            if (arg_name == null) arg_name = nil;;
            if ($truthy(arg_name)) {
              
              if ($eqeq(arg_name, "fwd_rest_arg")) {
                arg_name = "*"
              };
              return "['rest', '" + (arg_name) + "']";
            } else {
              return "['rest']"
            };
          }, -1);
          
          $def(self, '$on_kwarg', function $$on_kwarg(arg_name) {
            
            return "['keyreq', '" + (arg_name) + "']"
          }, 1);
          
          $def(self, '$on_kwoptarg', function $$on_kwoptarg(arg_name, _default_value) {
            
            return "['key', '" + (arg_name) + "']"
          }, 2);
          
          $def(self, '$on_kwrestarg', function $$on_kwrestarg(arg_name) {
            
            
            
            if (arg_name == null) arg_name = nil;;
            if ($truthy(arg_name)) {
              return "['keyrest', '" + (arg_name) + "']"
            } else {
              return "['keyrest']"
            };
          }, -1);
          
          $def(self, '$on_blockarg', function $$on_blockarg(arg_name) {
            
            
            if ($eqeq(arg_name, "fwd_block_arg")) {
              arg_name = "&"
            };
            return "['block', '" + (arg_name) + "']";
          }, 1);
          
          $def(self, '$on_kwnilarg', $return_val("['nokey']"), 0);
          return $def(self, '$on_shadowarg', $return_val(nil), 0);
        })($nesting[0], null)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/nodes/args/prepare_post_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,children,add_temp,==,offset,line');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Args');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'PreparePostArgs');

          
          
          self.$handle("prepare_post_args");
          self.$children("offset");
          return $def(self, '$compile', function $$compile() {
            var self = this;

            
            self.$add_temp("$post_args");
            if ($eqeq(self.$offset(), 0)) {
              return self.$line("$post_args = Opal.slice.call(arguments)")
            } else {
              return self.$line("$post_args = Opal.slice.call(arguments, " + (self.$offset()) + ")")
            };
          }, 0);
        })($nesting[0], $$('Base'))
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $def = Opal.def;

  Opal.add_stubs('require,handle,each_with_index,children,multiple_underscore?,[],[]=,+,>,s,type,!=,push,process,==,count,start_with?,to_s,first');
  
  self.$require("opal/nodes/base");
  self.$require("opal/nodes/args/arg");
  self.$require("opal/nodes/args/arity_check");
  self.$require("opal/nodes/args/ensure_kwargs_are_kwargs");
  self.$require("opal/nodes/args/extract_block_arg");
  self.$require("opal/nodes/args/extract_kwarg");
  self.$require("opal/nodes/args/extract_kwargs");
  self.$require("opal/nodes/args/extract_kwoptarg");
  self.$require("opal/nodes/args/extract_kwrestarg");
  self.$require("opal/nodes/args/extract_optarg");
  self.$require("opal/nodes/args/extract_post_arg");
  self.$require("opal/nodes/args/extract_post_optarg");
  self.$require("opal/nodes/args/extract_restarg");
  self.$require("opal/nodes/args/fake_arg");
  self.$require("opal/nodes/args/initialize_iterarg");
  self.$require("opal/nodes/args/initialize_shadowarg");
  self.$require("opal/nodes/args/parameters");
  self.$require("opal/nodes/args/prepare_post_args");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ArgsNode');

        
        
        self.$handle("args");
        
        $def(self, '$compile', function $$compile() {
          var self = this, same_arg_counter = nil;

          
          same_arg_counter = $hash2([], {});
          return $send(self.$children(), 'each_with_index', [], function $$1(arg, idx){var self = $$1.$$s == null ? this : $$1.$$s, $ret_or_1 = nil;

            
            
            if (arg == null) arg = nil;;
            
            if (idx == null) idx = nil;;
            if ($truthy(self['$multiple_underscore?'](arg))) {
              
              if ($truthy(($ret_or_1 = same_arg_counter['$[]'](arg)))) {
                $ret_or_1
              } else {
                same_arg_counter['$[]='](arg, 0)
              };
              same_arg_counter['$[]='](arg, $rb_plus(same_arg_counter['$[]'](arg), 1));
              if ($truthy($rb_gt(same_arg_counter['$[]'](arg), 1))) {
                arg = self.$s(arg.$type(), "" + (arg.$children()['$[]'](0)) + "_$" + (same_arg_counter['$[]'](arg)))
              };
            };
            if ($neqeq(idx, 0)) {
              self.$push(", ")
            };
            return self.$push(self.$process(arg));}, {$$arity: 2, $$s: self});
        }, 0);
        return $def(self, '$multiple_underscore?', function $ArgsNode_multiple_underscore$ques$2(arg) {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = arg.$type()['$==']("arg"))) ? (arg.$children().$count()['$=='](1)) : ($ret_or_3)))) ? (arg.$children().$first().$to_s()['$start_with?']("_")) : ($ret_or_2))))) {
            return $rb_gt(self.$children().$count(arg), 1)
          } else {
            return $ret_or_1
          }
        }, 1);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/node_with_args/shortcuts"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $def = Opal.def, $hash2 = Opal.hash2, $truthy = Opal.truthy, $defs = Opal.defs, $eqeq = Opal.eqeq, $lambda = Opal.lambda, $range = Opal.range;

  Opal.add_stubs('new,instance_exec,to_proc,when,helper,name,transform,[],[]=,<<,select,include?,for,arity_check?,compiler,compile_body,is_a?,each,shortcuts_for,match?,==,mid,warn,compile,define_shortcut,type,stmts,push,simple_value?,expr,to_sym,to_s,first,children,updated,length,inline_args,last');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeWithArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'Shortcut', $send($$('Struct'), 'new', ["name", "for", "when", "transform"], function $NodeWithArgs$1(){var self = $NodeWithArgs$1.$$s == null ? this : $NodeWithArgs$1.$$s;

          
          
          $def(self, '$match?', function $match$ques$2(node) {
            var self = this;

            return $send(node, 'instance_exec', [], self.$when().$to_proc())
          }, 1);
          return $def(self, '$compile', function $$compile(node) {
            var self = this;

            
            node.$helper(self.$name());
            return $send(node, 'instance_exec', [], self.$transform().$to_proc());
          }, 1);}, {$$arity: 0, $$s: self}));
        self.shortcuts = [];
        self.shortcuts_for = $hash2([], {});
        $defs(self, '$define_shortcut', function $$define_shortcut(name, $kwargs) {
          var block = $$define_shortcut.$$p || nil, kwargs, self = this, $ret_or_1 = nil;
          if (self.shortcuts == null) self.shortcuts = nil;

          delete $$define_shortcut.$$p;
          
          ;
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          kwargs = Opal.kwrestargs($kwargs, {});;
          if ($truthy(($ret_or_1 = kwargs['$[]']("for")))) {
            $ret_or_1
          } else {
            kwargs['$[]=']("for", "def")
          };
          return self.shortcuts['$<<']($$('Shortcut').$new(name, kwargs['$[]']("for"), kwargs['$[]']("when"), block));
        }, -2);
        $defs(self, '$shortcuts_for', function $$shortcuts_for(node_type) {
          var $a, self = this, $ret_or_1 = nil;
          if (self.shortcuts_for == null) self.shortcuts_for = nil;
          if (self.shortcuts == null) self.shortcuts = nil;

          if ($truthy(($ret_or_1 = self.shortcuts_for['$[]'](node_type)))) {
            return $ret_or_1
          } else {
            return ($a = [node_type, $send(self.shortcuts, 'select', [], function $$3(shortcut){
              
              
              if (shortcut == null) shortcut = nil;;
              return [node_type, "*"]['$include?'](shortcut.$for());}, 1)], $send(self.shortcuts_for, '[]=', $a), $a[$a.length - 1])
          }
        }, 1);
        
        $def(self, '$compile_body_or_shortcut', function $$compile_body_or_shortcut() {try {

          var self = this, node_type = nil;

          
          if ($truthy(self.$compiler()['$arity_check?']())) {
            return self.$compile_body()
          };
          node_type = ($truthy(self['$is_a?']($$('DefNode'))) ? ("def") : ("iter"));
          $send($$('NodeWithArgs').$shortcuts_for(node_type), 'each', [], function $$4(shortcut){var self = $$4.$$s == null ? this : $$4.$$s, node_desc = nil;

            
            
            if (shortcut == null) shortcut = nil;;
            if ($truthy(shortcut['$match?'](self))) {
              
              if ($truthy($$('ENV')['$[]']("OPAL_DEBUG_SHORTCUTS"))) {
                
                node_desc = ($eqeq(node_type, "def") ? ("def " + (self.$mid())) : ("iter"));
                self.$warn("* shortcut " + (shortcut.$name()) + " used for " + (node_desc));
              };
              Opal.ret(shortcut.$compile(self));
            } else {
              return nil
            };}, {$$arity: 1, $$s: self});
          return self.$compile_body();
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, 0);
        $send(self, 'define_shortcut', ["return_self", $hash2(["when"], {"when": $lambda(function $NodeWithArgs$5(){var self = $NodeWithArgs$5.$$s == null ? this : $NodeWithArgs$5.$$s;

          return self.$stmts().$type()['$==']("self")}, {$$arity: 0, $$s: self})})], function $NodeWithArgs$6(){var self = $NodeWithArgs$6.$$s == null ? this : $NodeWithArgs$6.$$s;

          return self.$push("$return_self")}, {$$arity: 0, $$s: self});
        
        $def(self, '$simple_value?', function $NodeWithArgs_simple_value$ques$7(node) {
          var self = this;

          
          
          if (node == null) node = self.$stmts();;
          return ["true", "false", "nil", "int", "float", "str", "sym"]['$include?'](node.$type());
        }, -1);
        $send(self, 'define_shortcut', ["return_val", $hash2(["for", "when"], {"for": "*", "when": $lambda(function $NodeWithArgs$8(){var self = $NodeWithArgs$8.$$s == null ? this : $NodeWithArgs$8.$$s;

          return self['$simple_value?']()}, {$$arity: 0, $$s: self})})], function $NodeWithArgs$9(){var self = $NodeWithArgs$9.$$s == null ? this : $NodeWithArgs$9.$$s;

          return self.$push("$return_val(", self.$expr(self.$stmts()), ")")}, {$$arity: 0, $$s: self});
        $send(self, 'define_shortcut', ["return_ivar", $hash2(["when"], {"when": $lambda(function $NodeWithArgs$10(){var self = $NodeWithArgs$10.$$s == null ? this : $NodeWithArgs$10.$$s;

          return self.$stmts().$type()['$==']("ivar")}, {$$arity: 0, $$s: self})})], function $NodeWithArgs$11(){var self = $NodeWithArgs$11.$$s == null ? this : $NodeWithArgs$11.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          return self.$push("$return_ivar(", self.$expr(self.$stmts().$updated("sym", [name])), ")");}, {$$arity: 0, $$s: self});
        $send(self, 'define_shortcut', ["assign_ivar", $hash2(["when"], {"when": $lambda(function $NodeWithArgs$12(){var self = $NodeWithArgs$12.$$s == null ? this : $NodeWithArgs$12.$$s, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$stmts().$type()['$==']("ivasgn"))) ? (self.$inline_args().$children().$length()['$=='](1)) : ($ret_or_4)))) ? (self.$inline_args().$children().$last().$type()['$==']("arg")) : ($ret_or_3)))) ? (self.$stmts().$children().$last().$type()['$==']("lvar")) : ($ret_or_2))))) {
            return self.$stmts().$children().$last().$children().$last()['$=='](self.$inline_args().$children().$last().$children().$last())
          } else {
            return $ret_or_1
          }}, {$$arity: 0, $$s: self})})], function $NodeWithArgs$13(){var self = $NodeWithArgs$13.$$s == null ? this : $NodeWithArgs$13.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          name = self.$expr(self.$stmts().$updated("sym", [name]));
          return self.$push("$assign_ivar(", name, ")");}, {$$arity: 0, $$s: self});
        return $send(self, 'define_shortcut', ["assign_ivar_val", $hash2(["when"], {"when": $lambda(function $NodeWithArgs$14(){var self = $NodeWithArgs$14.$$s == null ? this : $NodeWithArgs$14.$$s, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$stmts().$type()['$==']("ivasgn")))) {
            return self['$simple_value?'](self.$stmts().$children().$last())
          } else {
            return $ret_or_1
          }}, {$$arity: 0, $$s: self})})], function $NodeWithArgs$15(){var self = $NodeWithArgs$15.$$s == null ? this : $NodeWithArgs$15.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          name = self.$expr(self.$stmts().$updated("sym", [name]));
          return self.$push("$assign_ivar_val(", name, ", ", self.$expr(self.$stmts().$children().$last()), ")");}, {$$arity: 0, $$s: self});
      })($nesting[0], $$('ScopeNode'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/nodes/node_with_args"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy;

  Opal.add_stubs('require,attr_reader,attr_accessor,[],meta,s,original_args,push,process,arity_check_node,uses_block?,scope,prepare_block,to_code,new');
  
  self.$require("opal/nodes/scope");
  self.$require("opal/nodes/args/parameters");
  self.$require("opal/nodes/node_with_args/shortcuts");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeWithArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.sexp = nil;
        
        self.$attr_reader("used_kwargs");
        self.$attr_accessor("arity");
        self.$attr_reader("original_args");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          self.original_args = self.sexp.$meta()['$[]']("original_args");
          self.used_kwargs = [];
          return (self.arity = 0);
        }, -1);
        
        $def(self, '$arity_check_node', function $$arity_check_node() {
          var self = this;

          return self.$s("arity_check", self.$original_args())
        }, 0);
        
        $def(self, '$compile_arity_check', function $$compile_arity_check() {
          var self = this;

          return self.$push(self.$process(self.$arity_check_node()))
        }, 0);
        
        $def(self, '$compile_block_arg', function $$compile_block_arg() {
          var self = this;

          if ($truthy(self.$scope()['$uses_block?']())) {
            return self.$scope().$prepare_block()
          } else {
            return nil
          }
        }, 0);
        return $def(self, '$parameters_code', function $$parameters_code() {
          var self = this;

          return $$$($$('Args'), 'Parameters').$new(self.$original_args()).$to_code()
        }, 0);
      })($nesting[0], $$('ScopeNode'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/iter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $rb_gt = Opal.rb_gt, $def = Opal.def, $send = Opal.send;

  Opal.add_stubs('require,handle,children,lambda_definition?,scope,is_lambda!,compile_body_or_shortcut,<<,arity,self,contains_break?,arity_check?,compiler,parameters_code,has_top_level_mlhs_arg?,has_trailing_comma_in_args?,==,length,push,>,join,nesting,relative_access,in_scope,identify!,process,inline_args,compile_arity_check,stmt,returned_body,add_temp,to_vars,line,catch_return,unshift,await_encountered,block_arg,prepare_block,each,args,first,updated,stmts,returns,s,any?,original_args,type,expression,loc,source,match,new,found_break?');
  
  self.$require("opal/nodes/node_with_args");
  self.$require("opal/rewriters/break_finder");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IterNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.define_self = $proto.define_nesting = $proto.define_relative_access = $proto.sexp = nil;
        
        self.$handle("iter");
        self.$children("inline_args", "stmts");
        
        $def(self, '$compile', function $$compile() {
          var self = this, blockopts = nil;

          
          if ($truthy(self.$scope()['$lambda_definition?']())) {
            self['$is_lambda!']()
          };
          self.$compile_body_or_shortcut();
          blockopts = [];
          blockopts['$<<']("$$arity: " + (self.$arity()));
          if ($truthy(self.define_self)) {
            blockopts['$<<']("$$s: " + (self.$scope().$self()))
          };
          if ($truthy(self['$contains_break?']())) {
            blockopts['$<<']("$$brk: $brk")
          };
          if ($truthy(self.$compiler()['$arity_check?']())) {
            blockopts['$<<']("$$parameters: " + (self.$parameters_code()))
          };
          if ($truthy(self['$has_top_level_mlhs_arg?']())) {
            blockopts['$<<']("$$has_top_level_mlhs_arg: true")
          };
          if ($truthy(self['$has_trailing_comma_in_args?']())) {
            blockopts['$<<']("$$has_trailing_comma_in_args: true")
          };
          if ($eqeq(blockopts.$length(), 1)) {
            self.$push(", " + (self.$arity()))
          } else if ($truthy($rb_gt(blockopts.$length(), 1))) {
            self.$push(", {", blockopts.$join(", "), "}")
          };
          if ($truthy(self.define_nesting)) {
            self.$scope().$nesting()
          };
          if ($truthy(self.define_relative_access)) {
            return self.$scope().$relative_access()
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$compile_body', function $$compile_body() {
          var self = this, inline_params = nil, to_vars = nil, identity = nil, body_code = nil;

          
          inline_params = nil;
          to_vars = (identity = (body_code = nil));
          $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;
            if (self.define_self == null) self.define_self = nil;

            
            identity = self.$scope()['$identify!']();
            inline_params = self.$process(self.$inline_args());
            self.$compile_arity_check();
            body_code = self.$stmt(self.$returned_body());
            if ($truthy(self.define_self)) {
              self.$add_temp("self = " + (identity) + ".$$s == null ? this : " + (identity) + ".$$s")
            };
            to_vars = self.$scope().$to_vars();
            self.$line(body_code);
            if ($truthy(self.$scope().$catch_return())) {
              
              self.$unshift("try {\n");
              self.$line("} catch ($returner) { if ($returner === Opal.returner) { return $returner.$v }");
              return self.$push(" throw $returner; }");
            } else {
              return nil
            };}, {$$arity: 0, $$s: self});
          self.$unshift(to_vars);
          if ($truthy(self.$await_encountered())) {
            self.$unshift("async function " + (identity) + "(", inline_params, "){")
          } else {
            self.$unshift("function " + (identity) + "(", inline_params, "){")
          };
          return self.$push("}");
        }, 0);
        
        $def(self, '$compile_block_arg', function $$compile_block_arg() {
          var self = this;

          if ($truthy(self.$block_arg())) {
            return self.$scope().$prepare_block()
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$extract_underscore_args', function $$extract_underscore_args() {
          var self = this, valid_args = nil, caught_blank_argument = nil;

          
          valid_args = [];
          caught_blank_argument = false;
          $send(self.$args().$children(), 'each', [], function $$2(arg){var arg_name = nil;

            
            
            if (arg == null) arg = nil;;
            arg_name = arg.$children().$first();
            if ($eqeq(arg_name, "_")) {
              if ($truthy(caught_blank_argument)) {
                return nil
              } else {
                
                caught_blank_argument = true;
                return valid_args['$<<'](arg);
              }
            } else {
              return valid_args['$<<'](arg)
            };}, 1);
          return (self.sexp = self.sexp.$updated(nil, [self.$args().$updated(nil, valid_args), self.$stmts()]));
        }, 0);
        
        $def(self, '$returned_body', function $$returned_body() {
          var self = this, $ret_or_1 = nil;

          return self.$compiler().$returns(($truthy(($ret_or_1 = self.$stmts())) ? ($ret_or_1) : (self.$s("nil"))))
        }, 0);
        
        $def(self, '$has_top_level_mlhs_arg?', function $IterNode_has_top_level_mlhs_arg$ques$3() {
          var self = this;

          return $send(self.$original_args().$children(), 'any?', [], function $$4(arg){
            
            
            if (arg == null) arg = nil;;
            return arg.$type()['$==']("mlhs");}, 1)
        }, 0);
        
        $def(self, '$has_trailing_comma_in_args?', function $IterNode_has_trailing_comma_in_args$ques$5() {
          var self = this, args_source = nil;

          if (($truthy(self.$original_args().$loc()) && ($truthy(self.$original_args().$loc().$expression())))) {
            
            args_source = self.$original_args().$loc().$expression().$source();
            return args_source.$match(/,\s*\|/);
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$arity_check_node', function $$arity_check_node() {
          var self = this;

          return self.$s("iter_arity_check", self.$original_args())
        }, 0);
        return $def(self, '$contains_break?', function $IterNode_contains_break$ques$6() {
          var self = this, finder = nil;

          
          finder = $$$($$$($$('Opal'), 'Rewriters'), 'BreakFinder').$new();
          finder.$process(self.sexp);
          return finder['$found_break?']();
        }, 0);
      })($nesting[0], $$('NodeWithArgs'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/def"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $rb_gt = Opal.rb_gt, $def = Opal.def, $send = Opal.send, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('require,handle,children,compile_body_or_shortcut,<<,arity,arity_check?,compiler,parameters_code,parse_comments?,comments_code,enable_source_location?,source_location,==,length,push,>,join,wrap_with_definition,nesting,scope,relative_access,in_scope,mid=,mid,type,defs=,identify!,identity,block_name=,process,inline_args,stmt,returns,stmts,compile_block_arg,add_temp,compile_arity_check,unshift,current_indent,to_vars,line,catch_return,await_encountered,helper,wrap,self,expr?,+,map,comments,inspect,text');
  
  self.$require("opal/nodes/node_with_args");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DefNode');

        var $proto = self.$$prototype;

        $proto.define_nesting = $proto.define_relative_access = nil;
        
        self.$handle("def");
        self.$children("mid", "inline_args", "stmts");
        
        $def(self, '$compile', function $$compile() {
          var self = this, blockopts = nil;

          
          self.$compile_body_or_shortcut();
          blockopts = [];
          blockopts['$<<']("$$arity: " + (self.$arity()));
          if ($truthy(self.$compiler()['$arity_check?']())) {
            blockopts['$<<']("$$parameters: " + (self.$parameters_code()))
          };
          if ($truthy(self.$compiler()['$parse_comments?']())) {
            blockopts['$<<']("$$comments: " + (self.$comments_code()))
          };
          if ($truthy(self.$compiler()['$enable_source_location?']())) {
            blockopts['$<<']("$$source_location: " + (self.$source_location()))
          };
          if ($eqeq(blockopts.$length(), 1)) {
            self.$push(", " + (self.$arity()))
          } else if ($truthy($rb_gt(blockopts.$length(), 1))) {
            self.$push(", {", blockopts.$join(", "), "}")
          };
          self.$wrap_with_definition();
          if ($truthy(self.define_nesting)) {
            self.$scope().$nesting()
          };
          if ($truthy(self.define_relative_access)) {
            return self.$scope().$relative_access()
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$compile_body', function $$compile_body() {
          var self = this, inline_params = nil, scope_name = nil;

          
          inline_params = nil;
          scope_name = nil;
          $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s, stmt_code = nil;
            if (self.sexp == null) self.sexp = nil;
            if (self.define_self == null) self.define_self = nil;

            
            self.$scope()['$mid='](self.$mid());
            if ($eqeq(self.sexp.$type(), "defs")) {
              self.$scope()['$defs='](true)
            };
            self.$scope()['$identify!']();
            scope_name = self.$scope().$identity();
            self.$scope()['$block_name=']("$yield");
            inline_params = self.$process(self.$inline_args());
            stmt_code = self.$stmt(self.$compiler().$returns(self.$stmts()));
            self.$compile_block_arg();
            if ($truthy(self.define_self)) {
              self.$add_temp("self = this")
            };
            self.$compile_arity_check();
            self.$unshift("\n" + (self.$current_indent()), self.$scope().$to_vars());
            self.$line(stmt_code);
            if ($truthy(self.$scope().$catch_return())) {
              
              self.$unshift("try {\n");
              self.$line("} catch ($returner) { if ($returner === Opal.returner) { return $returner.$v }");
              return self.$push(" throw $returner; }");
            } else {
              return nil
            };}, {$$arity: 0, $$s: self});
          self.$unshift(") {");
          self.$unshift(inline_params);
          self.$unshift("function " + (scope_name) + "(");
          if ($truthy(self.$await_encountered())) {
            self.$unshift("async ")
          };
          return self.$line("}");
        }, 0);
        
        $def(self, '$wrap_with_definition', function $$wrap_with_definition() {
          var self = this;

          
          self.$helper("def");
          self.$wrap("$def(" + (self.$scope().$self()) + ", '$" + (self.$mid()) + "', ", ")");
          if ($truthy(self['$expr?']())) {
            return nil
          } else {
            return self.$unshift("\n" + (self.$current_indent()))
          };
        }, 0);
        return $def(self, '$comments_code', function $$comments_code() {
          var self = this;

          return $rb_plus($rb_plus("[", $send(self.$comments(), 'map', [], function $$2(comment){
            
            
            if (comment == null) comment = nil;;
            return comment.$text().$inspect();}, 1).$join(", ")), "]")
        }, 0);
      })($nesting[0], $$('NodeWithArgs'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/defs"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def;

  Opal.add_stubs('require,handle,children,helper,unshift,expr,recvr,mid,push');
  
  self.$require("opal/nodes/def");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DefsNode');

        
        
        self.$handle("defs");
        self.$children("recvr", "mid", "inline_args", "stmts");
        return $def(self, '$wrap_with_definition', function $$wrap_with_definition() {
          var self = this;

          
          self.$helper("defs");
          self.$unshift("$defs(", self.$expr(self.$recvr()), ", '$" + (self.$mid()) + "', ");
          return self.$push(")");
        }, 0);
      })($nesting[0], $$('DefNode'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/ast/matcher"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $truthy = Opal.truthy, $const_set = Opal.const_set, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $range = Opal.range;

  Opal.add_stubs('require,instance_exec,to_proc,new,match,inspect,attr_accessor,nil?,+,type,children,!=,length,all?,times,[],==,is_a?,first,===,include?,<<,captures');
  
  self.$require("ast");
  self.$require("parser/ast/node");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Matcher');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.root = $proto.captures = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          ;
          return (self.root = $send(self, 'instance_exec', [], block.$to_proc()));
        }, 0);
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children;

          
          
          $post_args = Opal.slice.call(arguments, 1);
          
          children = $post_args;;
          return $$('Node').$new(type, children);
        }, -2);
        
        $def(self, '$cap', function $$cap(capture) {
          
          return $$('Node').$new("capture", [capture])
        }, 1);
        
        $def(self, '$match', function $$match(ast) {
          var self = this, $ret_or_1 = nil;

          
          self.captures = [];
          if ($truthy(($ret_or_1 = self.root.$match(ast, self)))) {
            $ret_or_1
          } else {
            
            return false;
          };
          return self.captures;
        }, 1);
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Opal::AST::Matcher: " + (self.root.$inspect()) + ">"
        }, 0);
        self.$attr_accessor("captures");
        return $const_set($nesting[0], 'Node', $send($$('Struct'), 'new', ["type", "children"], function $Matcher$1(){var self = $Matcher$1.$$s == null ? this : $Matcher$1.$$s;

          
          
          $def(self, '$match', function $$match(ast, matcher) {
            var self = this, ast_parts = nil, self_parts = nil;

            
            if ($truthy(ast['$nil?']())) {
              return false
            };
            ast_parts = $rb_plus([ast.$type()], ast.$children());
            self_parts = $rb_plus([self.$type()], self.$children());
            if ($neqeq(ast_parts.$length(), self_parts.$length())) {
              return false
            };
            return $send(ast_parts.$length().$times(), 'all?', [], function $$2(i){var ast_elem = nil, self_elem = nil, capture = nil, res = nil, $ret_or_1 = nil;

              
              
              if (i == null) i = nil;;
              ast_elem = ast_parts['$[]'](i);
              self_elem = self_parts['$[]'](i);
              if (($truthy(self_elem['$is_a?']($$('Node'))) && ($eqeq(self_elem.$type(), "capture")))) {
                
                capture = true;
                self_elem = self_elem.$children().$first();
              };
              res = ($eqeqeq($$('Node'), ($ret_or_1 = self_elem)) ? (self_elem.$match(ast_elem, matcher)) : ($eqeqeq($$('Array'), $ret_or_1) ? (self_elem['$include?'](ast_elem)) : ($eqeqeq("*", $ret_or_1) || (self_elem['$=='](ast_elem)))));
              if ($truthy(capture)) {
                matcher.$captures()['$<<'](ast_elem)
              };
              return res;}, 1);
          }, 2);
          return $def(self, '$inspect', function $$inspect() {
            var self = this;

            if ($eqeq(self.$type(), "capture")) {
              return "{" + (self.$children().$first().$inspect()) + "}"
            } else {
              return "s(" + (self.$type().$inspect()) + ", " + (self.$children().$inspect()['$[]']($range(1, -2, false))) + ")"
            }
          }, 0);}, {$$arity: 0, $$s: self}));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/if"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $not = Opal.not, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $const_set = Opal.const_set, $to_a = Opal.to_a, $neqeq = Opal.neqeq, $hash2 = Opal.hash2, $return_val = Opal.return_val;

  Opal.add_stubs('require,handle,children,should_compile_as_simple_expression?,==,true_body,s,compile_with_binary_or,false_body,compile_with_binary_and,compile_with_ternary,could_become_switch?,compile_with_switch,compile_with_if,truthy,falsy,!,push,js_truthy,test,indent,line,stmt,type,expects_expression?,await_encountered,scope,wrap,returnify,returns,compiler,expr?,recv?,simple?,expr,[],meta,sexp,===,single_line?,strip_empty_children,all?,new,cap,match,handle_additional_switch_rules,valid_switch_body?,could_become_switch_branch?,<<,!=,[]=,merge!,compile_switch_case,include?,last,each,returning?,compile_switch_default,helper,new_temp,top_scope,excl,from,to');
  
  self.$require("opal/nodes/base");
  self.$require("opal/ast/matcher");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IfNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.switch_variable = $proto.switch_first_test = $proto.switch_additional_rules = nil;
        
        self.$handle("if");
        self.$children("test", "true_body", "false_body");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$should_compile_as_simple_expression?']())) {
            if ($eqeq(self.$true_body(), self.$s("true"))) {
              return self.$compile_with_binary_or()
            } else if ($eqeq(self.$false_body(), self.$s("false"))) {
              return self.$compile_with_binary_and()
            } else {
              return self.$compile_with_ternary()
            }
          } else if ($truthy(self['$could_become_switch?']())) {
            return self.$compile_with_switch()
          } else {
            return self.$compile_with_if()
          }
        }, 0);
        
        $def(self, '$compile_with_if', function $$compile_with_if() {
          var $a, self = this, truthy = nil, falsy = nil;

          
          truthy = self.$truthy();
          falsy = self.$falsy();
          if (($truthy(falsy) && ($not(truthy)))) {
            
            self.$push("if (!", self.$js_truthy(self.$test()), ") {");
            $a = [truthy, falsy], (falsy = $a[0]), (truthy = $a[1]), $a;
          } else {
            self.$push("if (", self.$js_truthy(self.$test()), ") {")
          };
          if ($truthy(truthy)) {
            $send(self, 'indent', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

              return self.$line(self.$stmt(truthy))}, {$$arity: 0, $$s: self})
          };
          if ($truthy(falsy)) {
            if ($eqeq(falsy.$type(), "if")) {
              self.$line("} else ", self.$stmt(falsy))
            } else {
              
              self.$line("} else {");
              $send(self, 'indent', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

                return self.$line(self.$stmt(falsy))}, {$$arity: 0, $$s: self});
              self.$line("}");
            }
          } else {
            
            self.$line("}");
            if ($truthy(self['$expects_expression?']())) {
              self.$line("return nil;")
            };
          };
          if ($truthy(self['$expects_expression?']())) {
            if ($truthy(self.$scope().$await_encountered())) {
              return self.$wrap("(await (async function() {", "})())")
            } else {
              return self.$wrap("(function() {", "})()")
            }
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$truthy', function $$truthy() {
          var self = this;

          return self.$returnify(self.$true_body())
        }, 0);
        
        $def(self, '$falsy', function $$falsy() {
          var self = this;

          return self.$returnify(self.$false_body())
        }, 0);
        
        $def(self, '$returnify', function $$returnify(body) {
          var self = this;

          if (($truthy(self['$expects_expression?']()) && ($truthy(body)))) {
            return self.$compiler().$returns(body)
          } else {
            return body
          }
        }, 1);
        
        $def(self, '$expects_expression?', function $IfNode_expects_expression$ques$3() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$expr?']()))) {
            return $ret_or_1
          } else {
            return self['$recv?']()
          }
        }, 0);
        
        $def(self, '$should_compile_as_simple_expression?', function $IfNode_should_compile_as_simple_expression$ques$4() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self['$expects_expression?']())) ? (self['$simple?'](self.$true_body())) : ($ret_or_2))))) {
            return self['$simple?'](self.$false_body())
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$compile_with_ternary', function $$compile_with_ternary() {
          var self = this, truthy = nil, falsy = nil, $ret_or_1 = nil;

          
          truthy = self.$true_body();
          falsy = self.$false_body();
          self.$push("(");
          self.$push(self.$js_truthy(self.$test()), " ? ");
          self.$push("(", self.$expr(($truthy(($ret_or_1 = truthy)) ? ($ret_or_1) : (self.$s("nil")))), ") : ");
          if (($not(falsy) || ($eqeq(falsy.$type(), "if")))) {
            self.$push(self.$expr(($truthy(($ret_or_1 = falsy)) ? ($ret_or_1) : (self.$s("nil")))))
          } else {
            self.$push("(", self.$expr(($truthy(($ret_or_1 = falsy)) ? ($ret_or_1) : (self.$s("nil")))), ")")
          };
          return self.$push(")");
        }, 0);
        
        $def(self, '$compile_with_binary_and', function $$compile_with_binary_and() {
          var self = this, truthy = nil, $ret_or_1 = nil;

          
          if ($truthy(self.$sexp().$meta()['$[]']("do_js_truthy_on_true_body"))) {
            truthy = self.$js_truthy(($truthy(($ret_or_1 = self.$true_body())) ? ($ret_or_1) : (self.$s("nil"))))
          } else {
            truthy = self.$expr(($truthy(($ret_or_1 = self.$true_body())) ? ($ret_or_1) : (self.$s("nil"))))
          };
          self.$push("(");
          self.$push(self.$js_truthy(self.$test()), " && ");
          self.$push("(", truthy, ")");
          return self.$push(")");
        }, 0);
        
        $def(self, '$compile_with_binary_or', function $$compile_with_binary_or() {
          var self = this, falsy = nil, $ret_or_1 = nil;

          
          if ($truthy(self.$sexp().$meta()['$[]']("do_js_truthy_on_false_body"))) {
            falsy = self.$js_truthy(($truthy(($ret_or_1 = self.$false_body())) ? ($ret_or_1) : (self.$s("nil"))))
          } else {
            falsy = self.$expr(($truthy(($ret_or_1 = self.$false_body())) ? ($ret_or_1) : (self.$s("nil"))))
          };
          self.$push("(");
          self.$push(self.$js_truthy(self.$test()), " || ");
          self.$push("(", falsy, ")");
          return self.$push(")");
        }, 0);
        
        $def(self, '$simple?', function $IfNode_simple$ques$5(body) {
          var self = this, $ret_or_1 = nil;

          if ($eqeqeq($$$($$('AST'), 'Node'), ($ret_or_1 = body))) {
            
            switch (body.$type()) {
              case "return":
              case "js_return":
              case "break":
              case "next":
              case "redo":
              case "retry":
                return false
              case "xstr":
                return $$('XStringNode')['$single_line?']($$('XStringNode').$strip_empty_children(body.$children()))
              default:
                return $send(body.$children(), 'all?', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s;

                  
                  
                  if (i == null) i = nil;;
                  return self['$simple?'](i);}, {$$arity: 1, $$s: self})
            }
          } else {
            return true
          }
        }, 1);
        $const_set($nesting[0], 'SWITCH_TEST_MATCH', $send($$$($$('AST'), 'Matcher'), 'new', [], function $IfNode$7(){var self = $IfNode$7.$$s == null ? this : $IfNode$7.$$s;

          return self.$s("send", self.$cap(self.$s(["float", "int", "sym", "str", "true", "false", "nil"], "*")), "===", self.$s("lvasgn", self.$cap("*"), self.$cap("*")))}, {$$arity: 0, $$s: self}));
        $const_set($nesting[0], 'SWITCH_TEST_MATCH_CONTINUED', $send($$$($$('AST'), 'Matcher'), 'new', [], function $IfNode$8(){var self = $IfNode$8.$$s == null ? this : $IfNode$8.$$s;

          return self.$s("if", self.$s("send", self.$cap(self.$s(["float", "int", "sym", "str", "true", "false", "nil"], "*")), "===", self.$s("lvasgn", self.$cap("*"), self.$cap("*"))), self.$s("true"), self.$cap("*"))}, {$$arity: 0, $$s: self}));
        $const_set($nesting[0], 'SWITCH_BRANCH_TEST_MATCH', $send($$$($$('AST'), 'Matcher'), 'new', [], function $IfNode$9(){var self = $IfNode$9.$$s == null ? this : $IfNode$9.$$s;

          return self.$s("send", self.$cap(self.$s(["float", "int", "sym", "str", "true", "false", "nil"], "*")), "===", self.$s("js_tmp", self.$cap("*")))}, {$$arity: 0, $$s: self}));
        $const_set($nesting[0], 'SWITCH_BRANCH_TEST_MATCH_CONTINUED', $send($$$($$('AST'), 'Matcher'), 'new', [], function $IfNode$10(){var self = $IfNode$10.$$s == null ? this : $IfNode$10.$$s;

          return self.$s("if", self.$s("send", self.$cap(self.$s(["float", "int", "sym", "str", "true", "false", "nil"], "*")), "===", self.$s("js_tmp", self.$cap("*"))), self.$s("true"), self.$cap("*"))}, {$$arity: 0, $$s: self}));
        
        $def(self, '$could_become_switch?', function $IfNode_could_become_switch$ques$11() {
          var $a, self = this, test_match = nil, $ret_or_1 = nil, additional_rules = nil;

          
          if ($truthy(self['$expects_expression?']())) {
            return false
          };
          if ($truthy(self.$sexp().$meta()['$[]']("switch_child"))) {
            return true
          };
          test_match = ($truthy(($ret_or_1 = $$('SWITCH_TEST_MATCH').$match(self.$test()))) ? ($ret_or_1) : ($$('SWITCH_TEST_MATCH_CONTINUED').$match(self.$test())));
          if (!$truthy(test_match)) {
            return false
          };
          $a = [].concat($to_a(test_match)), (self.switch_test = ($a[0] == null ? nil : $a[0])), (self.switch_variable = ($a[1] == null ? nil : $a[1])), (self.switch_first_test = ($a[2] == null ? nil : $a[2])), (additional_rules = ($a[3] == null ? nil : $a[3])), $a;
          additional_rules = self.$handle_additional_switch_rules(additional_rules);
          if (!$truthy(additional_rules)) {
            return false
          };
          self.switch_additional_rules = additional_rules;
          if (!$truthy(self['$valid_switch_body?'](self.$true_body()))) {
            return false
          };
          return self['$could_become_switch_branch?'](self.$false_body());
        }, 0);
        
        $def(self, '$handle_additional_switch_rules', function $$handle_additional_switch_rules(additional_rules) {
          var $a, $b, self = this, switch_additional_rules = nil, match = nil, $ret_or_1 = nil, switch_test = nil, switch_variable = nil;

          
          switch_additional_rules = [];
          while ($truthy(additional_rules)) {
            
            match = ($truthy(($ret_or_1 = $$('SWITCH_BRANCH_TEST_MATCH').$match(additional_rules))) ? ($ret_or_1) : ($$('SWITCH_BRANCH_TEST_MATCH_CONTINUED').$match(additional_rules)));
            if (!$truthy(match)) {
              return false
            };
            $b = [].concat($to_a(match)), (switch_test = ($b[0] == null ? nil : $b[0])), (switch_variable = ($b[1] == null ? nil : $b[1])), (additional_rules = ($b[2] == null ? nil : $b[2])), $b;
            if (!$eqeq(switch_variable, self.switch_variable)) {
              return false
            };
            switch_additional_rules['$<<'](switch_test);
          };
          return switch_additional_rules;
        }, 1);
        
        $def(self, '$could_become_switch_branch?', function $IfNode_could_become_switch_branch$ques$12(body) {
          var $a, self = this, test = nil, true_body = nil, false_body = nil, test_match = nil, $ret_or_1 = nil, switch_test = nil, switch_variable = nil, additional_rules = nil, switch_additional_rules = nil;

          
          if ($not(body)) {
            return true
          } else if ($neqeq(body.$type(), "if")) {
            
            if ($truthy(self['$valid_switch_body?'](body))) {
              
              body.$meta()['$[]=']("switch_default", true);
              return true;
            };
            return false;
          };
          $a = [].concat($to_a(body)), (test = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
          test_match = ($truthy(($ret_or_1 = $$('SWITCH_BRANCH_TEST_MATCH').$match(test))) ? ($ret_or_1) : ($$('SWITCH_BRANCH_TEST_MATCH_CONTINUED').$match(test)));
          if (!$truthy(test_match)) {
            if ($truthy(self['$valid_switch_body?'](body, true))) {
              
              body.$meta()['$[]=']("switch_default", true);
              return true;
            }
          };
          $a = [].concat($to_a(test_match)), (switch_test = ($a[0] == null ? nil : $a[0])), (switch_variable = ($a[1] == null ? nil : $a[1])), (additional_rules = ($a[2] == null ? nil : $a[2])), $a;
          switch_additional_rules = self.$handle_additional_switch_rules(additional_rules);
          if (!$truthy(switch_additional_rules)) {
            return false
          };
          if (!$eqeq(switch_variable, self.switch_variable)) {
            return false
          };
          if (!$truthy(self['$valid_switch_body?'](true_body))) {
            return false
          };
          if (!$truthy(self['$could_become_switch_branch?'](false_body))) {
            return false
          };
          body.$meta()['$merge!']($hash2(["switch_child", "switch_test", "switch_variable", "switch_additional_rules"], {"switch_child": true, "switch_test": switch_test, "switch_variable": self.switch_variable, "switch_additional_rules": switch_additional_rules}));
          return true;
        }, 1);
        
        $def(self, '$valid_switch_body?', function $IfNode_valid_switch_body$ques$13(body, check_variable) {
          var self = this, $ret_or_1 = nil;

          
          
          if (check_variable == null) check_variable = false;;
          if ($eqeqeq($$$($$('AST'), 'Node'), ($ret_or_1 = body))) {
            
            switch (body.$type()) {
              case "break":
              case "redo":
              case "retry":
                return false
              case "iter":
              case "while":
                return true
              default:
                return $send(body.$children(), 'all?', [], function $$14(i){var self = $$14.$$s == null ? this : $$14.$$s;

                  
                  
                  if (i == null) i = nil;;
                  return self['$valid_switch_body?'](i, check_variable);}, {$$arity: 1, $$s: self})
            }
          } else if ($eqeqeq(self.switch_variable, $ret_or_1)) {
            return check_variable['$!']()
          } else {
            return true
          };
        }, -2);
        
        $def(self, '$compile_with_switch', function $$compile_with_switch() {
          var self = this;

          if ($truthy(self.$sexp().$meta()['$[]']("switch_child"))) {
            
            self.switch_variable = self.$sexp().$meta()['$[]']("switch_variable");
            self.switch_additional_rules = self.$sexp().$meta()['$[]']("switch_additional_rules");
            return self.$compile_switch_case(self.$sexp().$meta()['$[]']("switch_test"));
          } else {
            
            self.$line("switch (", self.$expr(self.switch_first_test), ") {");
            $send(self, 'indent', [], function $$15(){var self = $$15.$$s == null ? this : $$15.$$s;
              if (self.switch_test == null) self.switch_test = nil;

              return self.$compile_switch_case(self.switch_test)}, {$$arity: 0, $$s: self});
            return self.$line("}");
          }
        }, 0);
        
        $def(self, '$returning?', function $IfNode_returning$ques$16(body) {
          var $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ["return", "js_return", "next"]['$include?'](body.$type())))) {
            return $ret_or_1
          } else {
            
            if ($truthy(($ret_or_2 = body.$type()['$==']("begin")))) {
              return ["return", "js_return", "next"]['$include?'](body.$children().$last().$type())
            } else {
              return $ret_or_2
            };
          }
        }, 1);
        
        $def(self, '$compile_switch_case', function $$compile_switch_case(test) {
          var self = this;

          
          self.$line("case ", self.$expr(test), ":");
          if ($truthy(self.switch_additional_rules)) {
            $send(self.switch_additional_rules, 'each', [], function $$17(rule){var self = $$17.$$s == null ? this : $$17.$$s;

              
              
              if (rule == null) rule = nil;;
              return self.$line("case ", self.$expr(rule), ":");}, {$$arity: 1, $$s: self})
          };
          $send(self, 'indent', [], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

            
            self.$line(self.$stmt(self.$true_body()));
            if (($not(self.$true_body()) || ($not(self['$returning?'](self.$true_body()))))) {
              return self.$line("break;")
            } else {
              return nil
            };}, {$$arity: 0, $$s: self});
          if ($truthy(self.$false_body())) {
            if ($truthy(self.$false_body().$meta()['$[]']("switch_default"))) {
              return self.$compile_switch_default()
            } else if ($truthy(self.$false_body().$meta()['$[]']("switch_child"))) {
              return self.$push(self.$stmt(self.$false_body()))
            } else {
              return nil
            }
          } else {
            return self.$push(self.$stmt(self.$s("nil")))
          };
        }, 1);
        return $def(self, '$compile_switch_default', function $$compile_switch_default() {
          var self = this;

          
          self.$line("default:");
          return $send(self, 'indent', [], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

            return self.$line(self.$stmt(self.$false_body()))}, {$$arity: 0, $$s: self});
        }, 0);
      })($nesting[0], $$('Base'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'IFlipFlop');

        
        
        self.$handle("iflipflop");
        self.$children("from", "to");
        
        $def(self, '$excl', $return_val(""), 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, fun_name = nil, ff = nil;

          
          self.$helper("truthy");
          fun_name = self.$top_scope().$new_temp();
          ff = "" + (fun_name) + ".$$ff";
          self.$push("(typeof " + (fun_name) + " === 'undefined' ? (" + (fun_name) + " = function(from, to){");
          self.$push("  if (typeof " + (ff) + " === 'undefined') " + (ff) + " = false;");
          self.$push("  var retval = " + (ff) + ";");
          self.$push("  if (!" + (ff) + ") {");
          self.$push("    " + (ff) + " = retval = $truthy(from());");
          self.$push("  }");
          self.$push("  " + (self.$excl()) + "if (" + (ff) + ") {");
          self.$push("    if ($truthy(to())) " + (ff) + " = false;");
          self.$push("  }");
          self.$push("  return retval;");
          self.$push("}) : " + (fun_name) + ")(");
          self.$push("  function() { ", self.$stmt(self.$compiler().$returns(self.$from())), " },");
          self.$push("  function() { ", self.$stmt(self.$compiler().$returns(self.$to())), " }");
          return self.$push(")");
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'EFlipFlop');

        
        
        self.$handle("eflipflop");
        return $def(self, '$excl', $return_val("else "), 0);
      })($nesting[0], $$('IFlipFlop'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/logic"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $rb_gt = Opal.rb_gt, $not = Opal.not;

  Opal.add_stubs('require,handle,in_while?,push,iter?,scope,expr_or_nil,value,error,size,children,s,first,compile_while,compile_iter,[],while_loop,stmt?,line,break_val,nil?,expr,[]=,helper,identity,==,empty_splat?,recv,>,find_parent_def,!,lambda?,def?,expr?,return_in_iter?,return_expr_in_def?,scope_to_catch_return,catch_return=,return_val,to_s');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'NextNode');

        
        
        self.$handle("next");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$in_while?']())) {
            return self.$push("continue;")
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$push("return ", self.$expr_or_nil(self.$value()), ";")
          } else {
            return self.$error("Invalid next")
          }
        }, 0);
        return $def(self, '$value', function $$value() {
          var self = this;

          
          switch (self.$children().$size()) {
            case 0:
              return self.$s("nil")
            case 1:
              return self.$children().$first()
            default:
              return $send(self, 's', ["array"].concat($to_a(self.$children())))
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'BreakNode');

        
        
        self.$handle("break");
        self.$children("value");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$in_while?']())) {
            return self.$compile_while()
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$compile_iter()
          } else {
            return self.$error("void value expression: cannot use break outside of iter/while")
          }
        }, 0);
        
        $def(self, '$compile_while', function $$compile_while() {
          var self = this;

          if ($truthy(self.$while_loop()['$[]']("closure"))) {
            return self.$push("return ", self.$expr_or_nil(self.$value()))
          } else {
            return self.$push("break;")
          }
        }, 0);
        
        $def(self, '$compile_iter', function $$compile_iter() {
          var self = this;

          
          if (!$truthy(self['$stmt?']())) {
            self.$error("break must be used as a statement")
          };
          return self.$line("Opal.brk(", self.$break_val(), ", $brk)");
        }, 0);
        return $def(self, '$break_val', function $$break_val() {
          var self = this;

          if ($truthy(self.$value()['$nil?']())) {
            return self.$expr(self.$s("nil"))
          } else {
            return self.$expr(self.$value())
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'RedoNode');

        
        
        self.$handle("redo");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$in_while?']())) {
            return self.$compile_while()
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$compile_iter()
          } else {
            return self.$push("REDO()")
          }
        }, 0);
        
        $def(self, '$compile_while', function $$compile_while() {
          var self = this;

          
          self.$while_loop()['$[]=']("use_redo", true);
          return self.$push("" + (self.$while_loop()['$[]']("redo_var")) + " = true; continue;");
        }, 0);
        return $def(self, '$compile_iter', function $$compile_iter() {
          var self = this;

          
          self.$helper("slice");
          return self.$push("return " + (self.$scope().$identity()) + ".apply(null, $slice.call(arguments))");
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'SplatNode');

        
        
        self.$handle("splat");
        self.$children("value");
        
        $def(self, '$empty_splat?', function $SplatNode_empty_splat$ques$1() {
          var self = this;

          return self.$value()['$=='](self.$s("array"))
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$empty_splat?']())) {
            return self.$push("[]")
          } else {
            
            self.$helper("to_a");
            return self.$push("$to_a(", self.$recv(self.$value()), ")");
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'ReturnNode');

        
        
        self.$handle("return");
        self.$children("value");
        
        $def(self, '$return_val', function $$return_val() {
          var self = this;

          if ($truthy(self.$value()['$nil?']())) {
            return self.$expr(self.$s("nil"))
          } else if ($truthy($rb_gt(self.$children().$size(), 1))) {
            return self.$expr($send(self, 's', ["array"].concat($to_a(self.$children()))))
          } else {
            return self.$expr(self.$value())
          }
        }, 0);
        
        $def(self, '$return_in_iter?', function $ReturnNode_return_in_iter$ques$2() {
          var self = this, parent_def = nil;

          if ((($truthy(self.$scope()['$iter?']()) && ($not(self.$scope()['$lambda?']()))) && ($truthy((parent_def = self.$scope().$find_parent_def()))))) {
            return parent_def
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$return_expr_in_def?', function $ReturnNode_return_expr_in_def$ques$3() {
          var self = this;

          if (($truthy(self['$expr?']()) && (($truthy(self.$scope()['$def?']()) || ($truthy(self.$scope()['$lambda?']())))))) {
            return self.$scope()
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$scope_to_catch_return', function $$scope_to_catch_return() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$return_in_iter?']()))) {
            return $ret_or_1
          } else {
            return self['$return_expr_in_def?']()
          }
        }, 0);
        return $def(self, '$compile', function $$compile() {
          var self = this, def_scope = nil;

          if ($truthy((def_scope = self.$scope_to_catch_return()))) {
            
            def_scope['$catch_return='](true);
            return self.$push("Opal.ret(", self.$return_val(), ")");
          } else if ($truthy(self['$stmt?']())) {
            return self.$push("return ", self.$return_val())
          } else {
            return self.$error("void value expression: cannot return as an expression")
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JSReturnNode');

        
        
        self.$handle("js_return");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push("return ");
          return self.$push(self.$expr(self.$value()));
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JSTempNode');

        
        
        self.$handle("js_tmp");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$value().$to_s())
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'BlockPassNode');

        
        
        self.$handle("block_pass");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$expr(self.$s("send", self.$value(), "to_proc", self.$s("arglist"))))
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/definitions"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $range = Opal.range, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $slice = Opal.slice, $rb_plus = Opal.rb_plus, $hash2 = Opal.hash2, $const_set = Opal.const_set;

  Opal.add_stubs('require,handle,children,each,line,self,scope,expr,type,new_name,helper,inspect,[],to_s,first,old_name,push,==,record_method_call,compiler,last,error,empty?,stmt?,compile_children,simple_children?,compile_inline_children,>,size,wrap,returned_children,await_encountered,parent,+,returns,s,process,fragment,freeze,none?,include?,map,each_with_index,reject,to_proc');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'UndefNode');

        
        
        self.$handle("undef");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return $send(self.$children(), 'each', [], function $$1(child){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (child == null) child = nil;;
            return self.$line("Opal.udef(" + (self.$scope().$self()) + ", '$' + ", self.$expr(child), ");");}, {$$arity: 1, $$s: self})
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'AliasNode');

        
        
        self.$handle("alias");
        self.$children("new_name", "old_name");
        return $def(self, '$compile', function $$compile() {
          var self = this, new_name_str = nil, old_name_str = nil;

          
          switch (self.$new_name().$type()) {
            case "gvar":
              
              self.$helper("alias_gvar");
              new_name_str = self.$new_name().$children().$first().$to_s()['$[]']($range(1, -1, false)).$inspect();
              old_name_str = self.$old_name().$children().$first().$to_s()['$[]']($range(1, -1, false)).$inspect();
              return self.$push("$alias_gvar(", new_name_str, ", ", old_name_str, ")");
            case "dsym":
            case "sym":
              
              self.$helper("alias");
              if ($eqeq(self.$old_name().$type(), "sym")) {
                self.$compiler().$record_method_call(self.$old_name().$children().$last())
              };
              return self.$push("$alias(" + (self.$scope().$self()) + ", ", self.$expr(self.$new_name()), ", ", self.$expr(self.$old_name()), ")");
            default:
              return self.$error("Opal doesn't know yet how to alias with " + (self.$new_name().$type()))
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BeginNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.level = $proto.returned_children = nil;
        
        self.$handle("begin");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          if ($truthy(self.$children()['$empty?']())) {
            return self.$push("nil")
          };
          if ($truthy(self['$stmt?']())) {
            return self.$compile_children(self.$children(), self.level)
          } else if ($truthy(self['$simple_children?']())) {
            
            self.$compile_inline_children(self.$children(), self.level);
            if ($truthy($rb_gt(self.$children().$size(), 1))) {
              return self.$wrap("(", ")")
            } else {
              return nil
            };
          } else if ($eqeq(self.$children().$size(), 1)) {
            return self.$compile_inline_children(self.$returned_children(), self.level)
          } else {
            
            self.$compile_children(self.$returned_children(), self.level);
            if ($truthy(self.$scope().$parent().$await_encountered())) {
              return self.$wrap("(await (async function() {", "})())")
            } else {
              return self.$wrap("(function() {", "})()")
            };
          };
        }, 0);
        
        $def(self, '$returned_children', function $$returned_children() {
          var $a, $b, self = this, $ret_or_1 = nil, rest = nil, last_child = nil;

          return (self.returned_children = ($truthy(($ret_or_1 = self.returned_children)) ? ($ret_or_1) : (($a = [].concat($to_a(self.$children())), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (rest = $slice.call($a, 0, $b)), (last_child = ($a[$b] == null ? nil : $a[$b])), $a, ($truthy(last_child) ? ($rb_plus(rest, [self.$compiler().$returns(last_child)])) : ([self.$s("nil")]))))))
        }, 0);
        
        $def(self, '$compile_children', function $$compile_children(children, level) {
          var self = this;

          return $send(children, 'each', [], function $$2(child){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (child == null) child = nil;;
            return self.$line(self.$process(child, level), self.$fragment(";", $hash2(["loc"], {"loc": false})));}, {$$arity: 1, $$s: self})
        }, 2);
        $const_set($nesting[0], 'COMPLEX_CHILDREN', ["while", "while_post", "until", "until_post", "js_return"].$freeze());
        
        $def(self, '$simple_children?', function $BeginNode_simple_children$ques$3() {
          var self = this;

          return $send(self.$children(), 'none?', [], function $$4(child){
            
            
            if (child == null) child = nil;;
            return $$('COMPLEX_CHILDREN')['$include?'](child.$type());}, 1)
        }, 0);
        return $def(self, '$compile_inline_children', function $$compile_inline_children(children, level) {
          var self = this, processed_children = nil;

          
          processed_children = $send(children, 'map', [], function $$5(child){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (child == null) child = nil;;
            return self.$process(child, level);}, {$$arity: 1, $$s: self});
          return $send($send(processed_children, 'reject', [], "empty?".$to_proc()), 'each_with_index', [], function $$6(child, idx){var self = $$6.$$s == null ? this : $$6.$$s;

            
            
            if (child == null) child = nil;;
            
            if (idx == null) idx = nil;;
            if (!$eqeq(idx, 0)) {
              self.$push(self.$fragment(", ", $hash2(["loc"], {"loc": false})))
            };
            return self.$push(child);}, {$$arity: 2, $$s: self});
        }, 2);
      })($nesting[0], $$('ScopeNode'), $nesting);
      return (function($base, $super) {
        var self = $klass($base, $super, 'KwBeginNode');

        
        return self.$handle("kwbegin")
      })($nesting[0], $$('BeginNode'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/yield"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def;

  Opal.add_stubs('require,find_yielding_scope,uses_block!,block_name,block_name=,yields_single_arg?,children,push,expr,first,wrap,s,uses_splat?,scope,def?,parent,!,==,size,any?,type,handle,compile_call');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'BaseYieldNode');

        
        
        
        $def(self, '$compile_call', function $$compile_call() {
          var self = this, yielding_scope = nil, $ret_or_1 = nil, block_name = nil;

          
          yielding_scope = self.$find_yielding_scope();
          yielding_scope['$uses_block!']();
          if ($truthy(($ret_or_1 = yielding_scope.$block_name()))) {
            $ret_or_1
          } else {
            yielding_scope['$block_name=']("$yield")
          };
          block_name = yielding_scope.$block_name();
          if ($truthy(self['$yields_single_arg?'](self.$children()))) {
            
            self.$push(self.$expr(self.$children().$first()));
            return self.$wrap("Opal.yield1(" + (block_name) + ", ", ")");
          } else {
            
            self.$push(self.$expr($send(self, 's', ["arglist"].concat($to_a(self.$children())))));
            if ($truthy(self['$uses_splat?'](self.$children()))) {
              return self.$wrap("Opal.yieldX(" + (block_name) + ", ", ")")
            } else {
              return self.$wrap("Opal.yieldX(" + (block_name) + ", [", "])")
            };
          };
        }, 0);
        
        $def(self, '$find_yielding_scope', function $$find_yielding_scope() {
          var $a, self = this, working = nil;

          
          working = self.$scope();
          while ($truthy(working)) {
            
            if (($truthy(working.$block_name()) || ($truthy(working['$def?']())))) {
              break;
            };
            working = working.$parent();
          };
          return working;
        }, 0);
        
        $def(self, '$yields_single_arg?', function $BaseYieldNode_yields_single_arg$ques$1(children) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$uses_splat?'](children)['$!']()))) {
            return children.$size()['$=='](1)
          } else {
            return $ret_or_1
          }
        }, 1);
        return $def(self, '$uses_splat?', function $BaseYieldNode_uses_splat$ques$2(children) {
          
          return $send(children, 'any?', [], function $$3(child){
            
            
            if (child == null) child = nil;;
            return child.$type()['$==']("splat");}, 1)
        }, 1);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'YieldNode');

        
        
        self.$handle("yield");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$compile_call()
        }, 0);
      })($nesting[0], $$('BaseYieldNode'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ReturnableYieldNode');

        
        
        self.$handle("returnable_yield");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$compile_call();
          return self.$wrap("return ", ";");
        }, 0);
      })($nesting[0], $$('BaseYieldNode'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/rescue"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $def = Opal.def, $range = Opal.range, $eqeq = Opal.eqeq, $to_a = Opal.to_a;

  Opal.add_stubs('require,handle,children,push,in_ensure,line,stmt,body_sexp,indent,has_rescue_else?,unshift,rescue_else_code,process,compiler,ensr_sexp,wrap_in_closure?,await_encountered,scope,wrap,returns,begn,ensr,s,recv?,expr?,rescue_else_sexp,stmt?,rescue_else_sexp=,detect,[],!=,type,handle_rescue_else_manually?,in_rescue,body_code,each_with_index,==,retry_id,body,nil?,!,in_ensure?,gen_retry_id,attr_reader,expr,klasses,lvar,updated,in_resbody,rescue_body,klasses_sexp,in_resbody?,error,current_rescue');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'EnsureNode');

        
        
        self.$handle("ensure");
        self.$children("begn", "ensr");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push("try {");
          $send(self, 'in_ensure', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$line(self.$stmt(self.$body_sexp()))}, {$$arity: 0, $$s: self});
          self.$line("} finally {");
          $send(self, 'indent', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;
            if (self.level == null) self.level = nil;

            if ($truthy(self['$has_rescue_else?']())) {
              
              self.$unshift("var $no_errors = true; ");
              self.$line("var $rescue_else_result;");
              self.$line("if ($no_errors) { ");
              $send(self, 'indent', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

                
                self.$line("$rescue_else_result = (function() {");
                $send(self, 'indent', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

                  return self.$line(self.$stmt(self.$rescue_else_code()))}, {$$arity: 0, $$s: self});
                return self.$line("})();");}, {$$arity: 0, $$s: self});
              self.$line("}");
              self.$line(self.$compiler().$process(self.$ensr_sexp(), self.level));
              return self.$line("if ($no_errors) { return $rescue_else_result; }");
            } else {
              return self.$line(self.$compiler().$process(self.$ensr_sexp(), self.level))
            }}, {$$arity: 0, $$s: self});
          self.$line("}");
          if ($truthy(self['$wrap_in_closure?']())) {
            if ($truthy(self.$scope().$await_encountered())) {
              return self.$wrap("(await (async function() { ", "; })())")
            } else {
              return self.$wrap("(function() { ", "; })()")
            }
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$body_sexp', function $$body_sexp() {
          var self = this;

          if ($truthy(self['$wrap_in_closure?']())) {
            return self.$compiler().$returns(self.$begn())
          } else {
            return self.$begn()
          }
        }, 0);
        
        $def(self, '$ensr_sexp', function $$ensr_sexp() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$ensr()))) {
            return $ret_or_1
          } else {
            return self.$s("nil")
          }
        }, 0);
        
        $def(self, '$wrap_in_closure?', function $EnsureNode_wrap_in_closure$ques$5() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self['$recv?']())) ? ($ret_or_2) : (self['$expr?']()))))) {
            return $ret_or_1
          } else {
            return self['$has_rescue_else?']()
          }
        }, 0);
        return $def(self, '$rescue_else_code', function $$rescue_else_code() {
          var self = this, rescue_else_code = nil;

          
          rescue_else_code = self.$scope().$rescue_else_sexp();
          if (!$truthy(self['$stmt?']())) {
            rescue_else_code = self.$compiler().$returns(rescue_else_code)
          };
          return rescue_else_code;
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'RescueNode');

        var $proto = self.$$prototype;

        $proto.retry_id = nil;
        
        self.$handle("rescue");
        self.$children("body");
        
        $def(self, '$compile', function $$compile() {
          var self = this, _has_rescue_handlers = nil;

          
          self.$scope()['$rescue_else_sexp=']($send(self.$children()['$[]']($range(1, -1, false)), 'detect', [], function $$6(sexp){var $ret_or_1 = nil;

            
            
            if (sexp == null) sexp = nil;;
            if ($truthy(($ret_or_1 = sexp))) {
              return sexp.$type()['$!=']("resbody")
            } else {
              return $ret_or_1
            };}, 1));
          _has_rescue_handlers = false;
          if ($truthy(self['$handle_rescue_else_manually?']())) {
            self.$line("var $no_errors = true;")
          };
          $send(self, 'in_rescue', [self], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

            
            self.$push("try {");
            $send(self, 'indent', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

              return self.$line(self.$stmt(self.$body_code()))}, {$$arity: 0, $$s: self});
            self.$line("} catch ($err) {");
            $send(self, 'indent', [], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

              
              if ($truthy(self['$has_rescue_else?']())) {
                self.$line("$no_errors = false;")
              };
              $send(self.$children()['$[]']($range(1, -1, false)), 'each_with_index', [], function $$10(child, idx){var self = $$10.$$s == null ? this : $$10.$$s;
                if (self.level == null) self.level = nil;

                
                
                if (child == null) child = nil;;
                
                if (idx == null) idx = nil;;
                if (!($truthy(child) && ($eqeq(child.$type(), "resbody")))) {
                  return nil;
                };
                _has_rescue_handlers = true;
                if (!$eqeq(idx, 0)) {
                  self.$push(" else ")
                };
                return self.$line(self.$process(child, self.level));}, {$$arity: 2, $$s: self});
              return self.$push(" else { throw $err; }");}, {$$arity: 0, $$s: self});
            self.$line("}");
            if ($truthy(self['$handle_rescue_else_manually?']())) {
              
              self.$push("finally {");
              $send(self, 'indent', [], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s;

                
                self.$line("if ($no_errors) { ");
                $send(self, 'indent', [], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

                  return self.$line(self.$stmt(self.$rescue_else_code()))}, {$$arity: 0, $$s: self});
                return self.$line("}");}, {$$arity: 0, $$s: self});
              self.$push("}");
            };
            if ($truthy(self.$retry_id())) {
              return self.$wrap("" + (self.$retry_id()) + ": do { ", " break; } while(1)")
            } else {
              return nil
            };}, {$$arity: 0, $$s: self});
          if (($truthy(self['$expr?']()) || ($truthy(self['$recv?']())))) {
            if ($truthy(self.$scope().$await_encountered())) {
              return self.$wrap("(await (async function() { ", "})())")
            } else {
              return self.$wrap("(function() { ", "})()")
            }
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$body_code', function $$body_code() {
          var self = this, body_code = nil;

          
          body_code = (($truthy(self.$body()['$nil?']()) || ($eqeq(self.$body().$type(), "resbody"))) ? (self.$s("nil")) : (self.$body()));
          if (!$truthy(self['$stmt?']())) {
            body_code = self.$compiler().$returns(body_code)
          };
          return body_code;
        }, 0);
        
        $def(self, '$rescue_else_code', function $$rescue_else_code() {
          var self = this, rescue_else_code = nil;

          
          rescue_else_code = self.$scope().$rescue_else_sexp();
          if (!$truthy(self['$stmt?']())) {
            rescue_else_code = self.$compiler().$returns(rescue_else_code)
          };
          return rescue_else_code;
        }, 0);
        
        $def(self, '$handle_rescue_else_manually?', function $RescueNode_handle_rescue_else_manually$ques$13() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$in_ensure?']()['$!']()))) {
            return self['$has_rescue_else?']()
          } else {
            return $ret_or_1
          }
        }, 0);
        
        $def(self, '$gen_retry_id', function $$gen_retry_id() {
          var self = this, $ret_or_1 = nil;

          return (self.retry_id = ($truthy(($ret_or_1 = self.retry_id)) ? ($ret_or_1) : (self.$scope().$gen_retry_id())))
        }, 0);
        return self.$attr_reader("retry_id");
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'ResBodyNode');

        
        
        self.$handle("resbody");
        self.$children("klasses_sexp", "lvar", "body");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push("if (Opal.rescue($err, ", self.$expr(self.$klasses()), ")) {");
          $send(self, 'indent', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

            
            if ($truthy(self.$lvar())) {
              self.$push(self.$expr(self.$lvar().$updated(nil, [].concat($to_a(self.$lvar().$children())).concat([self.$s("js_tmp", "$err")]))))
            };
            self.$line("try {");
            $send(self, 'indent', [], function $$15(){var self = $$15.$$s == null ? this : $$15.$$s;

              return $send(self, 'in_resbody', [], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

                return self.$line(self.$stmt(self.$rescue_body()))}, {$$arity: 0, $$s: self})}, {$$arity: 0, $$s: self});
            return self.$line("} finally { Opal.pop_exception(); }");}, {$$arity: 0, $$s: self});
          return self.$line("}");
        }, 0);
        
        $def(self, '$klasses', function $$klasses() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$klasses_sexp()))) {
            return $ret_or_1
          } else {
            return self.$s("array", self.$s("const", nil, "StandardError"))
          }
        }, 0);
        return $def(self, '$rescue_body', function $$rescue_body() {
          var self = this, body_code = nil, $ret_or_1 = nil;

          
          body_code = ($truthy(($ret_or_1 = self.$body())) ? ($ret_or_1) : (self.$s("nil")));
          if (!$truthy(self['$stmt?']())) {
            body_code = self.$compiler().$returns(body_code)
          };
          return body_code;
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'RetryNode');

        
        
        self.$handle("retry");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          if (!$truthy(self['$in_resbody?']())) {
            self.$error("Invalid retry")
          };
          return self.$push("continue " + (self.$scope().$current_rescue().$gen_retry_id()));
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/super"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $return_val = Opal.return_val, $to_ary = Opal.to_ary, $eqeq = Opal.eqeq, $not = Opal.not, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $eqeqeq = Opal.eqeqeq;

  Opal.add_stubs('require,include?,type,s,helper,push,compile_receiver,compile_method_body,compile_method_name,compile_arguments,compile_block_pass,private,def?,scope,find_parent_def,to_s,mid,def_scope,identify!,self,method_id,def_scope_identity,defined_check_param,allow_stubs,super_chain,join,map,implicit_arguments_param,super_method_invocation,iter?,super_block_invocation,raise,handle,wrap,uses_block!,compile_using_send,==,iter,block_name,implicit_arglist,!,<<,new,each,children,original_args,[],[]=,+,>,meta,empty?,===');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'BaseSuperNode');

        var $proto = self.$$prototype;

        $proto.sexp = $proto.def_scope = nil;
        
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $b, $c, $yield = $$initialize.$$p || nil, self = this, args = nil, rest = nil, last_child = nil;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          args = [].concat($to_a(self.sexp));
          $b = [].concat($to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_child = ($b[$c] == null ? nil : $b[$c])), $b;
          if (($truthy(last_child) && ($truthy(["iter", "block_pass"]['$include?'](last_child.$type()))))) {
            
            self.iter = last_child;
            args = rest;
          } else {
            self.iter = self.$s("js_tmp", "null")
          };
          self.arglist = $send(self, 's', ["arglist"].concat($to_a(args)));
          return (self.recvr = self.$s("self"));
        }, -1);
        
        $def(self, '$compile_using_send', function $$compile_using_send() {
          var self = this;

          
          self.$helper("send2");
          self.$push("$send2(");
          self.$compile_receiver();
          self.$compile_method_body();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        }, 0);
        self.$private();
        
        $def(self, '$def_scope', function $$def_scope() {
          var self = this, $ret_or_1 = nil;

          return (self.def_scope = ($truthy(($ret_or_1 = self.def_scope)) ? ($ret_or_1) : ($truthy(self.$scope()['$def?']()) ? (self.$scope()) : (self.$scope().$find_parent_def()))))
        }, 0);
        
        $def(self, '$defined_check_param', $return_val("false"), 0);
        
        $def(self, '$implicit_arguments_param', $return_val("false"), 0);
        
        $def(self, '$method_id', function $$method_id() {
          var self = this;

          return self.$def_scope().$mid().$to_s()
        }, 0);
        
        $def(self, '$def_scope_identity', function $$def_scope_identity() {
          var self = this;

          return self.$def_scope()['$identify!'](self.$def_scope().$mid())
        }, 0);
        
        $def(self, '$allow_stubs', $return_val("true"), 0);
        
        $def(self, '$super_method_invocation', function $$super_method_invocation() {
          var self = this;

          
          self.$helper("find_super");
          return "$find_super(" + (self.$scope().$self()) + ", '" + (self.$method_id()) + "', " + (self.$def_scope_identity()) + ", " + (self.$defined_check_param()) + ", " + (self.$allow_stubs()) + ")";
        }, 0);
        
        $def(self, '$super_block_invocation', function $$super_block_invocation() {
          var $a, $b, self = this, chain = nil, cur_defn = nil, mid = nil, trys = nil;

          
          self.$helper("find_block_super");
          $b = self.$scope().$super_chain(), $a = $to_ary($b), (chain = ($a[0] == null ? nil : $a[0])), (cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
          trys = $send(chain, 'map', [], function $$1(c){
            
            
            if (c == null) c = nil;;
            return "" + (c) + ".$$def";}, 1).$join(" || ");
          return "$find_block_super(" + (self.$scope().$self()) + ", " + (mid) + ", (" + (trys) + " || " + (cur_defn) + "), " + (self.$defined_check_param()) + ", " + (self.$implicit_arguments_param()) + ")";
        }, 0);
        
        $def(self, '$compile_method_body', function $$compile_method_body() {
          var self = this;

          
          self.$push(", ");
          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$super_method_invocation())
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$push(self.$super_block_invocation())
          } else {
            return self.$raise("super must be called from method body or block")
          };
        }, 0);
        return $def(self, '$compile_method_name', function $$compile_method_name() {
          var $a, $b, self = this, _chain = nil, _cur_defn = nil, mid = nil;

          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(", '" + (self.$method_id()) + "'")
          } else if ($truthy(self.$scope()['$iter?']())) {
            
            $b = self.$scope().$super_chain(), $a = $to_ary($b), (_chain = ($a[0] == null ? nil : $a[0])), (_cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
            return self.$push(", " + (mid));
          } else {
            return nil
          }
        }, 0);
      })($nesting[0], $$('CallNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'DefinedSuperNode');

        
        
        self.$handle("defined_super");
        
        $def(self, '$allow_stubs', $return_val("false"), 0);
        
        $def(self, '$defined_check_param', $return_val("true"), 0);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$compile_receiver();
          self.$compile_method_body();
          return self.$wrap("((", ") != null ? \"super\" : nil)");
        }, 0);
      })($nesting[0], $$('BaseSuperNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'SuperNode');

        
        
        self.$handle("super");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          if ($truthy(self.$scope()['$def?']())) {
            return self.$scope()['$uses_block!']()
          } else {
            return nil
          };
        }, -1);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$compile_using_send()
        }, 0);
      })($nesting[0], $$('BaseSuperNode'));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ZsuperNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("zsuper");
        
        $def(self, '$implicit_arguments_param', $return_val("true"), 0);
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          if ($eqeq(self.$iter().$type(), "iter")) {
            return nil
          } else {
            
            self.$scope()['$uses_block!']();
            return (self.iter = self.$s("js_tmp", ($truthy(($ret_or_1 = self.$scope().$block_name())) ? ($ret_or_1) : ("$yield"))));
          };
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this, implicit_args = nil, block_pass = nil;

          
          if ($truthy(self.$def_scope())) {
            
            implicit_args = self.$implicit_arglist();
            if (($truthy(self.$block_name()) && ($not(self.$iter())))) {
              
              block_pass = self.$s("block_pass", self.$s("lvar", self.$block_name()));
              implicit_args['$<<'](block_pass);
            };
            self.arglist = $send(self, 's', ["arglist"].concat($to_a(implicit_args)));
          };
          return self.$compile_using_send();
        }, 0);
        
        $def(self, '$implicit_arglist', function $$implicit_arglist() {
          var self = this, args = nil, kwargs = nil, same_arg_counter = nil;

          
          args = [];
          kwargs = [];
          same_arg_counter = $$('Hash').$new(0);
          $send(self.$def_scope().$original_args().$children(), 'each', [], function $$2(sexp){var self = $$2.$$s == null ? this : $$2.$$s, lvar_name = nil, arg_node = nil, key_name = nil;

            
            
            if (sexp == null) sexp = nil;;
            lvar_name = sexp.$children()['$[]'](0);
            
            switch (sexp.$type()) {
              case "arg":
              case "optarg":
                
                arg_node = self.$s("lvar", lvar_name);
                if ($eqeq(lvar_name['$[]'](0), "_")) {
                  
                  same_arg_counter['$[]='](lvar_name, $rb_plus(same_arg_counter['$[]'](lvar_name), 1));
                  if ($truthy($rb_gt(same_arg_counter['$[]'](lvar_name), 1))) {
                    arg_node = self.$s("js_tmp", "" + (lvar_name) + "_$" + (same_arg_counter['$[]'](lvar_name)))
                  };
                };
                return args['$<<'](arg_node);
              case "restarg":
                
                arg_node = ($truthy(lvar_name) ? (self.$s("lvar", lvar_name)) : (self.$s("js_tmp", "$rest_arg")));
                return args['$<<'](self.$s("splat", arg_node));
              case "kwarg":
              case "kwoptarg":
                
                key_name = sexp.$meta()['$[]']("arg_name");
                return kwargs['$<<'](self.$s("pair", self.$s("sym", key_name), self.$s("lvar", lvar_name)));
              case "kwrestarg":
                
                arg_node = ($truthy(lvar_name) ? (self.$s("lvar", lvar_name)) : (self.$s("js_tmp", "$kw_rest_arg")));
                return kwargs['$<<'](self.$s("kwsplat", arg_node));
              default:
                return nil
            };}, {$$arity: 1, $$s: self});
          if (!$truthy(kwargs['$empty?']())) {
            args['$<<']($send(self, 's', ["hash"].concat($to_a(kwargs))))
          };
          return args;
        }, 0);
        return $def(self, '$block_name', function $$block_name() {
          var self = this, $ret_or_1 = nil;

          if ($eqeqeq($$$($$$($$('Opal'), 'Nodes'), 'IterNode'), ($ret_or_1 = self.$def_scope()))) {
            return self.$def_scope().$block_name()
          } else if ($eqeqeq($$$($$$($$('Opal'), 'Nodes'), 'DefNode'), $ret_or_1)) {
            return self.$def_scope().$block_name()
          } else {
            return self.$raise("Don't know what to do with super in the scope " + (self.$def_scope()))
          }
        }, 0);
      })($nesting[0], $$('SuperNode'), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/version"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "1.5.1")
  })($nesting[0], $nesting)
};

Opal.modules["opal/nodes/top"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $def = Opal.def;

  Opal.add_stubs('require,handle,children,top_scope=,compiler,[],meta,sexp,dynamic_cache_result=,push,version_comment,eof_content,helper,==,body,s,eval?,esm?,requirable?,unshift,definition,in_scope,use_strict?,line,stmt,stmts,is_a?,add_temp,add_used_helpers,to_vars,scope,compile_method_stubs,compile_irb_vars,compile_end_construct,opening,closing,inspect,module_name,file,await_encountered,returns,irb?,each,to_a,helpers,method_missing?,method_calls,join,map,to_proc,empty?');
  
  self.$require("pathname");
  self.$require("opal/version");
  self.$require("opal/nodes/scope");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TopNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("top");
        self.$children("body");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$compiler()['$top_scope='](self);
          if ($truthy(self.$sexp().$meta()['$[]']("dynamic_cache_result"))) {
            self.$compiler()['$dynamic_cache_result='](true)
          };
          self.$push(self.$version_comment());
          if ($truthy(self.$compiler().$eof_content())) {
            self.$helper("return_val")
          };
          if ($eqeq(self.$body(), self.$s("nil"))) {
            if ((($truthy(self.$compiler()['$requirable?']()) || ($truthy(self.$compiler()['$esm?']()))) || ($truthy(self.$compiler()['$eval?']())))) {
              
              self.$unshift("Opal.return_val(Opal.nil); ");
              return self.$definition();
            } else {
              return self.$unshift("Opal.nil; ")
            }
          } else {
            
            $send(self, 'in_scope', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s, body_code = nil;
              if (self.define_nesting == null) self.define_nesting = nil;
              if (self.define_self == null) self.define_self = nil;
              if (self.define_relative_access == null) self.define_relative_access = nil;
              if (self.define_absolute_const == null) self.define_absolute_const = nil;

              
              if ($truthy(self.$compiler()['$use_strict?']())) {
                self.$line("\"use strict\";")
              };
              body_code = self.$stmt(self.$stmts());
              if (!$truthy(body_code['$is_a?']($$('Array')))) {
                body_code = [body_code]
              };
              if ($truthy(self.$compiler()['$eval?']())) {
                if ($truthy(self.define_nesting)) {
                  self.$add_temp("$nesting = self.$$is_a_module ? [self] : [self.$$class]")
                }
              } else {
                
                if ($truthy(self.define_self)) {
                  self.$add_temp("self = Opal.top")
                };
                if ($truthy(self.define_nesting)) {
                  self.$add_temp("$nesting = []")
                };
              };
              if ($truthy(self.define_relative_access)) {
                self.$add_temp("$$ = Opal.$r($nesting)")
              };
              self.$add_temp("nil = Opal.nil");
              if ($truthy(self.define_absolute_const)) {
                self.$add_temp("$$$ = Opal.$$$")
              };
              self.$add_used_helpers();
              self.$line(self.$scope().$to_vars());
              self.$compile_method_stubs();
              self.$compile_irb_vars();
              self.$compile_end_construct();
              return self.$line(body_code);}, {$$arity: 0, $$s: self});
            self.$opening();
            self.$definition();
            return self.$closing();
          };
        }, 0);
        
        $def(self, '$definition', function $$definition() {
          var self = this;

          if ($truthy(self.$compiler()['$requirable?']())) {
            return self.$unshift("Opal.modules[" + ($$$($$('Opal'), 'Compiler').$module_name(self.$compiler().$file()).$inspect()) + "] = ")
          } else if ($truthy(self.$compiler()['$esm?']())) {
            return self.$unshift("export default ")
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$opening', function $$opening() {
          var self = this, async_prefix = nil;

          
          if ($truthy(self.$await_encountered())) {
            async_prefix = "async "
          };
          if ($truthy(self.$compiler()['$requirable?']())) {
            return self.$unshift("" + (async_prefix) + "function(Opal) {")
          } else if ($truthy(self.$compiler()['$eval?']())) {
            return self.$unshift("(" + (async_prefix) + "function(Opal, self) {")
          } else {
            return self.$unshift("Opal.queue(" + (async_prefix) + "function(Opal) {")
          };
        }, 0);
        
        $def(self, '$closing', function $$closing() {
          var self = this;

          if ($truthy(self.$compiler()['$requirable?']())) {
            return self.$line("};\n")
          } else if ($truthy(self.$compiler()['$eval?']())) {
            return self.$line("})(Opal, self);")
          } else {
            return self.$line("});\n")
          }
        }, 0);
        
        $def(self, '$stmts', function $$stmts() {
          var self = this;

          return self.$compiler().$returns(self.$body())
        }, 0);
        
        $def(self, '$absolute_const', function $$absolute_const() {
          var self = this;

          
          self.define_absolute_const = true;
          return "$$$";
        }, 0);
        
        $def(self, '$compile_irb_vars', function $$compile_irb_vars() {
          var self = this;

          if ($truthy(self.$compiler()['$irb?']())) {
            return self.$line("if (!Opal.irb_vars) { Opal.irb_vars = {}; }")
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$add_used_helpers', function $$add_used_helpers() {
          var self = this;

          return $send(self.$compiler().$helpers().$to_a(), 'each', [], function $$2(h){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (h == null) h = nil;;
            return self.$add_temp("$" + (h) + " = Opal." + (h));}, {$$arity: 1, $$s: self})
        }, 0);
        
        $def(self, '$compile_method_stubs', function $$compile_method_stubs() {
          var self = this, calls = nil, stubs = nil;

          if ($truthy(self.$compiler()['$method_missing?']())) {
            
            calls = self.$compiler().$method_calls();
            stubs = $send(calls.$to_a(), 'map', [], "to_s".$to_proc()).$join(",");
            if ($truthy(stubs['$empty?']())) {
              return nil
            } else {
              return self.$line("Opal.add_stubs('" + (stubs) + "');")
            };
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$compile_end_construct', function $$compile_end_construct() {
          var self = this, content = nil;

          if ($truthy((content = self.$compiler().$eof_content()))) {
            
            self.$line("var $__END__ = Opal.Object.$new();");
            return self.$line("$__END__.$read = $return_val(" + (content.$inspect()) + ");");
          } else {
            return nil
          }
        }, 0);
        return $def(self, '$version_comment', function $$version_comment() {
          
          return "/* Generated by Opal " + ($$$($$('Opal'), 'VERSION')) + " */"
        }, 0);
      })($nesting[0], $$('ScopeNode'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/while"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $def = Opal.def, $to_a = Opal.to_a, $return_val = Opal.return_val;

  Opal.add_stubs('require,handle,children,js_truthy,test,with_temp,in_while,compiler,wrap_in_closure?,[]=,while_loop,indent,stmt,body,uses_redo?,compile_with_redo,compile_without_redo,await_encountered,scope,wrap,private,push,compile_while,while_open,while_close,line,[],expr?,recv?');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'WhileNode');

        
        
        self.$handle("while");
        self.$children("test", "body");
        
        $def(self, '$compile', function $$compile() {
          var self = this, test_code = nil;

          
          test_code = self.$js_truthy(self.$test());
          $send(self, 'with_temp', [], function $$1(redo_var){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (redo_var == null) redo_var = nil;;
            return $send(self.$compiler(), 'in_while', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s, body_code = nil;

              
              if ($truthy(self['$wrap_in_closure?']())) {
                self.$while_loop()['$[]=']("closure", true)
              };
              self.$while_loop()['$[]=']("redo_var", redo_var);
              body_code = $send(self, 'indent', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

                return self.$stmt(self.$body())}, {$$arity: 0, $$s: self});
              if ($truthy(self['$uses_redo?']())) {
                return self.$compile_with_redo(test_code, body_code, redo_var)
              } else {
                return self.$compile_without_redo(test_code, body_code)
              };}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
          if ($truthy(self['$wrap_in_closure?']())) {
            if ($truthy(self.$scope().$await_encountered())) {
              return self.$wrap("(await (async function() {", "; return nil; })())")
            } else {
              return self.$wrap("(function() {", "; return nil; })()")
            }
          } else {
            return nil
          };
        }, 0);
        self.$private();
        
        $def(self, '$compile_with_redo', function $$compile_with_redo(test_code, body_code, redo_var) {
          var self = this;

          
          self.$push("" + (redo_var) + " = false; ");
          return self.$compile_while([redo_var, " || ", test_code], ["" + (redo_var) + " = false;", body_code]);
        }, 3);
        
        $def(self, '$compile_without_redo', function $$compile_without_redo(test_code, body_code) {
          var self = this;

          return self.$compile_while([test_code], [body_code])
        }, 2);
        
        $def(self, '$compile_while', function $$compile_while(test_code, body_code) {
          var self = this;

          
          $send(self, 'push', [self.$while_open()].concat($to_a(test_code)).concat([self.$while_close()]));
          $send(self, 'indent', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return $send(self, 'line', $to_a(body_code))}, {$$arity: 0, $$s: self});
          return self.$line("}");
        }, 2);
        
        $def(self, '$while_open', $return_val("while ("), 0);
        
        $def(self, '$while_close', $return_val(") {"), 0);
        
        $def(self, '$uses_redo?', function $WhileNode_uses_redo$ques$5() {
          var self = this;

          return self.$while_loop()['$[]']("use_redo")
        }, 0);
        return $def(self, '$wrap_in_closure?', function $WhileNode_wrap_in_closure$ques$6() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$expr?']()))) {
            return $ret_or_1
          } else {
            return self['$recv?']()
          }
        }, 0);
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'UntilNode');

        
        
        self.$handle("until");
        self.$private();
        
        $def(self, '$while_open', $return_val("while (!("), 0);
        return $def(self, '$while_close', $return_val(")) {"), 0);
      })($nesting[0], $$('WhileNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'WhilePostNode');

        
        
        self.$handle("while_post");
        self.$private();
        
        $def(self, '$compile_while', function $$compile_while(test_code, body_code) {
          var self = this;

          
          self.$push("do {");
          $send(self, 'indent', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

            return $send(self, 'line', $to_a(body_code))}, {$$arity: 0, $$s: self});
          return $send(self, 'line', ["} ", self.$while_open()].concat($to_a(test_code)).concat([self.$while_close()]));
        }, 2);
        return $def(self, '$while_close', $return_val(");"), 0);
      })($nesting[0], $$('WhileNode'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'UntilPostNode');

        
        
        self.$handle("until_post");
        self.$private();
        
        $def(self, '$while_open', $return_val("while(!("), 0);
        return $def(self, '$while_close', $return_val("));"), 0);
      })($nesting[0], $$('WhilePostNode'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/hash"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $send = Opal.send, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $hash2 = Opal.hash2;

  Opal.add_stubs('require,handle,attr_accessor,each,children,type,<<,[],all?,keys,include?,has_kwsplat,compile_merge,simple_keys?,compile_hash2,compile_hash,helper,==,empty?,expr,s,each_with_index,push,wrap,times,size,inspect,to_s,[]=,values,join,value');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'HashNode');

        
        
        self.$handle("hash");
        self.$attr_accessor("has_kwsplat", "keys", "values");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $rest_arg, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          $rest_arg = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($rest_arg), $yield);
          self.has_kwsplat = false;
          self.keys = [];
          self.values = [];
          return $send(self.$children(), 'each', [], function $$1(child){var self = $$1.$$s == null ? this : $$1.$$s;
            if (self.keys == null) self.keys = nil;
            if (self.values == null) self.values = nil;

            
            
            if (child == null) child = nil;;
            
            switch (child.$type()) {
              case "kwsplat":
                return (self.has_kwsplat = true)
              case "pair":
                
                self.keys['$<<'](child.$children()['$[]'](0));
                return self.values['$<<'](child.$children()['$[]'](1));
              default:
                return nil
            };}, {$$arity: 1, $$s: self});
        }, -1);
        
        $def(self, '$simple_keys?', function $HashNode_simple_keys$ques$2() {
          var self = this;

          return $send(self.$keys(), 'all?', [], function $$3(key){
            
            
            if (key == null) key = nil;;
            return ["sym", "str"]['$include?'](key.$type());}, 1)
        }, 0);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self.$has_kwsplat())) {
            return self.$compile_merge()
          } else if ($truthy(self['$simple_keys?']())) {
            return self.$compile_hash2()
          } else {
            return self.$compile_hash()
          }
        }, 0);
        
        $def(self, '$compile_merge', function $$compile_merge() {
          var $a, self = this, result = nil, seq = nil;

          
          self.$helper("hash");
          $a = [[], []], (result = $a[0]), (seq = $a[1]), $a;
          $send(self.$children(), 'each', [], function $$4(child){var self = $$4.$$s == null ? this : $$4.$$s;

            
            
            if (child == null) child = nil;;
            if ($eqeq(child.$type(), "kwsplat")) {
              
              if (!$truthy(seq['$empty?']())) {
                result['$<<'](self.$expr($send(self, 's', ["hash"].concat($to_a(seq)))))
              };
              result['$<<'](self.$expr(child));
              return (seq = []);
            } else {
              return seq['$<<'](child)
            };}, {$$arity: 1, $$s: self});
          if (!$truthy(seq['$empty?']())) {
            result['$<<'](self.$expr($send(self, 's', ["hash"].concat($to_a(seq)))))
          };
          return $send(result, 'each_with_index', [], function $$5(fragment, idx){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (fragment == null) fragment = nil;;
            
            if (idx == null) idx = nil;;
            if ($eqeq(idx, 0)) {
              return self.$push(fragment)
            } else {
              return self.$push(".$merge(", fragment, ")")
            };}, {$$arity: 2, $$s: self});
        }, 0);
        
        $def(self, '$compile_hash', function $$compile_hash() {
          var self = this;

          
          self.$helper("hash");
          $send(self.$children(), 'each_with_index', [], function $$6(pair, idx){var $a, $b, self = $$6.$$s == null ? this : $$6.$$s, key = nil, value = nil;

            
            
            if (pair == null) pair = nil;;
            
            if (idx == null) idx = nil;;
            $b = pair.$children(), $a = $to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;
            if (!$eqeq(idx, 0)) {
              self.$push(", ")
            };
            return self.$push(self.$expr(key), ", ", self.$expr(value));}, {$$arity: 2, $$s: self});
          return self.$wrap("$hash(", ")");
        }, 0);
        return $def(self, '$compile_hash2', function $$compile_hash2() {
          var $a, self = this, hash_obj = nil, hash_keys = nil;

          
          $a = [$hash2([], {}), []], (hash_obj = $a[0]), (hash_keys = $a[1]), $a;
          self.$helper("hash2");
          $send(self.$keys().$size(), 'times', [], function $$7(idx){var $b, self = $$7.$$s == null ? this : $$7.$$s, key = nil;

            
            
            if (idx == null) idx = nil;;
            key = self.$keys()['$[]'](idx).$children()['$[]'](0).$to_s().$inspect();
            if (!$truthy(hash_obj['$include?'](key))) {
              hash_keys['$<<'](key)
            };
            return ($b = [key, self.$expr(self.$values()['$[]'](idx))], $send(hash_obj, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
          $send(hash_keys, 'each_with_index', [], function $$8(key, idx){var self = $$8.$$s == null ? this : $$8.$$s;

            
            
            if (key == null) key = nil;;
            
            if (idx == null) idx = nil;;
            if (!$eqeq(idx, 0)) {
              self.$push(", ")
            };
            self.$push("" + (key) + ": ");
            return self.$push(hash_obj['$[]'](key));}, {$$arity: 2, $$s: self});
          return self.$wrap("$hash2([" + (hash_keys.$join(", ")) + "], {", "})");
        }, 0);
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'KwSplatNode');

        
        
        self.$handle("kwsplat");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push("Opal.to_hash(", self.$expr(self.$value()), ")")
        }, 0);
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/array"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def;

  Opal.add_stubs('require,handle,empty?,children,push,each,==,type,expr,<<,fragment');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ArrayNode');

        
        
        self.$handle("array");
        return $def(self, '$compile', function $$compile() {
          var $a, self = this, code = nil, work = nil, join = nil;

          
          if ($truthy(self.$children()['$empty?']())) {
            return self.$push("[]")
          };
          $a = [[], []], (code = $a[0]), (work = $a[1]), $a;
          $send(self.$children(), 'each', [], function $$1(child){var self = $$1.$$s == null ? this : $$1.$$s, splat = nil, part = nil;

            
            
            if (child == null) child = nil;;
            splat = child.$type()['$==']("splat");
            part = self.$expr(child);
            if ($truthy(splat)) {
              
              if ($truthy(work['$empty?']())) {
                if ($truthy(code['$empty?']())) {
                  code['$<<'](self.$fragment("[].concat("))['$<<'](part)['$<<'](self.$fragment(")"))
                } else {
                  code['$<<'](self.$fragment(".concat("))['$<<'](part)['$<<'](self.$fragment(")"))
                }
              } else {
                
                if ($truthy(code['$empty?']())) {
                  code['$<<'](self.$fragment("["))['$<<'](work)['$<<'](self.$fragment("]"))
                } else {
                  code['$<<'](self.$fragment(".concat(["))['$<<'](work)['$<<'](self.$fragment("])"))
                };
                code['$<<'](self.$fragment(".concat("))['$<<'](part)['$<<'](self.$fragment(")"));
              };
              return (work = []);
            } else {
              
              if (!$truthy(work['$empty?']())) {
                work['$<<'](self.$fragment(", "))
              };
              return work['$<<'](part);
            };}, {$$arity: 1, $$s: self});
          if (!$truthy(work['$empty?']())) {
            
            join = [self.$fragment("["), work, self.$fragment("]")];
            if ($truthy(code['$empty?']())) {
              code = join
            } else {
              code.$push([self.$fragment(".concat("), join, self.$fragment(")")])
            };
          };
          return self.$push(code);
        }, 0);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/defined"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def, $truthy = Opal.truthy, $to_a = Opal.to_a, $slice = Opal.slice, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs('require,handle,children,type,value,push,inspect,to_s,==,[],size,compile_defined_send,wrap,compile_defined_ivar,compile_defined_super,compile_defined_yield,compile_defined_xstr,compile_defined_const,compile_defined_cvar,compile_defined_gvar,compile_defined_back_ref,compile_defined_nth_ref,compile_defined_array,respond_to?,__send__,new_temp,scope,expr,wrap_with_try_catch,mid_to_jsid,compile_defined,compile_send_recv_doesnt_raise,self,each,s,uses_block!,block_name,find_parent_def,nil?,relative_access,absolute_const,top_scope,class_variable_owner,helper,include?,each_with_index');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DefinedNode');

        
        
        self.$handle("defined?");
        self.$children("value");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          switch (self.$value().$type()) {
            case "self":
            case "nil":
            case "false":
            case "true":
              return self.$push(self.$value().$type().$to_s().$inspect())
            case "lvasgn":
            case "ivasgn":
            case "gvasgn":
            case "cvasgn":
            case "casgn":
            case "op_asgn":
            case "or_asgn":
            case "and_asgn":
              return self.$push("'assignment'")
            case "lvar":
              return self.$push("'local-variable'")
            case "begin":
              if (($eqeq(self.$value().$children().$size(), 1) && ($eqeq(self.$value().$children()['$[]'](0).$type(), "masgn")))) {
                return self.$push("'assignment'")
              } else {
                return self.$push("'expression'")
              }
              break;
            case "send":
              
              self.$compile_defined_send(self.$value());
              return self.$wrap("(", " ? 'method' : nil)");
            case "ivar":
              
              self.$compile_defined_ivar(self.$value());
              return self.$wrap("(", " ? 'instance-variable' : nil)");
            case "zsuper":
            case "super":
              return self.$compile_defined_super()
            case "yield":
              
              self.$compile_defined_yield();
              return self.$wrap("(", " ? 'yield' : nil)");
            case "xstr":
              return self.$compile_defined_xstr(self.$value())
            case "const":
              
              self.$compile_defined_const(self.$value());
              return self.$wrap("(", " ? 'constant' : nil)");
            case "cvar":
              
              self.$compile_defined_cvar(self.$value());
              return self.$wrap("(", " ? 'class variable' : nil)");
            case "gvar":
              
              self.$compile_defined_gvar(self.$value());
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "back_ref":
              
              self.$compile_defined_back_ref();
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "nth_ref":
              
              self.$compile_defined_nth_ref();
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "array":
              
              self.$compile_defined_array(self.$value());
              return self.$wrap("(", " ? 'expression' : nil)");
            default:
              return self.$push("'expression'")
          }
        }, 0);
        
        $def(self, '$compile_defined', function $$compile_defined(node) {
          var self = this, type = nil, node_tmp = nil;

          
          type = node.$type();
          if ($truthy(self['$respond_to?']("compile_defined_" + (type)))) {
            return self.$__send__("compile_defined_" + (type), node)
          } else {
            
            node_tmp = self.$scope().$new_temp();
            self.$push("(" + (node_tmp) + " = ", self.$expr(node), ")");
            return node_tmp;
          };
        }, 1);
        
        $def(self, '$wrap_with_try_catch', function $$wrap_with_try_catch(code) {
          var self = this, returning_tmp = nil;

          
          returning_tmp = self.$scope().$new_temp();
          self.$push("(" + (returning_tmp) + " = (function() { try {");
          self.$push("  return " + (code) + ";");
          self.$push("} catch ($err) {");
          self.$push("  if (Opal.rescue($err, [Opal.Exception])) {");
          self.$push("    try {");
          self.$push("      return false;");
          self.$push("    } finally { Opal.pop_exception() }");
          self.$push("  } else { throw $err; }");
          self.$push("}})())");
          return returning_tmp;
        }, 1);
        
        $def(self, '$compile_send_recv_doesnt_raise', function $$compile_send_recv_doesnt_raise(recv_code) {
          var self = this;

          return self.$wrap_with_try_catch(recv_code)
        }, 1);
        
        $def(self, '$compile_defined_send', function $$compile_defined_send(node) {
          var $a, self = this, recv = nil, method_name = nil, args = nil, mid = nil, recv_code = nil, recv_tmp = nil, recv_value_tmp = nil, meth_tmp = nil;

          
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;
          mid = self.$mid_to_jsid(method_name.$to_s());
          if ($truthy(recv)) {
            
            recv_code = self.$compile_defined(recv);
            self.$push(" && ");
            if ($eqeq(recv.$type(), "send")) {
              
              recv_code = self.$compile_send_recv_doesnt_raise(recv_code);
              self.$push(" && ");
            };
            recv_tmp = self.$scope().$new_temp();
            self.$push("(" + (recv_tmp) + " = ", recv_code, ", " + (recv_tmp) + ") && ");
          } else {
            recv_tmp = self.$scope().$self()
          };
          recv_value_tmp = self.$scope().$new_temp();
          self.$push("(" + (recv_value_tmp) + " = " + (recv_tmp) + ") && ");
          meth_tmp = self.$scope().$new_temp();
          self.$push("(((" + (meth_tmp) + " = " + (recv_value_tmp) + (mid) + ") && !" + (meth_tmp) + ".$$stub)");
          self.$push(" || " + (recv_value_tmp) + "['$respond_to_missing?']('" + (method_name) + "'))");
          $send(args, 'each', [], function $$1(arg){var self = $$1.$$s == null ? this : $$1.$$s;

            
            
            if (arg == null) arg = nil;;
            
            switch (arg.$type()) {
              case "block_pass":
                return nil
              default:
                
                self.$push(" && ");
                return self.$compile_defined(arg);
            };}, {$$arity: 1, $$s: self});
          self.$wrap("(", ")");
          return "" + (meth_tmp) + "()";
        }, 1);
        
        $def(self, '$compile_defined_ivar', function $$compile_defined_ivar(node) {
          var self = this, name = nil, tmp = nil;

          
          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));
          tmp = self.$scope().$new_temp();
          self.$push("(" + (tmp) + " = " + (self.$scope().$self()) + "['" + (name) + "'], " + (tmp) + " != null && " + (tmp) + " !== nil)");
          return tmp;
        }, 1);
        
        $def(self, '$compile_defined_super', function $$compile_defined_super() {
          var self = this;

          return self.$push(self.$expr(self.$s("defined_super")))
        }, 0);
        
        $def(self, '$compile_defined_yield', function $$compile_defined_yield() {
          var self = this, block_name = nil, $ret_or_1 = nil;

          
          self.$scope()['$uses_block!']();
          block_name = ($truthy(($ret_or_1 = self.$scope().$block_name())) ? ($ret_or_1) : (self.$scope().$find_parent_def().$block_name()));
          self.$push("(" + (block_name) + " != null && " + (block_name) + " !== nil)");
          return block_name;
        }, 0);
        
        $def(self, '$compile_defined_xstr', function $$compile_defined_xstr(node) {
          var self = this;

          return self.$push("(typeof(", self.$expr(node), ") !== \"undefined\")")
        }, 1);
        
        $def(self, '$compile_defined_const', function $$compile_defined_const(node) {
          var $a, self = this, const_scope = nil, const_name = nil, const_tmp = nil, const_scope_tmp = nil;

          
          $a = [].concat($to_a(node)), (const_scope = ($a[0] == null ? nil : $a[0])), (const_name = ($a[1] == null ? nil : $a[1])), $a;
          const_tmp = self.$scope().$new_temp();
          if ($truthy(const_scope['$nil?']())) {
            self.$push("(" + (const_tmp) + " = " + (self.$scope().$relative_access()) + "('" + (const_name) + "', 'skip_raise'))")
          } else if ($eqeq(const_scope, self.$s("cbase"))) {
            self.$push("(" + (const_tmp) + " = " + (self.$top_scope().$absolute_const()) + "('::', '" + (const_name) + "', 'skip_raise'))")
          } else {
            
            const_scope_tmp = self.$compile_defined(const_scope);
            self.$push(" && (" + (const_tmp) + " = " + (self.$top_scope().$absolute_const()) + "(" + (const_scope_tmp) + ", '" + (const_name) + "', 'skip_raise'))");
          };
          return const_tmp;
        }, 1);
        
        $def(self, '$compile_defined_cvar', function $$compile_defined_cvar(node) {
          var $a, self = this, cvar_name = nil, _ = nil, cvar_tmp = nil;

          
          $a = [].concat($to_a(node)), (cvar_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          cvar_tmp = self.$scope().$new_temp();
          self.$push("(" + (cvar_tmp) + " = " + (self.$class_variable_owner()) + ".$$cvars['" + (cvar_name) + "'], " + (cvar_tmp) + " != null)");
          return cvar_tmp;
        }, 1);
        
        $def(self, '$compile_defined_gvar', function $$compile_defined_gvar(node) {
          var self = this, name = nil, gvar_temp = nil;

          
          self.$helper("gvars");
          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));
          gvar_temp = self.$scope().$new_temp();
          if ($truthy(["~", "!"]['$include?'](name))) {
            self.$push("(" + (gvar_temp) + " = ", self.$expr(node), " || true)")
          } else {
            self.$push("(" + (gvar_temp) + " = $gvars[" + (name.$inspect()) + "], " + (gvar_temp) + " != null)")
          };
          return gvar_temp;
        }, 1);
        
        $def(self, '$compile_defined_back_ref', function $$compile_defined_back_ref() {
          var self = this, back_ref_temp = nil;

          
          self.$helper("gvars");
          back_ref_temp = self.$scope().$new_temp();
          self.$push("(" + (back_ref_temp) + " = $gvars['~'], " + (back_ref_temp) + " != null && " + (back_ref_temp) + " !== nil)");
          return back_ref_temp;
        }, 0);
        
        $def(self, '$compile_defined_nth_ref', function $$compile_defined_nth_ref() {
          var self = this, nth_ref_tmp = nil;

          
          self.$helper("gvars");
          nth_ref_tmp = self.$scope().$new_temp();
          self.$push("(" + (nth_ref_tmp) + " = $gvars['~'], " + (nth_ref_tmp) + " != null && " + (nth_ref_tmp) + " != nil)");
          return nth_ref_tmp;
        }, 0);
        return $def(self, '$compile_defined_array', function $$compile_defined_array(node) {
          var self = this;

          return $send(node.$children(), 'each_with_index', [], function $$2(child, idx){var self = $$2.$$s == null ? this : $$2.$$s;

            
            
            if (child == null) child = nil;;
            
            if (idx == null) idx = nil;;
            if (!$eqeq(idx, 0)) {
              self.$push(" && ")
            };
            return self.$compile_defined(child);}, {$$arity: 2, $$s: self})
        }, 1);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/masgn"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $def = Opal.def, $rb_ge = Opal.rb_ge, $not = Opal.not, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('require,freeze,handle,children,with_temp,==,type,rhs,push,expr,any?,size,compile_masgn,lhs,helper,take_while,!=,drop,each_with_index,compile_assignment,empty?,shift,[],<<,dup,s,new_temp,scope,queue_temp,>=,!,updated,include?,+,last,raise');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MassAssignNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'SIMPLE_ASSIGNMENT', ["lvasgn", "ivasgn", "lvar", "gvasgn", "cdecl", "casgn"].$freeze());
        self.$handle("masgn");
        self.$children("lhs", "rhs");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return $send(self, 'with_temp', [], function $$1(array){var self = $$1.$$s == null ? this : $$1.$$s, rhs_len = nil;

            
            
            if (array == null) array = nil;;
            if ($eqeq(self.$rhs().$type(), "array")) {
              
              self.$push("" + (array) + " = ", self.$expr(self.$rhs()));
              rhs_len = ($truthy($send(self.$rhs().$children(), 'any?', [], function $$2(c){
                
                
                if (c == null) c = nil;;
                return c.$type()['$==']("splat");}, 1)) ? (nil) : (self.$rhs().$children().$size()));
              self.$compile_masgn(self.$lhs().$children(), array, rhs_len);
              return self.$push(", " + (array));
            } else {
              
              self.$helper("to_ary");
              return $send(self, 'with_temp', [], function $$3(retval){var self = $$3.$$s == null ? this : $$3.$$s;

                
                
                if (retval == null) retval = nil;;
                self.$push("" + (retval) + " = ", self.$expr(self.$rhs()));
                self.$push(", " + (array) + " = $to_ary(" + (retval) + ")");
                self.$compile_masgn(self.$lhs().$children(), array);
                return self.$push(", " + (retval));}, {$$arity: 1, $$s: self});
            };}, {$$arity: 1, $$s: self})
        }, 0);
        
        $def(self, '$compile_masgn', function $$compile_masgn(lhs_items, array, len) {
          var self = this, pre_splat = nil, post_splat = nil, splat = nil, part = nil, tmp = nil;

          
          
          if (len == null) len = nil;;
          pre_splat = $send(lhs_items, 'take_while', [], function $$4(child){
            
            
            if (child == null) child = nil;;
            return child.$type()['$!=']("splat");}, 1);
          post_splat = lhs_items.$drop(pre_splat.$size());
          $send(pre_splat, 'each_with_index', [], function $$5(child, idx){var self = $$5.$$s == null ? this : $$5.$$s;

            
            
            if (child == null) child = nil;;
            
            if (idx == null) idx = nil;;
            return self.$compile_assignment(child, array, idx, len);}, {$$arity: 2, $$s: self});
          if ($truthy(post_splat['$empty?']())) {
            return nil
          } else {
            
            splat = post_splat.$shift();
            if ($truthy(post_splat['$empty?']())) {
              if ($truthy((part = splat.$children()['$[]'](0)))) {
                
                self.$helper("slice");
                part = part.$dup()['$<<'](self.$s("js_tmp", "$slice.call(" + (array) + ", " + (pre_splat.$size()) + ")"));
                self.$push(", ");
                return self.$push(self.$expr(part));
              } else {
                return nil
              }
            } else {
              
              tmp = self.$scope().$new_temp();
              self.$push(", " + (tmp) + " = " + (array) + ".length - " + (post_splat.$size()));
              self.$push(", " + (tmp) + " = (" + (tmp) + " < " + (pre_splat.$size()) + ") ? " + (pre_splat.$size()) + " : " + (tmp));
              if ($truthy((part = splat.$children()['$[]'](0)))) {
                
                self.$helper("slice");
                part = part.$dup()['$<<'](self.$s("js_tmp", "$slice.call(" + (array) + ", " + (pre_splat.$size()) + ", " + (tmp) + ")"));
                self.$push(", ");
                self.$push(self.$expr(part));
              };
              $send(post_splat, 'each_with_index', [], function $$6(child, idx){var self = $$6.$$s == null ? this : $$6.$$s;

                
                
                if (child == null) child = nil;;
                
                if (idx == null) idx = nil;;
                if ($eqeq(idx, 0)) {
                  return self.$compile_assignment(child, array, tmp)
                } else {
                  return self.$compile_assignment(child, array, "" + (tmp) + " + " + (idx))
                };}, {$$arity: 2, $$s: self});
              return self.$scope().$queue_temp(tmp);
            };
          };
        }, -3);
        return $def(self, '$compile_assignment', function $$compile_assignment(child, array, idx, len) {
          var self = this, assign = nil, part = nil, tmp = nil;

          
          
          if (len == null) len = nil;;
          assign = (($not(len) || ($truthy($rb_ge(idx, len)))) ? (self.$s("js_tmp", "(" + (array) + "[" + (idx) + "] == null ? nil : " + (array) + "[" + (idx) + "])")) : (self.$s("js_tmp", "" + (array) + "[" + (idx) + "]")));
          part = child.$updated();
          if ($truthy($$('SIMPLE_ASSIGNMENT')['$include?'](child.$type()))) {
            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))
          } else if ($eqeq(child.$type(), "send")) {
            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))
          } else if ($eqeq(child.$type(), "attrasgn")) {
            part.$last()['$<<'](assign)
          } else if ($eqeq(child.$type(), "mlhs")) {
            
            self.$helper("to_ary");
            tmp = self.$scope().$new_temp();
            self.$push(", (" + (tmp) + " = $to_ary(" + (assign.$children()['$[]'](0)) + ")");
            self.$compile_masgn(child.$children(), tmp);
            self.$push(")");
            self.$scope().$queue_temp(tmp);
            return nil;
          } else {
            self.$raise("Bad child node in masgn LHS: " + (child) + ". LHS: " + (self.$lhs()))
          };
          self.$push(", ");
          return self.$push(self.$expr(part));
        }, -4);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/arglist"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $to_a = Opal.to_a, $def = Opal.def;

  Opal.add_stubs('require,handle,each,children,==,type,expr,empty?,<<,fragment,push');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ArglistNode');

        
        
        self.$handle("arglist");
        return $def(self, '$compile', function $$compile() {
          var $a, self = this, code = nil, work = nil, join = nil;

          
          $a = [[], []], (code = $a[0]), (work = $a[1]), $a;
          $send(self.$children(), 'each', [], function $$1(current){var self = $$1.$$s == null ? this : $$1.$$s, splat = nil, arg = nil;

            
            
            if (current == null) current = nil;;
            splat = current.$type()['$==']("splat");
            arg = self.$expr(current);
            if ($truthy(splat)) {
              
              if ($truthy(work['$empty?']())) {
                if ($truthy(code['$empty?']())) {
                  code['$<<'](arg)
                } else {
                  code['$<<'](self.$fragment(".concat("))['$<<'](arg)['$<<'](self.$fragment(")"))
                }
              } else {
                
                if ($truthy(code['$empty?']())) {
                  code['$<<'](self.$fragment("["))['$<<'](work)['$<<'](self.$fragment("]"))
                } else {
                  code['$<<'](self.$fragment(".concat(["))['$<<'](work)['$<<'](self.$fragment("])"))
                };
                code['$<<'](self.$fragment(".concat("))['$<<'](arg)['$<<'](self.$fragment(")"));
              };
              return (work = []);
            } else {
              
              if (!$truthy(work['$empty?']())) {
                work['$<<'](self.$fragment(", "))
              };
              return work['$<<'](arg);
            };}, {$$arity: 1, $$s: self});
          if (!$truthy(work['$empty?']())) {
            
            join = work;
            if ($truthy(code['$empty?']())) {
              code = join
            } else {
              code['$<<'](self.$fragment(".concat(["))['$<<'](join)['$<<'](self.$fragment("])"))
            };
          };
          return $send(self, 'push', $to_a(code));
        }, 0);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes/x_string"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $defs = Opal.defs, $lambda = Opal.lambda, $eqeq = Opal.eqeq, $not = Opal.not, $range = Opal.range;

  Opal.add_stubs('handle,unpack_return,children,strip_empty_children,single_line?,compile_single_line,each,compile_child,recv?,wrap,push,==,size,none?,type,end_with?,source,expression,loc,dup,nil?,empty?,rstrip,any?,[],first,shift,last,pop,private,include?,self,scope,new,expr,raise,s,strip,=~,!,extract_last_value,expr?,warning,compiler,line');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'XStringNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.should_add_semicolon = $proto.returning = nil;
        
        self.$handle("xstr");
        
        $def(self, '$compile', function $$compile() {
          var self = this, unpacked_children = nil, stripped_children = nil;

          
          self.should_add_semicolon = false;
          unpacked_children = self.$unpack_return(self.$children());
          stripped_children = $$('XStringNode').$strip_empty_children(unpacked_children);
          if ($truthy($$('XStringNode')['$single_line?'](stripped_children))) {
            self.$compile_single_line(stripped_children)
          } else {
            $send(unpacked_children, 'each', [], function $$1(c){var self = $$1.$$s == null ? this : $$1.$$s;

              
              
              if (c == null) c = nil;;
              return self.$compile_child(c);}, {$$arity: 1, $$s: self})
          };
          if ($truthy(self['$recv?']())) {
            self.$wrap("(", ")")
          };
          if ($truthy(self.should_add_semicolon)) {
            return self.$push(";")
          } else {
            return nil
          };
        }, 0);
        $defs(self, '$single_line?', function $XStringNode_single_line$ques$2(children) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = children.$size()['$=='](1)))) {
            return $ret_or_1
          } else {
            return $send(children, 'none?', [], function $$3(c){var $ret_or_2 = nil;

              
              
              if (c == null) c = nil;;
              if ($truthy(($ret_or_2 = c.$type()['$==']("str")))) {
                return c.$loc().$expression().$source()['$end_with?']("\n")
              } else {
                return $ret_or_2
              };}, 1)
          }
        }, 1);
        $defs(self, '$strip_empty_children', function $$strip_empty_children(children) {
          var $a, empty_line = nil, $ret_or_1 = nil;

          
          children = children.$dup();
          empty_line = $lambda(function $$4(child){var $ret_or_1 = nil, $ret_or_2 = nil;

            
            
            if (child == null) child = nil;;
            if ($truthy(($ret_or_1 = child['$nil?']()))) {
              return $ret_or_1
            } else {
              
              if ($truthy(($ret_or_2 = child.$type()['$==']("str")))) {
                return child.$loc().$expression().$source().$rstrip()['$empty?']()
              } else {
                return $ret_or_2
              };
            };}, 1);
          while ($truthy(($truthy(($ret_or_1 = children['$any?']())) ? (empty_line['$[]'](children.$first())) : ($ret_or_1)))) {
            children.$shift()
          };
          while ($truthy(($truthy(($ret_or_1 = children['$any?']())) ? (empty_line['$[]'](children.$last())) : ($ret_or_1)))) {
            children.$pop()
          };
          return children;
        }, 1);
        self.$private();
        
        $def(self, '$compile_child', function $$compile_child(child) {
          var self = this, value = nil;

          
          switch (child.$type()) {
            case "str":
              
              value = child.$loc().$expression().$source();
              if ($truthy(value['$include?']("self"))) {
                self.$scope().$self()
              };
              return self.$push($$('Fragment').$new(value, self.$scope(), child));
            case "begin":
            case "gvar":
            case "ivar":
            case "nil":
              return self.$push(self.$expr(child))
            default:
              return self.$raise("Unsupported xstr part: " + (child.$type()))
          }
        }, 1);
        
        $def(self, '$compile_single_line', function $$compile_single_line(children) {
          var self = this, has_embeded_return = nil, first_child = nil, single_child = nil, $ret_or_1 = nil, first_value = nil, last_child = nil, last_value = nil;

          
          has_embeded_return = false;
          first_child = children.$shift();
          single_child = children['$empty?']();
          first_child = ($truthy(($ret_or_1 = first_child)) ? ($ret_or_1) : (self.$s("nil")));
          if ($eqeq(first_child.$type(), "str")) {
            
            first_value = first_child.$loc().$expression().$source().$strip();
            has_embeded_return = first_value['$=~'](/^return\b/);
          };
          if (($truthy(self.returning) && ($not(has_embeded_return)))) {
            self.$push("return ")
          };
          last_child = ($truthy(($ret_or_1 = children.$pop())) ? ($ret_or_1) : (first_child));
          if ($eqeq(last_child.$type(), "str")) {
            last_value = self.$extract_last_value(last_child)
          };
          if (!$truthy(single_child)) {
            
            self.should_add_semicolon = false;
            self.$compile_child(first_child);
            $send(children, 'each', [], function $$5(c){var self = $$5.$$s == null ? this : $$5.$$s;

              
              
              if (c == null) c = nil;;
              return self.$compile_child(c);}, {$$arity: 1, $$s: self});
          };
          if ($eqeq(last_child.$type(), "str")) {
            return self.$push($$('Fragment').$new(last_value, self.$scope(), last_child))
          } else {
            return self.$compile_child(last_child)
          };
        }, 1);
        
        $def(self, '$extract_last_value', function $$extract_last_value(last_child) {
          var self = this, last_value = nil;

          
          last_value = last_child.$loc().$expression().$source().$rstrip();
          if ($truthy(last_value['$include?']("self"))) {
            self.$scope().$self()
          };
          if ((($truthy(self.returning) || ($truthy(self['$expr?']()))) && ($truthy(last_value['$end_with?'](";"))))) {
            
            self.$compiler().$warning("Removed semicolon ending x-string expression, interpreted as unintentional", last_child.$line());
            last_value = last_value['$[]']($range(0, -2, false));
          };
          if ($truthy(self.returning)) {
            self.should_add_semicolon = true
          };
          return last_value;
        }, 1);
        return $def(self, '$unpack_return', function $$unpack_return(children) {
          var self = this, first_child = nil;

          
          first_child = children.$first();
          self.returning = false;
          if ($eqeq(first_child.$type(), "js_return")) {
            
            self.returning = true;
            children = first_child.$children();
          };
          return children;
        }, 1);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/nodes/lambda"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $def = Opal.def;

  Opal.add_stubs('require,handle,children,helper,defines_lambda,scope,push,expr,iter');
  
  self.$require("opal/nodes/call");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'LambdaNode');

        
        
        self.$handle("lambda");
        self.$children("iter");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$helper("lambda");
          return $send(self.$scope(), 'defines_lambda', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$push("$lambda(", self.$expr(self.$iter()), ")")}, {$$arity: 0, $$s: self});
        }, 0);
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/nodes"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("opal/nodes/base");
  self.$require("opal/nodes/literal");
  self.$require("opal/nodes/variables");
  self.$require("opal/nodes/constants");
  self.$require("opal/nodes/call");
  self.$require("opal/nodes/call_special");
  self.$require("opal/nodes/module");
  self.$require("opal/nodes/class");
  self.$require("opal/nodes/singleton_class");
  self.$require("opal/nodes/args");
  self.$require("opal/nodes/args/arity_check");
  self.$require("opal/nodes/iter");
  self.$require("opal/nodes/def");
  self.$require("opal/nodes/defs");
  self.$require("opal/nodes/if");
  self.$require("opal/nodes/logic");
  self.$require("opal/nodes/definitions");
  self.$require("opal/nodes/yield");
  self.$require("opal/nodes/rescue");
  self.$require("opal/nodes/super");
  self.$require("opal/nodes/top");
  self.$require("opal/nodes/while");
  self.$require("opal/nodes/hash");
  self.$require("opal/nodes/array");
  self.$require("opal/nodes/defined");
  self.$require("opal/nodes/masgn");
  self.$require("opal/nodes/arglist");
  self.$require("opal/nodes/x_string");
  return self.$require("opal/nodes/lambda");
};

Opal.modules["opal/eof_content"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $eqeq = Opal.eqeq, $range = Opal.range, $to_ary = Opal.to_ary;

  Opal.add_stubs('empty?,[],last_token_position,drop_while,lines,==,join,private,last,end_pos');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EofContent');

      var $nesting = [self].concat($parent_nesting), $proto = self.$$prototype;

      $proto.tokens = $proto.source = nil;
      
      $const_set($nesting[0], 'DATA_SEPARATOR', "__END__\n");
      
      $def(self, '$initialize', function $$initialize(tokens, source) {
        var self = this;

        
        self.tokens = tokens;
        return (self.source = source);
      }, 2);
      
      $def(self, '$eof', function $$eof() {
        var self = this, eof_content = nil, $ret_or_1 = nil;

        
        if ($truthy(self.tokens['$empty?']())) {
          return nil
        };
        eof_content = self.source['$[]'](Opal.Range.$new(self.$last_token_position(), -1, false));
        if (!$truthy(eof_content)) {
          return nil
        };
        eof_content = $send(eof_content.$lines(), 'drop_while', [], function $$1(line){
          
          
          if (line == null) line = nil;;
          return line['$==']("\n");}, 1);
        if ($eqeq(eof_content['$[]'](0), "__END__\n")) {
          
          eof_content = ($truthy(($ret_or_1 = eof_content['$[]']($range(1, -1, false)))) ? ($ret_or_1) : ([]));
          return eof_content.$join();
        } else if ($eqeq(eof_content, ["__END__"])) {
          return ""
        } else {
          return nil
        };
      }, 0);
      self.$private();
      return $def(self, '$last_token_position', function $$last_token_position() {
        var $a, $b, self = this, _ = nil, last_token_info = nil, last_token_range = nil;

        
        $b = self.tokens.$last(), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (last_token_info = ($a[1] == null ? nil : $a[1])), $b;
        $b = last_token_info, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (last_token_range = ($a[1] == null ? nil : $a[1])), $b;
        return last_token_range.$end_pos();
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/errors"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $defs = Opal.defs, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $send = Opal.send;

  Opal.add_stubs('attr_reader,attr_accessor,new,respond_to?,location=,location,diagnostic=,diagnostic,to_a,backtrace,unshift,to_s,set_backtrace,path,lineno,+,label,lineno=,line,label=,source_line,expression');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $klass($nesting[0], $$('StandardError'), 'Error');
    (function($base, $super) {
      var self = $klass($base, $super, 'GemNotFound');

      
      
      self.$attr_reader("gem_name");
      return $def(self, '$initialize', function $$initialize(gem_name) {
        var $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        self.gem_name = gem_name;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["can't find gem " + (gem_name)], null);
      }, 1);
    })($nesting[0], $$('Error'));
    (function($base, $super) {
      var self = $klass($base, $super, 'CompilationError');

      
      return self.$attr_accessor("location")
    })($nesting[0], $$('Error'));
    $klass($nesting[0], $$('CompilationError'), 'ParsingError');
    $klass($nesting[0], $$('ParsingError'), 'RewritingError');
    (function($base, $super) {
      var self = $klass($base, $super, 'SyntaxError');

      
      return self.$attr_accessor("location")
    })($nesting[0], $$$('SyntaxError'));
    $defs(self, '$opal_location_from_error', function $$opal_location_from_error(error) {
      var opal_location = nil;

      
      opal_location = $$('OpalBacktraceLocation').$new();
      if ($truthy(error['$respond_to?']("location"))) {
        opal_location['$location='](error.$location())
      };
      if ($truthy(error['$respond_to?']("diagnostic"))) {
        opal_location['$diagnostic='](error.$diagnostic())
      };
      return opal_location;
    }, 1);
    $defs(self, '$add_opal_location_to_error', function $$add_opal_location_to_error(opal_location, error) {
      var backtrace = nil;

      
      backtrace = error.$backtrace().$to_a();
      backtrace.$unshift(opal_location.$to_s());
      error.$set_backtrace(backtrace);
      return error;
    }, 2);
    return (function($base, $super) {
      var self = $klass($base, $super, 'OpalBacktraceLocation');

      
      
      self.$attr_accessor("path", "lineno", "label");
      
      $def(self, '$initialize', function $$initialize(path, lineno, label) {
        var $a, self = this;

        
        
        if (path == null) path = nil;;
        
        if (lineno == null) lineno = nil;;
        
        if (label == null) label = nil;;
        return $a = [path, lineno, label], (self.path = $a[0]), (self.lineno = $a[1]), (self.label = $a[2]), $a;
      }, -1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this, string = nil;

        
        string = self.$path();
        if ($truthy(self.$lineno())) {
          string = $rb_plus(string, ":" + (self.$lineno()))
        };
        string = $rb_plus(string, ":in ");
        if ($truthy(self.$label())) {
          string = $rb_plus(string, "`" + (self.$label()) + "'")
        } else {
          string = $rb_plus(string, "unknown")
        };
        return string;
      }, 0);
      $alias(self, "line", "lineno");
      
      $def(self, '$diagnostic=', function $OpalBacktraceLocation_diagnostic$eq$1(diagnostic) {
        var $a, self = this;

        
        if (!$truthy(diagnostic)) {
          return nil
        };
        return ($a = [diagnostic.$location()], $send(self, 'location=', $a), $a[$a.length - 1]);
      }, 1);
      return $def(self, '$location=', function $OpalBacktraceLocation_location$eq$2(location) {
        var $a, self = this;

        
        if (!$truthy(location)) {
          return nil
        };
        self['$lineno='](location.$line());
        if ($truthy(location['$respond_to?']("source_line"))) {
          return ($a = [location.$source_line()], $send(self, 'label=', $a), $a[$a.length - 1])
        } else if ($truthy(location['$respond_to?']("expression"))) {
          return ($a = [location.$expression().$source_line()], $send(self, 'label=', $a), $a[$a.length - 1])
        } else {
          return nil
        };
      }, 1);
    })($nesting[0], null);
  })($nesting[0], $nesting)
};

Opal.modules["opal/magic_comments"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $rb_ge = Opal.rb_ge, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs;

  Opal.add_stubs('freeze,line,loc,take,each,>=,any?,scan,text,[]=,to_sym,===');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'MagicComments');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'MAGIC_COMMENT_RE', /^# *(\w+) *: *(\S+.*?) *$/.$freeze());
    $const_set($nesting[0], 'EMACS_MAGIC_COMMENT_RE', /^# *-\*- *(\w+) *: *(\S+.*?) *-\*- *$/.$freeze());
    return $defs(self, '$parse', function $$parse(sexp, comments) {
      var flags = nil, first_line = nil;

      
      flags = $hash2([], {});
      if ($truthy(sexp)) {
        
        first_line = sexp.$loc().$line();
        comments = comments.$take(first_line);
      };
      $send(comments, 'each', [], function $$1(comment){var parts = nil;

        
        
        if (comment == null) comment = nil;;
        if (($truthy(first_line) && ($truthy($rb_ge(comment.$loc().$line(), first_line))))) {
          return nil;
        };
        if (($truthy((parts = comment.$text().$scan($$('MAGIC_COMMENT_RE')))['$any?']()) || ($truthy((parts = comment.$text().$scan($$('EMACS_MAGIC_COMMENT_RE')))['$any?']())))) {
          return $send(parts, 'each', [], function $$2(key, value){var $a, $ret_or_1 = nil;

            
            
            if (key == null) key = nil;;
            
            if (value == null) value = nil;;
            return ($a = [key.$to_sym(), ($eqeqeq("true", ($ret_or_1 = value)) || (($eqeqeq("false", $ret_or_1) ? (false) : (value))))], $send(flags, '[]=', $a), $a[$a.length - 1]);}, 2)
        } else {
          return nil
        };}, 1);
      return flags;
    }, 2);
  })($$('Opal'), $nesting)
};

Opal.modules["opal/compiler"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $hash2 = Opal.hash2, $defs = Opal.defs, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $truthy = Opal.truthy, $not = Opal.not, $def = Opal.def, $Opal = Opal.Opal, $to_ary = Opal.to_ary, $alias = Opal.alias, $eqeqeq = Opal.eqeqeq, $regexp = Opal.regexp, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq;

  Opal.add_stubs('require,compile,new,freeze,join,dirname,first,split,basename,to_s,cleanpath,Pathname,fetch,define_method,option_value,key?,[],!,include?,raise,inspect,[]=,compiler_option,attr_reader,attr_accessor,parse,re_raise_with_location,flatten,process,end_with?,code,last,<<,fragment,s,map,to_proc,file,source=,default_parser,tokenize,requirable?,eval?,tap,meta,location,children,associate_locations,eof,magic_comments,to_sym,strip,async_await,async_await_before_typecasting,===,async_await_set_to_regexp,to_a,gsub,escape,location=,opal_location_from_error,path=,label,label=,lines,-,to_i,line,message,set_backtrace,backtrace,add_opal_location_to_error,warn,empty?,+,start_with?,helpers,new_temp,queue_temp,push_while,pop_while,in_while?,nil?,scope,handlers,type,compile_to_fragments,error,returns,updated,==,uses_block!,block_name,find_parent_def,cache,source_map');
  
  self.$require("set");
  self.$require("opal/parser");
  self.$require("opal/fragment");
  self.$require("opal/nodes");
  self.$require("opal/eof_content");
  self.$require("opal/errors");
  self.$require("opal/magic_comments");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$compile', function $$compile(source, options) {
      
      
      
      if (options == null) options = $hash2([], {});;
      return $$('Compiler').$new(source, options).$compile();
    }, -2);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Compiler');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.option_values = $proto.options = $proto.magic_comments = $proto.fragments = $proto.buffer = $proto.source = $proto.source_map = $proto.result = $proto.helpers = $proto.method_calls = $proto.async_await = $proto.unique = $proto.indent = $proto.scope = $proto.case_stmt = $proto.handlers = $proto.requires = $proto.required_trees = $proto.autoloads = nil;
      
      $const_set($nesting[0], 'INDENT', "  ");
      $const_set($nesting[0], 'COMPARE', ["<", ">", "<=", ">="].$freeze());
      $defs(self, '$module_name', function $$module_name(path) {
        var self = this;

        
        path = $$('File').$join($$('File').$dirname(path), $$('File').$basename(path).$split(".").$first());
        return self.$Pathname(path).$cleanpath().$to_s();
      }, 1);
      $defs(self, '$compiler_option', function $$compiler_option(name, config) {
        var self = this, method_name = nil;

        
        
        if (config == null) config = $hash2([], {});;
        method_name = config.$fetch("as", name);
        return $send(self, 'define_method', [method_name], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          return self.$option_value(name, config)}, {$$arity: 0, $$s: self});
      }, -2);
      
      $def(self, '$option_value', function $$option_value(name, config) {
        var $a, self = this, default_value = nil, valid_values = nil, magic_comment = nil, value = nil;

        
        if ($truthy(self.option_values['$key?'](name))) {
          return self.option_values['$[]'](name)
        };
        default_value = config['$[]']("default");
        valid_values = config['$[]']("valid_values");
        magic_comment = config['$[]']("magic_comment");
        value = self.options.$fetch(name, default_value);
        if (($truthy(magic_comment) && ($truthy(self.magic_comments['$key?'](name))))) {
          value = self.magic_comments.$fetch(name)
        };
        if (($truthy(valid_values) && ($not(valid_values['$include?'](value))))) {
          self.$raise($$('ArgumentError'), "" + ("invalid value " + (value.$inspect()) + " for option " + (name.$inspect()) + " ") + ("(valid values: " + (valid_values.$inspect()) + ")"))
        };
        return ($a = [name, value], $send(self.option_values, '[]=', $a), $a[$a.length - 1]);
      }, 2);
      self.$compiler_option("file", $hash2(["default"], {"default": "(file)"}));
      self.$compiler_option("method_missing", $hash2(["default", "as"], {"default": true, "as": "method_missing?"}));
      self.$compiler_option("arity_check", $hash2(["default", "as"], {"default": false, "as": "arity_check?"}));
      self.$compiler_option("freezing", $hash2(["default", "as"], {"default": true, "as": "freezing?"}));
      self.$compiler_option("irb", $hash2(["default", "as"], {"default": false, "as": "irb?"}));
      self.$compiler_option("dynamic_require_severity", $hash2(["default", "valid_values"], {"default": "ignore", "valid_values": ["error", "warning", "ignore"]}));
      self.$compiler_option("requirable", $hash2(["default", "as"], {"default": false, "as": "requirable?"}));
      self.$compiler_option("esm", $hash2(["default", "as"], {"default": false, "as": "esm?"}));
      self.$compiler_option("inline_operators", $hash2(["default", "as"], {"default": true, "as": "inline_operators?"}));
      self.$compiler_option("eval", $hash2(["default", "as"], {"default": false, "as": "eval?"}));
      self.$compiler_option("enable_source_location", $hash2(["default", "as"], {"default": false, "as": "enable_source_location?"}));
      self.$compiler_option("use_strict", $hash2(["default", "as", "magic_comment"], {"default": false, "as": "use_strict?", "magic_comment": true}));
      self.$compiler_option("parse_comments", $hash2(["default", "as"], {"default": false, "as": "parse_comments?"}));
      self.$compiler_option("scope_variables", $hash2(["default"], {"default": []}));
      self.$compiler_option("await", $hash2(["default", "as", "magic_comment"], {"default": false, "as": "async_await", "magic_comment": true}));
      self.$attr_reader("result");
      self.$attr_reader("fragments");
      self.$attr_accessor("scope");
      self.$attr_accessor("top_scope");
      self.$attr_reader("case_stmt");
      self.$attr_reader("eof_content");
      self.$attr_reader("comments");
      self.$attr_reader("method_calls");
      self.$attr_reader("magic_comments");
      self.$attr_accessor("dynamic_cache_result");
      
      $def(self, '$initialize', function $$initialize(source, options) {
        var self = this;

        
        
        if (options == null) options = $hash2([], {});;
        self.source = source;
        self.indent = "";
        self.unique = 0;
        self.options = options;
        self.comments = $$('Hash').$new([]);
        self.case_stmt = nil;
        self.method_calls = $$('Set').$new();
        self.option_values = $hash2([], {});
        self.magic_comments = $hash2([], {});
        return (self.dynamic_cache_result = false);
      }, -2);
      
      $def(self, '$compile', function $$compile() {
        var self = this;

        
        self.$parse();
        self.fragments = $send(self, 're_raise_with_location', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.sexp == null) self.sexp = nil;

          return self.$process(self.sexp).$flatten()}, {$$arity: 0, $$s: self});
        if (!$truthy(self.fragments.$last().$code()['$end_with?']("\n"))) {
          self.fragments['$<<'](self.$fragment("\n", nil, self.$s("newline")))
        };
        return (self.result = $send(self.fragments, 'map', [], "code".$to_proc()).$join(""));
      }, 0);
      
      $def(self, '$parse', function $$parse() {
        var $a, $b, self = this, sexp = nil, comments = nil, tokens = nil, kind = nil, first_node = nil;

        
        self.buffer = $$$($$$($Opal, 'Parser'), 'SourceBuffer').$new(self.$file(), 1);
        self.buffer['$source='](self.source);
        self.parser = $$$($$('Opal'), 'Parser').$default_parser();
        $b = $send(self, 're_raise_with_location', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
          if (self.parser == null) self.parser = nil;
          if (self.buffer == null) self.buffer = nil;

          return self.parser.$tokenize(self.buffer)}, {$$arity: 0, $$s: self}), $a = $to_ary($b), (sexp = ($a[0] == null ? nil : $a[0])), (comments = ($a[1] == null ? nil : $a[1])), (tokens = ($a[2] == null ? nil : $a[2])), $b;
        kind = ($truthy(self['$requirable?']()) ? ("require") : ($truthy(self['$eval?']()) ? ("eval") : ("main")));
        self.sexp = $send(sexp, 'tap', [], function $$4(i){var $c;

          
          
          if (i == null) i = nil;;
          return ($c = ["kind", kind], $send(i.$meta(), '[]=', $c), $c[$c.length - 1]);}, 1);
        if ($truthy(sexp.$children().$first().$location())) {
          first_node = sexp.$children().$first()
        };
        self.comments = $$$($$$($$$('Parser'), 'Source'), 'Comment').$associate_locations(first_node, comments);
        self.magic_comments = $$('MagicComments').$parse(first_node, comments);
        return (self.eof_content = $$('EofContent').$new(tokens, self.source).$eof());
      }, 0);
      
      $def(self, '$source_map', function $$source_map() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_map))) {
          return $ret_or_1
        } else {
          return $$$($$$($Opal, 'SourceMap'), 'File').$new(self.fragments, self.$file(), self.source, self.result)
        }
      }, 0);
      
      $def(self, '$helpers', function $$helpers() {
        var self = this, $ret_or_1 = nil;

        return (self.helpers = ($truthy(($ret_or_1 = self.helpers)) ? ($ret_or_1) : ($$('Set').$new($send(self.$magic_comments()['$[]']("helpers").$to_s().$split(","), 'map', [], function $$5(h){
          
          
          if (h == null) h = nil;;
          return h.$strip().$to_sym();}, 1)))))
      }, 0);
      
      $def(self, '$record_method_call', function $$record_method_call(mid) {
        var self = this;

        return self.method_calls['$<<'](mid)
      }, 1);
      $alias(self, "async_await_before_typecasting", "async_await");
      
      $def(self, '$async_await', function $$async_await() {
        var $a, self = this, original = nil, $ret_or_1 = nil;

        if ($truthy((($a = self['async_await'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          return self.async_await
        } else {
          
          original = self.$async_await_before_typecasting();
          return (self.async_await = ($eqeqeq($$('String'), ($ret_or_1 = original)) ? (self.$async_await_set_to_regexp($send(original.$split(","), 'map', [], function $$6(h){
            
            
            if (h == null) h = nil;;
            return h.$strip().$to_sym();}, 1))) : (($eqeqeq($$('Array'), $ret_or_1) || ($eqeqeq($$('Set'), $ret_or_1))) ? (self.$async_await_set_to_regexp($send(original.$to_a(), 'map', [], "to_sym".$to_proc()))) : (($eqeqeq($$('Regexp'), $ret_or_1) || (($eqeqeq(true, $ret_or_1) || ($eqeqeq(false, $ret_or_1))))) ? (original) : (self.$raise("A value of await compiler option can be either " + "a Set, an Array, a String or a Boolean."))))));
        }
      }, 0);
      
      $def(self, '$async_await_set_to_regexp', function $$async_await_set_to_regexp(set) {
        
        
        set = $send(set, 'map', [], function $$7(name){
          
          
          if (name == null) name = nil;;
          return $$('Regexp').$escape(name.$to_s()).$gsub("\\*", ".*?");}, 1);
        set = set.$join("|");
        return $regexp(["^(", set, ")$"]);
      }, 1);
      
      $def(self, '$error', function $$error(msg, line) {
        var self = this, error = nil;

        
        
        if (line == null) line = nil;;
        error = $$$($Opal, 'SyntaxError').$new(msg);
        error['$location=']($$$($$('Opal'), 'OpalBacktraceLocation').$new(self.$file(), line));
        return self.$raise(error);
      }, -2);
      
      $def(self, '$re_raise_with_location', function $$re_raise_with_location() {
        var $yield = $$re_raise_with_location.$$p || nil, self = this, error = nil, opal_location = nil, $ret_or_1 = nil, new_error = nil;

        delete $$re_raise_with_location.$$p;
        try {
          return Opal.yieldX($yield, []);
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError'), $$$($Opal, 'SyntaxError')])) {(error = $err)
            try {
              
              opal_location = $Opal.$opal_location_from_error(error);
              opal_location['$path='](self.$file());
              if ($truthy(($ret_or_1 = opal_location.$label()))) {
                $ret_or_1
              } else {
                opal_location['$label='](self.source.$lines()['$[]']($rb_minus(opal_location.$line().$to_i(), 1)).$strip())
              };
              new_error = $$$($Opal, 'SyntaxError').$new(error.$message());
              new_error.$set_backtrace(error.$backtrace());
              $Opal.$add_opal_location_to_error(opal_location, new_error);
              return self.$raise(new_error);
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      }, 0);
      
      $def(self, '$warning', function $$warning(msg, line) {
        var self = this;

        
        
        if (line == null) line = nil;;
        return self.$warn("warning: " + (msg) + " -- " + (self.$file()) + ":" + (line));
      }, -2);
      
      $def(self, '$parser_indent', $return_ivar("indent"), 0);
      
      $def(self, '$s', function $$s(type, $a) {
        var $post_args, children;

        
        
        $post_args = Opal.slice.call(arguments, 1);
        
        children = $post_args;;
        return $$$($$$($Opal, 'AST'), 'Node').$new(type, children);
      }, -2);
      
      $def(self, '$fragment', function $$fragment(str, scope, sexp) {
        
        
        
        if (sexp == null) sexp = nil;;
        return $$('Fragment').$new(str, scope, sexp);
      }, -3);
      
      $def(self, '$unique_temp', function $$unique_temp(name) {
        var self = this, unique = nil;

        
        name = name.$to_s();
        if (($truthy(name) && ($not(name['$empty?']())))) {
          name = name.$to_s().$gsub("<=>", "$lt_eq_gt").$gsub("===", "$eq_eq_eq").$gsub("==", "$eq_eq").$gsub("=~", "$eq_tilde").$gsub("!~", "$excl_tilde").$gsub("!=", "$not_eq").$gsub("<=", "$lt_eq").$gsub(">=", "$gt_eq").$gsub("=", "$eq").$gsub("?", "$ques").$gsub("!", "$excl").$gsub("/", "$slash").$gsub("%", "$percent").$gsub("+", "$plus").$gsub("-", "$minus").$gsub("<", "$lt").$gsub(">", "$gt").$gsub(/[^\w\$]/, "$")
        };
        unique = (self.unique = $rb_plus(self.unique, 1));
        return "" + (($truthy(name['$start_with?']("$")) ? (nil) : ("$"))) + (name) + "$" + (unique);
      }, 1);
      
      $def(self, '$helper', function $$helper(name) {
        var self = this;

        return self.$helpers()['$<<'](name)
      }, 1);
      
      $def(self, '$indent', function $$indent() {
        var $yield = $$indent.$$p || nil, self = this, indent = nil, res = nil;

        delete $$indent.$$p;
        
        indent = self.indent;
        self.indent = $rb_plus(self.indent, $$('INDENT'));
        self.space = "\n" + (self.indent);
        res = Opal.yieldX($yield, []);
        self.indent = indent;
        self.space = "\n" + (self.indent);
        return res;
      }, 0);
      
      $def(self, '$with_temp', function $$with_temp() {
        var $yield = $$with_temp.$$p || nil, self = this, tmp = nil, res = nil;

        delete $$with_temp.$$p;
        
        tmp = self.scope.$new_temp();
        res = Opal.yield1($yield, tmp);
        self.scope.$queue_temp(tmp);
        return res;
      }, 0);
      
      $def(self, '$in_while', function $$in_while() {
        var $yield = $$in_while.$$p || nil, self = this, result = nil;

        delete $$in_while.$$p;
        
        if (!($yield !== nil)) {
          return nil
        };
        self.while_loop = self.scope.$push_while();
        result = Opal.yieldX($yield, []);
        self.scope.$pop_while();
        return result;
      }, 0);
      
      $def(self, '$in_case', function $$in_case() {
        var $yield = $$in_case.$$p || nil, self = this, old = nil;

        delete $$in_case.$$p;
        
        if (!($yield !== nil)) {
          return nil
        };
        old = self.case_stmt;
        self.case_stmt = $hash2([], {});
        Opal.yieldX($yield, []);
        return (self.case_stmt = old);
      }, 0);
      
      $def(self, '$in_while?', function $Compiler_in_while$ques$8() {
        var self = this;

        return self.scope['$in_while?']()
      }, 0);
      
      $def(self, '$process', function $$process(sexp, level) {
        var self = this, handler = nil;

        
        
        if (level == null) level = "expr";;
        if ($truthy(sexp['$nil?']())) {
          return self.$fragment("", self.$scope())
        };
        if ($truthy((handler = self.$handlers()['$[]'](sexp.$type())))) {
          return handler.$new(sexp, level, self).$compile_to_fragments()
        } else {
          return self.$error("Unsupported sexp: " + (sexp.$type()))
        };
      }, -2);
      
      $def(self, '$handlers', function $$handlers() {
        var self = this, $ret_or_1 = nil;

        return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ($$$($$$($$('Opal'), 'Nodes'), 'Base').$handlers())))
      }, 0);
      
      $def(self, '$requires', function $$requires() {
        var self = this, $ret_or_1 = nil;

        return (self.requires = ($truthy(($ret_or_1 = self.requires)) ? ($ret_or_1) : ([])))
      }, 0);
      
      $def(self, '$required_trees', function $$required_trees() {
        var self = this, $ret_or_1 = nil;

        return (self.required_trees = ($truthy(($ret_or_1 = self.required_trees)) ? ($ret_or_1) : ([])))
      }, 0);
      
      $def(self, '$autoloads', function $$autoloads() {
        var self = this, $ret_or_1 = nil;

        return (self.autoloads = ($truthy(($ret_or_1 = self.autoloads)) ? ($ret_or_1) : ([])))
      }, 0);
      
      $def(self, '$returns', function $$returns(sexp) {
        var $a, $b, self = this, when_sexp = nil, then_sexp = nil, body_sexp = nil, resbodies = nil, else_sexp = nil, klass = nil, lvar = nil, body = nil, rescue_sexp = nil, ensure_body = nil, rest = nil, last = nil, cond = nil, true_body = nil, false_body = nil;

        
        if (!$truthy(sexp)) {
          return self.$returns(self.$s("nil"))
        };
        
        switch (sexp.$type()) {
          case "undef":
            return self.$returns(sexp.$updated("begin", [sexp, self.$s("nil")]))
          case "break":
          case "next":
          case "redo":
          case "retry":
            return sexp
          case "yield":
            return sexp.$updated("returnable_yield", nil)
          case "when":
            
            $a = [].concat($to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_sexp = $slice.call($a, 0, $b)), (then_sexp = ($a[$b] == null ? nil : $a[$b])), $a;
            return sexp.$updated(nil, [].concat($to_a(when_sexp)).concat([self.$returns(then_sexp)]));
          case "rescue":
            
            $a = [].concat($to_a(sexp)), (body_sexp = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (resbodies = $slice.call($a, 1, $b)), (else_sexp = ($a[$b] == null ? nil : $a[$b])), $a;
            resbodies = $send(resbodies, 'map', [], function $$9(resbody){var self = $$9.$$s == null ? this : $$9.$$s;

              
              
              if (resbody == null) resbody = nil;;
              return self.$returns(resbody);}, {$$arity: 1, $$s: self});
            if ($truthy(else_sexp)) {
              else_sexp = self.$returns(else_sexp)
            };
            return sexp.$updated(nil, [self.$returns(body_sexp)].concat($to_a(resbodies)).concat([else_sexp]));
          case "resbody":
            
            $a = [].concat($to_a(sexp)), (klass = ($a[0] == null ? nil : $a[0])), (lvar = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
            return sexp.$updated(nil, [klass, lvar, self.$returns(body)]);
          case "ensure":
            
            $a = [].concat($to_a(sexp)), (rescue_sexp = ($a[0] == null ? nil : $a[0])), (ensure_body = ($a[1] == null ? nil : $a[1])), $a;
            sexp = sexp.$updated(nil, [self.$returns(rescue_sexp), ensure_body]);
            return sexp.$updated("js_return", [sexp]);
          case "begin":
          case "kwbegin":
            
            $a = [].concat($to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (rest = $slice.call($a, 0, $b)), (last = ($a[$b] == null ? nil : $a[$b])), $a;
            return sexp.$updated(nil, [].concat($to_a(rest)).concat([self.$returns(last)]));
          case "while":
          case "until":
          case "while_post":
          case "until_post":
            return sexp
          case "return":
          case "js_return":
          case "returnable_yield":
            return sexp
          case "xstr":
            return sexp.$updated(nil, [$send(self, 's', ["js_return"].concat($to_a(sexp.$children())))])
          case "if":
            
            $a = [].concat($to_a(sexp)), (cond = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
            return sexp.$updated(nil, [cond, self.$returns(true_body), self.$returns(false_body)]);
          default:
            if (($eqeq(sexp.$type(), "send") && ($eqeq(sexp.$children()['$[]'](1), "debugger")))) {
              return sexp.$updated("begin", [sexp, self.$s("js_return", self.$s("nil"))])
            } else {
              return sexp.$updated("js_return", [sexp])
            }
        };
      }, 1);
      
      $def(self, '$handle_block_given_call', function $$handle_block_given_call(sexp) {
        var self = this, scope = nil;

        
        self.scope['$uses_block!']();
        if ($truthy(self.scope.$block_name())) {
          return self.$fragment("(" + (self.scope.$block_name()) + " !== nil)", self.$scope(), sexp)
        } else if (($truthy((scope = self.scope.$find_parent_def())) && ($truthy(scope.$block_name())))) {
          return self.$fragment("(" + (scope.$block_name()) + " !== nil)", scope, sexp)
        } else {
          return self.$fragment("false", scope, sexp)
        };
      }, 1);
      
      $def(self, '$marshal_dump', function $$marshal_dump() {
        var self = this, $ret_or_1 = nil;

        return [self.options, self.option_values, (self.source_map = ($truthy(($ret_or_1 = self.source_map)) ? ($ret_or_1) : (self.$source_map().$cache()))), self.magic_comments, self.result, self.required_trees, self.requires, self.autoloads]
      }, 0);
      return $def(self, '$marshal_load', function $$marshal_load(src) {
        var $a, $b, self = this;

        return $b = src, $a = $to_ary($b), (self.options = ($a[0] == null ? nil : $a[0])), (self.option_values = ($a[1] == null ? nil : $a[1])), (self.source_map = ($a[2] == null ? nil : $a[2])), (self.magic_comments = ($a[3] == null ? nil : $a[3])), (self.result = ($a[4] == null ? nil : $a[4])), (self.required_trees = ($a[5] == null ? nil : $a[5])), (self.requires = ($a[6] == null ? nil : $a[6])), (self.autoloads = ($a[7] == null ? nil : $a[7])), $b
      }, 1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["opal/erb"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $regexp = Opal.regexp;

  Opal.add_stubs('require,compile,new,freeze,fix_quotes,find_contents,find_code,wrap_compiled,require_erb,prepared_source,gsub,+,last_match,=~,sub');
  
  self.$require("opal/compiler");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'ERB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$compile', function $$compile(source, file_name) {
        
        
        
        if (file_name == null) file_name = "(erb)";;
        return $$('Compiler').$new(source, file_name).$compile();
      }, -2);
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Compiler');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.prepared_source = $proto.source = $proto.file_name = nil;
        
        $const_set($nesting[0], 'BLOCK_EXPR', /\s+(do|\{)(\s*\|[^|]*\|)?\s*\Z/.$freeze());
        
        $def(self, '$initialize', function $$initialize(source, file_name) {
          var $a, self = this;

          
          
          if (file_name == null) file_name = "(erb)";;
          return $a = [source, file_name, source], (self.source = $a[0]), (self.file_name = $a[1]), (self.result = $a[2]), $a;
        }, -2);
        
        $def(self, '$prepared_source', function $$prepared_source() {
          var self = this, $ret_or_1 = nil, source = nil;

          return (self.prepared_source = ($truthy(($ret_or_1 = self.prepared_source)) ? ($ret_or_1) : (((source = self.source), (source = self.$fix_quotes(source)), (source = self.$find_contents(source)), (source = self.$find_code(source)), (source = self.$wrap_compiled(source)), (source = self.$require_erb(source)), source))))
        }, 0);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return $$('Opal').$compile(self.$prepared_source())
        }, 0);
        
        $def(self, '$fix_quotes', function $$fix_quotes(result) {
          
          return result.$gsub("\"", "\\\"")
        }, 1);
        
        $def(self, '$require_erb', function $$require_erb(result) {
          
          return $rb_plus("require \"erb\";", result)
        }, 1);
        
        $def(self, '$find_contents', function $$find_contents(result) {
          
          return $send(result, 'gsub', [/<%=([\s\S]+?)%>/], function $$1(){var inner = nil;

            
            inner = $$('Regexp').$last_match(1).$gsub(/\\'/, "'").$gsub(/\\"/, "\"");
            if ($truthy(inner['$=~']($$('BLOCK_EXPR')))) {
              return "\")\noutput_buffer.append= " + (inner) + "\noutput_buffer.append(\""
            } else {
              return "\")\noutput_buffer.append=(" + (inner) + ")\noutput_buffer.append(\""
            };}, 0)
        }, 1);
        
        $def(self, '$find_code', function $$find_code(result) {
          
          return $send(result, 'gsub', [/<%([\s\S]+?)%>/], function $$2(){var inner = nil;

            
            inner = $$('Regexp').$last_match(1).$gsub(/\\"/, "\"");
            return "\")\n" + (inner) + "\noutput_buffer.append(\"";}, 0)
        }, 1);
        return $def(self, '$wrap_compiled', function $$wrap_compiled(result) {
          var self = this, path = nil;

          
          path = self.file_name.$sub($regexp(["\\.opalerb", $$('REGEXP_END')]), "");
          return "Template.new('" + (path) + "') do |output_buffer|\noutput_buffer.append(\"" + (result) + "\")\noutput_buffer.join\nend\n";
        }, 1);
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["opal/builder_processors"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $def = Opal.def, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $to_a = Opal.to_a;

  Opal.add_stubs('require,end_with?,+,dup,delete,cache,attr_reader,to_s,source,join,==,size,new,register_processor,is_a?,match,match_regexp,raise,inspect,handles,map,with_index,each_line,index,filename,mark_as_required,result,compiled,source_map,fetch,cache_key,compiler_for,compile,class,merge,requires,required_trees,autoloads,extname,prepare,private,prepared_source,module_name');
  
  self.$require("opal/compiler");
  self.$require("opal/erb");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'BuilderProcessors');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Processor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.options = nil;
        
        
        $def(self, '$initialize', function $$initialize(source, filename, options) {
          var $a, self = this;

          
          
          if (options == null) options = $hash2([], {});;
          if (!$truthy(source['$end_with?']("\n"))) {
            source = $rb_plus(source, "\n")
          };
          $a = [source, filename, options.$dup()], (self.source = $a[0]), (self.filename = $a[1]), (self.options = $a[2]), $a;
          self.cache = $send(self.options, 'delete', ["cache"], function $$1(){
            return $$('Opal').$cache()}, 0);
          self.requires = [];
          self.required_trees = [];
          return (self.autoloads = []);
        }, -3);
        self.$attr_reader("source", "filename", "options", "requires", "required_trees", "autoloads");
        
        $def(self, '$to_s', function $$to_s() {
          var self = this;

          return self.$source().$to_s()
        }, 0);
        (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          self.$attr_reader("extensions");
          
          $def(self, '$handles', function $$handles($a) {
            var $post_args, extensions, self = this, matches = nil;

            
            
            $post_args = Opal.slice.call(arguments);
            
            extensions = $post_args;;
            self.extensions = extensions;
            matches = extensions.$join("|");
            if (!$eqeq(extensions.$size(), 1)) {
              matches = "(" + (matches) + ")"
            };
            self.match_regexp = $$('Regexp').$new("\\." + (matches) + ($$('REGEXP_END')));
            $$$($Opal, 'Builder').$register_processor(self, extensions);
            return nil;
          }, -1);
          
          $def(self, '$match?', function $match$ques$2(other) {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = other['$is_a?']($$('String'))))) {
              return other.$match(self.$match_regexp())
            } else {
              return $ret_or_1
            }
          }, 1);
          return $def(self, '$match_regexp', function $$match_regexp() {
            var self = this, $ret_or_1 = nil;
            if (self.match_regexp == null) self.match_regexp = nil;

            if ($truthy(($ret_or_1 = self.match_regexp))) {
              return $ret_or_1
            } else {
              return self.$raise($$('NotImplementedError'))
            }
          }, 0);
        })(Opal.get_singleton_class(self), $nesting);
        return $def(self, '$mark_as_required', function $$mark_as_required(filename) {
          
          return "Opal.loaded([" + (filename.$to_s().$inspect()) + "]);"
        }, 1);
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'JsProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.source_map = $proto.source = $proto.filename = nil;
        
        self.$handles("js");
        $const_set($nesting[0], 'ManualFragment', $$('Struct').$new("line", "column", "code", "source_map_name"));
        
        $def(self, '$source_map', function $$source_map() {
          var self = this, $ret_or_1 = nil, manual_fragments = nil;

          return (self.source_map = ($truthy(($ret_or_1 = self.source_map)) ? ($ret_or_1) : (((manual_fragments = $send(self.$source().$each_line().$with_index(), 'map', [], function $$3(line_source, index){var column = nil, line = nil;

            
            
            if (line_source == null) line_source = nil;;
            
            if (index == null) index = nil;;
            column = line_source.$index(/\S/);
            line = $rb_plus(index, 1);
            return $$('ManualFragment').$new(line, column, line_source, nil);}, 2)), $$$($$$($Opal, 'SourceMap'), 'File').$new(manual_fragments, self.$filename(), self.$source())))))
        }, 0);
        return $def(self, '$source', function $$source() {
          var self = this;

          return $rb_plus(self.source.$to_s(), self.$mark_as_required(self.filename))
        }, 0);
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RubyProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.compiled = $proto.cache = $proto.filename = $proto.source = $proto.options = nil;
        
        self.$handles("rb", "opal");
        
        $def(self, '$source', function $$source() {
          var self = this;

          return self.$compiled().$result()
        }, 0);
        
        $def(self, '$source_map', function $$source_map() {
          var self = this;

          return self.$compiled().$source_map()
        }, 0);
        
        $def(self, '$compiled', function $$compiled() {
          var self = this, $ret_or_1 = nil;

          return (self.compiled = ($truthy(($ret_or_1 = self.compiled)) ? ($ret_or_1) : ($send($$$($$('Opal'), 'Cache'), 'fetch', [self.cache, self.$cache_key()], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s, compiler = nil;
            if (self.source == null) self.source = nil;
            if (self.filename == null) self.filename = nil;

            
            compiler = self.$compiler_for(self.source, $hash2(["file"], {"file": self.filename}));
            compiler.$compile();
            return compiler;}, {$$arity: 0, $$s: self}))))
        }, 0);
        
        $def(self, '$cache_key', function $$cache_key() {
          var self = this;

          return [self.$class(), self.filename, self.source, self.options]
        }, 0);
        
        $def(self, '$compiler_for', function $$compiler_for(source, options) {
          var self = this;

          
          
          if (options == null) options = $hash2([], {});;
          return $$$($Opal, 'Compiler').$new(source, self.options.$merge(options));
        }, -2);
        
        $def(self, '$requires', function $$requires() {
          var self = this;

          return self.$compiled().$requires()
        }, 0);
        
        $def(self, '$required_trees', function $$required_trees() {
          var self = this;

          return self.$compiled().$required_trees()
        }, 0);
        
        $def(self, '$autoloads', function $$autoloads() {
          var self = this;

          return self.$compiled().$autoloads()
        }, 0);
        return $defs(self, '$match?', function $RubyProcessor_match$ques$5(other) {
          var $yield = $RubyProcessor_match$ques$5.$$p || nil, self = this, $ret_or_1 = nil;

          delete $RubyProcessor_match$ques$5.$$p;
          if ($truthy(($ret_or_1 = $send2(self, $find_super(self, 'match?', $RubyProcessor_match$ques$5, false, true), 'match?', [other], $yield)))) {
            return $ret_or_1
          } else {
            return $$('File').$extname(other.$to_s())['$==']("")
          }
        }, 1);
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'OpalERBProcessor');

        var $proto = self.$$prototype;

        $proto.source = $proto.filename = nil;
        
        self.$handles("opalerb");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, args, $yield = $$initialize.$$p || nil, self = this;

          delete $$initialize.$$p;
          
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a(args), $yield);
          return (self.source = self.$prepare(self.source, self.filename));
        }, -1);
        
        $def(self, '$requires', function $$requires() {
          var $yield = $$requires.$$p || nil, self = this;

          delete $$requires.$$p;
          return $rb_plus(["erb"], $send2(self, $find_super(self, 'requires', $$requires, false, true), 'requires', [], $yield))
        }, 0);
        self.$private();
        return $def(self, '$prepare', function $$prepare(source, path) {
          
          return $$$($$$($Opal, 'ERB'), 'Compiler').$new(source, path).$prepared_source()
        }, 2);
      })($nesting[0], $$('RubyProcessor'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ERBProcessor');

        var $proto = self.$$prototype;

        $proto.source = $proto.filename = nil;
        
        self.$handles("erb");
        return $def(self, '$source', function $$source() {
          var self = this, result = nil, module_name = nil;

          
          result = $$$('ERB').$new(self.source.$to_s()).$result();
          module_name = $$$($Opal, 'Compiler').$module_name(self.filename);
          return "Opal.modules[" + (module_name.$inspect()) + "] = function() {" + (result) + "};";
        }, 0);
      })($nesting[0], $$('Processor'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    }, 1);
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, 1);
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    }, 1);
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    }, 1);
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, 1);
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

Opal.modules["corelib/pack_unpack/format_string_parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $Kernel = Opal.Kernel;

  Opal.add_stubs('raise');
  return (function($base) {
    var self = $module($base, 'PackUnpack');

    
    
    var directives = [
      // Integer
      'C',
      'S',
      'L',
      'Q',
      'J',

      'c',
      's',
      'l',
      'q',
      'j',

      'n',
      'N',
      'v',
      'V',

      'U',
      'w',

      // Float
      'D',
      'd',
      'F',
      'f',
      'E',
      'e',
      'G',
      'g',

      // String
      'A',
      'a',
      'Z',
      'B',
      'b',
      'H',
      'h',
      'u',
      'M',
      'm',

      'P',
      'p',

      // Misc
      '@',
      'X',
      'x'
    ];

    var modifiers = [
      '!', // ignored
      '_', // ignored
      '>', // big endian
      '<'  // little endian
    ];

    self.eachDirectiveAndCount = function(format, callback) {
      var currentDirective,
          currentCount,
          currentModifiers,
          countSpecified;

      function reset() {
        currentDirective = null;
        currentCount = 0;
        currentModifiers = [];
        countSpecified = false;
      }

      reset();

      function yieldAndReset() {
        if (currentDirective == null) {
          reset();
          return;
        }

        var directiveSupportsModifiers = /[sSiIlLqQjJ]/.test(currentDirective);

        if (!directiveSupportsModifiers && currentModifiers.length > 0) {
          $Kernel.$raise($$$('ArgumentError'), "'" + (currentModifiers[0]) + "' allowed only after types sSiIlLqQjJ")
        }

        if (currentModifiers.indexOf('<') !== -1 && currentModifiers.indexOf('>') !== -1) {
          $Kernel.$raise($$$('RangeError'), "Can't use both '<' and '>'")
        }

        if (!countSpecified) {
          currentCount = 1;
        }

        if (currentModifiers.indexOf('>') !== -1) {
          currentDirective = currentDirective + '>';
        }

        callback(currentDirective, currentCount);

        reset();
      }

      for (var i = 0; i < format.length; i++) {
        var currentChar = format[i];

        if (directives.indexOf(currentChar) !== -1) {
          // Directive char always resets current state
          yieldAndReset();
          currentDirective = currentChar;
        } else if (currentDirective) {
          if (/\d/.test(currentChar)) {
            // Count can be represented as a sequence of digits
            currentCount = currentCount * 10 + parseInt(currentChar, 10);
            countSpecified = true;
          } else if (currentChar === '*' && countSpecified === false) {
            // Count can be represented by a star character
            currentCount = Infinity;
            countSpecified = true;
          } else if (modifiers.indexOf(currentChar) !== -1 && countSpecified === false) {
            // Directives can be specified only after directive and before count
            currentModifiers.push(currentChar);
          } else {
            yieldAndReset();
          }
        }
      }

      yieldAndReset();
    }
  
  })('::')
};

Opal.modules["corelib/string/unpack"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $Opal = Opal.Opal, $rb_gt = Opal.rb_gt, $def = Opal.def;

  Opal.add_stubs('require,flatten,decode64,raise,<,delete,gsub,coerce_to!,>,length,inspect,[],unpack');
  
  self.$require("base64");
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), expected = nil, given = nil;

    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function flattenArray(callback) {
      return function(data) {
        var array = callback(data);
        return (array).$flatten();
      }
    }

    function mapChunksToWords(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse().reduce(function(result, singleByte) {
            return result * 256 + singleByte;
          }, 0);
        });
      }
    }

    function chunkBy(chunkSize, callback) {
      return function(data) {
        var array = callback(data),
            chunks = [],
            chunksCount = (array.length / chunkSize);

        for (var i = 0; i < chunksCount; i++) {
          var chunk = array.splice(0, chunkSize);
          if (chunk.length === chunkSize) {
            chunks.push(chunk);
          }
        }

        return chunks;
      }
    }

    function toNByteSigned(bytesCount, callback) {
      return function(data) {
        var unsignedBits = callback(data),
            bitsCount = bytesCount * 8,
            limit = Math.pow(2, bitsCount);

        return unsignedBits.map(function(n) {
          if (n >= limit / 2) {
            n -= limit;
          }

          return n;
        });
      }
    }

    function bytesToAsciiChars(callback) {
      return function(data) {
        var bytes = callback(data);

        return bytes.map(function(singleByte) {
          return String.fromCharCode(singleByte);
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var chars = callback(data);
        return chars.join('');
      }
    }

    function wrapIntoArray(callback) {
      return function(data) {
        var object = callback(data);
        return [object];
      }
    }

    function filterTrailingChars(chars) {
      var charCodesToFilter = chars.map(function(s) { return s.charCodeAt(0); });

      return function(callback) {
        return function(data) {
          var charCodes = callback(data);

          while (charCodesToFilter.indexOf(charCodes[charCodes.length - 1]) !== -1) {
            charCodes = charCodes.slice(0, charCodes.length - 1);
          }

          return charCodes;
        }
      }
    }

    var filterTrailingZerosAndSpaces = filterTrailingChars(["\u0000", " "]);

    function invertChunks(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse();
        });
      }
    }

    function uudecode(callback) {
      return function(data) {
        var bytes = callback(data);

        var stop = false;
        var i = 0, length = 0;

        var result = [];

        do {
          if (i < bytes.length) {
            var n = bytes[i] - 32 & 0x3F;

            ++i;

            if (bytes[i] === 10) {
              continue;
            }

            if (n > 45) {
              return '';
            }

            length += n;

            while (n > 0) {
              var c1 = bytes[i];
              var c2 = bytes[i + 1];
              var c3 = bytes[i + 2];
              var c4 = bytes[i + 3];

              var b1 = (c1 - 32 & 0x3F) << 2 | (c2 - 32 & 0x3F) >> 4;
              var b2 = (c2 - 32 & 0x3F) << 4 | (c3 - 32 & 0x3F) >> 2;
              var b3 = (c3 - 32 & 0x3F) << 6 | c4 - 32 & 0x3F;

              result.push(b1 & 0xFF);
              result.push(b2 & 0xFF);
              result.push(b3 & 0xFF);

              i += 4;
              n -= 3;
            }

            ++i;
          } else {
            break;
          }
        } while (true);

        return result.slice(0, length);
      }
    }

    function toBits(callback) {
      return function(data) {
        var bytes = callback(data);

        var bits = bytes.map(function(singleByte) {
          return singleByte.toString(2);
        });

        return bits;
      }
    }

    function decodeBERCompressedIntegers(callback) {
      return function(data) {
        var bytes = callback(data), result = [], buffer = '';

        for (var i = 0; i < bytes.length; i++) {
          var singleByte = bytes[i],
              bits = singleByte.toString(2);

          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          var firstBit = bits[0];
          bits = bits.slice(1, bits.length);

          buffer = buffer.concat(bits);

          if (firstBit === '0') {
            var decoded = parseInt(buffer, 2);
            result.push(decoded);
            buffer = ''
          }
        }

        return result;
      }
    }

    function base64Decode(callback) {
      return function(data) {
        return $$('Base64').$decode64(callback(data));
      }
    }

    // quoted-printable decode
    function qpdecode(callback) {
      return function(data) {
        var string = callback(data);

        return string
          .replace(/[\t\x20]$/gm, '')
          .replace(/=(?:\r\n?|\n|$)/g, '')
          .replace(/=([a-fA-F0-9]{2})/g, function($0, $1) {
            var codePoint = parseInt($1, 16);
            return String.fromCharCode(codePoint);
          });
      }
    }

    function identityFunction(value) { return value; }

    var handlers = {
      // Integer
      'C': identityFunction,
      'S': mapChunksToWords(chunkBy(2, identityFunction)),
      'L': mapChunksToWords(chunkBy(4, identityFunction)),
      'Q': mapChunksToWords(chunkBy(8, identityFunction)),
      'J': null,

      'S>': mapChunksToWords(invertChunks(chunkBy(2, identityFunction))),
      'L>': mapChunksToWords(invertChunks(chunkBy(4, identityFunction))),
      'Q>': mapChunksToWords(invertChunks(chunkBy(8, identityFunction))),

      'c': toNByteSigned(1, identityFunction),
      's': toNByteSigned(2, mapChunksToWords(chunkBy(2, identityFunction))),
      'l': toNByteSigned(4, mapChunksToWords(chunkBy(4, identityFunction))),
      'q': toNByteSigned(8, mapChunksToWords(chunkBy(8, identityFunction))),
      'j': null,

      's>': toNByteSigned(2, mapChunksToWords(invertChunks(chunkBy(2, identityFunction)))),
      'l>': toNByteSigned(4, mapChunksToWords(invertChunks(chunkBy(4, identityFunction)))),
      'q>': toNByteSigned(8, mapChunksToWords(invertChunks(chunkBy(8, identityFunction)))),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': identityFunction,
      'w': decodeBERCompressedIntegers(identityFunction),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': wrapIntoArray(joinChars(bytesToAsciiChars(filterTrailingZerosAndSpaces(identityFunction)))),
      'a': wrapIntoArray(joinChars(bytesToAsciiChars(identityFunction))),
      'Z': joinChars(bytesToAsciiChars(identityFunction)),
      'B': joinChars(identityFunction),
      'b': joinChars(identityFunction),
      'H': joinChars(identityFunction),
      'h': joinChars(identityFunction),
      'u': joinChars(bytesToAsciiChars(uudecode(identityFunction))),
      'M': qpdecode(joinChars(bytesToAsciiChars(identityFunction))),
      'm': base64Decode(joinChars(bytesToAsciiChars(identityFunction))),

      'P': null,
      'p': null
    };

    function readBytes(n) {
      return function(bytes) {
        var chunk = bytes.slice(0, n);
        bytes = bytes.slice(n, bytes.length);
        return { chunk: chunk, rest: bytes };
      }
    }

    function readUnicodeCharChunk(bytes) {
      var currentByteIndex = 0;
      var bytesLength = bytes.length;
      function readByte() {
        var result = bytes[currentByteIndex++];
        bytesLength = bytes.length - currentByteIndex;
        return result;
      }

      var c = readByte(), extraLength;

      if (c >> 7 == 0) {
        // 0xxx xxxx
        return { chunk: [c], rest: bytes.slice(currentByteIndex) };
      }

      if (c >> 6 == 0x02) {
        $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character")
      }

      if (c >> 5 == 0x06) {
        // 110x xxxx (two bytes)
        extraLength = 1;
      } else if (c >> 4 == 0x0e) {
        // 1110 xxxx (three bytes)
        extraLength = 2;
      } else if (c >> 3 == 0x1e) {
        // 1111 0xxx (four bytes)
        extraLength = 3;
      } else if (c >> 2 == 0x3e) {
        // 1111 10xx (five bytes)
        extraLength = 4;
      } else if (c >> 1 == 0x7e) {
        // 1111 110x (six bytes)
        extraLength = 5;
      } else {
        $Kernel.$raise("malformed UTF-8 character")
      }

      if (extraLength > bytesLength) {
        ((expected = extraLength + 1), (given = bytesLength + 1), $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character (expected " + (expected) + " bytes, given " + (given) + " bytes)"))
      }

      // Remove the UTF-8 prefix from the char
      var mask = (1 << (8 - extraLength - 1)) - 1,
          result = c & mask;

      for (var i = 0; i < extraLength; i++) {
        c = readByte();

        if (c >> 6 != 0x02) {
          $Kernel.$raise("Invalid multibyte sequence")
        }

        result = (result << 6) | (c & 0x3f);
      }

      if (result <= 0xffff) {
        return { chunk: [result], rest: bytes.slice(currentByteIndex) };
      } else {
        result -= 0x10000;
        var high = ((result >> 10) & 0x3ff) + 0xd800,
            low = (result & 0x3ff) + 0xdc00;
        return { chunk: [high, low], rest: bytes.slice(currentByteIndex) };
      }
    }

    function readUuencodingChunk(buffer) {
      var length = buffer.indexOf(32); // 32 = space

      if (length === -1) {
        return { chunk: buffer, rest: [] };
      } else {
        return { chunk: buffer.slice(0, length), rest: buffer.slice(length, buffer.length) };
      }
    }

    function readNBitsLSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits).split('').reverse().join('');

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readNBitsMSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readWhileFirstBitIsOne(buffer) {
      var result = [];

      for (var i = 0; i < buffer.length; i++) {
        var singleByte = buffer[i];

        result.push(singleByte);

        if ((singleByte & 128) === 0) {
          break;
        }
      }

      return { chunk: result, rest: buffer.slice(result.length, buffer.length) };
    }

    function readTillNullCharacter(buffer, count) {
      var result = [];

      for (var i = 0; i < count && i < buffer.length; i++) {
        var singleByte = buffer[i];

        if (singleByte === 0) {
          break;
        } else {
          result.push(singleByte);
        }
      }

      if (count === Infinity) {
        count = result.length;
      }

      if (buffer[count] === 0) {
        count++;
      }

      buffer = buffer.slice(count, buffer.length);

      return { chunk: result, rest: buffer };
    }

    function readHexCharsHighNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[0]);
          count--;
        } else {
          result.push(hex[0], hex[1]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readHexCharsLowNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[1]);
          count--;
        } else {
          result.push(hex[1], hex[0]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readNTimesAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readAll(buffer, count) {
      return { chunk: buffer, rest: [] };
    }

    var readChunk = {
      // Integer
      'C': readNTimesAndMerge(readBytes(1)),
      'S': readNTimesAndMerge(readBytes(2)),
      'L': readNTimesAndMerge(readBytes(4)),
      'Q': readNTimesAndMerge(readBytes(8)),
      'J': null,

      'S>': readNTimesAndMerge(readBytes(2)),
      'L>': readNTimesAndMerge(readBytes(4)),
      'Q>': readNTimesAndMerge(readBytes(8)),

      'c': readNTimesAndMerge(readBytes(1)),
      's': readNTimesAndMerge(readBytes(2)),
      'l': readNTimesAndMerge(readBytes(4)),
      'q': readNTimesAndMerge(readBytes(8)),
      'j': null,

      's>': readNTimesAndMerge(readBytes(2)),
      'l>': readNTimesAndMerge(readBytes(4)),
      'q>': readNTimesAndMerge(readBytes(8)),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': readNTimesAndMerge(readUnicodeCharChunk),
      'w': readNTimesAndMerge(readWhileFirstBitIsOne),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNTimesAndMerge(readBytes(1)),
      'a': readNTimesAndMerge(readBytes(1)),
      'Z': readTillNullCharacter,
      'B': readNBitsMSBFirst,
      'b': readNBitsLSBFirst,
      'H': readHexCharsHighNibbleFirst,
      'h': readHexCharsLowNibbleFirst,
      'u': readNTimesAndMerge(readUuencodingChunk),
      'M': readAll,
      'm': readAll,

      'P': null,
      'p': null
    }

    var autocompletion = {
      // Integer
      'C': true,
      'S': true,
      'L': true,
      'Q': true,
      'J': null,

      'S>': true,
      'L>': true,
      'Q>': true,

      'c': true,
      's': true,
      'l': true,
      'q': true,
      'j': null,

      's>': true,
      'l>': true,
      'q>': true,

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': false,
      'w': false,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': false,
      'B': false,
      'b': false,
      'H': false,
      'h': false,
      'u': false,
      'M': false,
      'm': false,

      'P': null,
      'p': null
    }

    var optimized = {
      'C*': handlers['C'],
      'c*': handlers['c'],
      'A*': handlers['A'],
      'a*': handlers['a'],
      'M*': wrapIntoArray(handlers['M']),
      'm*': wrapIntoArray(handlers['m']),
      'S*': handlers['S'],
      's*': handlers['s'],
      'L*': handlers['L'],
      'l*': handlers['l'],
      'Q*': handlers['Q'],
      'q*': handlers['q'],
      'S>*': handlers['S>'],
      's>*': handlers['s>'],
      'L>*': handlers['L>'],
      'l>*': handlers['l>'],
      'Q>*': handlers['Q>'],
      'q>*': handlers['q>']
    }

    function alias(existingDirective, newDirective) {
      readChunk[newDirective] = readChunk[existingDirective];
      handlers[newDirective] = handlers[existingDirective];
      autocompletion[newDirective] = autocompletion[existingDirective];
    }

    alias('S>', 'n');
    alias('L>', 'N');

    alias('S', 'v');
    alias('L', 'V');
  ;
    
    $def(self, '$unpack', function $$unpack(format, $kwargs) {
      var offset, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      offset = $kwargs.$$smap["offset"];
      if (offset == null) offset = 0;
      if ($truthy($rb_lt(offset, 0))) {
        $Kernel.$raise($$$('ArgumentError'), "offset can't be negative")
      };
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = [];

      // A very optimized handler for U*.
      if (format == "U*" &&
          self.internal_encoding.name === "UTF-8" &&
          typeof self.codePointAt === "function") {

        var cp, j = 0;

        output = new Array(self.length);
        for (var i = offset; i < self.length; i++) {
          cp = output[j++] = self.codePointAt(i);
          if (cp > 0xffff) i++;
        }
        return output.slice(0, j);
      }

      var buffer = self.$bytes();

      ($truthy($rb_gt(offset, (buffer).$length())) ? ($Kernel.$raise($$$('ArgumentError'), "offset outside of string")) : nil)

      buffer = buffer.slice(offset);


      // optimization
      var optimizedHandler = optimized[format];
      if (optimizedHandler) {
        return optimizedHandler(buffer);
      }

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive];

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      return output;
    ;
    }, -2);
    return $def(self, '$unpack1', function $$unpack1(format, $kwargs) {
      var offset, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      offset = $kwargs.$$smap["offset"];
      if (offset == null) offset = 0;
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      return self.$unpack(format['$[]'](0), $hash2(["offset"], {"offset": offset}))['$[]'](0);
    }, -2);
  })('::', null, $nesting);
};

Opal.modules["opal-builder"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("opal/builder");
  self.$require("opal/builder_processors");
  return self.$require("corelib/string/unpack");
};

},{}],86:[function(require,module,exports){
Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    }, 1);
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, 1);
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    }, 1);
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    }, 1);
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, 1);
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $Object = Opal.Object, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def, $return_val = Opal.return_val;

  Opal.add_stubs('raise,new,push,[]=,[],create_id,json_create,const_get,attr_accessor,create_id=,===,parse,generate,from_object,merge,to_json,responds_to?,to_io,write,to_s,to_a,strftime');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $klass($nesting[0], $$('StandardError'), 'JSONError');
    $klass($nesting[0], $$('JSONError'), 'ParserError');
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$('JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                ($a = [k, to_opal(value[k], options)], $send((hash), '[]=', $a), $a[$a.length - 1]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$('JSON').$create_id())) != nil) {
              return $Object.$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    self['$create_id=']("json_class");
    $defs(self, '$[]', function $JSON_$$$1(value, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      if ($eqeqeq($$('String'), value)) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, -2);
    $defs(self, '$parse', function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, -2);
    $defs(self, '$parse!', function $JSON_parse$excl$2(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$parse(source, options);
    }, -2);
    $defs(self, '$load', function $$load(source, options) {
      var self = this;

      
      
      if (options == null) options = $hash2([], {});;
      return self.$from_object($parse(source), options);
    }, -2);
    $defs(self, '$from_object', function $$from_object(js_object, options) {
      var $ret_or_1 = nil;

      
      
      if (options == null) options = $hash2([], {});;
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("object_class", $$('Hash'))
      };
      if ($truthy(($ret_or_1 = options['$[]']("array_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("array_class", $$('Array'))
      };
      return to_opal(js_object, options.$$smap);;
    }, -2);
    $defs(self, '$generate', function $$generate(obj, options) {
      
      
      
      if (options == null) options = $hash2([], {});;
      return obj.$to_json(options);
    }, -2);
    return $defs(self, '$dump', function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) io = nil;;
      
      if (limit == null) limit = nil;;
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()
        };
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0)
  })($nesting[0], null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, 0)
  })($nesting[0]);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(',') + '}';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_json', $return_val("null"), 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.toString();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, 0)
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Date');

    
    
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0);
    return $def(self, '$as_json', function $$as_json() {
      var self = this;

      return self.$to_s()
    }, 0);
  })($nesting[0], null);
};

Opal.modules["opal/source_map/map"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $to_ary = Opal.to_ary;

  Opal.add_stubs('require,map,to_json,to_h,to_s,delete,encode64,generated_code');
  
  self.$require("base64");
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Map');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$to_h', function $$to_h() {
      var self = this, $ret_or_1 = nil;
      if (self.to_h == null) self.to_h = nil;

      if ($truthy(($ret_or_1 = self.to_h))) {
        return $ret_or_1
      } else {
        return self.$map()
      }
    }, 0);
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_h().$to_json()
    }, 0);
    
    $def(self, '$as_json', function $$as_json($a) {
      var $post_args, $rest_arg, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return self.$to_h();
    }, -1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.$to_h().$to_s()
    }, 0);
    
    $def(self, '$to_data_uri_comment', function $$to_data_uri_comment() {
      var self = this;

      return "//# sourceMappingURL=data:application/json;base64," + ($$('Base64').$encode64(self.$to_json()).$delete("\n"))
    }, 0);
    
    $def(self, '$cache', function $$cache() {
      var self = this, $ret_or_1 = nil;
      if (self.to_h == null) self.to_h = nil;

      
      self.to_h = ($truthy(($ret_or_1 = self.to_h)) ? ($ret_or_1) : (self.$map()));
      return self;
    }, 0);
    
    $def(self, '$marshal_dump', function $$marshal_dump() {
      var self = this;

      return [self.$to_h(), self.$generated_code()]
    }, 0);
    return $def(self, '$marshal_load', function $$marshal_load(value) {
      var $a, $b, self = this;

      return $b = value, $a = $to_ary($b), (self.to_h = ($a[0] == null ? nil : $a[0])), (self.generated_code = ($a[1] == null ? nil : $a[1])), $b
    }, 1);
  })($$$($$('Opal'), 'SourceMap'), $nesting);
};

Opal.modules["opal/source_map/file"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $rb_minus = Opal.rb_minus, $rb_lt = Opal.rb_lt, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $not = Opal.not;

  Opal.add_stubs('include,attr_reader,new,[]=,size,join,map,to_proc,file,force_encoding,source,names,encode_mappings,relative_mappings,absolute_mappings,sort_by,to_a,-,line,<,column,source_map_name,[],to_s,to_int,each,fragments_by_line,skip_source_map?,is_a?,<<,segment_from_fragment,+,private,flat_map,fragments,code,split,with_index,!,zero?,last');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.generated_code = $proto.fragments = $proto.names = $proto.names_map = $proto.relative_mappings = $proto.absolute_mappings = nil;
    
    self.$include($$$($$$($$('Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("fragments");
    self.$attr_reader("file");
    self.$attr_reader("source");
    
    $def(self, '$initialize', function $$initialize(fragments, file, source, generated_code) {
      var self = this;

      
      
      if (generated_code == null) generated_code = nil;;
      self.fragments = fragments;
      self.file = file;
      self.source = source;
      self.names_map = $send($$('Hash'), 'new', [], function $$1(hash, name){var $a;

        
        
        if (hash == null) hash = nil;;
        
        if (name == null) name = nil;;
        return ($a = [name, hash.$size()], $send(hash, '[]=', $a), $a[$a.length - 1]);}, 2);
      self.generated_code = generated_code;
      return (self.absolute_mappings = nil);
    }, -4);
    
    $def(self, '$generated_code', function $$generated_code() {
      var self = this, $ret_or_1 = nil;

      return (self.generated_code = ($truthy(($ret_or_1 = self.generated_code)) ? ($ret_or_1) : ($send(self.fragments, 'map', [], "code".$to_proc()).$join())))
    }, 0);
    
    $def(self, '$map', function $$map($kwargs) {
      var source_root, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      source_root = $kwargs.$$smap["source_root"];
      if (source_root == null) source_root = "";
      return $hash2(["version", "sourceRoot", "sources", "sourcesContent", "names", "mappings"], {"version": 3, "sourceRoot": source_root, "sources": [self.$file()], "sourcesContent": [self.$source().$force_encoding("UTF-8")], "names": self.$names(), "mappings": $$$($$$($$('Opal'), 'SourceMap'), 'VLQ').$encode_mappings(self.$relative_mappings())});
    }, -1);
    
    $def(self, '$names', function $$names() {
      var self = this, $ret_or_1 = nil;

      return (self.names = ($truthy(($ret_or_1 = self.names)) ? ($ret_or_1) : ((self.$absolute_mappings(), $send($send(self.names_map.$to_a(), 'sort_by', [], function $$2(_, index){
        
        
        if (_ == null) _ = nil;;
        
        if (index == null) index = nil;;
        return index;}, 2), 'map', [], function $$3(name, _){
        
        
        if (name == null) name = nil;;
        
        if (_ == null) _ = nil;;
        return name;}, 2)))))
    }, 0);
    
    $def(self, '$segment_from_fragment', function $$segment_from_fragment(fragment, generated_column) {
      var $a, self = this, source_index = nil, original_line = nil, $ret_or_1 = nil, original_column = nil, map_name_index = nil;

      
      source_index = 0;
      original_line = $rb_minus(($truthy(($ret_or_1 = fragment.$line())) ? ($ret_or_1) : (0)), 1);
      if ($truthy($rb_lt(original_line, 0))) {
        original_line = 0
      };
      original_column = ($truthy(($ret_or_1 = fragment.$column())) ? ($ret_or_1) : (0));
      if ($truthy(fragment.$source_map_name())) {
        
        map_name_index = ($truthy(($ret_or_1 = self.names_map['$[]'](fragment.$source_map_name().$to_s()))) ? ($ret_or_1) : (($a = [fragment.$source_map_name().$to_s(), self.names_map.$size()], $send(self.names_map, '[]=', $a), $a[$a.length - 1])));
        return [generated_column, source_index, original_line, original_column, map_name_index];
      } else {
        return [generated_column, source_index, original_line, original_column]
      };
    }, 2);
    
    $def(self, '$relative_mappings', function $$relative_mappings() {
      var self = this, $ret_or_1 = nil, reference_segment = nil, reference_name_index = nil;

      return (self.relative_mappings = ($truthy(($ret_or_1 = self.relative_mappings)) ? ($ret_or_1) : (((reference_segment = [0, 0, 0, 0, 0]), (reference_name_index = 0), $send(self.$absolute_mappings(), 'map', [], function $$4(absolute_mapping){
        
        
        if (absolute_mapping == null) absolute_mapping = nil;;
        reference_segment['$[]='](0, 0);
        return $send(absolute_mapping, 'map', [], function $$5(absolute_segment){var segment = nil, $ret_or_2 = nil;

          
          
          if (absolute_segment == null) absolute_segment = nil;;
          segment = [];
          segment['$[]='](0, $rb_minus(absolute_segment['$[]'](0), reference_segment['$[]'](0)));
          segment['$[]='](1, $rb_minus(absolute_segment['$[]'](1), ($truthy(($ret_or_2 = reference_segment['$[]'](1))) ? ($ret_or_2) : (0))));
          segment['$[]='](2, $rb_minus(absolute_segment['$[]'](2), ($truthy(($ret_or_2 = reference_segment['$[]'](2))) ? ($ret_or_2) : (0))));
          segment['$[]='](3, $rb_minus(absolute_segment['$[]'](3), ($truthy(($ret_or_2 = reference_segment['$[]'](3))) ? ($ret_or_2) : (0))));
          if ($truthy(absolute_segment['$[]'](4))) {
            
            segment['$[]='](4, $rb_minus(absolute_segment['$[]'](4).$to_int(), ($truthy(($ret_or_2 = reference_segment['$[]'](4))) ? ($ret_or_2) : (reference_name_index)).$to_int()));
            reference_name_index = absolute_segment['$[]'](4);
          };
          reference_segment = absolute_segment;
          return segment;}, 1);}, 1)))))
    }, 0);
    
    $def(self, '$absolute_mappings', function $$absolute_mappings() {
      var self = this, $ret_or_1 = nil, mappings = nil;

      return (self.absolute_mappings = ($truthy(($ret_or_1 = self.absolute_mappings)) ? ($ret_or_1) : (((mappings = []), $send(self.$fragments_by_line(), 'each', [], function $$6(raw_segments){var self = $$6.$$s == null ? this : $$6.$$s, generated_column = nil, segments = nil;

        
        
        if (raw_segments == null) raw_segments = nil;;
        generated_column = 0;
        segments = [];
        $send(raw_segments, 'each', [], function $$7($mlhs_tmp1){var $a, $b, self = $$7.$$s == null ? this : $$7.$$s, generated_code = nil, fragment = nil;

          
          
          if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;;
          $b = $mlhs_tmp1, $a = $to_ary($b), (generated_code = ($a[0] == null ? nil : $a[0])), (fragment = ($a[1] == null ? nil : $a[1])), $b;
          if (!($truthy(fragment['$is_a?']($$$($$('Opal'), 'Fragment'))) && ($truthy(fragment['$skip_source_map?']())))) {
            segments['$<<'](self.$segment_from_fragment(fragment, generated_column))
          };
          return (generated_column = $rb_plus(generated_column, generated_code.$size()));}, {$$arity: 1, $$s: self, $$has_top_level_mlhs_arg: true});
        return mappings['$<<'](segments);}, {$$arity: 1, $$s: self}), mappings))))
    }, 0);
    self.$private();
    return $def(self, '$fragments_by_line', function $$fragments_by_line() {
      var self = this, raw_mappings = nil;

      
      raw_mappings = [[]];
      $send(self.$fragments(), 'flat_map', [], function $$8(fragment){var fragment_code = nil, fragment_lines = nil;

        
        
        if (fragment == null) fragment = nil;;
        fragment_code = fragment.$code();
        fragment_lines = fragment_code.$split("\n", -1);
        return $send(fragment_lines.$each(), 'with_index', [], function $$9(fragment_line, index){var raw_segment = nil;

          
          
          if (fragment_line == null) fragment_line = nil;;
          
          if (index == null) index = nil;;
          raw_segment = [fragment_line, fragment];
          if (($truthy(index['$zero?']()) && ($not(fragment_line.$size()['$zero?']())))) {
            return raw_mappings.$last()['$<<'](raw_segment)
          } else if (($truthy(index['$zero?']()) && ($truthy(fragment_line.$size()['$zero?']())))) {
            return nil
          } else if ($truthy(fragment_line.$size()['$zero?']())) {
            return raw_mappings['$<<']([])
          } else {
            return raw_mappings['$<<']([raw_segment])
          };}, 2);}, 1);
      return raw_mappings;
    }, 0);
  })($$$($$('Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/index"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('include,attr_reader,map,to_h,generated_code,+,count,[],rindex,size');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Index');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.source_maps = nil;
    
    self.$include($$$($$$($$('Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("source_maps");
    
    $def(self, '$initialize', function $$initialize(source_maps, $kwargs) {
      var join, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      join = $kwargs.$$smap["join"];
      if (join == null) join = nil;
      self.source_maps = source_maps;
      return (self.join = join);
    }, -2);
    return $def(self, '$map', function $$map() {
      var self = this, offset_line = nil, offset_column = nil;

      
      offset_line = 0;
      offset_column = 0;
      return $hash2(["version", "sections"], {"version": 3, "sections": $send(self.source_maps, 'map', [], function $$1(source_map){var self = $$1.$$s == null ? this : $$1.$$s, map = nil, generated_code = nil, new_lines_count = nil, last_line = nil;
        if (self.join == null) self.join = nil;

        
        
        if (source_map == null) source_map = nil;;
        map = $hash2(["offset", "map"], {"offset": $hash2(["line", "column"], {"line": offset_line, "column": offset_column}), "map": source_map.$to_h()});
        generated_code = source_map.$generated_code();
        if ($truthy(self.join)) {
          generated_code = $rb_plus(generated_code, self.join)
        };
        new_lines_count = generated_code.$count("\n");
        last_line = generated_code['$[]'](Opal.Range.$new($rb_plus(generated_code.$rindex("\n"), 1), -1, false));
        offset_line = $rb_plus(offset_line, new_lines_count);
        offset_column = $rb_plus(offset_column, last_line.$size());
        return map;}, {$$arity: 1, $$s: self})});
    }, 0);
  })($$$($$('Opal'), 'SourceMap'), null, $nesting)
};

Opal.modules["opal/source_map/vlq"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $const_set = Opal.const_set, $rb_minus = Opal.rb_minus, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $defs = Opal.defs, $eqeq = Opal.eqeq;

  Opal.add_stubs('<<,-,split,inject,[]=,[],each,<,+,-@,loop,&,>>,>,|,join,any?,shift,raise,==,map,encode,each_with_index,decode');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VLQ');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
    $const_set($nesting[0], 'VLQ_BASE', (1)['$<<']($$('VLQ_BASE_SHIFT')));
    $const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus($$('VLQ_BASE'), 1));
    $const_set($nesting[0], 'VLQ_CONTINUATION_BIT', $$('VLQ_BASE'));
    $const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
    $const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [$hash2([], {})], function $VLQ$1(h, i){
      
      
      if (h == null) h = nil;;
      
      if (i == null) i = nil;;
      h['$[]=']($$('BASE64_DIGITS')['$[]'](i), i);
      return h;}, 2));
    $defs(self, '$encode', function $$encode(ary) {
      var self = this, result = nil;

      
      result = [];
      (function(){var $brk = Opal.new_brk(); try {return $send(ary, 'each', [], function $$2(n){var self = $$2.$$s == null ? this : $$2.$$s, vlq = nil;

        
        
        if (n == null) n = nil;;
        vlq = ($truthy($rb_lt(n, 0)) ? ($rb_plus(n['$-@']()['$<<'](1), 1)) : (n['$<<'](1)));
        return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$3(){var digit = nil;

          
          digit = vlq['$&']($$('VLQ_BASE_MASK'));
          vlq = vlq['$>>']($$('VLQ_BASE_SHIFT'));
          if ($truthy($rb_gt(vlq, 0))) {
            digit = digit['$|']($$('VLQ_CONTINUATION_BIT'))
          };
          result['$<<']($$('BASE64_DIGITS')['$[]'](digit));
          if ($truthy($rb_gt(vlq, 0))) {
            return nil
          } else {
            
            Opal.brk(nil, $brk)
          };}, {$$arity: 0, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, {$$arity: 1, $$s: self, $$brk: $brk})
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return result.$join();
    }, 1);
    $defs(self, '$decode', function $$decode(str) {
      var $a, $b, self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

      
      result = [];
      chars = str.$split("");
      while ($truthy(chars['$any?']())) {
        
        vlq = 0;
        shift = 0;
        continuation = true;
        while ($truthy(continuation)) {
          
          char$ = chars.$shift();
          if (!$truthy(char$)) {
            self.$raise($$('ArgumentError'))
          };
          digit = $$('BASE64_VALUES')['$[]'](char$);
          if ($eqeq(digit['$&']($$('VLQ_CONTINUATION_BIT')), 0)) {
            continuation = false
          };
          digit = digit['$&']($$('VLQ_BASE_MASK'));
          vlq = $rb_plus(vlq, digit['$<<'](shift));
          shift = $rb_plus(shift, $$('VLQ_BASE_SHIFT'));
        };
        result['$<<'](($eqeq(vlq['$&'](1), 1) ? (vlq['$>>'](1)['$-@']()) : (vlq['$>>'](1))));
      };
      return result;
    }, 1);
    $defs(self, '$encode_mappings', function $$encode_mappings(ary) {
      var self = this;

      return $send(ary, 'map', [], function $$4(group){var self = $$4.$$s == null ? this : $$4.$$s;

        
        
        if (group == null) group = nil;;
        return $send(group, 'map', [], function $$5(segment){var self = $$5.$$s == null ? this : $$5.$$s;

          
          
          if (segment == null) segment = nil;;
          return self.$encode(segment);}, {$$arity: 1, $$s: self}).$join(",");}, {$$arity: 1, $$s: self}).$join(";")
    }, 1);
    return $defs(self, '$decode_mappings', function $$decode_mappings(str) {
      var self = this, mappings = nil;

      
      mappings = [];
      $send(str.$split(";"), 'each_with_index', [], function $$6(group, index){var self = $$6.$$s == null ? this : $$6.$$s;

        
        
        if (group == null) group = nil;;
        
        if (index == null) index = nil;;
        mappings['$[]='](index, []);
        return $send(group.$split(","), 'each', [], function $$7(segment){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (segment == null) segment = nil;;
          return mappings['$[]'](index)['$<<'](self.$decode(segment));}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
      return mappings;
    }, 1);
  })($$$($$('Opal'), 'SourceMap'), $nesting)
};

Opal.modules["opal/source_map"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module;

  Opal.add_stubs('autoload');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'SourceMap');

      
      
      self.$autoload("Map", "opal/source_map/map");
      self.$autoload("File", "opal/source_map/file");
      self.$autoload("Index", "opal/source_map/index");
      return self.$autoload("VLQ", "opal/source_map/vlq");
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["opal-source-maps"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  return self.$require("opal/source_map")
};

},{}],87:[function(require,module,exports){
(function (process){(function (){
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var fs = require("fs")
var path = require("path")
var minimatch = require("minimatch")
var isAbsolute = require("path-is-absolute")
var Minimatch = minimatch.Minimatch

function alphasort (a, b) {
  return a.localeCompare(b, 'en')
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute
  self.fs = options.fs || fs

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

}).call(this)}).call(this,require('_process'))
},{"_process":33,"fs":1,"minimatch":82,"path":32,"path-is-absolute":98}],88:[function(require,module,exports){
(function (process){(function (){
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var inherits = require('inherits')
var EE = require('events').EventEmitter
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var globSync = require('./sync.js')
var common = require('./common.js')
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require('inflight')
var util = require('util')
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = require('once')

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    self.fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  self.fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    self.fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return self.fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}

}).call(this)}).call(this,require('_process'))
},{"./common.js":87,"./sync.js":89,"_process":33,"assert":2,"events":14,"fs.realpath":78,"inflight":80,"inherits":81,"minimatch":82,"once":83,"path":32,"path-is-absolute":98,"util":64}],89:[function(require,module,exports){
(function (process){(function (){
module.exports = globSync
globSync.GlobSync = GlobSync

var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var Glob = require('./glob.js').Glob
var util = require('util')
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var common = require('./common.js')
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = this.fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, this.fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = this.fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = this.fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

}).call(this)}).call(this,require('_process'))
},{"./common.js":87,"./glob.js":88,"_process":33,"assert":2,"fs.realpath":78,"minimatch":82,"path":32,"path-is-absolute":98,"util":64}],90:[function(require,module,exports){
(function (process,Buffer,__dirname){(function (){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @contributor Guillaume Grossetie <ggrossetie@yuzutech.fr>
 * @contributor David Jencks <djencks@apache.org>
 * @license MIT
 */
const Url = require('url')
const fs = require('fs')
const ospath = require('path')

// 100 MB
const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100

exports.XMLHttpRequest = function () {
  'use strict'

  /**
   * Private variables
   */
  const self = this
  const http = require('http')
  const https = require('https')

  // Holds http.js objects
  let request
  let response

  // Request settings
  let settings = {}

  // Disable header blacklist.
  // Not part of XHR specs.
  let disableHeaderCheck = false

  // Set some default headers
  const defaultHeaders = {
    'User-Agent': 'node-XMLHttpRequest',
    Accept: '*/*'
  }

  let headers = {}
  const headersCase = {}

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  const forbiddenRequestHeaders = [
    'accept-charset',
    'accept-encoding',
    'access-control-request-headers',
    'access-control-request-method',
    'connection',
    'content-length',
    'content-transfer-encoding',
    'cookie',
    'cookie2',
    'date',
    'expect',
    'host',
    'keep-alive',
    'origin',
    'referer',
    'te',
    'trailer',
    'transfer-encoding',
    'upgrade',
    'via'
  ]

  // These request methods are not allowed
  const forbiddenRequestMethods = [
    'TRACE',
    'TRACK',
    'CONNECT'
  ]

  // Send flag
  let sendFlag = false
  // Error flag, used when errors occur or abort is called
  let errorFlag = false

  // Binary response (chunk)
  const responseBinary = []

  // Event listeners
  const listeners = {}

  /**
   * Constants
   */

  this.UNSENT = 0
  this.OPENED = 1
  this.HEADERS_RECEIVED = 2
  this.LOADING = 3
  this.DONE = 4

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null

  // Result & response
  this.responseText = ''
  this.responseXML = ''
  this.status = null
  this.statusText = null

  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false
  // "text", "arraybuffer", "blob", or "document", depending on your data needs.
  // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".
  // Omitting, '', or "text" will return a String.
  // Other values will return an ArrayBuffer.
  this.responseType = ''

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param header - {string} Header to validate
   * @return {boolean} - False if not allowed, otherwise true
   */
  const isAllowedHttpHeader = function (header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)
  }

  /**
   * Check if the specified method is allowed.
   *
   * @param method - {string}  Request method to validate
   * @return {boolean} - False if not allowed, otherwise true
   */
  const isAllowedHttpMethod = function (method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1)
  }

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param method - {string} Connection method (eg GET, POST)
   * @param url - {string} URL for the connection.
   * @param async - {boolean} Asynchronous connection. Default is true.
   * @param [user] - {string} Username for basic authentication (optional)
   * @param [password] - {string} Password for basic authentication (optional)
   */
  this.open = function (method, url, async, user, password) {
    this.abort()
    errorFlag = false

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error('SecurityError: Request method not allowed')
    }

    settings = {
      method: method,
      url: url.toString(),
      async: (typeof async !== 'boolean' ? true : async),
      user: user || null,
      password: password || null
    }

    setState(this.OPENED)
  }

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param state - {boolean} Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function (state) {
    disableHeaderCheck = state
  }

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param header - {string} Header name
   * @param value - {string} Header value
   */
  this.setRequestHeader = function (header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN')
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"')
      return
    }
    if (sendFlag) {
      throw new Error('INVALID_STATE_ERR: send flag is true')
    }
    header = headersCase[header.toLowerCase()] || header
    headersCase[header.toLowerCase()] = header
    headers[header] = headers[header] ? headers[header] + ', ' + value : value
  }

  /**
   * Gets a header from the server response.
   *
   * @param header - {string} Name of header to get.
   * @return {Object} - Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function (header) {
    if (typeof header === 'string' &&
      this.readyState > this.OPENED &&
      response &&
      response.headers &&
      response.headers[header.toLowerCase()] &&
      !errorFlag
    ) {
      return response.headers[header.toLowerCase()]
    }

    return null
  }

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function () {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return ''
    }
    let result = ''

    for (const i in response.headers) {
      // Cookie headers are excluded
      if (i !== 'set-cookie' && i !== 'set-cookie2') {
        result += i + ': ' + response.headers[i] + '\r\n'
      }
    }
    return result.substr(0, result.length - 2)
  }

  /**
   * Gets a request header
   *
   * @param name - {string} Name of header to get
   * @return {string} Returns the request header or empty string if not set
   */
  this.getRequestHeader = function (name) {
    if (typeof name === 'string' && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]]
    }

    return ''
  }

  /**
   * Sends the request to the server.
   *
   * @param data - {string} Optional data to send as request body.
   */
  this.send = function (data) {
    if (this.readyState !== this.OPENED) {
      throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called')
    }

    if (sendFlag) {
      throw new Error('INVALID_STATE_ERR: send has already been called')
    }
    let ssl = false
    let local = false
    const url = new Url.URL(settings.url)
    let host
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true
        host = url.hostname
        break
      case 'http:':
        host = url.hostname
        break
      case 'file:':
        local = true
        break
      case undefined:
      case null:
      case '':
        host = 'localhost'
        break
      default:
        throw new Error('Protocol not supported.')
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== 'GET') {
        throw new Error('XMLHttpRequest: Only GET method is supported')
      }
      if (settings.async) {
        fs.readFile(url, 'utf8', function (error, data) {
          if (error) {
            self.handleError(error, url)
          } else {
            self.status = 200
            self.responseText = data
            setState(self.DONE)
          }
        })
      } else {
        try {
          this.responseText = fs.readFileSync(url, 'utf8')
          this.status = 200
          setState(self.DONE)
        } catch (e) {
          this.handleError(e, url)
        }
      }

      return
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    const port = url.port || (ssl ? 443 : 80)
    // Add query string if one is used
    const uri = url.pathname + (url.search ? url.search : '')

    // Set the defaults if they haven't been set
    for (const name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name]
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host
    // IPv6 addresses must be escaped with brackets
    if (url.host[0] === '[') {
      headers.Host = '[' + headers.Host + ']'
    }
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ':' + url.port
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === 'undefined') {
        settings.password = ''
      }
      const authBuf = Buffer.from(settings.user + ':' + settings.password)
      headers.Authorization = 'Basic ' + authBuf.toString('base64')
    }

    // Set content length header
    if (settings.method === 'GET' || settings.method === 'HEAD') {
      data = null
    } else if (data) {
      headers['Content-Length'] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)

      if (!this.getRequestHeader('Content-Type')) {
        headers['Content-Type'] = 'text/plain;charset=UTF-8'
      }
    } else if (settings.method === 'POST') {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers['Content-Length'] = 0
    }

    const options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    }

    const responseType = this.responseType || 'text'

    // Reset error flag
    errorFlag = false

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      const doRequest = ssl ? https.request : http.request

      // Request is being sent, set send flag
      sendFlag = true

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent('readystatechange')

      // Handler for the response
      const responseHandler = function responseHandler (resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location
          const url = new Url.URL(settings.url)
          // Set host var in case it's used later
          host = url.hostname
          // Options for the new request
          const newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          }

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler)
          request.end()
          // @TODO Check if an XHR event needs to be fired here
          return
        }

        const encoding = responseType === 'text' ? 'utf8' : 'binary'
        if (encoding === 'utf8') {
          response.setEncoding('utf8')
        }

        setState(self.HEADERS_RECEIVED)
        self.status = response.statusCode

        if (encoding === 'utf8') {
          response.on('data', function (chunk) {
            // Make sure there's some data
            if (chunk) {
              self.responseText += chunk
            }
            // Don't emit state changes if the connection has been aborted.
            if (sendFlag) {
              setState(self.LOADING)
            }
          })

          response.on('end', function () {
            if (sendFlag) {
              // Discard the end event if the connection has been aborted
              setState(self.DONE)
              sendFlag = false
            }
          })
        } else {
          response.on('data', function (chunk) {
            // Make sure there's some data
            if (chunk) {
              responseBinary.push(chunk)
            }
            // Don't emit state changes if the connection has been aborted.
            if (sendFlag) {
              setState(self.LOADING)
            }
          })

          response.on('end', function () {
            // buffers are Uint8Array instances
            self.response = Buffer.concat(responseBinary).buffer
            if (sendFlag) {
              // Discard the end event if the connection has been aborted
              setState(self.DONE)
              sendFlag = false
            }
          })
        }

        response.on('error', function (error) {
          self.handleError(error, url)
        })
      }

      // Error handler for the request
      const errorHandler = function errorHandler (error) {
        self.handleError(error, url)
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler)

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data)
      }

      request.end()

      self.dispatchEvent('loadstart')
    } else { // Synchronous
      const maxBuffer = process.env.UNXHR_MAX_BUFFER
        ? parseInt(process.env.UNXHR_MAX_BUFFER)
        : DEFAULT_MAX_BUFFER
      const encoding = responseType === 'text' ? 'utf8' : 'binary'
      const scriptPath = ospath.join(__dirname, 'request.js')
      const output = require('child_process').execSync(`"${process.execPath}" "${scriptPath}" \
--ssl="${ssl}" \
--encoding="${encoding}" \
--request-options=${JSON.stringify(JSON.stringify(options))}`, { stdio: ['pipe', 'pipe', 'pipe'], input: data, maxBuffer: maxBuffer })
      const result = JSON.parse(output.toString('utf8'))
      if (result.error) {
        throw translateError(result.error, url)
      } else {
        response = result.data
        self.status = result.data.statusCode
        if (encoding === 'binary') {
          self.response = Uint8Array.from(result.data.binary.data).buffer
        } else {
          self.responseText = result.data.text
        }
        setState(self.DONE)
      }
    }
  }

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function (error, url) {
    this.status = 0
    this.statusText = ''
    this.responseText = ''
    errorFlag = true
    setState(this.DONE)
    this.dispatchEvent('error', { error: translateError(error, url) })
  }

  /**
   * Aborts a request.
   */
  this.abort = function () {
    if (request) {
      request.abort()
      request = null
    }

    headers = defaultHeaders
    this.status = 0
    this.responseText = ''
    this.responseXML = ''

    errorFlag = true

    if (this.readyState !== this.UNSENT &&
      (this.readyState !== this.OPENED || sendFlag) &&
      this.readyState !== this.DONE) {
      sendFlag = false
      setState(this.DONE)
    }
    this.readyState = this.UNSENT
    this.dispatchEvent('abort')
  }

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function (event, callback) {
    if (!(event in listeners)) {
      listeners[event] = []
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback)
  }

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function (event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function (ev) {
        return ev !== callback
      })
    }
  }

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function (event, args) {
    if (typeof self['on' + event] === 'function') {
      self['on' + event](args)
    }
    if (event in listeners) {
      for (let i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self, args)
      }
    }
  }

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param state - {Number} New state
   */
  const setState = function (state) {
    if (state === self.LOADING || self.readyState !== state) {
      self.readyState = state

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent('readystatechange')
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent('load')
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent('loadend')
      }
    }
  }

  const translateError = function (error, url) {
    if (typeof error === 'object') {
      if (error.code === 'ENOTFOUND' || error.code === 'EAI_AGAIN') {
        // XMLHttpRequest throws a DOMException when DNS lookup fails:
        // code: 19
        // message: "Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://url/'."
        // name: "NetworkError"
        // stack: (...)
        return new Error(`Failed to execute 'send' on 'XMLHttpRequest': Failed to load '${url}'.`)
      }
      if (error instanceof Error) {
        return error
      }
      return new Error(JSON.stringify(error))
    }
    return new Error(error)
  }
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/opal-runtime/node_modules/unxhr/lib")
},{"_process":33,"buffer":9,"child_process":8,"fs":8,"http":39,"https":23,"path":32,"url":59}],91:[function(require,module,exports){
Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    }, 1);
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, 1);
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    }, 1);
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    }, 1);
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, 1);
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

},{}],92:[function(require,module,exports){
/* global Opal */
require('./opal.js')
require('./nodejs.js')
require('./pathname.js')
require('./base64.js')
require('./open-uri.js')
require('./stringio.js')

module.exports.Opal = Opal

},{"./base64.js":91,"./nodejs.js":93,"./opal.js":94,"./open-uri.js":95,"./pathname.js":96,"./stringio.js":97}],93:[function(require,module,exports){
(function (process,Buffer){(function (){
Opal.modules["nodejs/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $module = Opal.module, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $lambda = Opal.lambda, $send = Opal.send;

  Opal.add_stubs('==,first,shift,write_proc=,read_proc=,tty=');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'NodeJS');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', process.version)
  })($nesting[0], $nesting);
  Opal.exit = process.exit;
  $const_set($nesting[0], 'ARGV', process.argv.slice(2));
  if ($eqeq($$('ARGV').$first(), "--")) {
    $$('ARGV').$shift()
  };
  $$('STDOUT')['$write_proc=']($lambda(function $$1(string){
    
    
    if (string == null) string = nil;;
    return process.stdout.write(string);;}, 1));
  $$('STDERR')['$write_proc=']($lambda(function $$2(string){
    
    
    if (string == null) string = nil;;
    return process.stderr.write(string);;}, 1));
  var __fs__ = require('fs');
  $$('STDIN')['$read_proc='](function(_count) {
  // Ignore count, return as much as we can get
  var buf = Buffer.alloc(65536), count;
  try {
    count = __fs__.readSync(this.fd, buf, 0, 65536, null);
  }
  catch (e) { // Windows systems may raise EOF
    return nil;
  }
  if (count == 0) return nil;
  return buf.toString('utf8', 0, count);
});
  $$('STDIN')['$tty='](true);
  $$('STDOUT')['$tty='](true);
  return ($a = [true], $send($$('STDERR'), 'tty=', $a), $a[$a.length - 1]);
};

Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $range = Opal.range, $to_a = Opal.to_a, $def = Opal.def, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $klass = Opal.klass, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $rb_ge = Opal.rb_ge, $return_self = Opal.return_self, $gvars = Opal.gvars;

  Opal.add_stubs('try_convert,native?,respond_to?,to_n,raise,inspect,Native,proc,map!,end_with?,define_method,[],convert,call,to_proc,new,each,native_reader,native_writer,extend,warn,include,is_a?,map,Array,to_a,_Array,method_missing,bind,instance_method,[]=,slice,-,length,has_key?,enum_for,===,>=,<<,each_pair,method_defined?,initialize,_initialize,name,native_module');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$is_a?', function $Native_is_a$ques$1(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, 2);
    $defs(self, '$try_convert', function $$try_convert(value, default$) {
      var self = this;

      
      
      if (default$ == null) default$ = nil;;
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, -2);
    $defs(self, '$convert', function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$('ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, 1);
    $defs(self, '$call', function $$call(obj, key, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      delete $$call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 2);
      
      args = $post_args;;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, -3);
    $defs(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil, self = this;

      delete $$proc.$$p;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('LocalJumpError'), "no block given")
      };
      return $send($Kernel, 'proc', [], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s, instance = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        $send(args, 'map!', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;

          
          
          if (arg == null) arg = nil;;
          return self.$Native(arg);}, {$$arity: 1, $$s: self});
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, {$$arity: -1, $$s: self});
    }, 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$alias_native', function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $yield = $$alias_native.$$p || nil, self = this;

        delete $$alias_native.$$p;
        
        
        $post_args = Opal.slice.call(arguments, 1);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) old = $post_args.shift();
        if (old == null) old = new$;;
        
        as = $kwargs.$$smap["as"];
        if (as == null) as = nil;
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], function $$4(value){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            
            if (value == null) value = nil;;
            self["native"][old['$[]']($range(0, -2, false))] = $$('Native').$convert(value);
            return value;}, {$$arity: 1, $$s: self})
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], function $$5($c){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, value = nil;
            if (self["native"] == null) self["native"] = nil;

            delete $$5.$$p;
            
            ;
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            value = $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, {$$arity: -1, $$s: self})
        } else {
          return $send(self, 'define_method', [new$], function $$6($c){var block = $$6.$$p || nil, $post_args, args, self = $$6.$$s == null ? this : $$6.$$s;
            if (self["native"] == null) self["native"] = nil;

            delete $$6.$$p;
            
            ;
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            return $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());}, {$$arity: -1, $$s: self})
        };
      }, -2);
      
      $def(self, '$native_reader', function $$native_reader($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        names = $post_args;;
        return $send(names, 'each', [], function $$7(name){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (name == null) name = nil;;
          return $send(self, 'define_method', [name], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$native_writer', function $$native_writer($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        names = $post_args;;
        return $send(names, 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s;

          
          
          if (name == null) name = nil;;
          return $send(self, 'define_method', ["" + (name) + "="], function $$10(value){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            
            if (value == null) value = nil;;
            return self.$Native(self["native"][name] = value);}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
      }, -1);
      return $def(self, '$native_accessor', function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        names = $post_args;;
        $send(self, 'native_reader', $to_a(names));
        return $send(self, 'native_writer', $to_a(names));
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$initialize', function $$initialize(native$) {
        var self = this;

        
        if (!$truthy($Kernel['$native?'](native$))) {
          $Kernel.$raise($$('ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, 1);
      
      $def(self, '$to_n', $return_ivar("native"), 0);
      return $defs(self, '$included', function $$included(klass) {
        
        return klass.$extend($$('Helpers'))
      }, 1);
    })($nesting[0], $nesting);
    return $defs(self, '$included', function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$('Wrapper'));
    }, 1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native?', function $Kernel_native$ques$11(value) {
      
      return value == null || !value.$$class;
    }, 1);
    
    $def(self, '$Native', function $$Native(obj) {
      var $yield = $$Native.$$p || nil, self = this;

      delete $$Native.$$p;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$('Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$('Array')))) {
        return $send(obj, 'map', [], function $$12(o){var self = $$12.$$s == null ? this : $$12.$$s;

          
          
          if (o == null) o = nil;;
          return self.$Native(o);}, {$$arity: 1, $$s: self})
      } else if ($truthy(obj['$is_a?']($$('Proc')))) {
        return $send(self, 'proc', [], function $$13($a){var block = $$13.$$p || nil, $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

          delete $$13.$$p;
          
          ;
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          return self.$Native($send(obj, 'call', $to_a(args), block.$to_proc()));}, {$$arity: -1, $$s: self})
      } else {
        return obj
      }
    }, 1);
    $alias(self, "_Array", "Array");
    return $def(self, '$Array', function $$Array(object, $a) {
      var block = $$Array.$$p || nil, $post_args, args, self = this;

      delete $$Array.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$('Native'), 'Array'), 'new', [object].concat($to_a(args)), block.$to_proc()).$to_a()
      };
      return self.$_Array(object);
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    var $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$$('Native'), 'Wrapper'));
    
    $def(self, '$==', function $Object_$eq_eq$14(other) {
      var self = this;

      return self["native"] === $$$('Native').$try_convert(other)
    }, 1);
    
    $def(self, '$has_key?', function $Object_has_key$ques$15(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, 1);
    
    $def(self, '$each', function $$each($a) {
      var $post_args, args, $yield = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat($to_a(args)))
      };
    }, -1);
    
    $def(self, '$[]', function $Object_$$$16(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('Native').$call(self["native"], key)
      }
    
    }, 1);
    
    $def(self, '$[]=', function $Object_$$$eq$17(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, 2);
    
    $def(self, '$merge!', function $Object_merge$excl$18(other) {
      var self = this;

      
      
      other = $$$('Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$respond_to?', function $Object_respond_to$ques$19(name, include_all) {
      var self = this;

      
      
      if (include_all == null) include_all = false;;
      return $Kernel.$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Object_respond_to_missing$ques$20(name, include_all) {
      var self = this;

      
      
      if (include_all == null) include_all = false;;
      return Opal.hasOwnProperty.call(self["native"], name);
    }, -2);
    
    $def(self, '$method_missing', function $$method_missing(mid, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, $b, self = this;

      delete $$method_missing.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return ($b = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)], $send(self, '[]=', $b), $b[$b.length - 1]);
      }
      else {
        return $send($$$('Native'), 'call', [self["native"], mid].concat($to_a(args)), block.$to_proc());
      }
    ;
    }, -2);
    
    $def(self, '$nil?', $return_val(false), 0);
    
    $def(self, '$is_a?', function $Object_is_a$ques$21(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, 1);
    
    $def(self, '$instance_of?', function $Object_instance_of$ques$22(klass) {
      var self = this;

      return self.$$class === klass;
    }, 1);
    
    $def(self, '$class', function $Object_class$23() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$to_a', function $$to_a(options) {
      var block = $$to_a.$$p || nil, self = this;

      delete $$to_a.$$p;
      
      ;
      
      if (options == null) options = $hash2([], {});;
      return $send($$$($$$('Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Native:" + (String(self["native"])) + ">"
    }, 0);
    $alias(self, "include?", "has_key?");
    $alias(self, "key?", "has_key?");
    $alias(self, "kind_of?", "is_a?");
    return $alias(self, "member?", "has_key?");
  })($$('Native'), $$('BasicObject'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.named = $proto["native"] = $proto.get = $proto.block = $proto.set = $proto.length = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    self.$include($$('Enumerable'));
    
    $def(self, '$initialize', function $$initialize(native$, options) {
      var block = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

      delete $$initialize.$$p;
      
      ;
      
      if (options == null) options = $hash2([], {});;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [native$], null);
      self.get = ($truthy(($ret_or_1 = options['$[]']("get"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.named = options['$[]']("named");
      self.set = ($truthy(($ret_or_1 = options['$[]']("set"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.length = ($truthy(($ret_or_1 = options['$[]']("length"))) ? ($ret_or_1) : ("length"));
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$('ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$[]', function $Array_$$$24(index) {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = (($eqeqeq($$('String'), ($ret_or_1 = index)) || ($eqeqeq($$('Symbol'), $ret_or_1))) ? (($truthy(self.named) ? (self["native"][self.named](index)) : (self["native"][index]))) : ($eqeqeq($$('Integer'), $ret_or_1) ? (($truthy(self.get) ? (self["native"][self.get](index)) : (self["native"][index]))) : (nil)));
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, 1);
    
    $def(self, '$[]=', function $Array_$$$eq$25(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$('Native').$convert(value))
      } else {
        return self["native"][index] = $$('Native').$convert(value)
      }
    }, 2);
    
    $def(self, '$last', function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      
      
      if (count == null) count = nil;;
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"][self.length]
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, 0);
    return $alias(self, "to_ary", "to_a");
  })($$('Native'), null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$to_n', $return_self, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$to_n', $return_ivar("matches"), 0)
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], function $$26(name, value){
        
        
        if (name == null) name = nil;;
        
        if (value == null) value = nil;;
        return result[name] = $$('Native').$try_convert(value, value);}, 2);
      return result;
    }, 0)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$('Native').$try_convert(obj, obj));
      }

      return result;
    
    }, 0)
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_n', $return_self, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_n', function $$to_n() {
      
      return null;
    }, 0)
  })($nesting[0], null);
  if (!$truthy($$('Hash')['$method_defined?']("_initialize"))) {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $alias(self, "_initialize", "initialize");
      
      $def(self, '$initialize', function $$initialize(defaults) {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        ;
        
        if (defaults != null &&
             (defaults.constructor === undefined ||
               defaults.constructor === Object)) {
          var smap = self.$$smap,
              keys = self.$$keys,
              key, value;

          for (key in defaults) {
            value = defaults[key];

            if (value &&
                 (value.constructor === undefined ||
                   value.constructor === Object)) {
              smap[key] = $$('Hash').$new(value);
            } else if (value && value.$$is_array) {
              value = value.map(function(item) {
                if (item &&
                     (item.constructor === undefined ||
                       item.constructor === Object)) {
                  return $$('Hash').$new(item);
                }

                return self.$Native(item);
              });
              smap[key] = value
            } else {
              smap[key] = self.$Native(value);
            }

            keys.push(key);
          }

          return self;
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, -1);
      return $def(self, '$to_n', function $$to_n() {
        var self = this;

        
        var result = {},
            keys = self.$$keys,
            smap = self.$$smap,
            key, value;

        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = smap[key];
          } else {
            key = key.key;
            value = key.value;
          }

          result[key] = $$('Native').$try_convert(value, value);
        }

        return result;
      
      }, 0);
    })($nesting[0], null, $nesting)
  };
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$native_module', function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, 0)
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native_alias', function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$('NameError').$new("undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, 2);
    return $def(self, '$native_class', function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, 0);
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["buffer/array"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs('include,[],name_for,attr_reader,==,for,to_n,enum_for,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Array');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$for', function $Array_for$1(bits, type) {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("" + ($$('Buffer').$name_for(bits, type)) + "Array")
      }, 2);
      self.$include($$('Enumerable'));
      self.$attr_reader("buffer", "type");
      
      $def(self, '$initialize', function $$initialize(buffer, bits, type) {
        var $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        
        if (bits == null) bits = nil;;
        
        if (type == null) type = nil;;
        if ($eqeq($$('Native'), buffer)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else {
          
          var klass = $$('Array').$for(bits, type);

          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new klass(buffer.$to_n())], null)
        
        };
        self.buffer = buffer;
        return (self.type = type);
      }, -2);
      
      $def(self, '$bits', function $$bits() {
        var self = this;

        return self["native"].BYTES_PER_ELEMENT * 8
      }, 0);
      
      $def(self, '$[]', function $Array_$$$2(index, offset) {
        var self = this;

        
        
        if (offset == null) offset = nil;;
        if ($truthy(offset)) {
          return self["native"].subarray(index, offset)
        } else {
          return self["native"][index]
        };
      }, -2);
      
      $def(self, '$[]=', function $Array_$$$eq$3(index, value) {
        var self = this;

        return self["native"][index] = value
      }, 2);
      
      $def(self, '$bytesize', function $$bytesize() {
        var self = this;

        return self["native"].byteLength
      }, 0);
      
      $def(self, '$each', function $$each() {
        var $yield = $$each.$$p || nil, self = this;

        delete $$each.$$p;
        
        if (!($yield !== nil)) {
          return self.$enum_for("each")
        };
        
        for (var i = 0, length = self["native"].length; i < length; i++) {
          Opal.yield1($yield, self["native"][i])
        }
      ;
        return self;
      }, 0);
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].length
      }, 0);
      
      $def(self, '$merge!', function $Array_merge$excl$4(other, offset) {
        var self = this;

        
        ;
        return self["native"].set(other.$to_n(), offset);
      }, -2);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["buffer/view"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias;

  Opal.add_stubs('include,!,nil?,[],attr_reader,native?,to_n,name_for,get,set,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'View');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$supported?', function $View_supported$ques$1() {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("DataView")['$nil?']()['$!']()
      }, 0);
      self.$attr_reader("buffer", "offset");
      
      $def(self, '$initialize', function $$initialize(buffer, offset, length) {
        var $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        
        if (offset == null) offset = nil;;
        
        if (length == null) length = nil;;
        if ($truthy(self['$native?'](buffer))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else if (($truthy(offset) && ($truthy(length)))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n(), length.$to_n())], null)
        } else if ($truthy(offset)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n())], null)
        } else {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n())], null)
        };
        self.buffer = buffer;
        return (self.offset = offset);
      }, -2);
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].byteLength
      }, 0);
      
      $def(self, '$get', function $$get(offset, bits, type, little) {
        var self = this;

        
        
        if (bits == null) bits = 8;;
        
        if (type == null) type = "unsigned";;
        
        if (little == null) little = false;;
        return self["native"]["get" + $$('Buffer').$name_for(bits, type)](offset, little);
      }, -2);
      $alias(self, "[]", "get");
      
      $def(self, '$set', function $$set(offset, value, bits, type, little) {
        var self = this;

        
        
        if (bits == null) bits = 8;;
        
        if (type == null) type = "unsigned";;
        
        if (little == null) little = false;;
        return self["native"]["set" + $$('Buffer').$name_for(bits, type)](offset, value, little);
      }, -3);
      $alias(self, "[]=", "set");
      
      $def(self, '$get_int8', function $$get_int8(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getInt8(offset, little);
      }, -2);
      
      $def(self, '$set_int8', function $$set_int8(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setInt8(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint8', function $$get_uint8(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getUint8(offset, little);
      }, -2);
      
      $def(self, '$set_uint8', function $$set_uint8(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setUint8(offset, value, little);
      }, -3);
      
      $def(self, '$get_int16', function $$get_int16(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getInt16(offset, little);
      }, -2);
      
      $def(self, '$set_int16', function $$set_int16(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setInt16(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint16', function $$get_uint16(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getUint16(offset, little);
      }, -2);
      
      $def(self, '$set_uint16', function $$set_uint16(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setUint16(offset, value, little);
      }, -3);
      
      $def(self, '$get_int32', function $$get_int32(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getInt32(offset, little);
      }, -2);
      
      $def(self, '$set_int32', function $$set_int32(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setInt32(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint32', function $$get_uint32(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getUint32(offset, little);
      }, -2);
      
      $def(self, '$set_uint32', function $$set_uint32(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setUint32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float32', function $$get_float32(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getFloat32(offset, little);
      }, -2);
      
      $def(self, '$set_float32', function $$set_float32(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setFloat32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float64', function $$get_float64(offset, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].getFloat64(offset, little);
      }, -2);
      
      $def(self, '$set_float64', function $$set_float64(offset, value, little) {
        var self = this;

        
        
        if (little == null) little = false;;
        return self["native"].setFloat64(offset, value, little);
      }, -3);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["buffer"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias;

  Opal.add_stubs('require,include,!,nil?,[],===,native?,new,pack,to_a,length');
  
  self.$require("native");
  self.$require("buffer/array");
  self.$require("buffer/view");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    $defs(self, '$supported?', function $Buffer_supported$ques$1() {
            if ($gvars.$ == null) $gvars.$ = nil;

      return $gvars.$['$[]']("ArrayBuffer")['$nil?']()['$!']()
    }, 0);
    $defs(self, '$name_for', function $$name_for(bits, type) {
      var part = nil, $ret_or_1 = nil;

      
      part = ($eqeqeq("unsigned", ($ret_or_1 = type)) ? ("Uint") : ($eqeqeq("signed", $ret_or_1) ? ("Int") : ($eqeqeq("float", $ret_or_1) ? ("Float") : (nil))));
      return "" + (part) + (bits);
    }, 2);
    
    $def(self, '$initialize', function $$initialize(size, bits) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (bits == null) bits = 8;;
      if ($truthy(self['$native?'](size))) {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], null)
      } else {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new ArrayBuffer(size * (bits / 8))], null)
      };
    }, -2);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"].byteLength
    }, 0);
    
    $def(self, '$to_a', function $$to_a(bits, type) {
      var self = this;

      
      
      if (bits == null) bits = 8;;
      
      if (type == null) type = "unsigned";;
      return $$('Array').$new(self, bits, type);
    }, -1);
    
    $def(self, '$view', function $$view(offset, length) {
      var self = this;

      
      
      if (offset == null) offset = nil;;
      
      if (length == null) length = nil;;
      return $$('View').$new(self, offset, length);
    }, -1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.$to_a().$to_a().$pack("c*")
    }, 0);
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/process/status"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $return_ivar = Opal.return_ivar;

  Opal.add_stubs('attr_reader,==');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Process');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Status');

      var $proto = self.$$prototype;

      $proto.status = $proto.pid = nil;
      
      
      $def(self, '$initialize', function $$initialize(status, pid) {
        var $a, self = this;

        return $a = [status, pid], (self.status = $a[0]), (self.pid = $a[1]), $a
      }, 2);
      
      $def(self, '$exitstatus', $return_ivar("status"), 0);
      self.$attr_reader("pid");
      
      $def(self, '$success?', function $Status_success$ques$1() {
        var self = this;

        return self.status['$=='](0)
      }, 0);
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Process::Status: pid " + (self.pid) + " exit " + (self.status) + ">"
      }, 0);
    })($nesting[0], null)
  })('::', $nesting)
};

Opal.modules["nodejs/kernel"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $neqeq = Opal.neqeq, $def = Opal.def;

  Opal.add_stubs('require,is_a?,first,shift,to_n,merge,empty?,===,[],new,!=,raise,==,encode,to_s');
  
  self.$require("buffer");
  self.$require("corelib/process/status");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);
    if (self.__child_process__ == null) self.__child_process__ = nil;

    
    self.__child_process__ = require('child_process');
    var __child_process__ = self.__child_process__;
    
    $def(self, '$system', function $$system($a, $b) {
      var $post_args, $kwargs, argv, exception, self = this, env = nil, cmdname = nil, out = nil, status = nil, pid = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      argv = $post_args;;
      
      exception = $kwargs.$$smap["exception"];
      if (exception == null) exception = false;
      env = $hash2([], {});
      if ($truthy(argv.$first()['$is_a?']($$('Hash')))) {
        env = argv.$shift()
      };
      env = $$('ENV').$merge(env).$to_n();
      cmdname = argv.$shift();
      out = ($truthy(argv['$empty?']()) ? (__child_process__.spawnSync(cmdname, { shell: true, stdio: 'inherit', env: env })) : ($eqeqeq($$('Array'), cmdname) ? (__child_process__.spawnSync(cmdname['$[]'](0), argv, { argv0: cmdname['$[]'](1), stdio: 'inherit', env: env })) : (__child_process__.spawnSync(cmdname, argv, { stdio: 'inherit', env: env }))));
      status = out["status"];
      if ($truthy(status === null)) {
        status = 127
      };
      pid = out["pid"];
      $gvars["?"] = $$$($$('Process'), 'Status').$new(status, pid);
      if (($truthy(exception) && ($neqeq(status, 0)))) {
        self.$raise("Command failed with exit " + (status) + ": " + (cmdname))
      };
      return status['$=='](0);
    }, -1);
    return $def(self, '$`', function $Kernel_$$1(cmdline) {
      
      return $$('Buffer').$new(__child_process__.execSync(cmdline)).$to_s().$encode("UTF-8")
    }, 1);
  })($nesting[0], $nesting);
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        
        if (level == null) level = 1;;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        
        if (suffix == null) suffix = nil;;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, 1);
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      }, 1);
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], function $$3(f){
          
          
          if (f == null) f = nil;;
          return f['$=~']($regexp(["^", path]));}, 1);
        return file;
      }, 1);
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };}, 2);
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };}, 2);
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      }, 1);
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["nodejs/file"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $const_set = Opal.const_set, $defs = Opal.defs, $alias = Opal.alias, $neqeq = Opal.neqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $assign_ivar = Opal.assign_ivar;

  Opal.add_stubs('require,constants,raise,warn,const_get,new,error,size,delete,respond_to?,path,join,call,start_with?,first,exist?,realpath,!=,close,to_path,pwd,to_str,include?,match?,sub,attr_reader');
  
  self.$require("corelib/file");
  
  var warnings = {}, errno_codes = $$('Errno').$constants();

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$('Kernel').$raise($$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }
  function warn(string) {
    if (warnings[string]) {
      return;
    }
    warnings[string] = true;
    self.$warn(string);
  }
  function is_utf8(bytes) {
    var i = 0;
    while (i < bytes.length) {
      if ((// ASCII
        bytes[i] === 0x09 ||
        bytes[i] === 0x0A ||
        bytes[i] === 0x0D ||
        (0x20 <= bytes[i] && bytes[i] <= 0x7E)
      )
      ) {
        i += 1;
        continue;
      }

      if ((// non-overlong 2-byte
        (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
        (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF)
      )
      ) {
        i += 2;
        continue;
      }

      if ((// excluding overlongs
          bytes[i] === 0xE0 &&
          (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// straight 3-byte
          ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
            bytes[i] === 0xEE ||
            bytes[i] === 0xEF) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// excluding surrogates
          bytes[i] === 0xED &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x9F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        )
      ) {
        i += 3;
        continue;
      }

      if ((// planes 1-3
          bytes[i] === 0xF0 &&
          (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// planes 4-15
          (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// plane 16
          bytes[i] === 0xF4 &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        )
      ) {
        i += 4;
        continue;
      }

      return false;
    }

    return true;
  }
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (errno_codes.indexOf(error.code) >= 0) {
        var error_class = $$('Errno').$const_get(error.code)
        $$('Kernel').$raise((error_class).$new(error.message))
      }
      $$('Kernel').$raise(self.$error())
    }
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__util__ == null) self.__util__ = nil;

    $proto.eof = $proto.binary_flag = $proto.path = $proto.fd = nil;
    
    self.__fs__ = require('fs');
    self.__path__ = require('path');
    self.__util__ = require('util');
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __util__ = self.__util__;
    var __TextEncoder__ = typeof TextEncoder !== 'undefined' ? TextEncoder : __util__.TextEncoder;
    var __TextDecoder__ = typeof TextDecoder !== 'undefined' ? TextDecoder : __util__.TextDecoder;
    var __utf8TextDecoder__ = new __TextDecoder__('utf8');
    var __textEncoder__ = new __TextEncoder__();
    if ($truthy(__path__.sep !== $$('Separator'))) {
      $const_set($nesting[0], 'ALT_SEPARATOR', __path__.sep)
    };
    $defs(self, '$read', function $$read(path) {
      
      return executeIOAction(function(){return __fs__.readFileSync(path).toString()})
    }, 1);
    $defs(self, '$write', function $$write(path, data) {
      
      
      executeIOAction(function(){return __fs__.writeFileSync(path, data)});
      return data.$size();
    }, 2);
    $defs(self, '$delete', function $File_delete$1(path) {
      
      return executeIOAction(function(){return __fs__.unlinkSync(path)})
    }, 1);
    (function(self, $parent_nesting) {
      
      return $alias(self, "unlink", "delete")
    })(Opal.get_singleton_class(self), $nesting);
    $defs(self, '$exist?', function $File_exist$ques$2(path) {
      
      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()
      };
      return executeIOAction(function(){return __fs__.existsSync(path)});
    }, 1);
    $defs(self, '$realpath', function $$realpath(pathname, dir_string, cache) {
      var block = $$realpath.$$p || nil, self = this;

      delete $$realpath.$$p;
      
      ;
      
      if (dir_string == null) dir_string = nil;;
      
      if (cache == null) cache = nil;;
      if ($truthy(dir_string)) {
        pathname = self.$join(dir_string, pathname)
      };
      if ((block !== nil)) {
        
        __fs__.realpath(pathname, cache, function(error, realpath){
          if (error) Opal.IOError.$new(error.message)
          else block.$call(realpath)
        })
        
      } else {
        return executeIOAction(function(){return __fs__.realpathSync(pathname, cache)})
      };
    }, -2);
    $defs(self, '$join', function $$join($a) {
      var $post_args, paths, $b, prefix = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      paths = $post_args;;
      prefix = ($truthy(($b = paths.$first(), ($b === nil || $b == null) ? nil : paths.$first()['$start_with?']("//"))) ? ("/") : (""));
      return prefix + __path__.posix.join.apply(__path__, paths);
    }, -1);
    $defs(self, '$directory?', function $File_directory$ques$3(path) {
      var self = this, result = nil, realpath = nil;

      
      if (!$truthy(self['$exist?'](path))) {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isDirectory()});
      if (!$truthy(result)) {
        
        realpath = self.$realpath(path);
        if ($neqeq(realpath, path)) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isDirectory()})
        };
      };
      return result;
    }, 1);
    $defs(self, '$file?', function $File_file$ques$4(path) {
      var self = this, result = nil, realpath = nil;

      
      if (!$truthy(self['$exist?'](path))) {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isFile()});
      if (!$truthy(result)) {
        
        realpath = self.$realpath(path);
        if ($neqeq(realpath, path)) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isFile()})
        };
      };
      return result;
    }, 1);
    $defs(self, '$readable?', function $File_readable$ques$5(path) {
      var self = this;

      
      if (!$truthy(self['$exist?'](path))) {
        return false
      };
      return "\n" + "        try {\n" + "          __fs__.accessSync(path, __fs__.R_OK);\n" + "          return true;\n" + "        } catch (error) {\n" + "          return false;\n" + "        }\n" + "      ";
    }, 1);
    $defs(self, '$size', function $$size(path) {
      
      return executeIOAction(function(){return __fs__.lstatSync(path).size});
    }, 1);
    $defs(self, '$open', function $$open(path, mode) {
      var $yield = $$open.$$p || nil, self = this, file = nil;

      delete $$open.$$p;
      
      
      if (mode == null) mode = "r";;
      file = self.$new(path, mode);
      if (($yield !== nil)) {
        
        return (function() { try {
        return Opal.yield1($yield, file);
        } finally {
          file.$close()
        }; })();
      } else {
        return file
      };
    }, -2);
    $defs(self, '$stat', function $$stat(path) {
      
      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()
      };
      return $$$($$('File'), 'Stat').$new(path);
    }, 1);
    $defs(self, '$mtime', function $$mtime(path) {
      
      return executeIOAction(function(){return __fs__.statSync(path).mtime})
    }, 1);
    $defs(self, '$symlink?', function $File_symlink$ques$6(path) {
      
      return executeIOAction(function(){return __fs__.lstatSync(path).isSymbolicLink()})
    }, 1);
    $defs(self, '$absolute_path', function $$absolute_path(path, basedir) {
      var $ret_or_1 = nil;

      
      
      if (basedir == null) basedir = nil;;
      path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
      basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$('Dir').$pwd()));
      return __path__.normalize(__path__.resolve(basedir.$to_str(), path.$to_str())).split(__path__.sep).join(__path__.posix.sep);
    }, -2);
    
    $def(self, '$initialize', function $$initialize(path, flags) {
      var $yield = $$initialize.$$p || nil, self = this, encoding_option_rx = nil, fd = nil;

      delete $$initialize.$$p;
      
      
      if (flags == null) flags = "r";;
      self.binary_flag = flags['$include?']("b");
      flags = flags.$delete("b");
      encoding_option_rx = /:(.*)/;
      if ($truthy(encoding_option_rx['$match?'](flags))) {
        
        handle_unsupported_feature("Encoding option (:encoding) is unsupported by Node.js openSync method and will be removed.");
        flags = flags.$sub(encoding_option_rx, "");
      };
      self.path = path;
      fd = executeIOAction(function(){return __fs__.openSync(path, flags)});
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [fd, flags], null);
    }, -2);
    self.$attr_reader("path");
    
    $def(self, '$sysread', function $$sysread(bytes) {
      var self = this, res = nil;

      if ($truthy(self.eof)) {
        return self.$raise($$('EOFError'), "end of file reached")
      } else {
        
        if ($truthy(self.binary_flag)) {
          
          
          var buf = executeIOAction(function(){return __fs__.readFileSync(self.path)})
          var content
          if (is_utf8(buf)) {
            content = buf.toString('utf8')
          } else {
            // coerce to utf8
            content = __utf8TextDecoder__.decode(__textEncoder__.encode(buf.toString('binary')))
          }
        ;
          res = content;
        } else {
          res = executeIOAction(function(){return __fs__.readFileSync(self.path).toString('utf8')})
        };
        self.eof = true;
        self.lineno = res.$size();
        return res;
      }
    }, 1);
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      return executeIOAction(function(){return __fs__.writeSync(self.fd, string)})
    }, 1);
    
    $def(self, '$flush', function $$flush() {
      var self = this;

      return executeIOAction(function(){return __fs__.fsyncSync(self.fd)})
    }, 0);
    
    $def(self, '$close', function $$close() {
      var $yield = $$close.$$p || nil, self = this;

      delete $$close.$$p;
      
      executeIOAction(function(){return __fs__.closeSync(self.fd)});
      return $send2(self, $find_super(self, 'close', $$close, false, true), 'close', [], $yield);
    }, 0);
    return $def(self, '$mtime', function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, 0);
  })($nesting[0], $$('IO'), $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Stat');

    var $proto = self.$$prototype;
    if (self.__fs__ == null) self.__fs__ = nil;

    $proto.path = nil;
    
    self.__fs__ = require('fs');
    var __fs__ = self.__fs__;
    
    $def(self, '$initialize', $assign_ivar("path"), 0);
    
    $def(self, '$file?', function $Stat_file$ques$7() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).isFile()})
    }, 0);
    
    $def(self, '$directory?', function $Stat_directory$ques$8() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).isDirectory()})
    }, 0);
    
    $def(self, '$mtime', function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, 0);
    
    $def(self, '$readable?', function $Stat_readable$ques$9() {
      var self = this;

      return executeIOAction(function(){return __fs__.accessSync(self.path, __fs__.constants.R_OK)})
    }, 0);
    
    $def(self, '$writable?', function $Stat_writable$ques$10() {
      var self = this;

      return executeIOAction(function(){return __fs__.accessSync(self.path, __fs__.constants.W_OK)})
    }, 0);
    return $def(self, '$executable?', function $Stat_executable$ques$11() {
      var self = this;

      return executeIOAction(function(){return __fs__.accessSync(self.path, __fs__.constants.X_OK)})
    }, 0);
  })($$('File'), null);
};

Opal.modules["nodejs/dir"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $Opal = Opal.Opal, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,flat_map,to_path,coerce_to!,pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);
    if (self.__glob__ == null) self.__glob__ = nil;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__os__ == null) self.__os__ = nil;

    
    self.__glob__ = require('glob');
    self.__fs__ = require('fs');
    self.__path__ = require('path');
    self.__os__ = require('os');
    var __glob__ = self.__glob__;
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __os__ = self.__os__;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$[]', function $$$1(glob) {
        
        return __glob__.sync(glob)
      }, 1);
      
      $def(self, '$pwd', function $$pwd() {
        
        return process.cwd().split(__path__.sep).join(__path__.posix.sep);
      }, 0);
      
      $def(self, '$home', function $$home() {
        
        return __os__.homedir();
      }, 0);
      
      $def(self, '$chdir', function $$chdir(path) {
        
        return process.chdir(path)
      }, 1);
      
      $def(self, '$mkdir', function $$mkdir(path) {
        
        return __fs__.mkdirSync(path)
      }, 1);
      
      $def(self, '$entries', function $$entries(dirname) {
        
        
        var result = [];
        var entries = __fs__.readdirSync(dirname);
        for (var i = 0, ii = entries.length; i < ii; i++) {
          result.push(entries[i]);
        }
        return result;
      
      }, 1);
      
      $def(self, '$glob', function $$glob(pattern) {
        
        
        if (!$truthy(pattern['$respond_to?']("each"))) {
          pattern = [pattern]
        };
        return $send(pattern, 'flat_map', [], function $$2(subpattern){
          
          
          if (subpattern == null) subpattern = nil;;
          if ($truthy(subpattern['$respond_to?']("to_path"))) {
            subpattern = subpattern.$to_path()
          };
          subpattern = $Opal['$coerce_to!'](subpattern, $$('String'), "to_str");
          return __glob__.sync(subpattern);;}, 1);
      }, 1);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting)
};

Opal.modules["nodejs/io"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $klass = Opal.klass, $alias = Opal.alias, $def = Opal.def, $defs = Opal.defs;

  Opal.add_stubs('require,attr_reader,initialize,initialize_before_node_io,write,read');
  
  self.$require("nodejs/file");
  
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (error.code === 'EACCES' ||
          error.code === 'EISDIR' ||
          error.code === 'EMFILE' ||
          error.code === 'ENOENT' ||
          error.code === 'EPERM') {
        throw Opal.IOError.$new(error.message)
      }
      throw error;
    }
  }
;
  var __fs__ = require('fs');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.__fs__ = __fs__;
    self.$attr_reader("lineno");
    $alias(self, "initialize_before_node_io", "initialize");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      
      if (flags == null) flags = "r";;
      self.lineno = 0;
      return self.$initialize_before_node_io(fd, flags);
    }, -2);
    $defs(self, '$write', function $$write(path, data) {
      
      return $$('File').$write(path, data)
    }, 2);
    $defs(self, '$read', function $$read(path) {
      
      return $$('File').$read(path)
    }, 1);
    return $defs(self, '$binread', function $$binread(path) {
      
      return executeIOAction(function(){return __fs__.readFileSync(path).toString('binary')})
    }, 1);
  })($nesting[0], null, $nesting);
};

Opal.modules["nodejs/argf"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $const_set = Opal.const_set, $return_val = Opal.return_val, $def = Opal.def, $eqeq = Opal.eqeq, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $not = Opal.not, $alias = Opal.alias;

  Opal.add_stubs('new,include,filename,==,open,argv,shift,close,file,closed?,enum_for,gets,nil?,+,loop,read,-,length,>,to_a,each,attr_accessor,rewind,!,fileno,eof?,lineno=');
  
  $const_set($nesting[0], 'ARGF', $$('Object').$new());
  (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$('Enumerable'));
    
    $def(self, '$inspect', $return_val("ARGF"), 0);
    
    $def(self, '$argv', function $$argv() {
      
      return $$('ARGV')
    }, 0);
    
    $def(self, '$file', function $$file() {
      var self = this, fn = nil, $ret_or_1 = nil;
      if (self.file == null) self.file = nil;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      fn = self.$filename();
      if ($eqeq(fn, "-")) {
        return $gvars.stdin
      } else {
        return (self.file = ($truthy(($ret_or_1 = self.file)) ? ($ret_or_1) : ($$('File').$open(fn, "r"))))
      };
    }, 0);
    
    $def(self, '$filename', function $$filename() {
      var self = this, $ret_or_1 = nil;
      if (self.filename == null) self.filename = nil;
      if (self.last_filename == null) self.last_filename = nil;

      
      if ($truthy(self.filename)) {
        return self.filename
      };
      if ($eqeq(self.$argv(), ["-"])) {
        return "-"
      } else if ($eqeq(self.$argv(), [])) {
        if ($truthy(($ret_or_1 = self.last_filename))) {
          return $ret_or_1
        } else {
          return "-"
        }
      } else {
        
        self.file = nil;
        return (self.filename = (self.last_filename = self.$argv().$shift()));
      };
    }, 0);
    
    $def(self, '$close', function $$close() {
      var self = this;

      
      self.$file().$close();
      self.filename = nil;
      return self;
    }, 0);
    
    $def(self, '$closed?', function $closed$ques$1() {
      var self = this;

      return self.$file()['$closed?']()
    }, 0);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, $b, self = this, l = nil;

      delete $$each.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (!(block !== nil)) {
        return self.$enum_for("each")
      };
      while ($truthy((l = $send(self, 'gets', $to_a(args))))) {
        Opal.yield1(block, l)
      };
    }, -1);
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args, self = this, s = nil;
      if (self.lineno == null) self.lineno = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      s = $send(self.$file(), 'gets', $to_a(args));
      if ($truthy(s['$nil?']())) {
        
        self.$close();
        s = $send(self.$file(), 'gets', $to_a(args));
      };
      if ($truthy(s)) {
        self.lineno = $rb_plus(self.lineno, 1)
      };
      return s;
    }, -1);
    
    $def(self, '$read', function $$read(len) {
      var self = this, buf = nil;

      
      
      if (len == null) len = nil;;
      buf = "";
      return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s, r = nil;
        if (self.filename == null) self.filename = nil;

        
        r = self.$file().$read(len);
        if ($truthy(r)) {
          
          buf = $rb_plus(buf, r);
          len = $rb_minus(len, r.$length());
        };
        self.$file().$close();
        if ((($truthy(len) && ($truthy($rb_gt(len, 0)))) && ($truthy(self.filename)))) {
          
          Opal.brk(nil, $brk)
        } else {
          return nil
        };}, {$$arity: 0, $$s: self, $$brk: $brk})
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
    }, -1);
    
    $def(self, '$readlines', function $$readlines($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send(self, 'each', $to_a(args)).$to_a();
    }, -1);
    self.$attr_accessor("lineno");
    
    $def(self, '$rewind', function $$rewind() {
      var self = this, f = nil;

      
      self.lineno = 1;
      f = self.$file();
      
      try {
        f.$rewind()
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {
          try {
            nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return 0;
    }, 0);
    
    $def(self, '$fileno', function $$fileno() {
      var self = this;
      if (self.last_filename == null) self.last_filename = nil;
      if (self.filename == null) self.filename = nil;

      
      if (($not(self.filename) && ($truthy(self.last_filename)))) {
        return 0
      };
      return self.$file().$fileno();
    }, 0);
    
    $def(self, '$eof?', function $eof$ques$3() {
      var self = this;

      return self.$file()['$eof?']()
    }, 0);
    $alias(self, "each_line", "each");
    $alias(self, "eof", "eof?");
    $alias(self, "path", "filename");
    $alias(self, "skip", "close");
    $alias(self, "to_i", "fileno");
    return $alias(self, "to_io", "file");
  })(Opal.get_singleton_class($$('ARGF')), $nesting);
  return ($a = [1], $send($$('ARGF'), 'lineno=', $a), $a[$a.length - 1]);
};

Opal.modules["nodejs/open-uri"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $defs = Opal.defs;

  return (function($base) {
    var self = $module($base, 'OpenURI');

        if (self.__xmlhttprequest__ == null) self.__xmlhttprequest__ = nil;

    
    self.__xmlhttprequest__ = require('unxhr');
    var __XMLHttpRequest__ = self.__xmlhttprequest__.XMLHttpRequest;
    $defs(self, '$request', function $$request(uri) {
      
      
      var xhr = new __XMLHttpRequest__();
      xhr.open('GET', uri, false);
      xhr.responseType = 'arraybuffer';
      xhr.send();
      return xhr;
    
    }, 1);
    return $defs(self, '$data', function $$data(req) {
      
      
      var arrayBuffer = req.response;
      var byteArray = new Uint8Array(arrayBuffer);
      var result = []
      for (var i = 0; i < byteArray.byteLength; i++) {
        result.push(byteArray[i]);
      }
      return result;
    
    }, 1);
  })($nesting[0])
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) max = nil;;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["pathname"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $defs = Opal.defs, $to_ary = Opal.to_ary, $send = Opal.send, $to_a = Opal.to_a, $return_ivar = Opal.return_ivar, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $not = Opal.not, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs('require,include,quote,===,to_s,path,respond_to?,to_path,is_a?,nil?,raise,class,==,new,pwd,attr_reader,!,relative?,chop_basename,basename,=~,source,[],rindex,sub,absolute?,expand_path,plus,unshift,length,!=,empty?,first,shift,+,join,dirname,pop,reverse_each,directory?,extname,<=>,nonzero?,proc,casecmp,cleanpath,inspect,include?,fill,map,entries');
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.path = nil;
    
    self.$include($$('Comparable'));
    $const_set($nesting[0], 'SEPARATOR_PAT', $regexp([$$('Regexp').$quote($$$($$('File'), 'SEPARATOR'))]));
    
    $def(self, '$initialize', function $$initialize(path) {
      var self = this;

      
      if ($eqeqeq($$('Pathname'), path)) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$('String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$('TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$('TypeError'), "no implicit conversion of " + (path.$class()) + " into String")
      };
      if ($eqeq(self.path, "\u0000")) {
        return self.$raise($$('ArgumentError'))
      } else {
        return nil
      };
    }, 1);
    $defs(self, '$pwd', function $$pwd() {
      var self = this;

      return self.$new($$('Dir').$pwd())
    }, 0);
    self.$attr_reader("path");
    
    $def(self, '$==', function $Pathname_$eq_eq$1(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, 1);
    
    $def(self, '$absolute?', function $Pathname_absolute$ques$2() {
      var self = this;

      return self['$relative?']()['$!']()
    }, 0);
    
    $def(self, '$relative?', function $Pathname_relative$ques$3() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = $to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, 0);
    
    $def(self, '$chop_basename', function $$chop_basename(path) {
      var base = nil;

      
      base = $$('File').$basename(path);
      if ($truthy($$('Regexp').$new("^" + ($$$($$('Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, 1);
    
    $def(self, '$root?', function $Pathname_root$ques$4() {
      var self = this;

      return self.path['$==']("/")
    }, 0);
    
    $def(self, '$parent', function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if ($eqeq(new_path, "")) {
        new_path = ($truthy(self['$absolute?']()) ? ("/") : ("."))
      };
      return $$('Pathname').$new(new_path);
    }, 0);
    
    $def(self, '$sub', function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $$('Pathname').$new($send(self.path, 'sub', $to_a(args)));
    }, -1);
    
    $def(self, '$cleanpath', function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, 0);
    
    $def(self, '$to_path', $return_ivar("path"), 0);
    
    $def(self, '$hash', $return_ivar("path"), 0);
    
    $def(self, '$expand_path', function $$expand_path() {
      var self = this;

      return $$('Pathname').$new($$('File').$expand_path(self.path))
    }, 0);
    
    $def(self, '$+', function $Pathname_$plus$5(other) {
      var self = this;

      
      if (!$eqeqeq($$('Pathname'), other)) {
        other = $$('Pathname').$new(other)
      };
      return $$('Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, 1);
    
    $def(self, '$plus', function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, $ret_or_1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = $to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($neqeq(prefix2, "")) {
        return path2
      };
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$=='](".")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if (!$truthy((r1 = self.$chop_basename(prefix1)))) {
          break;
        };
        $c = r1, $b = $to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if ($eqeq(basename1, ".")) {
          continue;
        };
        if ((($eqeq(basename1, "..") || ($truthy(basename_list2['$empty?']()))) || ($neqeq(basename_list2.$first(), "..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;
        };
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if (($not(r1) && ($truthy($regexp([$$('SEPARATOR_PAT')])['$=~']($$('File').$basename(prefix1)))))) {
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$==']("..")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }
      };
      if ($not(basename_list2['$empty?']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$('File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$('File').$dirname(prefix1)
      };
    }, 2);
    
    $def(self, '$join', function $$join($a) {try {

      var $post_args, args, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self
      };
      result = args.$pop();
      if (!$eqeqeq($$('Pathname'), result)) {
        result = $$('Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result
      };
      $send(args, 'reverse_each', [], function $$6(arg){
        
        
        if (arg == null) arg = nil;;
        if (!$eqeqeq($$('Pathname'), arg)) {
          arg = $$('Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, 1);
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$split', function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, 0);
    
    $def(self, '$dirname', function $$dirname() {
      var self = this;

      return $$('Pathname').$new($$('File').$dirname(self.path))
    }, 0);
    
    $def(self, '$basename', function $$basename() {
      var self = this;

      return $$('Pathname').$new($$('File').$basename(self.path))
    }, 0);
    
    $def(self, '$directory?', function $Pathname_directory$ques$7() {
      var self = this;

      return $$('File')['$directory?'](self.path)
    }, 0);
    
    $def(self, '$extname', function $$extname() {
      var self = this;

      return $$('File').$extname(self.path)
    }, 0);
    
    $def(self, '$<=>', function $Pathname_$lt_eq_gt$8(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, 1);
    $const_set($nesting[0], 'SAME_PATHS', ($truthy($$$($$('File'), 'FNM_SYSCASE')['$nonzero?']()) ? ($send(self, 'proc', [], function $Pathname$9(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a.$casecmp(b)['$=='](0);}, 2)) : ($send(self, 'proc', [], function $Pathname$10(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a['$=='](b);}, 2))));
    
    $def(self, '$relative_path_from', function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, $ret_or_1 = nil, $ret_or_2 = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = $to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          dest_names.$unshift(basename)
        };
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = $to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          base_names.$unshift(basename)
        };
      };
      if (!$truthy($$('SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
        self.$raise($$('ArgumentError'), "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = dest_names['$empty?']()['$!']())) ? (base_names['$empty?']()['$!']()) : ($ret_or_2)))) ? ($$('SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first())) : ($ret_or_1)))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$('ArgumentError'), "base_directory has ..: " + (base_directory.$inspect()))
      };
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$('Pathname').$new(".")
      } else {
        return $$('Pathname').$new($send($$('File'), 'join', $to_a(relpath_names)))
      };
    }, 1);
    
    $def(self, '$entries', function $$entries() {
      var self = this;

      return $send($$('Dir').$entries(self.path), 'map', [], function $$11(f){var self = $$11.$$s == null ? this : $$11.$$s;

        
        
        if (f == null) f = nil;;
        return self.$class().$new(f);}, {$$arity: 1, $$s: self})
    }, 0);
    $alias(self, "===", "==");
    $alias(self, "eql?", "==");
    $alias(self, "to_s", "to_path");
    return $alias(self, "to_str", "to_path");
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Pathname', function $$Pathname(path) {
      
      return $$('Pathname').$new(path)
    }, 1)
  })($nesting[0], $nesting);
};

Opal.modules["nodejs/pathname"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $klass = Opal.klass, $def = Opal.def, $return_ivar = Opal.return_ivar;

  Opal.add_stubs('require,include,to_str,!,absolute?');
  
  self.$require("pathname");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;
    if (self.__path__ == null) self.__path__ = nil;

    $proto.path = nil;
    
    self.$include($$('Comparable'));
    self.__path__ = require('path');
    var __path__ = self.__path__;
    
    $def(self, '$absolute?', function $Pathname_absolute$ques$1() {
      var self = this;

      return __path__.isAbsolute(self.path.$to_str())
    }, 0);
    
    $def(self, '$relative?', function $Pathname_relative$ques$2() {
      var self = this;

      return self['$absolute?']()['$!']()
    }, 0);
    return $def(self, '$to_path', $return_ivar("path"), 0);
  })($nesting[0], null, $nesting);
};

Opal.modules["nodejs/env"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $return_val = Opal.return_val, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs('new,to_s,key?,[],raise,to_h,keys,merge');
  
  $const_set($nesting[0], 'ENV', $$('Object').$new());
  return (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$[]', function $$$1(name) {
      
      return process.env[name] || nil
    }, 1);
    
    $def(self, '$[]=', function $$$eq$2(name, value) {
      
      return process.env[name.$to_s()] = value.$to_s()
    }, 2);
    
    $def(self, '$key?', function $key$ques$3(name) {
      
      return process.env.hasOwnProperty(name)
    }, 1);
    
    $def(self, '$empty?', function $empty$ques$4() {
      
      return Object.keys(process.env).length === 0;
    }, 0);
    
    $def(self, '$keys', function $$keys() {
      
      return Object.keys(process.env);
    }, 0);
    
    $def(self, '$delete', function $delete$5(name) {
      
      
      var value = process.env[name] || nil;
      delete process.env[name];
      return value;
    
    }, 1);
    
    $def(self, '$fetch', function $$fetch(key, default_value) {
      var block = $$fetch.$$p || nil, self = this;

      delete $$fetch.$$p;
      
      ;
      ;
      if ($truthy(self['$key?'](key))) {
        return self['$[]'](key)
      };
      if ((block !== nil)) {
        return Opal.yield1(block, key)
      };
      if (!$truthy(typeof(default_value) === 'undefined')) {
        return default_value
      };
      return self.$raise($$('KeyError'), "key not found");
    }, -2);
    
    $def(self, '$to_s', $return_val("ENV"), 0);
    
    $def(self, '$to_h', function $$to_h() {
      var self = this;

      return $send(self.$keys(), 'to_h', [], function $$6(k){var self = $$6.$$s == null ? this : $$6.$$s;

        
        
        if (k == null) k = nil;;
        return [k, self['$[]'](k)];}, {$$arity: 1, $$s: self})
    }, 0);
    
    $def(self, '$merge', function $$merge(keys) {
      var self = this;

      return self.$to_h().$merge(keys)
    }, 1);
    $alias(self, "has_key?", "key?");
    $alias(self, "include?", "key?");
    $alias(self, "inspect", "to_s");
    $alias(self, "member?", "key?");
    return $alias(self, "to_hash", "to_h");
  })(Opal.get_singleton_class($$('ENV')), $nesting);
};

Opal.modules["nodejs"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("nodejs/base");
  self.$require("nodejs/kernel");
  self.$require("nodejs/file");
  self.$require("nodejs/dir");
  self.$require("nodejs/io");
  self.$require("nodejs/argf");
  self.$require("nodejs/open-uri");
  self.$require("nodejs/pathname");
  return self.$require("nodejs/env");
};

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":33,"buffer":9,"child_process":1,"fs":1,"glob":88,"os":31,"path":32,"unxhr":90,"util":64}],94:[function(require,module,exports){
(function (process,global){(function (){
(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $prop(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      Opal.gvars["!"] = exception;
      Opal.gvars["@"] = exception.$backtrace();
    }
    else {
      Opal.gvars["!"] = Opal.gvars["@"] = nil;
    }
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;


  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object['$' + method];
      if (body == null || body.$$stub) throw Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on Everything you ever wanted to know about constant lookup in Ruby (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass, singleton) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name && name !== nil) {
      $prop(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', constructor);
    $prop(klass, '$$prototype', constructor.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }

      if (Opal.trace_class) { invoke_tracers_for_class(klass); }

      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    $const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $prop(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {

      if (Opal.trace_class) { invoke_tracers_for_class(module); }

      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    $const_set(scope, name, module);

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    $prop(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    $prop(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $prop(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    if (obj.$$meta) {
      return Opal.own_instance_methods(obj.$$meta);
    }
    else {
      return [];
    }
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = '$'+stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      delete method_missing_stub.$$p;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new(
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    if (recv.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(recv.$$meta);
    } else {
      ancestors = Opal.ancestors(recv.$$class);
    }

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);
      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];
        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;
          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;
          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] !== 'undefined') {
            refine_module = refine_modules[ancestor];
            // Does this module define a method we want to call?
            if (typeof refine_module.$$prototype['$'+method] !== 'undefined') {
              body = refine_module.$$prototype['$'+method];
              return Opal.send2(recv, body, method, args, block, blockopts);
            }
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype['$' + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      delete alias.$$p;

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty(Opal.gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return Opal.gvars[old_name];
      },
      set: function(new_value) {
        Opal.gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value, key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------
  Opal.rb_plus   = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return (typeof(l) === 'number' && typeof(r) === 'number') ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function $eqeq(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs === rhs;
    }
    return $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;

  Opal.eqeqeq = function(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs === rhs;
    }
    return $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    if ((typeof lhs === 'number' && typeof rhs === 'number') ||
        (typeof lhs === 'string' && typeof rhs === 'string')) {
      return lhs !== rhs;
    }
    return $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (true === arg) return false;
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) this[ivar] = nil;
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      return this[ivar] = static_val;
    }
  }

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = Opal.allocate_module('Opal');
  Opal.Kernel      = Kernel      = Opal.allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments);
    var block = top_define_method.$$p;
    delete top_define_method.$$p;
    return Opal.send(_Object, 'define_method', args, block)
  };

  // Nil
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    }, 2);
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3);
      
      args = $post_args;;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, 3);
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    }, 2);
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, 1);
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    }, 1);
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    }, 1);
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Kernel = Opal.Kernel, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $eqeq = Opal.eqeq, $return_val = Opal.return_val, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias;

  Opal.add_stubs('module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,append_features,included,name,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, 0);
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    }, 1);
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, 1);
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, 1);
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, 1);
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, 2);
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) jsid = mid;;
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, 0);
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, 1);
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };
      }
      return nil;
    
    }, 2);
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    }, 1);
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, 0);
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, 1);
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, 2);
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, 1);
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, 1);
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, 0);
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module  modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      
      if (inherit == null) inherit = true;;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          
          if (o == null) o = nil;;
          
          if (c == null) c = nil;;
          return o.$const_get(c);}, 2)
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    }, 1);
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    }, 2);
    
    $def(self, '$public_constant', $return_val(nil), 0);
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      delete $$define_method.$$p;
      
      ;
      ;
      
      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
    ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($eqeqeq($$$('Proc'), ($ret_or_2 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_2) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_2) ? ($lambda(function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s, bound = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        bound = method.$bind(self);
        return $send(bound, 'call', $to_a(args));}, {$$arity: -1, $$s: self})) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (block.$class()) + " (expected Proc/Method)"))))));
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid
            target.$$jsid = name;
            try {
              return target.apply(self, args);
            } finally {
              target.$$jsid = old_name
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, '$' + name, block);
    ;
    }, -2);
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$12() {
      var self = this;

      return !!self.$$is_singleton;
    }, 0);
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, 0);
    
    $def(self, '$include?', function $Module_include$ques$13(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, 1);
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) include_super = true;;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil), 0);
    
    $def(self, '$extended', $return_val(nil), 0);
    
    $def(self, '$extend_object', $return_val(nil), 0);
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      delete $$module_eval.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      delete $$module_exec.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$15(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, 1);
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, 0);
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, 1);
    
    $def(self, '$prepended', $return_val(nil), 0);
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, 1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, 0);
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this, copy = nil;

      delete $$dup.$$p;
      
      copy = $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, 0);
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, 1);
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    }, 1);
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      delete $$refine.$$p;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = {};
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    }, 1);
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    }, 1);
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      delete $$inspect.$$p;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    }, 0)
  })('::', $Module);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias;

  Opal.add_stubs('require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      delete $Class_new$1.$$p;
      
      ;
      
      if (superclass == null) superclass = $$('Object');;
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, 0);
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    }, 0);
    
    $def(self, '$inherited', $return_val(nil), 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, 1);
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      delete $Class_new$2.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    }, 0);
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      delete $$to_s.$$p;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    }, 0);
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.5.1 */
  "use strict";
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $alias = Opal.alias, $return_val = Opal.return_val, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge;

  Opal.add_stubs('==,raise,inspect,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller,pristine');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    }, 1);
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, 0);
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      delete $$__send__.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self['$' + symbol];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false), 0);
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, 1);
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      delete $$instance_eval.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      delete $$instance_exec.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      delete $$method_missing.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.5.1 */
  "use strict";
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,nil?,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,caller,map,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false), 0);
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, 1);
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, 1);
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, 1);
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      
      if (all == null) all = true;;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) all = true;;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, 1);
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      delete $$at_exit.$$p;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, 0);
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      
      if (start == null) start = 1;;
      
      if (length == null) length = nil;;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$class', function $Kernel_class$4() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      delete $$define_singleton_method.$$p;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      delete $$enum_for.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();
      if (method == null) method = "each";;
      
      args = $post_args;;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$5(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$exit', function $$exit(status) {
      var $a, $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) status = true;;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    }, 0);
    
    $def(self, '$initialize_copy', $return_val(nil), 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s, ivar = nil, inspect = nil;

            
            
            if (i == null) i = nil;;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$arity: 1, $$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$7(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, 1);
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, 1);
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, 1);
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, 2);
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$Integer', function $$Integer(value, base) {
      
      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            $Kernel.$raise($$$('FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $Opal['$coerce_to!'](value, $$$('Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value) {
      
      
      var str;

      if (value === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
    
    }, 1);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return $hash2([], {})
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    }, 1);
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, 1);
    
    $def(self, '$itself', $return_self, 0);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      delete $$lambda.$$p;
      
      ;
      return Opal.lambda(block);;
    }, 0);
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    }, 1);
    
    $def(self, '$loop', function $$loop() {
      var $a, $yield = $$loop.$$p || nil, self = this, e = nil;

      delete $$loop.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$10(){
          return $$$($$$('Float'), 'INFINITY')}, 0)
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    }, 0);
    
    $def(self, '$nil?', $return_val(false), 0);
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', $to_a(args)))
      };
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      delete $$proc.$$p;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, 0);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      $send(args, 'each', [], function $$11(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if (obj == null) obj = nil;;
        return $gvars.stdout.$puts(obj.$inspect());}, 1);
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, $e, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : self.$caller($rb_plus(uplevel, 1), 1).$first().$split(":in `")), ($c === nil || $c == null) ? nil : ($e = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($e === nil || $e == null) ? nil : self.$caller($rb_plus(uplevel, 1), 1).$first().$split(":in `")).$first());
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$12(s){
          
          
          if (s == null) s = nil;;
          return "" + (location) + "warning: " + (s);}, 1);
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      
      if (string == null) string = nil;;
      
      if (backtrace == null) backtrace = nil;;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$13(name, include_all) {
      var self = this;

      
      
      if (include_all == null) include_all = false;;
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$14(method_name, include_all) {
      
      
      
      if (include_all == null) include_all = false;;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    }, 1);
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, 1);
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      autoload = $kwargs.$$smap["autoload"];
      if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      
      if (seconds == null) seconds = nil;;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      
      if (seed == null) seed = $$('Random').$new_seed();;
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    }, 1);
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      delete $$tap.$$p;
      
      ;
      Opal.yield1(block, self);
      return self;
    }, 0);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, 0);
    
    $def(self, '$catch', function $Kernel_catch$15(tag) {
      var $yield = $Kernel_catch$15.$$p || nil, $ret_or_1 = nil, e = nil;

      delete $Kernel_catch$15.$$p;
      
      
      if (tag == null) tag = nil;;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$16(tag, obj) {
      
      
      
      if (obj == null) obj = nil;;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      delete $$open.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      delete $$yield_self.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1), 0)
      };
      return Opal.yield1($yield, self);;
    }, 0);
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $Kernel = Opal.Kernel;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"), 0);
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    }, 1);
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    }, 1);
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        delete $new$1.$$p;
        
        
        if (name == null) name = nil;;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    }, 0);
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $send2 = Opal.send2, $find_super = Opal.find_super, $module = Opal.module;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n").slice(0, 15));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace.slice(0, 15));
      }

      return [];
    
    }, 0);
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        
        if (loc == null) loc = nil;;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1))
      return self.backtrace_locations;
    
    }, 0);
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    }, 0);
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      
      if (str == null) str = nil;;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    }, 0);
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      if (kwargs == null) kwargs = nil;;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = $hash2(["highlight", "order"], {"highlight": $gvars.stderr['$tty?'](), "order": "top"}).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ($hash2([], {}))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        
        if (loc == null) loc = nil;;
        return "\tfrom " + (loc) + "\n";}, 1).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, 0);
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        
        if (i == null) i = nil;;
        return $rb_plus("  from ", i);}, 1).join("\n");
      }

      return backtrace;
    
    }, 1);
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, 0);
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (value == null) value = nil;;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (name == null) name = nil;;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (name == null) name = nil;;
      
      if (args == null) args = [];;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) receiver = nil;
      
      key = $kwargs.$$smap["key"];
      if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    }, 0);
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    }, 0);
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $const_set = Opal.const_set;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.1.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.5.1");
  $const_set('::', 'RUBY_RELEASE_DATE', "2022-07-20");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2022 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $hash2 = Opal.hash2, $NilClass = Opal.NilClass, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true), 0);
    
    $def(self, '$&', $return_val(false), 0);
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    }, 1);
    
    $def(self, '$dup', $return_val(nil), 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"), 0);
    
    $def(self, '$nil?', $return_val(true), 0);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      
      return Opal.hash();
    }, 0);
    
    $def(self, '$to_i', $return_val(0), 0);
    
    $def(self, '$to_s', $return_val(""), 0);
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    }, 0);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.5.1 */
  "use strict";
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_self = Opal.return_self, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, 0);
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    }, 0);
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, 1);
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, 1);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      delete $$method_missing.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      var body = self.$$class.$$prototype['$' + method];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      
      if (_include_all == null) _include_all = false;;
      var body = self.$$class.$$prototype['$' + method];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) max = nil;;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        delete $$allocate.$$p;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      }, 0);
      
      $def(self, '$escape', function $$escape(string) {
        
        return Opal.escape_regexp(string);
      }, 1);
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) n = nil;;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        regexp = regexp.replace('\\A', '^').replace('\\z', '$')

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, 1);
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    }, 1);
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, 0);
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      delete $$match.$$p;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$uniq()
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        
        if (i == null) i = nil;;
        return $send(i, 'map', [], function $$7(j){
          
          
          if (j == null) j = nil;;
          return $rb_plus(j.$last(), 1);}, 1);}, 1)
    }, 0);
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, 0);
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    }, 0);
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    }, 0);
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    }, 0);
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];
      if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : self.$match(idx).$length())
    }, 1);
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, 1);
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, 1);
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, 1);
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        
        if (i == null) i = nil;;
        return matches['$[]']($rb_minus(i.$last(), 1));}, 1);
    }, 0);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        
        if (k == null) k = nil;;
        
        if (v == null) v = nil;;
        return                str += " " + k + ":" + v.$inspect();}, 2)
      }

      return str + ">";
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    }, 0);
    
    $def(self, '$to_a', $return_ivar("matches"), 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $const_set = Opal.const_set;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,each_line,to_proc,to_a,class,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);
  ;
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.toString();
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    }, 1);
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $kwargs.$$smap["encoding"];
      if (encoding == null) encoding = nil;
      
      capacity = $kwargs.$$smap["capacity"];
      if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, 1);
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    }, 1);
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, 1);
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, 1);
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, 1);
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, 1);
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, 0);
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();
    }, 0);
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, 1);
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, 1);
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) separator = $gvars["/"];;
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result;
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return result;
    
    }, 0);
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.slice(prefix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.slice(0, self.length - suffix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.toLowerCase();
    }, 0);
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$each_line.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) separator = $post_args.shift();
      if (separator == null) separator = $gvars["/"];;
      
      chomp = $kwargs.$$smap["chomp"];
      if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash2(["chomp"], {"chomp": chomp}))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      delete $$gsub.$$p;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, 0);
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, 1);
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    }, 0);
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$lines.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) separator = $post_args.shift();
      if (separator == null) separator = $gvars["/"];;
      
      chomp = $kwargs.$$smap["chomp"];
      if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash2(["chomp"], {"chomp": chomp})], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\u0000\s]*/, '');
    }, 0);
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, 0);
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      delete $$match.$$p;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    }, 0);
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, 0);
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, 0);
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, 0);
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) padstr = " ";;
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, 0);
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      delete $$scan.$$p;
      
      ;
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];
      if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash2(["no_matchdata"], {"no_matchdata": no_matchdata}));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [result[0]];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\s\u0000]*|[\s\u0000]*$/g, '');
    }, 0);
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      delete $$sub.$$p;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      
      if (n == null) n = 16;;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      return str;
    
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil;

      delete $$to_proc.$$p;
      
      method_name = self.valueOf();
      return $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        delete $$17.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv['$' + method_name];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.toUpperCase();
    }, 0);
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      delete $$upto.$$p;
      
      ;
      
      if (excl == null) excl = false;;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) form = "nfc";;
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      
      if (form == null) form = "nfc";;
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') return self;
      self.$$frozen = true;
      return self;
    
    }, 0);
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen === true) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, 0);
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, 0);
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $module = Opal.module, $send = Opal.send, $to_a = Opal.to_a, $Opal = Opal.Opal, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $hash2 = Opal.hash2, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,to_proc,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base) {
    var self = $module($base, 'Enumerable');

    
    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try {

      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      delete $Enumerable_all$ques$1.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, -1)
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try {

      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      delete $Enumerable_any$ques$5.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy($Opal.$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, -1)
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      delete $$chunk.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      delete $$chunk_while.$$p;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        
        if (before == null) before = nil;;
        
        if (after == null) after = nil;;
        return Opal.yieldX(block, [before, after])['$!']();}, 2);
    }, 0);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      delete $$collect.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      delete $$collect_concat.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send(self, 'map', [], function $$14(item){
        
        
        if (item == null) item = nil;;
        return Opal.yield1(block, item);;}, 1).$flatten(1);
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      delete $$count.$$p;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$15($a){var $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true), 0)
      };
      $send(self, 'each', [], function $$16($a){var $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      delete $$cycle.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try {

      var block = $$detect.$$p || nil, self = this;

      delete $$detect.$$p;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$18($a){var $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, -1);
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, 1);
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      delete $$drop_while.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      delete $$each_cons.$$p;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    }, 1);
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      delete $$each_entry.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      data = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      delete $$each_slice.$$p;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      delete $$each_with_index.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      delete $$each_with_object.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, 1);
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      delete $$filter_map.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, 0);
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      delete $$find_all.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$find_index', function $$find_index(object) {try {

      var block = $$find_index.$$p || nil, self = this, index = nil;

      delete $$find_index.$$p;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($eqeq($Opal.$destructure(value), object)) {
            Opal.ret(index)
          };
          return index += 1;;}, -1)
      } else {
        $send(self, 'each', [], function $$27($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(index)
          };
          return index += 1;;}, -1)
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$first', function $$first(number) {try {

      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$28(value){
          
          
          if (value == null) value = nil;;
          Opal.ret(value);}, 1)
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$29($a){var $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments);
          
          args = $post_args;;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, -1);
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      delete $$grep.$$p;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      delete $$grep_v.$$p;
      
      ;
      result = [];
      $send(self, 'each', [], function $$31($a){var $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      delete $$group_by.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$32(){var self = $$32.$$s == null ? this : $$32.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, 0);
    
    $def(self, '$include?', function $Enumerable_include$ques$33(obj) {try {

      var self = this;

      
      $send(self, 'each', [], function $$34($a){var $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if ($eqeq($Opal.$destructure(args), obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, -1);
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, 1);
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      delete $$inject.$$p;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$35(enum$, $a){var $post_args, args;

        
        
        if (enum$ == null) enum$ = nil;;
        
        $post_args = Opal.slice.call(arguments, 1);
        
        args = $post_args;;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    }, 0);
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      delete $$max_by.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$37(a, b){
            
            
            if (a == null) a = nil;;
            
            if (b == null) b = nil;;
            return Opal.yieldX(block, [a, b]);;}, 2).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      delete $$min_by.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      delete $$minmax.$$p;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$39(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$<=>'](b);}, 2)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, 0);
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      delete $$minmax_by.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, 0);
    
    $def(self, '$none?', function $Enumerable_none$ques$41(pattern) {try {

      var block = $Enumerable_none$ques$41.$$p || nil, self = this;

      delete $Enumerable_none$ques$41.$$p;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$43($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$44($a){var $post_args, value, item = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$45(pattern) {try {

      var block = $Enumerable_one$ques$45.$$p || nil, self = this, count = nil;

      delete $Enumerable_one$ques$45.$$p;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, -1)
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      } else {
        $send(self, 'each', [], function $$48($a){var $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments);
          
          value = $post_args;;
          if (!$truthy($Opal.$destructure(value))) {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, -1)
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      delete $$partition.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      delete $$reverse_each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$51(){var self = $$51.$$s == null ? this : $$51.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      delete $$slice_before.$$p;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$52(e){var self = $$52.$$s == null ? this : $$52.$$s;

        
        
        if (e == null) e = nil;;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      delete $$slice_after.$$p;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$53(e){
          
          
          if (e == null) e = nil;;
          return pattern['$==='](e);}, 1)
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      delete $$slice_when.$$p;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$55(yielder){var self = $$55.$$s == null ? this : $$55.$$s;

        
        
        if (yielder == null) yielder = nil;;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      delete $$sort.$$p;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$56(a, b){
          
          
          if (a == null) a = nil;;
          
          if (b == null) b = nil;;
          return a['$<=>'](b);}, 2)
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, 0);
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      delete $$sort_by.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$57(){var self = $$57.$$s == null ? this : $$57.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      dup = $send(self, 'map', [], function $$58(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, 0);
      $send(dup, 'sort!', [], function $$59(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return (a[0])['$<=>'](b[0]);}, 2);
      return $send(dup, 'map!', [], function $$60(i){
        
        
        if (i == null) i = nil;;
        return i[1];;}, 1);
    }, 0);
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      delete $$sum.$$p;
      
      
      if (initial == null) initial = 0;;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$61($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {try {

      var block = $$take_while.$$p || nil, self = this, result = nil;

      delete $$take_while.$$p;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$62($a){var $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          Opal.ret(result)
        };
        return result.push(value);;}, -1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, 0);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      delete $$uniq.$$p;
      
      ;
      hash = $hash2([], {});
      $send(self, 'each', [], function $$63($a){var $post_args, args, $b, value = nil, produced = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    }, 0);
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$64(k, v){var $a;

          
          
          if (k == null) k = nil;;
          
          if (v == null) v = nil;;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);}, 2);
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      delete $$to_h.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      delete $$zip.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::')
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        
        if (creation_method == null) creation_method = "step";;
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      }, 0);
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      }, 0);
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      }, 0);
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      }, 1);
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      }, 1);
      
      $def(self, '$first', function $$first(count) {
        var $a, self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
          
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, $a, self = this, $ret_or_1 = nil, iter = nil;

        delete $$each.$$p;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
          
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      }, 0);
      
      $def(self, '$last', function $$last(count) {
        var $a, self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
          
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      }, 0);
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      }, 0);
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        enums = $post_args;;
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        delete $$each.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$arity: 0, $$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          
          if (enum$ == null) enum$ = nil;;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$arity: 1, $$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try {

        var $post_args, args, self = this, accum = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          
          if (enum$ == null) enum$ = nil;;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            Opal.ret(size)
          };
          return (accum = $rb_plus(accum, size));}, 1);
        return accum;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          
          if (enum$ == null) enum$ = nil;;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };}, 1);
        self.iterated = [];
        return self;
      }, 0);
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      }, 0);
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $breaker = Opal.breaker, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $send = Opal.send;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, 0);
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        delete $$each.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $rest_arg, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        delete $Lazy_for$1.$$p;
        
        
        $post_args = Opal.slice.call(arguments, 1);
        
        $rest_arg = $post_args;;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($rest_arg)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        
        if (size == null) size = nil;;
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          
          if (yielder == null) yielder = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              
              $post_args = Opal.slice.call(arguments);
              
              args = $post_args;;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self, 0);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        delete $$collect.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      }, 0);
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        delete $$collect_concat.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            
            if (v == null) v = nil;;
            return enum$.$yield(v);}, 1)
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            
            if (v == null) v = nil;;
            return enum$.$yield(v);}, 1);
            }
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 1);
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        delete $$drop_while.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 0);
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        delete $$enum_for.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();
        if (method == null) method = "each";;
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        delete $$find_all.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        delete $$grep.$$p;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            
            if (enum$ == null) enum$ = nil;;
            
            $post_args = Opal.slice.call(arguments, 1);
            
            args = $post_args;;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            
            if (enum$ == null) enum$ = nil;;
            
            $post_args = Opal.slice.call(arguments, 1);
            
            args = $post_args;;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      }, 1);
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        delete $$reject.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      }, 1);
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        delete $$take_while.$$p;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          
          if (enum$ == null) enum$ = nil;;
          
          $post_args = Opal.slice.call(arguments, 1);
          
          args = $post_args;;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, 0);
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        ;
        self.block = block;
        return self;
      }, 0);
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      }, 1);
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          
          $post_args = Opal.slice.call(arguments);
          
          values = $post_args;;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      }, 0);
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      delete $Enumerator_for$1.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();
      if (method == null) method = "each";;
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $rest_arg, self = this;

      delete $$initialize.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      delete $$each.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    }, 0);
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      delete $$with_index.$$p;
      
      ;
      
      if (offset == null) offset = 0;;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      delete $$each_with_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    }, 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    }, 0);
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        
        $post_args = Opal.slice.call(arguments);
        
        i = $post_args;;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    }, 0);
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    }, 0);
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    }, 1);
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    }, 0);
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $hash2 = Opal.hash2, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    }, 1);
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
        default:
          return nil
      }
    }, 2);
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    }, 1);
    
    $def(self, '$+@', $return_self, 0);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    }, 0);
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, 0);
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    }, 1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, 1);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    }, 0);
    
    $def(self, '$imag', $return_val(0), 0);
    
    $def(self, '$integer?', $return_val(false), 0);
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    }, 1);
    
    $def(self, '$real', $return_self, 0);
    
    $def(self, '$real?', $return_val(true), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    }, 0);
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, $d, self = this, counter = nil;

      delete $$step.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
        
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    }, 0);
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    }, 0);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    }, 0);
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    }, 0);
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true), 0);
    
    $def(self, '$infinite?', $return_val(nil), 0);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      
      if (size == null) size = nil;;
      
      if (obj == null) obj = nil;;
      
      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    }, 1);
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, 1);
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      return self.concat(other);;
    }, 1);
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, 1);
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, 1);
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      delete $Array_any$ques$12.$$p;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, 1);
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      delete $$bsearch_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, 0);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      delete $$bsearch.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, 0);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      delete $$cycle.$$p;
      
      ;
      
      if (n == null) n = nil;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      delete $$count.$$p;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, 1);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      delete $$collect.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      delete $Array_collect$excl$15.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      delete $$combination.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$arity: 0, $$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      delete $$repeated_combination.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, 0);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        
        if (other == null) other = nil;;
        other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$arity: 1, $$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        
        if (other == null) other = nil;;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      delete $Array_delete$22.$$p;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, 1);
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      delete $$delete_if.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      filterIf(self, $falsy, block);
      return self;
    }, 0);
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return $rb_minus(a, b);}, 2);
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    }, 1);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      delete $$dup.$$p;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    }, 0);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      delete $$each_index.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, 1);
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      delete $$fetch.$$p;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      delete $$fill.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      delete $$index.$$p;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, 0);
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$31(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$&'](b);}, 2);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$32(other) {
      var self = this;

      return self.$intersection(other)['$empty?']()['$!']()
    }, 1);
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) sep = nil;;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      delete $$keep_if.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      filterIf(self, $truthy, block);
      return self;
    }, 0);
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      delete $$permutation.$$p;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$arity: 0, $$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      delete $$repeated_permutation.$$p;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, 1);
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      delete $$product.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Array_reject$excl$37() {
      var block = $Array_reject$excl$37.$$p || nil, self = this, original = nil;

      delete $Array_reject$excl$37.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, 0);
    
    $def(self, '$reverse!', function $Array_reverse$excl$39() {
      var self = this;

      return self.reverse();
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      delete $$reverse_each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      delete $$rindex.$$p;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      
      if (n == null) n = 1;;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$41(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) cnt = 1;;
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"), 0);
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      }, 1);
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      delete $$select.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$42(){var self = $$42.$$s == null ? this : $$42.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$select!', function $Array_select$excl$43() {
      var block = $Array_select$excl$43.$$p || nil, self = this;

      delete $Array_select$excl$43.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$44(){var self = $$44.$$s == null ? this : $$44.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$45(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$46(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      delete $$sort.$$p;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, 0);
    
    $def(self, '$sort!', function $Array_sort$excl$47() {
      var block = $Array_sort$excl$47.$$p || nil, self = this;

      delete $Array_sort$excl$47.$$p;
      
      ;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$48() {
      var block = $Array_sort_by$excl$48.$$p || nil, self = this;

      delete $Array_sort_by$excl$48.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, 0);
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      delete $$take_while.$$p;
      
      ;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, 0);
    
    $def(self, '$to_ary', $return_self, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      delete $$to_h.$$p;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$50(row){var $ret_or_1 = nil;

        
        
        if (row == null) row = nil;;
        row = ($eqeqeq($$$('Array'), row) ? (row.$to_a()) : (($coerce_to(row, $$$('Array'), 'to_ary')).$to_a()));
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$51(i){var $a, entry = nil;

          
          
          if (i == null) i = nil;;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));}, 1);}, 1);
      return result;
    }, 0);
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$uniq()], function $$52(a, b){
        
        
        if (a == null) a = nil;;
        
        if (b == null) b = nil;;
        return a['$|'](b);}, 2);
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      delete $$uniq.$$p;
      
      ;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, 0);
    
    $def(self, '$uniq!', function $Array_uniq$excl$53() {
      var block = $Array_uniq$excl$53.$$p || nil, self = this;

      delete $Array_uniq$excl$53.$$p;
      
      ;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, 0);
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objects = $post_args;;
      
      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], function $$54(elem){var self = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;

        
        
        if (elem == null) elem = nil;;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], function $$55(i){var self = $$55.$$s == null ? this : $$55.$$s;

            
            
            if (i == null) i = nil;;
            return out['$<<'](self.$at(i));}, {$$arity: 1, $$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$arity: 1, $$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      delete $$zip.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      delete $$instance_variables.$$p;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$56(ivar){var $ret_or_1 = nil;

        
        
        if (ivar == null) ivar = nil;;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };}, 1)
    }, 0);
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $yield1 = Opal.yield1, $hash = Opal.hash, $hash_init = Opal.hash_init, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $alias = Opal.alias;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,eql?,default,default_proc,default_proc=,default=,to_h,proc,clone,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      $hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    }, 1);
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      ;
      ;
      
      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = $hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, 1);
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        
        if (other_key == null) other_key = nil;;
        
        if (other_val == null) other_val = nil;;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$arity: 2, $$s: self});
      return result;
    }, 1);
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, 1);
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    }, 1);
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    }, 1);
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, 1);
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $hash_put(self, key, value);
      return value;
    
    }, 2);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $hash_init(self);
      return self;
    
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, 0);
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, 0);
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        $hash_put(identity_hash, key, $hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, 0);
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    }, 0);
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, 1);
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, 0);
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, 1);
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      delete $Hash_delete$15.$$p;
      
      ;
      
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      delete $$delete_if.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $yield1(block, [key, value]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      delete $$each_key.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      delete $$each_value.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.$$keys.length === 0;
    }, 0);
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        
        if (key == null) key = nil;;
        return self.$delete(key);}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      delete $$fetch.$$p;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      delete $$fetch_values.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        
        if (key == null) key = nil;;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      
      if (level == null) level = 1;;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    }, 1);
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = $$('Opal').$inspect(key)
          value = $$('Opal').$inspect(value)

          result.push(key + '=>' + value);
        }

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    }, 0);
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $hash_put(hash, value, key);
      }

      return hash;
    
    }, 0);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      delete $$keep_if.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$$keys.length;
    }, 0);
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      delete $$merge.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      delete $Hash_merge$excl$27.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      others = $post_args;;
      
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            $hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = $hash_get(self, key);

            if (value === undefined) {
              $hash_put(self, key, other_value);
              continue;
            }

            $hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      delete $$reject.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      delete $Hash_reject$excl$29.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      $hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        $hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    }, 1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      delete $$select.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      delete $Hash_select$excl$32.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, $hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, 0);
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      keys = $post_args;;
      
      var result = $hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      delete $$to_h.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, 0);
    
    $def(self, '$to_hash', $return_self, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    }, 0);
    
    $def(self, '$transform_keys', function $$transform_keys() {
      var block = $$transform_keys.$$p || nil, self = this;

      delete $$transform_keys.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = $yield1(block, key);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36() {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      delete $Hash_transform_keys$excl$36.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = $yield1(block, key);

        $hash_delete(self, key);
        $hash_put(self, new_key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      delete $$transform_values.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      delete $Hash_transform_values$excl$39.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(self, key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$values', function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, 0);
    $alias(self, "dup", "clone");
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', null, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,__id__,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    }, 1);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, 0);
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, 1);
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, 1);
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, 1);
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, 1);
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, 1);
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, 1);
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, 1);
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, 1);
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, 1);
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, 1);
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, 1);
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, 1);
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, 1);
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, 1);
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    }, 0);
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    }, 0);
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    }, 0);
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($rb_lt(self, 0) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, 1);
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, 0);
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    }, 1);
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    }, 1);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, 0);
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      delete $$denominator.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    }, 0);
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      delete $$downto.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, 1);
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    }, 0);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, 1);
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, 1);
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    }, 0);
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      delete $Number_is_a$ques$28.$$p;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    }, 1);
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      delete $Number_instance_of$ques$29.$$p;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    }, 1);
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, 1);
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    }, 0);
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    }, 1);
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      delete $$numerator.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    }, 0);
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    }, 0);
    
    $def(self, '$ord', $return_self, 0);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      delete $$quo.$$p;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    }, 1);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, 1);
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      delete $$times.$$p;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$to_f', $return_self, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, 0);
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) ndigits = 0;;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      
      if (base == null) base = 10;;
      if ($rb_lt(self, 0)) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      delete $$divmod.$$p;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    }, 1);
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      delete $$upto.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    }, 0);
    
    $def(self, '$size', $return_val(4), 0);
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    }, 0);
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, 0);
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, 0);
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, 0);
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, 0);
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_ge(self, 0)) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    }, 0);
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_gt(self, 0)) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    }, 0);
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, 1);
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $rb_ge = Opal.rb_ge, $alias = Opal.alias;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash,cover?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) exclude = false;;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      return self['$include?'](value)
    }, 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      delete $$count.$$p;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      delete $$to_a.$$p;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    }, 0);
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;

      
      beg_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.begin['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (self.begin['$<=>'](value))))) && ($ret_or_1));
      end_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.end['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (value['$<=>'](self.end))))) && ($ret_or_1));
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(self.excl) ? (($truthy(($ret_or_3 = end_cmp)) ? ($rb_lt(end_cmp, 0)) : ($ret_or_3))) : ($truthy(($ret_or_3 = end_cmp)) ? ($rb_le(end_cmp, 0)) : ($ret_or_3))))) ? (beg_cmp) : ($ret_or_2))))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, $a, self = this, current = nil, last = nil, $ret_or_1 = nil;

      delete $$each.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    }, 0);
    
    $def(self, '$eql?', function $Range_eql$ques$4(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$exclude_end?', $return_ivar("excl"), 0);
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      delete $$first.$$p;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      delete $$max.$$p;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, 0);
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      delete $$min.$$p;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    }, 0);
    
    $def(self, '$size', function $$size() {
      var self = this, infinity = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$$('Float'), 'INFINITY');
      if ((($eqeq(self.begin, infinity) && ($not(self.end['$nil?']()))) || (($eqeq(self.end, infinity['$-@']()) && ($not(self.begin['$nil?']())))))) {
        return 0
      };
      if ($truthy(is_infinite(self))) {
        return infinity
      };
      if (!($eqeqeq($$$('Numeric'), self.begin) && ($eqeqeq($$$('Numeric'), self.end)))) {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0
      };
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, 0);
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      delete $$step.$$p;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$5(){
            
            coerceStepSize();
            return enumeratorSize();
          }, 0)
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$arity: 0, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$7(value, idx){
          
          
          if (value == null) value = nil;;
          
          if (idx == null) idx = nil;;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, 2);
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$8(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    }, 1);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      delete $$bsearch.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    }, 0);
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, 0);
    $alias(self, "==", "eql?");
    $alias(self, "include?", "cover?");
    return $alias(self, "member?", "cover?");
  })('::', null, $nesting);
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $Opal = Opal.Opal, $alias = Opal.alias;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      delete $Proc_new$1.$$p;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      delete $$call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      delete $Proc_$gt$gt$2.$$p;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        delete $$3.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      delete $Proc_$lt$lt$4.$$p;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        delete $$5.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        args = $post_args;;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    }, 0);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, 0);
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, 0);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, 0);
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      delete $$call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    }, 1);
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    }, 1);
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, 1);
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      delete $$bind_call.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
  })('::', null);
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, $hash2 = Opal.hash2;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      
      if (flags == null) flags = "r";;
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"), 0);
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, 1);
    
    $def(self, '$flush', $return_val(nil), 0);
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    }, 1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    }, 0);
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : self.$getc().$ord())
    }, 0);
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    }, 0);
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    }, 0);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, $c, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (sep == null) sep = false;;
      
      if (limit == null) limit = nil;;
      
      if (opts == null) opts = $hash2([], {});;
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $c = self.read_buffer.$split(sep, 2), $b = $to_ary($c), (ret = ($b[0] == null ? nil : $b[0])), (self.read_buffer = ($b[1] == null ? nil : $b[1])), $c;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    }, 1);
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    }, 1);
    
    $def(self, '$read', function $$read(integer) {
      var $a, $b, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      
      if (integer == null) integer = nil;;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $b = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $b[0]), (self.read_buffer = $b[1]), $b;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) separator = $gvars["/"];;
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, $c, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      delete $$each.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();
      if (sep == null) sep = $gvars["/"];;
      
      args = $post_args;;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
        Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, $a, self = this, s = nil;

      delete $$each_byte.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, $a, self = this, s = nil;

      delete $$each_char.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$close', $assign_ivar_val("closed", "both"), 0);
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, 0);
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, 0);
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    }, 0);
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, 0);
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $const_set = Opal.const_set;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $a, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $alias = Opal.alias;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=');
  
  self.$require("corelib/string");
  (function($base, $super) {
    var self = $klass($base, $super, 'Encoding');

    var $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      delete $$register.$$p;
      
      ;
      
      if (options == null) options = $hash2([], {});;
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        
        if (encoding_name == null) encoding_name = nil;;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$arity: 1, $$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    }, 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, 4);
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"), 0);
    
    $def(self, '$dummy?', $return_ivar("dummy"), 0);
    
    $def(self, '$binary?', $return_val(false), 0);
    
    $def(self, '$to_s', $return_ivar("name"), 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    }, 0);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, 1);
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      delete $$each_char.$$p;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    return ($klass('::', $$$('EncodingError'), 'CompatibilityError'), nil);
  })('::', null);
  $send($$$('Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_16LE')})], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_32LE')})], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      delete $$each_char.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      delete $$each_byte.$$p;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1);
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    }, 1);
    return $def(self, '$binary?', $return_val(true), 0);}, {$$arity: 0, $$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  $$$('Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, 0);
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, 0);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      delete $$each_byte.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$bytesize()}, {$$arity: 0, $$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      delete $$each_char.$$p;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$length()}, {$$arity: 0, $$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      delete $$chars.$$p;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, 0);
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      delete $$each_codepoint.$$p;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      delete $$codepoints.$$p;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    }, 0);
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, 1);
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, 1);
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    }, 1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, 1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    $alias(self, "size", "length");
    return $def(self, '$valid_encoding?', $return_val(true), 0);
  })('::', null);
  return ($a = [$$$($$('Encoding'), 'UTF_8')], $send($$$('Encoding'), 'default_external=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $Kernel = Opal.Kernel, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      
      if (method == null) method = nil;;
      return $send(self, 'define_method', [method], function $$4(x){
        
        
        if (x == null) x = nil;;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));}, 1);}, {$$arity: 1, $$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    }, 2);
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    }, 2);
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, 1);
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, 1);
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, 2);
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, 1);
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    }, 1);
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    }, 1);
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    }, 1);
  })('::', $nesting)
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      
      if (imag == null) imag = nil;;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    }, 0)
  })('::', null, $nesting);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      
      if (imag == null) imag = 0;;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      
      if (theta == null) theta = 0;;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) imag = 0;;
      self.real = real;
      return (self.imag = imag);
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, 1);
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, 0);
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
            
            $c = n.$divmod(2), $b = $to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while ($eqeq(mod, 0)) {
              
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = $to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    }, 0);
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, 0);
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, 1);
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Complex:" + (self.real) + ":" + (self.imag)
    }, 0);
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    }, 0);
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    }, 1);
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $def = Opal.def, $klass = Opal.klass;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      
      if (denominator == null) denominator = 1;;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    }, 0)
  })('::', null);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, 2);
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, 2);
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, 2);
    
    $def(self, '$numerator', $return_ivar("num"), 0);
    
    $def(self, '$denominator', $return_ivar("den"), 0);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    }, 1);
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    }, 0);
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Rational:" + (self.num) + ":" + (self.den)
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) precision = 0;;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    }, 0);
    
    $def(self, '$to_r', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, 0);
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) precision = 0;;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    }, 2);
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    }, 1);
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $slice = Opal.slice, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (utc_offset == null) utc_offset = nil;;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + (utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    }, 1);
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (millisecond == null) millisecond = nil;;
      
      if (_dummy1 == null) _dummy1 = nil;;
      
      if (_dummy2 == null) _dummy2 = nil;;
      
      if (_dummy3 == null) _dummy3 = nil;;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      
      if (month == null) month = nil;;
      
      if (day == null) day = nil;;
      
      if (hour == null) hour = nil;;
      
      if (min == null) min = nil;;
      
      if (sec == null) sec = nil;;
      
      if (millisecond == null) millisecond = nil;;
      
      if (_dummy1 == null) _dummy1 = nil;;
      
      if (_dummy2 == null) _dummy2 = nil;;
      
      if (_dummy3 == null) _dummy3 = nil;;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    }, 0);
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, 1);
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, 0);
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      
      if (method == null) method = nil;;
      
      if (getter == null) getter = nil;;
      
      if (utcgetter == null) utcgetter = nil;;
      
      if (difference == null) difference = 0;;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$arity: 0, $$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, 0);
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    }, 1);
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      
      if (method == null) method = nil;;
      
      if (weekday == null) weekday = nil;;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$arity: 0, $$s: self});}, {$$arity: 2, $$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, 0);
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    }, 0);
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, 0);
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    }, 0);
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      self.timezone = 0;
      return self;
    
    }, 0);
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    }, 0);
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    }, 0);
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, 1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, 0);
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    }, 0);
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      delete $Struct_new$1.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        
        if (arg == null) arg = nil;;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");}, 1);
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          
          if (arg == null) arg = nil;;
          return self.$define_struct_attribute(arg);}, {$$arity: 1, $$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$arity: 0, $$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$arity: 0, $$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        
        if (value == null) value = nil;;
        return self.$$data[name] = value;;}, {$$arity: 1, $$s: self});
    }, 1);
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    }, 0);
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$arity: 0, $$s: self});
    }, 1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ($hash2([], {})));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          
          if (name == null) name = nil;;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          
          if (name == null) name = nil;;
          
          if (index == null) index = nil;;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 2, $$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, 1);
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    }, 0);
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return $$('Hash').$new(self.$$data).$hash()
    }, 0);
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    }, 1);
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    }, 2);
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      delete $$each.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        
        if (name == null) name = nil;;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      delete $$each_pair.$$p;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        
        if (name == null) name = nil;;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        
        if (name == null) name = nil;;
        return self['$[]'](name);}, {$$arity: 1, $$s: self})
    }, 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          
          if (name == null) name = nil;;
          
          if (value == null) value = nil;;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}, 2).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      delete $$to_h.$$p;
      
      ;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(self.$args()))
      };
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], function $$22(name, h){var $a, self = $$22.$$s == null ? this : $$22.$$s;

        
        
        if (name == null) name = nil;;
        
        if (h == null) h = nil;;
        return ($a = [name, self['$[]'](name)], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      args = $send(args, 'map', [], function $$23(arg){
        
        
        if (arg == null) arg = nil;;
        return arg.$$is_range ? arg.$to_a() : arg;}, 1).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      keys = $post_args;;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        delete $$chdir.$$p;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, 1);
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      }, 0);
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, 0);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) basedir = nil;;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        
        if (level == null) level = 1;;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        
        if (suffix == null) suffix = nil;;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, 1);
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      }, 1);
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], function $$3(f){
          
          
          if (f == null) f = nil;;
          return f['$=~']($regexp(["^", path]));}, 1);
        return file;
      }, 1);
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        
        $post_args = Opal.slice.call(arguments);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };}, 2);
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          
          if (item == null) item = nil;;
          
          if (index == null) index = nil;;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };}, 2);
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      }, 1);
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $klass = Opal.klass, $defs = Opal.defs, $return_val = Opal.return_val;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil), 0)
  })('::', null);
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0), 0);
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, 0);
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) unit = "float_second";;
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        
        if (count == null) count = nil;;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        
        if (count == null) count = nil;;
        
        if (padding == null) padding = false;;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, 0);
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          
          if (i == null) i = nil;;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, 1);
        return $rb_divide(num.$abs(), 2147483647);
      }, 0);
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        
        if (count == null) count = nil;;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          
          if (i == null) i = nil;;
          return map['$[]'](self.$random_number(map.$length()));}, {$$arity: 1, $$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, 1);
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) seed = $$$('Random').$new_seed();;
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, 1);
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    }, 0);
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) n = $$$('Random').$new_seed();;
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    }, 1);
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$arity: 0, $$s: self}).$join().$encode("ASCII-8BIT");
    }, 1);
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    }, 1);
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, 0);
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    }, 0);
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, 1);
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      
      if (method_name == null) method_name = nil;;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $rest_arg;

        
        
        $post_args = Opal.slice.call(arguments);
        
        $rest_arg = $post_args;;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$arity: 1, $$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object freezing is not supported by Opal";
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$frozen?', function $Kernel_frozen$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$tainted?', function $Kernel_tainted$ques$4() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$5($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false), 0);
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      
      $post_args = Opal.slice.call(arguments);
      
      methods = $post_args;;
      return [];
    }, -1);
    return $alias(self, "private_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$6($a) {
      var $post_args, $rest_arg;

      
      
      $post_args = Opal.slice.call(arguments);
      
      $rest_arg = $post_args;;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$7($a) {
    var $post_args, methods;

    
    
    $post_args = Opal.slice.call(arguments);
    
    methods = $post_args;;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$8($a) {
    var $post_args, methods;

    
    
    $post_args = Opal.slice.call(arguments);
    
    methods = $post_args;;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $module = Opal.module, $const_set = Opal.const_set;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      
      if (scope_variables == null) scope_variables = [];;
      ;
      
      if (source_location == null) source_location = nil;;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + (symbol) + "' is not defined for " + (self.$inspect()))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval("" + (symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    }, 2);
    
    $def(self, '$local_variables', $return_ivar("scope_variables"), 0);
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    }, 1);
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {
      var self = this;

      
      
      if (file == null) file = nil;;
      
      if (line == null) line = nil;;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    }, 0)
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $hash = Opal.hash, $gvars = Opal.gvars, $lambda = Opal.lambda, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + (version) + "/" + (library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + (library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + (library) + " for some reason")
        };
      }, 1);
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        delete $$prepare_console.$$p;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash($gvars.stdout, $lambda(function $$1(i){
          
          
          if (i == null) i = nil;;
          return ($gvars.stdout = i);}, 1), $gvars.stderr, $lambda(function $$2(i){
          
          
          if (i == null) i = nil;;
          return ($gvars.stderr = i);}, 1));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            
            if (pipe == null) pipe = nil;;
            
            if (pipe_setter == null) pipe_setter = nil;;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              
              if (str == null) str = nil;;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$arity: 1, $$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$arity: 2, $$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            
            if (pipe == null) pipe = nil;;
            
            if (pipe_setter == null) pipe_setter = nil;;
            return pipe_setter.$call(pipe);}, 2), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      }, 0);
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      }, 0);
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        }, 0);
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          delete $$silence.$$p;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        }, 0);
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        }, 0);
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try {

      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return (function(){var $brk = Opal.new_brk(); try {return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            
            Opal.brk(nil, $brk)
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          retry_1: do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))}, 0)
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    Opal.ret(nil)
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue retry_1;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            Opal.ret(nil);
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$arity: 0, $$s: self, $$brk: $brk})
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()}, {$$arity: 0, $$s: self, $$brk: $brk})
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, 0)
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.queue(function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $Object = Opal.Object;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
});

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":33}],95:[function(require,module,exports){
Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      delete $$open.$$p;
      
      ;
      
      if (string == null) string = "";;
      
      if (mode == null) mode = nil;;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (string == null) string = "";;
      
      if (mode == null) mode = "rw";;
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, 0);
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');;
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"), 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, 1);
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) length = nil;;
      
      if (outbuf == null) outbuf = nil;;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    }, 1);
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};

Opal.modules["corelib/pack_unpack/format_string_parser"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $Kernel = Opal.Kernel;

  Opal.add_stubs('raise');
  return (function($base) {
    var self = $module($base, 'PackUnpack');

    
    
    var directives = [
      // Integer
      'C',
      'S',
      'L',
      'Q',
      'J',

      'c',
      's',
      'l',
      'q',
      'j',

      'n',
      'N',
      'v',
      'V',

      'U',
      'w',

      // Float
      'D',
      'd',
      'F',
      'f',
      'E',
      'e',
      'G',
      'g',

      // String
      'A',
      'a',
      'Z',
      'B',
      'b',
      'H',
      'h',
      'u',
      'M',
      'm',

      'P',
      'p',

      // Misc
      '@',
      'X',
      'x'
    ];

    var modifiers = [
      '!', // ignored
      '_', // ignored
      '>', // big endian
      '<'  // little endian
    ];

    self.eachDirectiveAndCount = function(format, callback) {
      var currentDirective,
          currentCount,
          currentModifiers,
          countSpecified;

      function reset() {
        currentDirective = null;
        currentCount = 0;
        currentModifiers = [];
        countSpecified = false;
      }

      reset();

      function yieldAndReset() {
        if (currentDirective == null) {
          reset();
          return;
        }

        var directiveSupportsModifiers = /[sSiIlLqQjJ]/.test(currentDirective);

        if (!directiveSupportsModifiers && currentModifiers.length > 0) {
          $Kernel.$raise($$$('ArgumentError'), "'" + (currentModifiers[0]) + "' allowed only after types sSiIlLqQjJ")
        }

        if (currentModifiers.indexOf('<') !== -1 && currentModifiers.indexOf('>') !== -1) {
          $Kernel.$raise($$$('RangeError'), "Can't use both '<' and '>'")
        }

        if (!countSpecified) {
          currentCount = 1;
        }

        if (currentModifiers.indexOf('>') !== -1) {
          currentDirective = currentDirective + '>';
        }

        callback(currentDirective, currentCount);

        reset();
      }

      for (var i = 0; i < format.length; i++) {
        var currentChar = format[i];

        if (directives.indexOf(currentChar) !== -1) {
          // Directive char always resets current state
          yieldAndReset();
          currentDirective = currentChar;
        } else if (currentDirective) {
          if (/\d/.test(currentChar)) {
            // Count can be represented as a sequence of digits
            currentCount = currentCount * 10 + parseInt(currentChar, 10);
            countSpecified = true;
          } else if (currentChar === '*' && countSpecified === false) {
            // Count can be represented by a star character
            currentCount = Infinity;
            countSpecified = true;
          } else if (modifiers.indexOf(currentChar) !== -1 && countSpecified === false) {
            // Directives can be specified only after directive and before count
            currentModifiers.push(currentChar);
          } else {
            yieldAndReset();
          }
        }
      }

      yieldAndReset();
    }
  
  })('::')
};

Opal.modules["corelib/array/pack"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $def = Opal.def;

  Opal.add_stubs('require,raise,delete,gsub,coerce_to!,inspect');
  
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function identityFunction(value) { return value; }

    function utf8BytesToUtf16LEString(bytes) {
      var str = String.fromCharCode.apply(null, bytes), out = "", i = 0, len = str.length, c, char2, char3;
      while (i < len) {
        c = str.charCodeAt(i++);
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            // 0xxxxxxx
            out += str.charAt(i - 1);
            break;
          case 12:
          case 13:
            // 110x xxxx 10xx xxxx
            char2 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
            break;
          case 14:
            // 1110 xxxx10xx xxxx10xx xxxx
            char2 = str.charCodeAt(i++);
            char3 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
            break;
        }
      }
      return out;
    }

    function asciiBytesToUtf16LEString(bytes) {
      return String.fromCharCode.apply(null, bytes);
    }

    function asciiStringFromUnsignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function asciiStringFromSignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data),
            bits = bytes * 8,
            limit = Math.pow(2, bits);

        return buffer.map(function(item) {
          if (item < 0) {
            item += limit;
          }

          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function toInt(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('Integer'), 'to_int')
        });
      }
    }

    function ToStr(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('String'), 'to_str')
        });
      }
    }

    function fromCodePoint(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.map(function(item) {
          try {
            return String.fromCodePoint(item);
          } catch (error) {
            if (error instanceof RangeError) {
              $Kernel.$raise($$$('RangeError'), "value out of range");
            }
            throw error;
          }
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.join('');
      }
    }

    var handlers = {
      // Integer
      'C': joinChars(asciiStringFromUnsignedInt(1, toInt(identityFunction))),
      'S': joinChars(asciiStringFromUnsignedInt(2, toInt(identityFunction))),
      'L': joinChars(asciiStringFromUnsignedInt(4, toInt(identityFunction))),
      'Q': joinChars(asciiStringFromUnsignedInt(8, toInt(identityFunction))),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': joinChars(asciiStringFromSignedInt(1, toInt(identityFunction))),
      's': joinChars(asciiStringFromSignedInt(2, toInt(identityFunction))),
      'l': joinChars(asciiStringFromSignedInt(4, toInt(identityFunction))),
      'q': joinChars(asciiStringFromSignedInt(8, toInt(identityFunction))),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': joinChars(fromCodePoint(toInt(identityFunction))),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': joinChars(identityFunction),
      'a': joinChars(identityFunction),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    function readNTimesFromBufferAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          if (buffer.length < count) {
            $Kernel.$raise($$$('ArgumentError'), "too few arguments");
          }
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readItem(buffer) {
      var chunk = buffer.slice(0, 1);
      buffer = buffer.slice(1, buffer.length);
      return { chunk: chunk, rest: buffer };
    }

    function readNCharsFromTheFirstItemAndMergeWithFallback(fallback, callback) {
      return function(buffer, count) {
        var chunk = [], source = buffer[0];

        if (source === nil) {
          source = '';
        } else if (source === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "too few arguments");
        } else {
          source = $coerce_to(source, $$$('String'), 'to_str');
        }

        buffer = buffer.slice(1, buffer.length);

        function infiniteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = []
          }

          chunk = chunk.concat(subChunk);
        }

        function finiteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 0) {
            subChunk = [fallback];
          }

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = [fallback];
          }

          chunk = chunk.concat(subChunk);
        }

        if (count === Infinity) {
          while (source.length > 0) {
            infiniteReeder();
          }
        } else {
          for (var i = 0; i < count; i++) {
            finiteReeder();
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    var readChunk = {
      // Integer
      'C': readNTimesFromBufferAndMerge(readItem),
      'S': readNTimesFromBufferAndMerge(readItem),
      'L': readNTimesFromBufferAndMerge(readItem),
      'Q': readNTimesFromBufferAndMerge(readItem),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': readNTimesFromBufferAndMerge(readItem),
      's': readNTimesFromBufferAndMerge(readItem),
      'l': readNTimesFromBufferAndMerge(readItem),
      'q': readNTimesFromBufferAndMerge(readItem),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': readNTimesFromBufferAndMerge(readItem),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNCharsFromTheFirstItemAndMergeWithFallback(" ", readItem),
      'a': readNCharsFromTheFirstItemAndMergeWithFallback("\x00", readItem),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    var autocompletion = {
      // Integer
      'C': false,
      'S': false,
      'L': false,
      'Q': false,
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': false,
      's': false,
      'l': false,
      'q': false,
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': false,
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': false,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };
  ;
    return $def(self, '$pack', function $$pack(format) {
      var self = this;

      
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = '';

      var buffer = self.slice();

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive]

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      if (format.match(/^(U\*?)+$/)) {
        return output;
      }
      else {
        return Opal.enc(output, "binary");
      }
    ;
    }, 1);
  })('::', null);
};

Opal.modules["open-uri"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $module = Opal.module, $alias = Opal.alias, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $hash2 = Opal.hash2, $defs = Opal.defs, $eqeq = Opal.eqeq, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq;

  Opal.add_stubs('require,private,open,=~,respond_to?,open_uri,to_proc,open_uri_original_open,module_function,open_loop,rewind,close_io,close!,closed?,close,request,==,build_response,raise,new,<<,pack,data,io,status=,meta_add_field,attr_reader,+,length,===,init,extend,instance_eval,status,base_uri=,base_uri,each,metas,meta_add_field2,attr_accessor,charset,find_encoding,set_encoding,force_encoding,string,find,downcase,[]=,join,meta_setup_encoding,[],utc,at,content_type_parse,scheme,read');
  
  self.$require("stringio");
  self.$require("corelib/array/pack");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$private();
    $alias(self, "open_uri_original_open", "open");
    (function(self, $parent_nesting) {
      
      return $alias(self, "open_uri_original_open", "open")
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$open', function $$open(name, $a) {
      var block = $$open.$$p || nil, $post_args, rest, self = this;

      delete $$open.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 1);
      
      rest = $post_args;;
      if (($truthy(name['$respond_to?']("to_str")) && ($truthy(/^[A-Za-z][A-Za-z0-9+\-\.]*:\/\//['$=~'](name))))) {
        return $send($$('OpenURI'), 'open_uri', [name].concat($to_a(rest)), block.$to_proc())
      } else {
        return $send(self, 'open_uri_original_open', [name].concat($to_a(rest)), block.$to_proc())
      };
    }, -2);
    return self.$module_function("open");
  })($nesting[0], $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$open_uri', function $$open_uri(name, $a) {
      var $post_args, rest, $yield = $$open_uri.$$p || nil, self = this, io = nil;

      delete $$open_uri.$$p;
      
      
      $post_args = Opal.slice.call(arguments, 1);
      
      rest = $post_args;;
      io = self.$open_loop(name, $hash2([], {}));
      io.$rewind();
      if (($yield !== nil)) {
        
        return (function() { try {
        return Opal.yield1($yield, io);
        } finally {
          self.$close_io(io)
        }; })();
      } else {
        return io
      };
    }, -2);
    $defs(self, '$close_io', function $$close_io(io) {
      
      if ($truthy(io['$respond_to?']("close!"))) {
        return io['$close!']()
      } else if ($truthy(io['$closed?']())) {
        return nil
      } else {
        return io.$close()
      }
    }, 1);
    $defs(self, '$open_loop', function $$open_loop(uri, options) {
      var self = this, req = nil, data = nil, status = nil, status_text = nil;

      
      req = self.$request(uri);
      data = req.responseText;
      status = req.status;
      status_text = req.statusText && req.statusText.errno ? req.statusText.errno : req.statusText;
      if (($eqeq(status, 200) || (($eqeq(status, 0) && ($truthy(data)))))) {
        return self.$build_response(req, status, status_text)
      } else {
        return self.$raise($$$($$('OpenURI'), 'HTTPError').$new("" + (status) + " " + (status_text), ""))
      };
    }, 2);
    $defs(self, '$build_response', function $$build_response(req, status, status_text) {
      var self = this, buf = nil, io = nil, last_modified = nil;

      
      buf = $$('Buffer').$new();
      buf['$<<'](self.$data(req).$pack("c*"));
      io = buf.$io();
      io['$status=']("" + (status) + " " + (status_text));
      io.$meta_add_field("content-type", req.getResponseHeader("Content-Type") || '');
      last_modified = req.getResponseHeader("Last-Modified");
      if ($truthy(last_modified)) {
        io.$meta_add_field("last-modified", last_modified)
      };
      return io;
    }, 3);
    $defs(self, '$data', function $$data(req) {
      
      
      var binStr = req.responseText;
      var byteArray = [];
      for (var i = 0, len = binStr.length; i < len; ++i) {
        var c = binStr.charCodeAt(i);
        var byteCode = c & 0xff; // byte at offset i
        byteArray.push(byteCode);
      }
      return byteArray;
    
    }, 1);
    $defs(self, '$request', function $$request(uri) {
      var self = this;

      
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', uri, false);
        // We cannot use xhr.responseType = "arraybuffer" because XMLHttpRequest is used in synchronous mode.
        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType#Synchronous_XHR_restrictions
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
        xhr.send();
        return xhr;
      } catch (error) {
        self.$raise($$$($$('OpenURI'), 'HTTPError').$new(error.message, ""))
      }
    
    }, 1);
    (function($base, $super) {
      var self = $klass($base, $super, 'HTTPError');

      
      
      
      $def(self, '$initialize', function $$initialize(message, io) {
        var $yield = $$initialize.$$p || nil, self = this;

        delete $$initialize.$$p;
        
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, io], null);
        return (self.io = io);
      }, 2);
      return self.$attr_reader("io");
    })($nesting[0], $$('StandardError'));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Buffer');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.io = $proto.size = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.io = $$('StringIO').$new();
        return (self.size = 0);
      }, 0);
      self.$attr_reader("size");
      
      $def(self, '$<<', function $Buffer_$lt$lt$1(str) {
        var self = this;

        
        self.io['$<<'](str);
        return (self.size = $rb_plus(self.size, str.$length()));
      }, 1);
      return $def(self, '$io', function $$io() {
        var self = this;

        
        if (!$eqeqeq($$('Meta'), self.io)) {
          $$('Meta').$init(self.io)
        };
        return self.io;
      }, 0);
    })($nesting[0], null, $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Meta');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs($$('Meta'), '$init', function $$init(obj, src) {
        var self = this;

        
        
        if (src == null) src = nil;;
        obj.$extend($$('Meta'));
        $send(obj, 'instance_eval', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          
          self.base_uri = nil;
          self.meta = $hash2([], {});
          return (self.metas = $hash2([], {}));}, {$$arity: 0, $$s: self});
        if ($truthy(src)) {
          
          obj['$status='](src.$status());
          obj['$base_uri='](src.$base_uri());
          return $send(src.$metas(), 'each', [], function $$3(name, values){
            
            
            if (name == null) name = nil;;
            
            if (values == null) values = nil;;
            return obj.$meta_add_field2(name, values);}, 2);
        } else {
          return nil
        };
      }, -2);
      self.$attr_accessor("status");
      self.$attr_accessor("base_uri");
      self.$attr_reader("meta");
      self.$attr_reader("metas");
      
      $def(self, '$meta_setup_encoding', function $$meta_setup_encoding() {
        var self = this, charset = nil, enc = nil;

        
        charset = self.$charset();
        enc = self.$find_encoding(charset);
        return self.$set_encoding(enc);
      }, 0);
      
      $def(self, '$set_encoding', function $$set_encoding(enc) {
        var self = this;

        if ($truthy(self['$respond_to?']("force_encoding"))) {
          return self.$force_encoding(enc)
        } else if ($truthy(self['$respond_to?']("string"))) {
          return self.$string().$force_encoding(enc)
        } else {
          return self.$set_encoding(enc)
        }
      }, 1);
      
      $def(self, '$find_encoding', function $$find_encoding(charset) {
        var enc = nil;

        
        enc = nil;
        if ($truthy(charset)) {
          
          try {
            enc = $$('Encoding').$find(charset)
          } catch ($err) {
            if (Opal.rescue($err, [$$('ArgumentError')])) {
              try {
                nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        };
        if (!$truthy(enc)) {
          enc = $$$($$('Encoding'), 'ASCII_8BIT')
        };
        return enc;
      }, 1);
      
      $def(self, '$meta_add_field2', function $$meta_add_field2(name, values) {
        var self = this;
        if (self.metas == null) self.metas = nil;
        if (self.meta == null) self.meta = nil;

        
        name = name.$downcase();
        self.metas['$[]='](name, values);
        self.meta['$[]='](name, values.$join(", "));
        if ($eqeq(name, "content-type")) {
          return self.$meta_setup_encoding()
        } else {
          return nil
        };
      }, 2);
      
      $def(self, '$meta_add_field', function $$meta_add_field(name, value) {
        var self = this;

        return self.$meta_add_field2(name, [value])
      }, 2);
      
      $def(self, '$last_modified', function $$last_modified() {
        var self = this, vs = nil;
        if (self.metas == null) self.metas = nil;

        if ($truthy((vs = self.metas['$[]']("last-modified")))) {
          return $$('Time').$at(Date.parse(vs.$join(", ")) / 1000).$utc()
        } else {
          return nil
        }
      }, 0);
      
      $def(self, '$content_type_parse', function $$content_type_parse() {
        var self = this, content_type = nil;
        if (self.metas == null) self.metas = nil;

        
        content_type = self.metas['$[]']("content-type");
        return content_type.$join(", ");
      }, 0);
      
      $def(self, '$charset', function $$charset() {
        var self = this, type = nil;
        if (self.base_uri == null) self.base_uri = nil;

        
        type = self.$content_type_parse();
        if (((($truthy(type) && ($truthy(/^text\//['$=~'](type)))) && ($truthy(self.base_uri))) && ($truthy(/^http$/i['$=~'](self.base_uri.$scheme()))))) {
          return "iso-8859-1"
        } else {
          return nil
        };
      }, 0);
      return $def(self, '$content_type', function $$content_type() {
        var self = this, type = nil, $ret_or_1 = nil;

        
        type = self.$content_type_parse();
        if ($truthy(($ret_or_1 = type))) {
          return $ret_or_1
        } else {
          return "application/octet-stream"
        };
      }, 0);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'OpenRead');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$open', function $$open($a) {
        var block = $$open.$$p || nil, $post_args, rest, self = this;

        delete $$open.$$p;
        
        ;
        
        $post_args = Opal.slice.call(arguments);
        
        rest = $post_args;;
        return $send($$('OpenURI'), 'open_uri', [self].concat($to_a(rest)), block.$to_proc());
      }, -1);
      return $def(self, '$read', function $$read(options) {
        var self = this;

        
        
        if (options == null) options = $hash2([], {});;
        return $send(self, 'open', [options], function $$4(f){var str = nil;

          
          
          if (f == null) f = nil;;
          str = f.$read();
          $$('Meta').$init(str, f);
          return str;}, 1);
      }, -1);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
};

},{}],96:[function(require,module,exports){
Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var nil = Opal.nil, $$$ = Opal.$$$, $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) max = nil;;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["pathname"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $defs = Opal.defs, $to_ary = Opal.to_ary, $send = Opal.send, $to_a = Opal.to_a, $return_ivar = Opal.return_ivar, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $not = Opal.not, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs('require,include,quote,===,to_s,path,respond_to?,to_path,is_a?,nil?,raise,class,==,new,pwd,attr_reader,!,relative?,chop_basename,basename,=~,source,[],rindex,sub,absolute?,expand_path,plus,unshift,length,!=,empty?,first,shift,+,join,dirname,pop,reverse_each,directory?,extname,<=>,nonzero?,proc,casecmp,cleanpath,inspect,include?,fill,map,entries');
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.path = nil;
    
    self.$include($$('Comparable'));
    $const_set($nesting[0], 'SEPARATOR_PAT', $regexp([$$('Regexp').$quote($$$($$('File'), 'SEPARATOR'))]));
    
    $def(self, '$initialize', function $$initialize(path) {
      var self = this;

      
      if ($eqeqeq($$('Pathname'), path)) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$('String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$('TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$('TypeError'), "no implicit conversion of " + (path.$class()) + " into String")
      };
      if ($eqeq(self.path, "\u0000")) {
        return self.$raise($$('ArgumentError'))
      } else {
        return nil
      };
    }, 1);
    $defs(self, '$pwd', function $$pwd() {
      var self = this;

      return self.$new($$('Dir').$pwd())
    }, 0);
    self.$attr_reader("path");
    
    $def(self, '$==', function $Pathname_$eq_eq$1(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, 1);
    
    $def(self, '$absolute?', function $Pathname_absolute$ques$2() {
      var self = this;

      return self['$relative?']()['$!']()
    }, 0);
    
    $def(self, '$relative?', function $Pathname_relative$ques$3() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = $to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, 0);
    
    $def(self, '$chop_basename', function $$chop_basename(path) {
      var base = nil;

      
      base = $$('File').$basename(path);
      if ($truthy($$('Regexp').$new("^" + ($$$($$('Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, 1);
    
    $def(self, '$root?', function $Pathname_root$ques$4() {
      var self = this;

      return self.path['$==']("/")
    }, 0);
    
    $def(self, '$parent', function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if ($eqeq(new_path, "")) {
        new_path = ($truthy(self['$absolute?']()) ? ("/") : ("."))
      };
      return $$('Pathname').$new(new_path);
    }, 0);
    
    $def(self, '$sub', function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return $$('Pathname').$new($send(self.path, 'sub', $to_a(args)));
    }, -1);
    
    $def(self, '$cleanpath', function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, 0);
    
    $def(self, '$to_path', $return_ivar("path"), 0);
    
    $def(self, '$hash', $return_ivar("path"), 0);
    
    $def(self, '$expand_path', function $$expand_path() {
      var self = this;

      return $$('Pathname').$new($$('File').$expand_path(self.path))
    }, 0);
    
    $def(self, '$+', function $Pathname_$plus$5(other) {
      var self = this;

      
      if (!$eqeqeq($$('Pathname'), other)) {
        other = $$('Pathname').$new(other)
      };
      return $$('Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, 1);
    
    $def(self, '$plus', function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, $ret_or_1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = $to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($neqeq(prefix2, "")) {
        return path2
      };
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$=='](".")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if (!$truthy((r1 = self.$chop_basename(prefix1)))) {
          break;
        };
        $c = r1, $b = $to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if ($eqeq(basename1, ".")) {
          continue;
        };
        if ((($eqeq(basename1, "..") || ($truthy(basename_list2['$empty?']()))) || ($neqeq(basename_list2.$first(), "..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;
        };
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if (($not(r1) && ($truthy($regexp([$$('SEPARATOR_PAT')])['$=~']($$('File').$basename(prefix1)))))) {
        while ($truthy(($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']())) ? (basename_list2.$first()['$==']("..")) : ($ret_or_1)))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }
      };
      if ($not(basename_list2['$empty?']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$('File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$('File').$dirname(prefix1)
      };
    }, 2);
    
    $def(self, '$join', function $$join($a) {try {

      var $post_args, args, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self
      };
      result = args.$pop();
      if (!$eqeqeq($$('Pathname'), result)) {
        result = $$('Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result
      };
      $send(args, 'reverse_each', [], function $$6(arg){
        
        
        if (arg == null) arg = nil;;
        if (!$eqeqeq($$('Pathname'), arg)) {
          arg = $$('Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, 1);
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, -1);
    
    $def(self, '$split', function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, 0);
    
    $def(self, '$dirname', function $$dirname() {
      var self = this;

      return $$('Pathname').$new($$('File').$dirname(self.path))
    }, 0);
    
    $def(self, '$basename', function $$basename() {
      var self = this;

      return $$('Pathname').$new($$('File').$basename(self.path))
    }, 0);
    
    $def(self, '$directory?', function $Pathname_directory$ques$7() {
      var self = this;

      return $$('File')['$directory?'](self.path)
    }, 0);
    
    $def(self, '$extname', function $$extname() {
      var self = this;

      return $$('File').$extname(self.path)
    }, 0);
    
    $def(self, '$<=>', function $Pathname_$lt_eq_gt$8(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, 1);
    $const_set($nesting[0], 'SAME_PATHS', ($truthy($$$($$('File'), 'FNM_SYSCASE')['$nonzero?']()) ? ($send(self, 'proc', [], function $Pathname$9(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a.$casecmp(b)['$=='](0);}, 2)) : ($send(self, 'proc', [], function $Pathname$10(a, b){
      
      
      if (a == null) a = nil;;
      
      if (b == null) b = nil;;
      return a['$=='](b);}, 2))));
    
    $def(self, '$relative_path_from', function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, $ret_or_1 = nil, $ret_or_2 = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = $to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          dest_names.$unshift(basename)
        };
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = $to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($neqeq(basename, ".")) {
          base_names.$unshift(basename)
        };
      };
      if (!$truthy($$('SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
        self.$raise($$('ArgumentError'), "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = dest_names['$empty?']()['$!']())) ? (base_names['$empty?']()['$!']()) : ($ret_or_2)))) ? ($$('SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first())) : ($ret_or_1)))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$('ArgumentError'), "base_directory has ..: " + (base_directory.$inspect()))
      };
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$('Pathname').$new(".")
      } else {
        return $$('Pathname').$new($send($$('File'), 'join', $to_a(relpath_names)))
      };
    }, 1);
    
    $def(self, '$entries', function $$entries() {
      var self = this;

      return $send($$('Dir').$entries(self.path), 'map', [], function $$11(f){var self = $$11.$$s == null ? this : $$11.$$s;

        
        
        if (f == null) f = nil;;
        return self.$class().$new(f);}, {$$arity: 1, $$s: self})
    }, 0);
    $alias(self, "===", "==");
    $alias(self, "eql?", "==");
    $alias(self, "to_s", "to_path");
    return $alias(self, "to_str", "to_path");
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Pathname', function $$Pathname(path) {
      
      return $$('Pathname').$new(path)
    }, 1)
  })($nesting[0], $nesting);
};

},{}],97:[function(require,module,exports){
Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      delete $$open.$$p;
      
      ;
      
      if (string == null) string = "";;
      
      if (mode == null) mode = nil;;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (string == null) string = "";;
      
      if (mode == null) mode = "rw";;
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, 0);
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');;
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"), 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, 1);
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) length = nil;;
      
      if (outbuf == null) outbuf = nil;;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    }, 1);
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};

},{}],98:[function(require,module,exports){
(function (process){(function (){
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))
},{"_process":33}],99:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}]},{},[71]);
